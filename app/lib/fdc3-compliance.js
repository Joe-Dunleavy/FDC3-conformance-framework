(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fdc3Compliance"] = factory();
	else
		root["fdc3Compliance"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/assertion-error/index.js":
/*!************************************************!*\
  !*** ../node_modules/assertion-error/index.js ***!
  \************************************************/
/***/ ((module) => {

/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || AssertionError;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch(e) {
      this.stack = e.stack;
    }
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};


/***/ }),

/***/ "../node_modules/base64-js/index.js":
/*!******************************************!*\
  !*** ../node_modules/base64-js/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../node_modules/browser-stdout/index.js":
/*!***********************************************!*\
  !*** ../node_modules/browser-stdout/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
var WritableStream = (__webpack_require__(/*! stream */ "../node_modules/stream-browserify/index.js").Writable)
var inherits = (__webpack_require__(/*! util */ "../node_modules/util/util.js").inherits)

module.exports = BrowserStdout


inherits(BrowserStdout, WritableStream)

function BrowserStdout(opts) {
  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)

  opts = opts || {}
  WritableStream.call(this, opts)
  this.label = (opts.label !== undefined) ? opts.label : 'stdout'
}

BrowserStdout.prototype._write = function(chunks, encoding, cb) {
  var output = chunks.toString ? chunks.toString() : chunks
  if (this.label === false) {
    console.log(output)
  } else {
    console.log(this.label+':', output)
  }
  process.nextTick(cb)
}


/***/ }),

/***/ "../node_modules/buffer/index.js":
/*!***************************************!*\
  !*** ../node_modules/buffer/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "../node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "../node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "../node_modules/call-bind/callBound.js":
/*!**********************************************!*\
  !*** ../node_modules/call-bind/callBound.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "../node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "../node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "../node_modules/call-bind/index.js":
/*!******************************************!*\
  !*** ../node_modules/call-bind/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "../node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "../node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "../node_modules/chai/index.js":
/*!*************************************!*\
  !*** ../node_modules/chai/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/chai */ "../node_modules/chai/lib/chai.js");


/***/ }),

/***/ "../node_modules/chai/lib/chai.js":
/*!****************************************!*\
  !*** ../node_modules/chai/lib/chai.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = [];

/*!
 * Chai version
 */

exports.version = '4.3.3';

/*!
 * Assertion Error
 */

exports.AssertionError = __webpack_require__(/*! assertion-error */ "../node_modules/assertion-error/index.js");

/*!
 * Utils for plugins (not exported)
 */

var util = __webpack_require__(/*! ./chai/utils */ "../node_modules/chai/lib/chai/utils/index.js");

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai.
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(exports, util);
    used.push(fn);
  }

  return exports;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = __webpack_require__(/*! ./chai/config */ "../node_modules/chai/lib/chai/config.js");
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = __webpack_require__(/*! ./chai/assertion */ "../node_modules/chai/lib/chai/assertion.js");
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = __webpack_require__(/*! ./chai/core/assertions */ "../node_modules/chai/lib/chai/core/assertions.js");
exports.use(core);

/*!
 * Expect interface
 */

var expect = __webpack_require__(/*! ./chai/interface/expect */ "../node_modules/chai/lib/chai/interface/expect.js");
exports.use(expect);

/*!
 * Should interface
 */

var should = __webpack_require__(/*! ./chai/interface/should */ "../node_modules/chai/lib/chai/interface/should.js");
exports.use(should);

/*!
 * Assert interface
 */

var assert = __webpack_require__(/*! ./chai/interface/assert */ "../node_modules/chai/lib/chai/interface/assert.js");
exports.use(assert);


/***/ }),

/***/ "../node_modules/chai/lib/chai/assertion.js":
/*!**************************************************!*\
  !*** ../node_modules/chai/lib/chai/assertion.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = __webpack_require__(/*! ./config */ "../node_modules/chai/lib/chai/config.js");

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion (obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);

    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      var assertionErrorObjectProperties = {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      };

      var operator = util.getOperator(this, arguments);
      if (operator) {
        assertionErrorObjectProperties.operator = operator;
      }

      throw new AssertionError(
        msg,
        assertionErrorObjectProperties,
        (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/config.js":
/*!***********************************************!*\
  !*** ../node_modules/chai/lib/chai/config.js ***!
  \***********************************************/
/***/ ((module) => {

module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */

  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */

  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/core/assertions.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/core/assertions.js ***!
  \********************************************************/
/***/ ((module) => {

/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , AssertionError = chai.AssertionError
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   * - also
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ 'to', 'be', 'been', 'is'
  , 'and', 'has', 'have', 'with'
  , 'that', 'which', 'at', 'of'
  , 'same', 'but', 'does', 'still', "also" ].forEach(function (chain) {
    Assertion.addProperty(chain);
  });

  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });

  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });

  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });

  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });

  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj).toLowerCase()
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return (_.isNaN(a) && _.isNaN(b)) || a === b;
  }

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object')
      , objType = _.type(obj).toLowerCase()
      , flagMsg = flag(this, 'message')
      , negate = flag(this, 'negate')
      , ssfi = flag(this, 'ssfi')
      , isDeep = flag(this, 'deep')
      , descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(
            flagMsg + 'unable to use .deep.include with WeakSet',
            undefined,
            ssfi
          );
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }
        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          })
        } else {
          included = obj.indexOf(val) !== -1;
        }
        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + 'the given combination of arguments ('
            + objType + ' and '
            + _.type(val).toLowerCase() + ')'
            + ' is invalid for this assertion. '
            + 'You can use an array, a map, an object, a set, a string, '
            + 'or a weakset instead of a '
            + _.type(val).toLowerCase(),
            undefined,
            ssfi
          );
        }

        var props = Object.keys(val)
          , firstErr = null
          , numErrs = 0;

        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);
          _.transferFlags(this, propAssertion, true);
          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }
            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this);

        // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.
        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }
        return;
    }

    // Assert inclusion in collection or substring in a string.
    this.assert(
      included
      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)
      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , flag(this, 'negate') ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , flag(this, 'negate') ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        _.isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * The alias `.exists` can be used interchangeably with `.exist`.
   *
   * @name exist
   * @alias exists
   * @namespace BDD
   * @api public
   */

  function assertExist () {
    var val = flag(this, 'object');
    this.assert(
        val !== null && val !== undefined
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  }

  Assertion.addProperty('exist', assertExist);
  Assertion.addProperty('exists', assertExist);

  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , flagMsg = flag(this, 'message')
      , itemsCount;

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;
      case 'map':
      case 'set':
        itemsCount = val.size;
        break;
      case 'weakmap':
      case 'weakset':
        throw new AssertionError(
          flagMsg + '.empty was passed a weak collection',
          undefined,
          ssfi
        );
      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);
        throw new AssertionError(msg.trim(), undefined, ssfi);
      default:
        if (val !== Object(val)) {
          throw new AssertionError(
            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),
            undefined,
            ssfi
          );
        }
        itemsCount = Object.keys(val).length;
    }

    this.assert(
        0 === itemsCount
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = _.type(obj);
    this.assert(
        'Arguments' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount > n
        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above #{exp}'
        , 'expected #{this} to be at most #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The aliases `.gte` and `.greaterThanOrEqual` can be used interchangeably with
   * `.least`.
   *
   * @name least
   * @alias gte
   * @alias greaterThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount >= n
        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'
        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least #{exp}'
        , 'expected #{this} to be below #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  Assertion.addMethod('greaterThanOrEqual', assertLeast);

  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount < n
        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below #{exp}'
        , 'expected #{this} to be at least #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The aliases `.lte` and `.lessThanOrEqual` can be used interchangeably with
   * `.most`.
   *
   * @name most
   * @alias lte
   * @alias lessThanOrEqual
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , nType = _.type(n).toLowerCase()
      , errorMessage
      , shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && nType !== 'date')) {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount <= n
        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'
        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'
        , n
        , itemsCount
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most #{exp}'
        , 'expected #{this} to be above #{exp}'
        , n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  Assertion.addMethod('lessThanOrEqual', assertMost);

  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , doLength = flag(this, 'doLength')
      , flagMsg = flag(this, 'message')
      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')
      , ssfi = flag(this, 'ssfi')
      , objType = _.type(obj).toLowerCase()
      , startType = _.type(start).toLowerCase()
      , finishType = _.type(finish).toLowerCase()
      , errorMessage
      , shouldThrow = true
      , range = (startType === 'date' && finishType === 'date')
          ? start.toISOString() + '..' + finish.toISOString()
          : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {
      var printObj = (objType === 'string') ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length'
        , itemsCount;
      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }
      this.assert(
          itemsCount >= start && itemsCount <= finish
        , 'expected #{this} to have a ' + descriptor + ' within ' + range
        , 'expected #{this} to not have a ' + descriptor + ' within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);

    var target = flag(this, 'object')
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(
          flagMsg + 'The instanceof assertion needs a constructor but '
            + _.type(constructor) + ' was given.',
          undefined,
          ssfi
        );
      }
      throw err;
    }

    var name = _.getName(constructor);
    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(
        isInstanceOf
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isNested = flag(this, 'nested')
      , isOwn = flag(this, 'own')
      , flagMsg = flag(this, 'message')
      , obj = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , nameType = typeof name;

    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(
          flagMsg + 'the argument to property must be a string when using nested syntax',
          undefined,
          ssfi
        );
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(
          flagMsg + 'the argument to property must be a string, number, or symbol',
          undefined,
          ssfi
        );
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(
        flagMsg + 'The "nested" and "own" flags cannot be combined.',
        undefined,
        ssfi
      );
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(
        flagMsg + 'Target cannot be null or undefined.',
        undefined,
        ssfi
      );
    }

    var isDeep = flag(this, 'deep')
      , negate = flag(this, 'negate')
      , pathInfo = isNested ? _.getPathInfo(obj, name) : null
      , value = isNested ? pathInfo.value : obj[name];

    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';

    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);
    else if (isNested) hasProperty = pathInfo.exists;
    else hasProperty = _.hasProperty(obj, name);

    // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.
    if (!negate || arguments.length === 1) {
      this.assert(
          hasProperty
        , 'expected #{this} to have ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          hasProperty && (isDeep ? _.eql(val, value) : val === value)
        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty (name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , objType = _.type(obj).toLowerCase()
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi')
      , descriptor = 'length'
      , itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;
      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(
        itemsCount == n
      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'
      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'
      , n
      , itemsCount
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });

  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , objType = _.type(obj)
      , keysType = _.type(keys)
      , ssfi = flag(this, 'ssfi')
      , isDeep = flag(this, 'deep')
      , str
      , deepStr = ''
      , actual
      , ok = true
      , flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = [];

      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.
      obj.forEach(function (val, key) { actual.push(key) });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }
          break;
        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }
          keys = Object.keys(keys);
          break;
        default:
          keys = Array.prototype.slice.call(arguments);
      }

      // Only stringify non-Symbols because Symbols would become "Symbol()"
      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all')
      , expected = keys;

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      ok = expected.some(function(expectedKey) {
        return actual.some(function(actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    }

    // Has all
    if (all) {
      ok = expected.every(function(expectedKey) {
        return actual.some(function(actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key) {
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + deepStr + str
      , 'expected #{this} to not ' + deepStr + str
      , expected.slice(0).sort(_.compareByInspect)
      , actual.sort(_.compareByInspect)
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , ssfi = flag(this, 'ssfi')
      , flagMsg = flag(this, 'message')
      , negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;
    try {
      obj();
    } catch (err) {
      caughtErr = err;
    }

    // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria
    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;

    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub
    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false;

    // Checking if error was thrown
    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';
      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(
          caughtErr
        , 'expected #{this} to throw ' + errorLikeString
        , 'expected #{this} to not throw an error but #{act} was thrown'
        , errorLike && errorLike.toString()
        , (caughtErr instanceof Error ?
            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&
                                    _.checkError.getConstructorName(caughtErr)))
      );
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(
                negate
              , 'expected #{this} to throw #{exp} but #{act} was thrown'
              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')
              , errorLike.toString()
              , caughtErr.toString()
            );
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);
      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
            errorLikeFail = true;
        } else {
          this.assert(
              negate
            , 'expected #{this} to throw #{exp} but #{act} was thrown'
            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
          );
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';
      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching'
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);
      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
            errMsgMatcherFail = true;
        } else {
          this.assert(
            negate
            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'
            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'
            ,  errMsgMatcher
            ,  _.checkError.getMessage(caughtErr)
          );
        }
      }
    }

    // If both assertions failed and both should've matched we throw an error
    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(
        negate
        , 'expected #{this} to throw #{exp} but #{act} was thrown'
        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')
        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))
        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))
      );
    }

    flag(this, 'object', caughtErr);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === typeof obj && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , flag(this, 'negate') ? false : true
      , result
    );
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');

    new Assertion(obj, flagMsg, ssfi, true).is.a('number');
    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      var deltaMessage = delta === undefined ? ", and a delta is required" : "";
      throw new AssertionError(
          flagMsg + 'the arguments to closeTo or approximately must be numbers' + deltaMessage,
          undefined,
          ssfi
      );
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo);

  // Note: Duplicates are ignored if testing for inclusion instead of sameness.
  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function(elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false;

        // Remove match from superset so not counted twice if duplicate in subset.
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function(elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false;

        // Remove match from superset so not counted twice if duplicate in subset.
        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }

  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');

    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');

    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');

    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    this.assert(
        isSubsetOf(subset, obj, cmp, contains, ordered)
      , failMsg
      , failNegateMsg
      , subset
      , obj
      , true
    );
  });

  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * It can also be chained with `.contain` or `.include`, which will work with
   * both arrays and strings:
   *
   *     expect('Today is sunny').to.contain.oneOf(['sunny', 'cloudy'])
   *     expect('Today is rainy').to.not.contain.oneOf(['sunny', 'cloudy'])
   *     expect([1,2,3]).to.contain.oneOf([3,4,5])
   *     expect([1,2,3]).to.not.contain.oneOf([4,5,6])
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi')
      , contains = flag(this, 'contains')
      , isDeep = flag(this, 'deep');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');

    if (contains) {
      this.assert(
        list.some(function(possibility) { return expected.indexOf(possibility) > -1 })
        , 'expected #{this} to contain one of #{exp}'
        , 'expected #{this} to not contain one of #{exp}'
        , list
        , expected
      );
    } else {
      if (isDeep) {
        this.assert(
          list.some(function(possibility) { return _.eql(expected, possibility) })
          , 'expected #{this} to deeply equal one of #{exp}'
          , 'expected #{this} to deeply equal one of #{exp}'
          , list
          , expected
        );
      } else {
        this.assert(
          list.indexOf(expected) > -1
          , 'expected #{this} to be one of #{exp}'
          , 'expected #{this} to not be one of #{exp}'
          , list
          , expected
        );
      }
    }
  }

  Assertion.addMethod('oneOf', oneOf);

  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    // This gets flagged because of the .by(delta) assertion
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);

    this.assert(
      initial !== final
      , 'expected ' + msgObj + ' to change'
      , 'expected ' + msgObj + ' to not change'
    );
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);

  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    // Make sure that the target is a number
    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);

    this.assert(
      final - initial > 0
      , 'expected ' + msgObj + ' to increase'
      , 'expected ' + msgObj + ' to not increase'
    );
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);

  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object')
      , flagMsg = flag(this, 'message')
      , ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');

    var initial;
    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    // Make sure that the target is a number
    new Assertion(initial, flagMsg, ssfi, true).is.a('number');

    fn();

    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);

    this.assert(
      final - initial < 0
      , 'expected ' + msgObj + ' to decrease'
      , 'expected ' + msgObj + ' to not decrease'
    );
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);

  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);

    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');

    var expression;
    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(
      expression
      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta
      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta
    );
  }

  Assertion.addMethod('by', assertDelta);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);

    this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;

    this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;

    this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });

  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function(msg) {
    var obj = flag(this, 'object');

    this.assert(
        typeof obj === 'number' && isFinite(obj)
      , 'expected #{this} to be a finite number'
      , 'expected #{this} to not be a finite number'
    );
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/assert.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/assert.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
        // Comply with Node's fail([message]) interface

        message = actual;
        actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
      , true
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
      , true
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };

  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };

  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };

  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };

   /**
   * ### .isFinite(value, [message])
   *
   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
   *
   *     var cups = 2;
   *     assert.isFinite(cups, 'how many cups');
   *
   *     assert.isFinite(NaN); // throws
   *
   * @name isFinite
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true)
      .to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };

  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };

  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };

  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };

  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true)
      .not.nested.include(inc);
  };

  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true)
      .deep.nested.include(inc);
  };

  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepNestedInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true)
      .not.deep.nested.include(inc);
  };

  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.ownInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };

  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };

  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true)
      .deep.own.include(inc);
  };

   /**
   * ### .notDeepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
   *
   * @name notDeepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepOwnInclude = function(exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true)
      .not.deep.own.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true)
      .to.not.have.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true)
      .to.have.property(prop, val);
  };

  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true)
      .to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true)
      .to.have.deep.property(prop, val);
  };

  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true)
      .to.not.have.deep.property(prop, val);
  };

  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true)
      .to.have.own.property(prop);
  };

  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true)
      .to.not.have.own.property(prop);
  };

  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true)
      .to.have.own.property(prop, value);
  };

  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true)
      .to.not.have.own.property(prop, value);
  };

  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)
      .to.have.deep.own.property(prop, value);
  };

  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)
      .to.not.have.deep.own.property(prop, value);
  };

  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true)
      .to.have.nested.property(prop);
  };

  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true)
      .to.not.have.nested.property(prop);
  };

  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true)
      .to.have.nested.property(prop, val);
  };

  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true)
      .to.not.have.nested.property(prop, val);
  };

  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)
      .to.have.deep.nested.property(prop, val);
  };

  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)
      .to.not.have.deep.nested.property(prop, val);
  }

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };

  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  }

  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  }

  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true)
      .to.contain.all.keys(keys);
  }

  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)
      .to.not.have.any.keys(keys);
  }

  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)
      .to.not.have.all.keys(keys);
  }

  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name hasAnyDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)
      .to.have.any.deep.keys(keys);
  }

 /**
   * ### .hasAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name hasAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true)
      .to.have.all.deep.keys(keys);
  }

 /**
   * ### .containsAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` contains all of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name containsAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true)
      .to.contain.all.deep.keys(keys);
  }

 /**
   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
   *
   * @name doesNotHaveAnyDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)
      .to.not.have.any.deep.keys(keys);
  }

 /**
   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
   *
   * @name doesNotHaveAllDeepKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)
      .to.not.have.all.deep.keys(keys);
  }

 /**
   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
   * message matching `errMsgMatcher`.
   *
   *     assert.throws(fn, 'Error thrown must have this msg');
   *     assert.throws(fn, /Error thrown must have a msg that matches this/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, errorInstance);
   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} fn
   * @param {ErrorConstructor|Error} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true)
      .to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true)
      .to.not.throw(errorLike, errMsgMatcher);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(
          msg + 'Invalid operator "' + operator + '"',
          undefined,
          assert.operator
        );
    }
    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true)
      .to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true)
      .to.have.same.members(set2);
  }

  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true)
      .to.not.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true)
      .to.have.same.deep.members(set2);
  }

  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true)
      .to.not.have.same.deep.members(set2);
  }

  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true)
      .to.have.same.ordered.members(set2);
  }

  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true)
      .to.not.have.same.ordered.members(set2);
  }

  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   *     assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)
      .to.have.same.deep.ordered.members(set2);
  }

  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   *     assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)
      .to.not.have.same.deep.ordered.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true)
      .to.include.members(subset);
  }

  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true)
      .to.not.include.members(subset);
  }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true)
      .to.include.deep.members(subset);
  }

  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)
      .to.not.include.deep.members(subset);
  }

  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true)
      .to.include.ordered.members(subset);
  }

  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)
      .to.not.include.ordered.members(subset);
  }

  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)
      .to.include.deep.ordered.members(subset);
  }

  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)
      .to.not.include.deep.ordered.members(subset);
  }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  }

  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  }

   /**
   * ### .changesBy(function, object, property, delta, [message])
   *
   * Asserts that a function changes the value of a property by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 2 };
   *     assert.changesBy(fn, obj, 'val', 2);
   *
   * @name changesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true)
      .to.change(obj, prop).by(delta);
  }

   /**
   * ### .doesNotChange(function, object, property, [message])
   *
   * Asserts that a function does not change the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true)
      .to.not.change(obj, prop);
  }

  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true)
      .to.change(obj, prop).but.not.by(delta);
  }

  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true)
      .to.increase(obj, prop);
  }

  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true)
      .to.increase(obj, prop).by(delta);
  }

  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true)
      .to.not.increase(obj, prop);
  }

  /**
   * ### .increasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true)
      .to.increase(obj, prop).but.not.by(delta);
  }

  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true)
      .to.decrease(obj, prop);
  }

  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true)
      .to.decrease(obj, prop).by(delta);
  }

  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true)
      .to.not.decrease(obj, prop);
  }

  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecreaseBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)
      .to.not.decrease(obj, prop).by(delta);
  }

  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true)
      .to.decrease(obj, prop).but.not.by(delta);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };

  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };

  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotEmpty = function(val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen')
  ('isEmpty', 'empty')
  ('isNotEmpty', 'notEmpty');
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/expect.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/expect.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
        message = actual;
        actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/should.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/should.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String
          || this instanceof Number
          || this instanceof Boolean
          || typeof Symbol === 'function' && this instanceof Symbol
          || typeof BigInt === 'function' && this instanceof BigInt) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
          message = actual;
          actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addChainableMethod.js":
/*!*****************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addChainableMethod.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ "../node_modules/chai/lib/chai/utils/addLengthGuard.js");
var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var proxify = __webpack_require__(/*! ./proxify */ "../node_modules/chai/lib/chai/utils/proxify.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/*!
 * Module variables
 */

// Check whether `Object.setPrototypeOf` is supported
var canSetPrototype = typeof Object.setPrototypeOf === 'function';

// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.
var testFn = function() {};
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);

  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.
  if (typeof propDesc !== 'object')
    return true;

  return !propDesc.configurable;
});

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function chainableMethodGetter() {
        chainableBehavior.chainingBehavior.call(this);

        var chainableMethodWrapper = function () {
          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
          // function to be the starting point for removing implementation
          // frames from the stack trace of a failed assertion.
          //
          // However, we only want to use this function as the starting point if
          // the `lockSsfi` flag isn't set.
          //
          // If the `lockSsfi` flag is set, then this assertion is being
          // invoked from inside of another assertion. In this case, the `ssfi`
          // flag has already been set by the outer assertion.
          //
          // Note that overwriting a chainable method merely replaces the saved
          // methods in `ctx.__methods` instead of completely replacing the
          // overwritten assertion. Therefore, an overwriting assertion won't
          // set the `ssfi` or `lockSsfi` flags.
          if (!flag(this, 'lockSsfi')) {
            flag(this, 'ssfi', chainableMethodWrapper);
          }

          var result = chainableBehavior.method.apply(this, arguments);
          if (result !== undefined) {
            return result;
          }

          var newAssertion = new chai.Assertion();
          transferFlags(this, newAssertion);
          return newAssertion;
        };

        addLengthGuard(chainableMethodWrapper, name, true);

        // Use `Object.setPrototypeOf` if available
        if (canSetPrototype) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
          Object.setPrototypeOf(chainableMethodWrapper, prototype);
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

        transferFlags(this, chainableMethodWrapper);
        return proxify(chainableMethodWrapper);
      }
    , configurable: true
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addLengthGuard.js":
/*!*************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addLengthGuard.js ***!
  \*************************************************************/
/***/ ((module) => {

var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');

/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

module.exports = function addLengthGuard (fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;

  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +
          ' to a compatibility issue, "length" cannot directly follow "' +
          assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +
        ' docs for proper usage of "' + assertionName + '".');
    }
  });

  return fn;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addMethod.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addMethod.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ "../node_modules/chai/lib/chai/utils/addLengthGuard.js");
var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var proxify = __webpack_require__(/*! ./proxify */ "../node_modules/chai/lib/chai/utils/proxify.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

module.exports = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined)
      return result;

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addProperty.js":
/*!**********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addProperty.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

module.exports = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;

  Object.defineProperty(ctx, name,
    { get: function propertyGetter() {
        // Setting the `ssfi` flag to `propertyGetter` causes this function to
        // be the starting point for removing implementation frames from the
        // stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set and proxy protection is disabled.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked
        // from inside of another assertion. In the first case, the `ssfi` flag
        // has already been set by the overwriting assertion. In the second
        // case, the `ssfi` flag has already been set by the outer assertion.
        //
        // If proxy protection is enabled, then the `ssfi` flag has already been
        // set by the proxy getter.
        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', propertyGetter);
        }

        var result = getter.call(this);
        if (result !== undefined)
          return result;

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }
    , configurable: true
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/compareByInspect.js":
/*!***************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/compareByInspect.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var inspect = __webpack_require__(/*! ./inspect */ "../node_modules/chai/lib/chai/utils/inspect.js");

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

module.exports = function compareByInspect(a, b) {
  return inspect(a) < inspect(b) ? -1 : 1;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/expectTypes.js":
/*!**********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/expectTypes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var AssertionError = __webpack_require__(/*! assertion-error */ "../node_modules/assertion-error/index.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var type = __webpack_require__(/*! type-detect */ "../node_modules/type-detect/type-detect.js");

module.exports = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');

  flagMsg = flagMsg ? flagMsg + ': ' : '';

  obj = flag(obj, 'object');
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'
  var str = types.map(function (t, index) {
    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');

  var objType = type(obj).toLowerCase();

  if (!types.some(function (expected) { return objType === expected; })) {
    throw new AssertionError(
      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',
      undefined,
      ssfi
    );
  }
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/flag.js":
/*!***************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/flag.js ***!
  \***************************************************/
/***/ ((module) => {

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

module.exports = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getActual.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getActual.js ***!
  \********************************************************/
/***/ ((module) => {

/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

module.exports = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getMessage.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getMessage.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js")
  , getActual = __webpack_require__(/*! ./getActual */ "../node_modules/chai/lib/chai/utils/getActual.js")
  , objDisplay = __webpack_require__(/*! ./objDisplay */ "../node_modules/chai/lib/chai/utils/objDisplay.js");

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

module.exports = function getMessage(obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + ': ' + msg : msg;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getOperator.js":
/*!**********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getOperator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var type = __webpack_require__(/*! type-detect */ "../node_modules/type-detect/type-detect.js");

var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");

function isObjectType(obj) {
  var objectType = type(obj);
  var objectTypes = ['Array', 'Object', 'function'];

  return objectTypes.indexOf(objectType) !== -1;
}

/**
 * ### .getOperator(message)
 *
 * Extract the operator from error message.
 * Operator defined is based on below link
 * https://nodejs.org/api/assert.html#assert_assert.
 *
 * Returns the `operator` or `undefined` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getOperator
 * @api public
 */

module.exports = function getOperator(obj, args) {
  var operator = flag(obj, 'operator');
  var negate = flag(obj, 'negate');
  var expected = args[3];
  var msg = negate ? args[2] : args[1];

  if (operator) {
    return operator;
  }

  if (typeof msg === 'function') msg = msg();

  msg = msg || '';
  if (!msg) {
    return undefined;
  }

  if (/\shave\s/.test(msg)) {
    return undefined;
  }

  var isObject = isObjectType(expected);
  if (/\snot\s/.test(msg)) {
    return isObject ? 'notDeepStrictEqual' : 'notStrictEqual';
  }

  return isObject ? 'deepStrictEqual' : 'strictEqual';
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js":
/*!*************************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ "../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js");

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

module.exports = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js":
/*!******************************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js ***!
  \******************************************************************************/
/***/ ((module) => {

/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */

module.exports = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];

  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getProperties.js":
/*!************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getProperties.js ***!
  \************************************************************/
/***/ ((module) => {

/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/index.js":
/*!****************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

var pathval = __webpack_require__(/*! pathval */ "../node_modules/pathval/index.js");

/*!
 * test utility
 */

exports.test = __webpack_require__(/*! ./test */ "../node_modules/chai/lib/chai/utils/test.js");

/*!
 * type utility
 */

exports.type = __webpack_require__(/*! type-detect */ "../node_modules/type-detect/type-detect.js");

/*!
 * expectTypes utility
 */
exports.expectTypes = __webpack_require__(/*! ./expectTypes */ "../node_modules/chai/lib/chai/utils/expectTypes.js");

/*!
 * message utility
 */

exports.getMessage = __webpack_require__(/*! ./getMessage */ "../node_modules/chai/lib/chai/utils/getMessage.js");

/*!
 * actual utility
 */

exports.getActual = __webpack_require__(/*! ./getActual */ "../node_modules/chai/lib/chai/utils/getActual.js");

/*!
 * Inspect util
 */

exports.inspect = __webpack_require__(/*! ./inspect */ "../node_modules/chai/lib/chai/utils/inspect.js");

/*!
 * Object Display util
 */

exports.objDisplay = __webpack_require__(/*! ./objDisplay */ "../node_modules/chai/lib/chai/utils/objDisplay.js");

/*!
 * Flag utility
 */

exports.flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");

/*!
 * Flag transferring utility
 */

exports.transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/*!
 * Deep equal utility
 */

exports.eql = __webpack_require__(/*! deep-eql */ "../node_modules/deep-eql/index.js");

/*!
 * Deep path info
 */

exports.getPathInfo = pathval.getPathInfo;

/*!
 * Check if a property exists
 */

exports.hasProperty = pathval.hasProperty;

/*!
 * Function name
 */

exports.getName = __webpack_require__(/*! get-func-name */ "../node_modules/get-func-name/index.js");

/*!
 * add Property
 */

exports.addProperty = __webpack_require__(/*! ./addProperty */ "../node_modules/chai/lib/chai/utils/addProperty.js");

/*!
 * add Method
 */

exports.addMethod = __webpack_require__(/*! ./addMethod */ "../node_modules/chai/lib/chai/utils/addMethod.js");

/*!
 * overwrite Property
 */

exports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ "../node_modules/chai/lib/chai/utils/overwriteProperty.js");

/*!
 * overwrite Method
 */

exports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ "../node_modules/chai/lib/chai/utils/overwriteMethod.js");

/*!
 * Add a chainable method
 */

exports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ "../node_modules/chai/lib/chai/utils/addChainableMethod.js");

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ "../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js");

/*!
 * Compare by inspect method
 */

exports.compareByInspect = __webpack_require__(/*! ./compareByInspect */ "../node_modules/chai/lib/chai/utils/compareByInspect.js");

/*!
 * Get own enumerable property symbols method
 */

exports.getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ "../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js");

/*!
 * Get own enumerable properties method
 */

exports.getOwnEnumerableProperties = __webpack_require__(/*! ./getOwnEnumerableProperties */ "../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js");

/*!
 * Checks error against a given set of criteria
 */

exports.checkError = __webpack_require__(/*! check-error */ "../node_modules/check-error/index.js");

/*!
 * Proxify util
 */

exports.proxify = __webpack_require__(/*! ./proxify */ "../node_modules/chai/lib/chai/utils/proxify.js");

/*!
 * addLengthGuard util
 */

exports.addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ "../node_modules/chai/lib/chai/utils/addLengthGuard.js");

/*!
 * isProxyEnabled helper
 */

exports.isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js");

/*!
 * isNaN method
 */

exports.isNaN = __webpack_require__(/*! ./isNaN */ "../node_modules/chai/lib/chai/utils/isNaN.js");

/*!
 * getOperator method
 */

exports.getOperator = __webpack_require__(/*! ./getOperator */ "../node_modules/chai/lib/chai/utils/getOperator.js");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/inspect.js":
/*!******************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/inspect.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = __webpack_require__(/*! get-func-name */ "../node_modules/get-func-name/index.js");
var loupe = __webpack_require__(/*! loupe */ "../node_modules/loupe/loupe.js");
var config = __webpack_require__(/*! ../config */ "../node_modules/chai/lib/chai/config.js");

module.exports = inspect;

/**
 * ### .inspect(obj, [showHidden], [depth], [colors])
 *
 * Echoes the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects. Default is false.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var options = {
    colors: colors,
    depth: (typeof depth === 'undefined' ? 2 : depth),
    showHidden: showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : Infinity,
  };
  return loupe.inspect(obj, options);
}


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/isNaN.js":
/*!****************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/isNaN.js ***!
  \****************************************************/
/***/ ((module) => {

/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */

function isNaN(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
}

// If ECMAScript 6's Number.isNaN is present, prefer that.
module.exports = Number.isNaN || isNaN;


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js":
/*!*************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/isProxyEnabled.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var config = __webpack_require__(/*! ../config */ "../node_modules/chai/lib/chai/config.js");

/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

module.exports = function isProxyEnabled() {
  return config.useProxy &&
    typeof Proxy !== 'undefined' &&
    typeof Reflect !== 'undefined';
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/objDisplay.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/objDisplay.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var inspect = __webpack_require__(/*! ./inspect */ "../node_modules/chai/lib/chai/utils/inspect.js");
var config = __webpack_require__(/*! ../config */ "../node_modules/chai/lib/chai/config.js");

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

module.exports = function objDisplay(obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js":
/*!***********************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);
    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteMethod.js":
/*!**************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteMethod.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ "../node_modules/chai/lib/chai/utils/addLengthGuard.js");
var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var proxify = __webpack_require__(/*! ./proxify */ "../node_modules/chai/lib/chai/utils/proxify.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

module.exports = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name]
    , _super = function () {
      throw new Error(name + ' is not a function');
    };

  if (_method && 'function' === typeof _method)
    _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    }

    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.
    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteProperty.js":
/*!****************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteProperty.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var chai = __webpack_require__(/*! ../../chai */ "../node_modules/chai/lib/chai.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js");
var transferFlags = __webpack_require__(/*! ./transferFlags */ "../node_modules/chai/lib/chai/utils/transferFlags.js");

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

module.exports = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function overwritingPropertyGetter() {
        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
        // function to be the starting point for removing implementation frames
        // from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set and proxy protection is disabled.
        //
        // If the `lockSsfi` flag is set, then either this assertion has been
        // overwritten by another assertion, or this assertion is being invoked
        // from inside of another assertion. In the first case, the `ssfi` flag
        // has already been set by the overwriting assertion. In the second
        // case, the `ssfi` flag has already been set by the outer assertion.
        //
        // If proxy protection is enabled, then the `ssfi` flag has already been
        // set by the proxy getter.
        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', overwritingPropertyGetter);
        }

        // Setting the `lockSsfi` flag to `true` prevents the overwritten
        // assertion from changing the `ssfi` flag. By this point, the `ssfi`
        // flag is already set to the correct starting point for this assertion.
        var origLockSsfi = flag(this, 'lockSsfi');
        flag(this, 'lockSsfi', true);
        var result = getter(_super).call(this);
        flag(this, 'lockSsfi', origLockSsfi);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }
    , configurable: true
  });
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/proxify.js":
/*!******************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/proxify.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var config = __webpack_require__(/*! ../config */ "../node_modules/chai/lib/chai/config.js");
var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");
var getProperties = __webpack_require__(/*! ./getProperties */ "../node_modules/chai/lib/chai/utils/getProperties.js");
var isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js");

/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

module.exports = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;

  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' &&
          config.proxyExcludedKeys.indexOf(property) === -1 &&
          !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +
            property + '. See docs for proper usage of "' +
            nonChainableMethodName + '".');
        }

        // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.
        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function(prop) {
          if (
            !Object.prototype.hasOwnProperty(prop) &&
            builtins.indexOf(prop) === -1
          ) {
            var dist = stringDistanceCapped(
              property,
              prop,
              suggestionDistance
            );
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property +
            '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      }

      // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.
      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};

/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */

function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = [];
  // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).
  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }
  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);
    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }
      memo[i][j] = Math.min(
        memo[i - 1][j] + 1,
        memo[i][j - 1] + 1,
        memo[i - 1][j - 1] +
          (ch === strB.charCodeAt(j - 1) ? 0 : 1)
      );
    }
  }

  return memo[strA.length][strB.length];
}


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/test.js":
/*!***************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/test.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var flag = __webpack_require__(/*! ./flag */ "../node_modules/chai/lib/chai/utils/flag.js");

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

module.exports = function test(obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};


/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/transferFlags.js":
/*!************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/transferFlags.js ***!
  \************************************************************/
/***/ ((module) => {

/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

module.exports = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};


/***/ }),

/***/ "../node_modules/check-error/index.js":
/*!********************************************!*\
  !*** ../node_modules/check-error/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}

/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}

/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */

function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}

/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */

var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;
function getFunctionName(constructorFn) {
  var name = '';
  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch);
    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}

/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */

function getConstructorName(errorLike) {
  var constructorName = errorLike;
  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() ||
        getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}

/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */

function getMessage(errorLike) {
  var msg = '';
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

module.exports = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage,
  getConstructorName: getConstructorName,
};


/***/ }),

/***/ "../node_modules/deep-eql/index.js":
/*!*****************************************!*\
  !*** ../node_modules/deep-eql/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* globals Symbol: false, Uint8Array: false, WeakMap: false */
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = __webpack_require__(/*! type-detect */ "../node_modules/type-detect/type-detect.js");
function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true,
      });
    }
  },
};

var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === 'boolean') {
      return result;
    }
  }
  return null;
}

/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;
module.exports.MemoizeMap = MemoizeMap;

/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */
function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }

  // Deeper comparisons are pushed through to a larger function
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}

/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */
function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }

  // handle NaN cases
  if (
    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
    return true;
  }

  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.
  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }
  return null;
}

/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;

  // Check if a memoized result exists.
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }

  // If a comparator is present, use it.
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    // Comparators may return null, in which case we want to go back to default behavior.
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = type(leftHandOperand);
  if (leftHandType !== type(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }

  // Temporarily set the operands in the memoize object to prevent blowing the stack
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);

  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;
    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);
    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}

/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */

function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}

/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }
  if (leftHandOperand.size === 0) {
    return true;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([ key, value ]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([ key, value ]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}

/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) {
    return false;
  }
  if (length === 0) {
    return true;
  }
  var index = -1;
  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }
  return true;
}

/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}

/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */
function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' &&
    typeof target === 'object' &&
    typeof Symbol.iterator !== 'undefined' &&
    typeof target[Symbol.iterator] === 'function';
}

/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}

/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [ generatorResult.value ];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}

/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */
function getEnumerableKeys(target) {
  var keys = [];
  for (var key in target) {
    keys.push(key);
  }
  return keys;
}

/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;
  if (length === 0) {
    return true;
  }
  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }
  return true;
}

/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */

function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();
    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 &&
      leftHandEntries.length === 0 &&
      rightHandKeys.length === 0 &&
      rightHandEntries.length === 0) {
    return true;
  }

  return false;
}

/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */
function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}


/***/ }),

/***/ "../node_modules/diff/lib/convert/dmp.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/convert/dmp.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToDMP = convertChangesToDMP;

/*istanbul ignore end*/
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L2RtcC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvRE1QIiwiY2hhbmdlcyIsInJldCIsImNoYW5nZSIsIm9wZXJhdGlvbiIsImkiLCJsZW5ndGgiLCJhZGRlZCIsInJlbW92ZWQiLCJwdXNoIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ08sU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUlDLEdBQUcsR0FBRyxFQUFWO0FBQUEsTUFDSUMsTUFESjtBQUFBLE1BRUlDLFNBRko7O0FBR0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixPQUFPLENBQUNLLE1BQTVCLEVBQW9DRCxDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDRixJQUFBQSxNQUFNLEdBQUdGLE9BQU8sQ0FBQ0ksQ0FBRCxDQUFoQjs7QUFDQSxRQUFJRixNQUFNLENBQUNJLEtBQVgsRUFBa0I7QUFDaEJILE1BQUFBLFNBQVMsR0FBRyxDQUFaO0FBQ0QsS0FGRCxNQUVPLElBQUlELE1BQU0sQ0FBQ0ssT0FBWCxFQUFvQjtBQUN6QkosTUFBQUEsU0FBUyxHQUFHLENBQUMsQ0FBYjtBQUNELEtBRk0sTUFFQTtBQUNMQSxNQUFBQSxTQUFTLEdBQUcsQ0FBWjtBQUNEOztBQUVERixJQUFBQSxHQUFHLENBQUNPLElBQUosQ0FBUyxDQUFDTCxTQUFELEVBQVlELE1BQU0sQ0FBQ08sS0FBbkIsQ0FBVDtBQUNEOztBQUNELFNBQU9SLEdBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXG5leHBvcnQgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIGxldCByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/convert/xml.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/convert/xml.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToXML = convertChangesToXML;

/*istanbul ignore end*/
function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0L3htbC5qcyJdLCJuYW1lcyI6WyJjb252ZXJ0Q2hhbmdlc1RvWE1MIiwiY2hhbmdlcyIsInJldCIsImkiLCJsZW5ndGgiLCJjaGFuZ2UiLCJhZGRlZCIsInB1c2giLCJyZW1vdmVkIiwiZXNjYXBlSFRNTCIsInZhbHVlIiwiam9pbiIsInMiLCJuIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsbUJBQVQsQ0FBNkJDLE9BQTdCLEVBQXNDO0FBQzNDLE1BQUlDLEdBQUcsR0FBRyxFQUFWOztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsT0FBTyxDQUFDRyxNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxRQUFJRSxNQUFNLEdBQUdKLE9BQU8sQ0FBQ0UsQ0FBRCxDQUFwQjs7QUFDQSxRQUFJRSxNQUFNLENBQUNDLEtBQVgsRUFBa0I7QUFDaEJKLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTLE9BQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUYsTUFBTSxDQUFDRyxPQUFYLEVBQW9CO0FBQ3pCTixNQUFBQSxHQUFHLENBQUNLLElBQUosQ0FBUyxPQUFUO0FBQ0Q7O0FBRURMLElBQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRSxVQUFVLENBQUNKLE1BQU0sQ0FBQ0ssS0FBUixDQUFuQjs7QUFFQSxRQUFJTCxNQUFNLENBQUNDLEtBQVgsRUFBa0I7QUFDaEJKLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTLFFBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSUYsTUFBTSxDQUFDRyxPQUFYLEVBQW9CO0FBQ3pCTixNQUFBQSxHQUFHLENBQUNLLElBQUosQ0FBUyxRQUFUO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPTCxHQUFHLENBQUNTLElBQUosQ0FBUyxFQUFULENBQVA7QUFDRDs7QUFFRCxTQUFTRixVQUFULENBQW9CRyxDQUFwQixFQUF1QjtBQUNyQixNQUFJQyxDQUFDLEdBQUdELENBQVI7QUFDQUMsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE9BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLE1BQWhCLENBQUo7QUFDQUQsRUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFFBQWhCLENBQUo7QUFFQSxTQUFPRCxDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb1hNTChjaGFuZ2VzKSB7XG4gIGxldCByZXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgcmV0LnB1c2goJzxkZWw+Jyk7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcblxuICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPC9kZWw+Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUhUTUwocykge1xuICBsZXQgbiA9IHM7XG4gIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG5cbiAgcmV0dXJuIG47XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/diff/array.js":
/*!**********************************************!*\
  !*** ../node_modules/diff/lib/diff/array.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffArrays = diffArrays;
exports.arrayDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var arrayDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.arrayDiff = arrayDiff;

/*istanbul ignore end*/
arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2FycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5RGlmZiIsIkRpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic2xpY2UiLCJqb2luIiwicmVtb3ZlRW1wdHkiLCJkaWZmQXJyYXlzIiwib2xkQXJyIiwibmV3QXJyIiwiY2FsbGJhY2siLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxTQUFTLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUFsQjs7Ozs7O0FBQ1BELFNBQVMsQ0FBQ0UsUUFBVixHQUFxQixVQUFTQyxLQUFULEVBQWdCO0FBQ25DLFNBQU9BLEtBQUssQ0FBQ0MsS0FBTixFQUFQO0FBQ0QsQ0FGRDs7QUFHQUosU0FBUyxDQUFDSyxJQUFWLEdBQWlCTCxTQUFTLENBQUNNLFdBQVYsR0FBd0IsVUFBU0gsS0FBVCxFQUFnQjtBQUN2RCxTQUFPQSxLQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTSSxVQUFULENBQW9CQyxNQUFwQixFQUE0QkMsTUFBNUIsRUFBb0NDLFFBQXBDLEVBQThDO0FBQUUsU0FBT1YsU0FBUyxDQUFDVyxJQUFWLENBQWVILE1BQWYsRUFBdUJDLE1BQXZCLEVBQStCQyxRQUEvQixDQUFQO0FBQWtEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGFycmF5RGlmZiA9IG5ldyBEaWZmKCk7XG5hcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbn07XG5hcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykgeyByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTsgfVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/diff/base.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/base.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJsZW5ndGgiLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsImJlc3RQYXRoIiwibmV3UG9zIiwiY29tcG9uZW50cyIsIm9sZFBvcyIsImV4dHJhY3RDb21tb24iLCJqb2luIiwiY291bnQiLCJleGVjRWRpdExlbmd0aCIsImRpYWdvbmFsUGF0aCIsImJhc2VQYXRoIiwiYWRkUGF0aCIsInJlbW92ZVBhdGgiLCJjYW5BZGQiLCJjYW5SZW1vdmUiLCJjbG9uZVBhdGgiLCJwdXNoQ29tcG9uZW50IiwiYnVpbGRWYWx1ZXMiLCJ1c2VMb25nZXN0VG9rZW4iLCJleGVjIiwicmV0IiwiYWRkZWQiLCJyZW1vdmVkIiwibGFzdCIsInB1c2giLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJzcGxpdCIsImNoYXJzIiwiY29tcG9uZW50UG9zIiwiY29tcG9uZW50TGVuIiwiY29tcG9uZW50Iiwic2xpY2UiLCJtYXAiLCJvbGRWYWx1ZSIsInRtcCIsImxhc3RDb21wb25lbnQiLCJwb3AiLCJwYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZSxTQUFTQSxJQUFULEdBQWdCLENBQUU7O0FBRWpDQSxJQUFJLENBQUNDLFNBQUwsR0FBaUI7QUFBQTs7QUFBQTtBQUNmQyxFQUFBQSxJQURlLGdCQUNWQyxTQURVLEVBQ0NDLFNBREQsRUFDMEI7QUFBQTtBQUFBO0FBQUE7QUFBZEMs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QUcsQ0FBZixJQUNHLE9BQU9NLGFBQWEsQ0FBQ3JELEtBQXJCLEtBQStCLFFBRGxDLEtBRUlxRCxhQUFhLENBQUN0QixLQUFkLElBQXVCc0IsYUFBYSxDQUFDckIsT0FGekMsS0FHR3ZDLElBQUksQ0FBQzJDLE1BQUwsQ0FBWSxFQUFaLEVBQWdCaUIsYUFBYSxDQUFDckQsS0FBOUIsQ0FIUCxFQUc2QztBQUMzQ2EsSUFBQUEsVUFBVSxDQUFDa0MsWUFBWSxHQUFHLENBQWhCLENBQVYsQ0FBNkIvQyxLQUE3QixJQUFzQ3FELGFBQWEsQ0FBQ3JELEtBQXBEO0FBQ0FhLElBQUFBLFVBQVUsQ0FBQ3lDLEdBQVg7QUFDRDs7QUFFRCxTQUFPekMsVUFBUDtBQUNEOztBQUVELFNBQVNZLFNBQVQsQ0FBbUI4QixJQUFuQixFQUF5QjtBQUN2QixTQUFPO0FBQUUzQyxJQUFBQSxNQUFNLEVBQUUyQyxJQUFJLENBQUMzQyxNQUFmO0FBQXVCQyxJQUFBQSxVQUFVLEVBQUUwQyxJQUFJLENBQUMxQyxVQUFMLENBQWdCb0MsS0FBaEIsQ0FBc0IsQ0FBdEI7QUFBbkMsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlmZigpIHt9XG5cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcblxuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLCBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIGxldCBlZGl0TGVuZ3RoID0gMTtcbiAgICBsZXQgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICBsZXQgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcblxuICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG4gICAgbGV0IG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe3ZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSwgY291bnQ6IG5ld1N0cmluZy5sZW5ndGh9XSk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yIChsZXQgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgbGV0IGJhc2VQYXRoO1xuICAgICAgICBsZXQgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxuICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxuICAgICAgICAgICAgb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXG4gICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gb2xkUG9zICYmIG9sZFBvcyA8IG9sZExlbjtcbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcbiAgICAgICAgaWYgKCFjYW5BZGQgfHwgKGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSkge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcbiAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICBsZXQgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIGxldCBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goe2NvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XG4gICAgfVxuICB9LFxuICBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgbGV0IG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcbiAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxuXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe2NvdW50OiBjb21tb25Db3VudH0pO1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICByZXR1cm4gb2xkUG9zO1xuICB9LFxuXG4gIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0XG4gICAgICAgIHx8ICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gIH0sXG4gIGpvaW4oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgbGV0IGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgIG5ld1BvcyA9IDAsXG4gICAgICBvbGRQb3MgPSAwO1xuXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsdWUsIGkpIHtcbiAgICAgICAgICBsZXQgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICB9XG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuXG4gICAgICAvLyBDb21tb24gY2FzZVxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcblxuICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICBsZXQgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cbiAgbGV0IGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpXG4gICAgICAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcbn1cbiJdfQ==


/***/ }),

/***/ "../node_modules/diff/lib/diff/character.js":
/*!**************************************************!*\
  !*** ../node_modules/diff/lib/diff/character.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffChars = diffChars;
exports.characterDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.characterDiff = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJEaWZmIiwiRGlmZiIsImRpZmZDaGFycyIsIm9sZFN0ciIsIm5ld1N0ciIsIm9wdGlvbnMiLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxhQUFhLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUF0Qjs7Ozs7O0FBQ0EsU0FBU0MsU0FBVCxDQUFtQkMsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DQyxPQUFuQyxFQUE0QztBQUFFLFNBQU9MLGFBQWEsQ0FBQ00sSUFBZCxDQUFtQkgsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DQyxPQUFuQyxDQUFQO0FBQXFEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNoYXJhY3RlckRpZmYgPSBuZXcgRGlmZigpO1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykgeyByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTsgfVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/diff/css.js":
/*!********************************************!*\
  !*** ../node_modules/diff/lib/diff/css.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffCss = diffCss;
exports.cssDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var cssDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.cssDiff = cssDiff;

/*istanbul ignore end*/
cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Nzcy5qcyJdLCJuYW1lcyI6WyJjc3NEaWZmIiwiRGlmZiIsInRva2VuaXplIiwidmFsdWUiLCJzcGxpdCIsImRpZmZDc3MiLCJvbGRTdHIiLCJuZXdTdHIiLCJjYWxsYmFjayIsImRpZmYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7OztBQUVPLElBQU1BLE9BQU8sR0FBRztBQUFJQztBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxDQUFKLEVBQWhCOzs7Ozs7QUFDUEQsT0FBTyxDQUFDRSxRQUFSLEdBQW1CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDakMsU0FBT0EsS0FBSyxDQUFDQyxLQUFOLENBQVksZUFBWixDQUFQO0FBQ0QsQ0FGRDs7QUFJTyxTQUFTQyxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsTUFBekIsRUFBaUNDLFFBQWpDLEVBQTJDO0FBQUUsU0FBT1IsT0FBTyxDQUFDUyxJQUFSLENBQWFILE1BQWIsRUFBcUJDLE1BQXJCLEVBQTZCQyxRQUE3QixDQUFQO0FBQWdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IGNzc0RpZmYgPSBuZXcgRGlmZigpO1xuY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykgeyByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==


/***/ }),

/***/ "../node_modules/diff/lib/diff/json.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/json.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffJson = diffJson;
exports.canonicalize = canonicalize;
exports.jsonDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*istanbul ignore end*/
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

/*istanbul ignore start*/
exports.jsonDiff = jsonDiff;

/*istanbul ignore end*/
jsonDiff.useLongestToken = true;
jsonDiff.tokenize =
/*istanbul ignore start*/
_line
/*istanbul ignore end*/
.
/*istanbul ignore start*/
lineDiff
/*istanbul ignore end*/
.tokenize;

jsonDiff.castInput = function (value) {
  /*istanbul ignore start*/
  var _this$options =
  /*istanbul ignore end*/
  this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      typeof v === 'undefined' ? undefinedReplacement : v
    );
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return (
    /*istanbul ignore start*/
    _base
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  );
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer


function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (
  /*istanbul ignore start*/
  _typeof(
  /*istanbul ignore end*/
  obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2pzb24uanMiXSwibmFtZXMiOlsib2JqZWN0UHJvdG90eXBlVG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImpzb25EaWZmIiwiRGlmZiIsInVzZUxvbmdlc3RUb2tlbiIsInRva2VuaXplIiwibGluZURpZmYiLCJjYXN0SW5wdXQiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJ1bmRlZmluZWRSZXBsYWNlbWVudCIsInN0cmluZ2lmeVJlcGxhY2VyIiwiayIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwiY2Fub25pY2FsaXplIiwiZXF1YWxzIiwibGVmdCIsInJpZ2h0IiwiY2FsbCIsInJlcGxhY2UiLCJkaWZmSnNvbiIsIm9sZE9iaiIsIm5ld09iaiIsImRpZmYiLCJvYmoiLCJzdGFjayIsInJlcGxhY2VtZW50U3RhY2siLCJyZXBsYWNlciIsImtleSIsImkiLCJsZW5ndGgiLCJjYW5vbmljYWxpemVkT2JqIiwicHVzaCIsIkFycmF5IiwicG9wIiwidG9KU09OIiwic29ydGVkS2V5cyIsImhhc093blByb3BlcnR5Iiwic29ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFFQSxJQUFNQSx1QkFBdUIsR0FBR0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqRDtBQUdPLElBQU1DLFFBQVEsR0FBRztBQUFJQztBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxDQUFKLEVBQWpCLEMsQ0FDUDtBQUNBOzs7Ozs7QUFDQUQsUUFBUSxDQUFDRSxlQUFULEdBQTJCLElBQTNCO0FBRUFGLFFBQVEsQ0FBQ0csUUFBVDtBQUFvQkM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQTtBQUFBLENBQVNELFFBQTdCOztBQUNBSCxRQUFRLENBQUNLLFNBQVQsR0FBcUIsVUFBU0MsS0FB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Z0IsR0FBR1AsR0FBbkI7QUFDRDs7QUFDRCxTQUFPTyxnQkFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7bGluZURpZmZ9IGZyb20gJy4vbGluZSc7XG5cbmNvbnN0IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuXG5leHBvcnQgY29uc3QganNvbkRpZmYgPSBuZXcgRGlmZigpO1xuLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbi8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcblxuanNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGNvbnN0IHt1bmRlZmluZWRSZXBsYWNlbWVudCwgc3RyaW5naWZ5UmVwbGFjZXIgPSAoaywgdikgPT4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2fSA9IHRoaXMub3B0aW9ucztcblxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5qc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykgeyByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7IH1cblxuLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcInN0YWNrXCIgb2YgaXRlbXMgYmVpbmcgcHJvY2Vzc2VkLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHJlcGxhY2VyXG5leHBvcnQgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XG5cbiAgaWYgKHJlcGxhY2VyKSB7XG4gICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICB9XG5cbiAgbGV0IGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YWNrW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjYW5vbmljYWxpemVkT2JqO1xuXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG4gICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcbiAgICBsZXQgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNvcnRlZEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAga2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpba2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/diff/line.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/line.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffLines = diffLines;
exports.diffTrimmedLines = diffTrimmedLines;
exports.lineDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "../node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var lineDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.lineDiff = lineDiff;

/*istanbul ignore end*/
lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}

function diffTrimmedLines(oldStr, newStr, callback) {
  var options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2xpbmUuanMiXSwibmFtZXMiOlsibGluZURpZmYiLCJEaWZmIiwidG9rZW5pemUiLCJ2YWx1ZSIsInJldExpbmVzIiwibGluZXNBbmROZXdsaW5lcyIsInNwbGl0IiwibGVuZ3RoIiwicG9wIiwiaSIsImxpbmUiLCJvcHRpb25zIiwibmV3bGluZUlzVG9rZW4iLCJpZ25vcmVXaGl0ZXNwYWNlIiwidHJpbSIsInB1c2giLCJkaWZmTGluZXMiLCJvbGRTdHIiLCJuZXdTdHIiLCJjYWxsYmFjayIsImRpZmYiLCJkaWZmVHJpbW1lZExpbmVzIiwiZ2VuZXJhdGVPcHRpb25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxRQUFRLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUFqQjs7Ozs7O0FBQ1BELFFBQVEsQ0FBQ0UsUUFBVCxHQUFvQixVQUFTQyxLQUFULEVBQWdCO0FBQ2xDLE1BQUlDLFFBQVEsR0FBRyxFQUFmO0FBQUEsTUFDSUMsZ0JBQWdCLEdBQUdGLEtBQUssQ0FBQ0csS0FBTixDQUFZLFdBQVosQ0FEdkIsQ0FEa0MsQ0FJbEM7O0FBQ0EsTUFBSSxDQUFDRCxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUNFLE1BQWpCLEdBQTBCLENBQTNCLENBQXJCLEVBQW9EO0FBQ2xERixJQUFBQSxnQkFBZ0IsQ0FBQ0csR0FBakI7QUFDRCxHQVBpQyxDQVNsQzs7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixnQkFBZ0IsQ0FBQ0UsTUFBckMsRUFBNkNFLENBQUMsRUFBOUMsRUFBa0Q7QUFDaEQsUUFBSUMsSUFBSSxHQUFHTCxnQkFBZ0IsQ0FBQ0ksQ0FBRCxDQUEzQjs7QUFFQSxRQUFJQSxDQUFDLEdBQUcsQ0FBSixJQUFTLENBQUMsS0FBS0UsT0FBTCxDQUFhQyxjQUEzQixFQUEyQztBQUN6Q1IsTUFBQUEsUUFBUSxDQUFDQSxRQUFRLENBQUNHLE1BQVQsR0FBa0IsQ0FBbkIsQ0FBUixJQUFpQ0csSUFBakM7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJLEtBQUtDLE9BQUwsQ0FBYUUsZ0JBQWpCLEVBQW1DO0FBQ2pDSCxRQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ0ksSUFBTCxFQUFQO0FBQ0Q7O0FBQ0RWLE1BQUFBLFFBQVEsQ0FBQ1csSUFBVCxDQUFjTCxJQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPTixRQUFQO0FBQ0QsQ0F4QkQ7O0FBMEJPLFNBQVNZLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCQyxNQUEzQixFQUFtQ0MsUUFBbkMsRUFBNkM7QUFBRSxTQUFPbkIsUUFBUSxDQUFDb0IsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QkMsUUFBOUIsQ0FBUDtBQUFpRDs7QUFDaEcsU0FBU0UsZ0JBQVQsQ0FBMEJKLE1BQTFCLEVBQWtDQyxNQUFsQyxFQUEwQ0MsUUFBMUMsRUFBb0Q7QUFDekQsTUFBSVIsT0FBTztBQUFHO0FBQUE7QUFBQTs7QUFBQVc7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQTtBQUFBLEdBQWdCSCxRQUFoQixFQUEwQjtBQUFDTixJQUFBQSxnQkFBZ0IsRUFBRTtBQUFuQixHQUExQixDQUFkO0FBQ0EsU0FBT2IsUUFBUSxDQUFDb0IsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QlAsT0FBOUIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7Z2VuZXJhdGVPcHRpb25zfSBmcm9tICcuLi91dGlsL3BhcmFtcyc7XG5cbmV4cG9ydCBjb25zdCBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5saW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGxldCByZXRMaW5lcyA9IFtdLFxuICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxufFxcclxcbikvKTtcblxuICAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcbiAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICB9XG5cbiAgLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG4gICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXRMaW5lcztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7IHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICBsZXQgb3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucyhjYWxsYmFjaywge2lnbm9yZVdoaXRlc3BhY2U6IHRydWV9KTtcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xufVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/diff/sentence.js":
/*!*************************************************!*\
  !*** ../node_modules/diff/lib/diff/sentence.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffSentences = diffSentences;
exports.sentenceDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var sentenceDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.sentenceDiff = sentenceDiff;

/*istanbul ignore end*/
sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3NlbnRlbmNlLmpzIl0sIm5hbWVzIjpbInNlbnRlbmNlRGlmZiIsIkRpZmYiLCJ0b2tlbml6ZSIsInZhbHVlIiwic3BsaXQiLCJkaWZmU2VudGVuY2VzIiwib2xkU3RyIiwibmV3U3RyIiwiY2FsbGJhY2siLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFHTyxJQUFNQSxZQUFZLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUEsQ0FBSixFQUFyQjs7Ozs7O0FBQ1BELFlBQVksQ0FBQ0UsUUFBYixHQUF3QixVQUFTQyxLQUFULEVBQWdCO0FBQ3RDLFNBQU9BLEtBQUssQ0FBQ0MsS0FBTixDQUFZLHVCQUFaLENBQVA7QUFDRCxDQUZEOztBQUlPLFNBQVNDLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxNQUEvQixFQUF1Q0MsUUFBdkMsRUFBaUQ7QUFBRSxTQUFPUixZQUFZLENBQUNTLElBQWIsQ0FBa0JILE1BQWxCLEVBQTBCQyxNQUExQixFQUFrQ0MsUUFBbEMsQ0FBUDtBQUFxRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5cblxuZXhwb3J0IGNvbnN0IHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHsgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7IH1cbiJdfQ==


/***/ }),

/***/ "../node_modules/diff/lib/diff/word.js":
/*!*********************************************!*\
  !*** ../node_modules/diff/lib/diff/word.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffWords = diffWords;
exports.diffWordsWithSpace = diffWordsWithSpace;
exports.wordDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "../node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.wordDiff = wordDiff;

/*istanbul ignore end*/
wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}

function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL3dvcmQuanMiXSwibmFtZXMiOlsiZXh0ZW5kZWRXb3JkQ2hhcnMiLCJyZVdoaXRlc3BhY2UiLCJ3b3JkRGlmZiIsIkRpZmYiLCJlcXVhbHMiLCJsZWZ0IiwicmlnaHQiLCJvcHRpb25zIiwiaWdub3JlQ2FzZSIsInRvTG93ZXJDYXNlIiwiaWdub3JlV2hpdGVzcGFjZSIsInRlc3QiLCJ0b2tlbml6ZSIsInZhbHVlIiwidG9rZW5zIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwic3BsaWNlIiwiZGlmZldvcmRzIiwib2xkU3RyIiwibmV3U3RyIiwiZ2VuZXJhdGVPcHRpb25zIiwiZGlmZiIsImRpZmZXb3Jkc1dpdGhTcGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsaUJBQWlCLEdBQUcsK0RBQTFCO0FBRUEsSUFBTUMsWUFBWSxHQUFHLElBQXJCO0FBRU8sSUFBTUMsUUFBUSxHQUFHO0FBQUlDO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBLENBQUosRUFBakI7Ozs7OztBQUNQRCxRQUFRLENBQUNFLE1BQVQsR0FBa0IsVUFBU0MsSUFBVCxFQUFlQyxLQUFmLEVBQXNCO0FBQ3RDLE1BQUksS0FBS0MsT0FBTCxDQUFhQyxVQUFqQixFQUE2QjtBQUMzQkgsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNJLFdBQUwsRUFBUDtBQUNBSCxJQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ0csV0FBTixFQUFSO0FBQ0Q7O0FBQ0QsU0FBT0osSUFBSSxLQUFLQyxLQUFULElBQW1CLEtBQUtDLE9BQUwsQ0FBYUcsZ0JBQWIsSUFBaUMsQ0FBQ1QsWUFBWSxDQUFDVSxJQUFiLENBQWtCTixJQUFsQixDQUFsQyxJQUE2RCxDQUFDSixZQUFZLENBQUNVLElBQWIsQ0FBa0JMLEtBQWxCLENBQXhGO0FBQ0QsQ0FORDs7QUFPQUosUUFBUSxDQUFDVSxRQUFULEdBQW9CLFVBQVNDLEtBQVQsRUFBZ0I7QUFDbEM7QUFDQSxNQUFJQyxNQUFNLEdBQUdELEtBQUssQ0FBQ0UsS0FBTixDQUFZLGlDQUFaLENBQWIsQ0FGa0MsQ0FJbEM7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixNQUFNLENBQUNHLE1BQVAsR0FBZ0IsQ0FBcEMsRUFBdUNELENBQUMsRUFBeEMsRUFBNEM7QUFDMUM7QUFDQSxRQUFJLENBQUNGLE1BQU0sQ0FBQ0UsQ0FBQyxHQUFHLENBQUwsQ0FBUCxJQUFrQkYsTUFBTSxDQUFDRSxDQUFDLEdBQUcsQ0FBTCxDQUF4QixJQUNLaEIsaUJBQWlCLENBQUNXLElBQWxCLENBQXVCRyxNQUFNLENBQUNFLENBQUQsQ0FBN0IsQ0FETCxJQUVLaEIsaUJBQWlCLENBQUNXLElBQWxCLENBQXVCRyxNQUFNLENBQUNFLENBQUMsR0FBRyxDQUFMLENBQTdCLENBRlQsRUFFZ0Q7QUFDOUNGLE1BQUFBLE1BQU0sQ0FBQ0UsQ0FBRCxDQUFOLElBQWFGLE1BQU0sQ0FBQ0UsQ0FBQyxHQUFHLENBQUwsQ0FBbkI7QUFDQUYsTUFBQUEsTUFBTSxDQUFDSSxNQUFQLENBQWNGLENBQUMsR0FBRyxDQUFsQixFQUFxQixDQUFyQjtBQUNBQSxNQUFBQSxDQUFDO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPRixNQUFQO0FBQ0QsQ0FqQkQ7O0FBbUJPLFNBQVNLLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCQyxNQUEzQixFQUFtQ2QsT0FBbkMsRUFBNEM7QUFDakRBLEVBQUFBLE9BQU87QUFBRztBQUFBO0FBQUE7O0FBQUFlO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUFBO0FBQUE7QUFBQSxHQUFnQmYsT0FBaEIsRUFBeUI7QUFBQ0csSUFBQUEsZ0JBQWdCLEVBQUU7QUFBbkIsR0FBekIsQ0FBVjtBQUNBLFNBQU9SLFFBQVEsQ0FBQ3FCLElBQVQsQ0FBY0gsTUFBZCxFQUFzQkMsTUFBdEIsRUFBOEJkLE9BQTlCLENBQVA7QUFDRDs7QUFFTSxTQUFTaUIsa0JBQVQsQ0FBNEJKLE1BQTVCLEVBQW9DQyxNQUFwQyxFQUE0Q2QsT0FBNUMsRUFBcUQ7QUFDMUQsU0FBT0wsUUFBUSxDQUFDcUIsSUFBVCxDQUFjSCxNQUFkLEVBQXNCQyxNQUF0QixFQUE4QmQsT0FBOUIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpZmYgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7Z2VuZXJhdGVPcHRpb25zfSBmcm9tICcuLi91dGlsL3BhcmFtcyc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbi8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG5jb25zdCBleHRlbmRlZFdvcmRDaGFycyA9IC9eW2EtekEtWlxcdXtDMH0tXFx1e0ZGfVxcdXtEOH0tXFx1e0Y2fVxcdXtGOH0tXFx1ezJDNn1cXHV7MkM4fS1cXHV7MkQ3fVxcdXsyREV9LVxcdXsyRkZ9XFx1ezFFMDB9LVxcdXsxRUZGfV0rJC91O1xuXG5jb25zdCByZVdoaXRlc3BhY2UgPSAvXFxTLztcblxuZXhwb3J0IGNvbnN0IHdvcmREaWZmID0gbmV3IERpZmYoKTtcbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSkge1xuICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KGxlZnQpICYmICFyZVdoaXRlc3BhY2UudGVzdChyaWdodCkpO1xufTtcbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gQWxsIHdoaXRlc3BhY2Ugc3ltYm9scyBleGNlcHQgbmV3bGluZSBncm91cCBpbnRvIG9uZSB0b2tlbiwgZWFjaCBuZXdsaW5lIC0gaW4gc2VwYXJhdGUgdG9rZW5cbiAgbGV0IHRva2VucyA9IHZhbHVlLnNwbGl0KC8oW15cXFNcXHJcXG5dK3xbKClbXFxde30nXCJcXHJcXG5dfFxcYikvKTtcblxuICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXh0IGZpZWxkIGFuZCB3ZSBoYXZlIG9ubHkgd29yZCBjaGFycyBiZWZvcmUgYW5kIGFmdGVyLCBtZXJnZVxuICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pXG4gICAgICAgICAgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIHtpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/index.js":
/*!*****************************************!*\
  !*** ../node_modules/diff/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Diff", ({
  enumerable: true,
  get: function get() {
    return _base["default"];
  }
}));
Object.defineProperty(exports, "diffChars", ({
  enumerable: true,
  get: function get() {
    return _character.diffChars;
  }
}));
Object.defineProperty(exports, "diffWords", ({
  enumerable: true,
  get: function get() {
    return _word.diffWords;
  }
}));
Object.defineProperty(exports, "diffWordsWithSpace", ({
  enumerable: true,
  get: function get() {
    return _word.diffWordsWithSpace;
  }
}));
Object.defineProperty(exports, "diffLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffLines;
  }
}));
Object.defineProperty(exports, "diffTrimmedLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffTrimmedLines;
  }
}));
Object.defineProperty(exports, "diffSentences", ({
  enumerable: true,
  get: function get() {
    return _sentence.diffSentences;
  }
}));
Object.defineProperty(exports, "diffCss", ({
  enumerable: true,
  get: function get() {
    return _css.diffCss;
  }
}));
Object.defineProperty(exports, "diffJson", ({
  enumerable: true,
  get: function get() {
    return _json.diffJson;
  }
}));
Object.defineProperty(exports, "canonicalize", ({
  enumerable: true,
  get: function get() {
    return _json.canonicalize;
  }
}));
Object.defineProperty(exports, "diffArrays", ({
  enumerable: true,
  get: function get() {
    return _array.diffArrays;
  }
}));
Object.defineProperty(exports, "applyPatch", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatch;
  }
}));
Object.defineProperty(exports, "applyPatches", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatches;
  }
}));
Object.defineProperty(exports, "parsePatch", ({
  enumerable: true,
  get: function get() {
    return _parse.parsePatch;
  }
}));
Object.defineProperty(exports, "merge", ({
  enumerable: true,
  get: function get() {
    return _merge.merge;
  }
}));
Object.defineProperty(exports, "structuredPatch", ({
  enumerable: true,
  get: function get() {
    return _create.structuredPatch;
  }
}));
Object.defineProperty(exports, "createTwoFilesPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createTwoFilesPatch;
  }
}));
Object.defineProperty(exports, "createPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createPatch;
  }
}));
Object.defineProperty(exports, "convertChangesToDMP", ({
  enumerable: true,
  get: function get() {
    return _dmp.convertChangesToDMP;
  }
}));
Object.defineProperty(exports, "convertChangesToXML", ({
  enumerable: true,
  get: function get() {
    return _xml.convertChangesToXML;
  }
}));

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./diff/base */ "../node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_character = __webpack_require__(/*! ./diff/character */ "../node_modules/diff/lib/diff/character.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_word = __webpack_require__(/*! ./diff/word */ "../node_modules/diff/lib/diff/word.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./diff/line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_sentence = __webpack_require__(/*! ./diff/sentence */ "../node_modules/diff/lib/diff/sentence.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_css = __webpack_require__(/*! ./diff/css */ "../node_modules/diff/lib/diff/css.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_json = __webpack_require__(/*! ./diff/json */ "../node_modules/diff/lib/diff/json.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ./diff/array */ "../node_modules/diff/lib/diff/array.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_apply = __webpack_require__(/*! ./patch/apply */ "../node_modules/diff/lib/patch/apply.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./patch/parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_merge = __webpack_require__(/*! ./patch/merge */ "../node_modules/diff/lib/patch/merge.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./patch/create */ "../node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_dmp = __webpack_require__(/*! ./convert/dmp */ "../node_modules/diff/lib/convert/dmp.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_xml = __webpack_require__(/*! ./convert/xml */ "../node_modules/diff/lib/convert/xml.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBTZWUgTElDRU5TRSBmaWxlIGZvciB0ZXJtcyBvZiB1c2UgKi9cblxuLypcbiAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBBUElTOlxuICogSnNEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXG4gKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcYiByZWdleCkgZGlmZiB3aGljaCBpZ25vcmVzIHdoaXRlc3BhY2VcbiAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxuICpcbiAqIEpzRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XG4gKlxuICogVGhlc2UgbWV0aG9kcyBhcmUgYmFzZWQgb24gdGhlIGltcGxlbWVudGF0aW9uIHByb3Bvc2VkIGluXG4gKiBcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgVmFyaWF0aW9uc1wiIChNeWVycywgMTk4NikuXG4gKiBodHRwOi8vY2l0ZXNlZXJ4LmlzdC5wc3UuZWR1L3ZpZXdkb2Mvc3VtbWFyeT9kb2k9MTAuMS4xLjQuNjkyN1xuICovXG5pbXBvcnQgRGlmZiBmcm9tICcuL2RpZmYvYmFzZSc7XG5pbXBvcnQge2RpZmZDaGFyc30gZnJvbSAnLi9kaWZmL2NoYXJhY3Rlcic7XG5pbXBvcnQge2RpZmZXb3JkcywgZGlmZldvcmRzV2l0aFNwYWNlfSBmcm9tICcuL2RpZmYvd29yZCc7XG5pbXBvcnQge2RpZmZMaW5lcywgZGlmZlRyaW1tZWRMaW5lc30gZnJvbSAnLi9kaWZmL2xpbmUnO1xuaW1wb3J0IHtkaWZmU2VudGVuY2VzfSBmcm9tICcuL2RpZmYvc2VudGVuY2UnO1xuXG5pbXBvcnQge2RpZmZDc3N9IGZyb20gJy4vZGlmZi9jc3MnO1xuaW1wb3J0IHtkaWZmSnNvbiwgY2Fub25pY2FsaXplfSBmcm9tICcuL2RpZmYvanNvbic7XG5cbmltcG9ydCB7ZGlmZkFycmF5c30gZnJvbSAnLi9kaWZmL2FycmF5JztcblxuaW1wb3J0IHthcHBseVBhdGNoLCBhcHBseVBhdGNoZXN9IGZyb20gJy4vcGF0Y2gvYXBwbHknO1xuaW1wb3J0IHtwYXJzZVBhdGNofSBmcm9tICcuL3BhdGNoL3BhcnNlJztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJy4vcGF0Y2gvbWVyZ2UnO1xuaW1wb3J0IHtzdHJ1Y3R1cmVkUGF0Y2gsIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gsIGNyZWF0ZVBhdGNofSBmcm9tICcuL3BhdGNoL2NyZWF0ZSc7XG5cbmltcG9ydCB7Y29udmVydENoYW5nZXNUb0RNUH0gZnJvbSAnLi9jb252ZXJ0L2RtcCc7XG5pbXBvcnQge2NvbnZlcnRDaGFuZ2VzVG9YTUx9IGZyb20gJy4vY29udmVydC94bWwnO1xuXG5leHBvcnQge1xuICBEaWZmLFxuXG4gIGRpZmZDaGFycyxcbiAgZGlmZldvcmRzLFxuICBkaWZmV29yZHNXaXRoU3BhY2UsXG4gIGRpZmZMaW5lcyxcbiAgZGlmZlRyaW1tZWRMaW5lcyxcbiAgZGlmZlNlbnRlbmNlcyxcblxuICBkaWZmQ3NzLFxuICBkaWZmSnNvbixcblxuICBkaWZmQXJyYXlzLFxuXG4gIHN0cnVjdHVyZWRQYXRjaCxcbiAgY3JlYXRlVHdvRmlsZXNQYXRjaCxcbiAgY3JlYXRlUGF0Y2gsXG4gIGFwcGx5UGF0Y2gsXG4gIGFwcGx5UGF0Y2hlcyxcbiAgcGFyc2VQYXRjaCxcbiAgbWVyZ2UsXG4gIGNvbnZlcnRDaGFuZ2VzVG9ETVAsXG4gIGNvbnZlcnRDaGFuZ2VzVG9YTUwsXG4gIGNhbm9uaWNhbGl6ZVxufTtcbiJdfQ==


/***/ }),

/***/ "../node_modules/diff/lib/patch/apply.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/apply.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyPatch = applyPatch;
exports.applyPatches = applyPatches;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_distanceIterator = _interopRequireDefault(__webpack_require__(/*! ../util/distance-iterator */ "../node_modules/diff/lib/util/distance-iterator.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
function applyPatch(source, uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _distanceIterator
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ])(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters[j];

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.


function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9hcHBseS5qcyJdLCJuYW1lcyI6WyJhcHBseVBhdGNoIiwic291cmNlIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJwYXJzZVBhdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiRXJyb3IiLCJsaW5lcyIsInNwbGl0IiwiZGVsaW1pdGVycyIsIm1hdGNoIiwiaHVua3MiLCJjb21wYXJlTGluZSIsImxpbmVOdW1iZXIiLCJsaW5lIiwib3BlcmF0aW9uIiwicGF0Y2hDb250ZW50IiwiZXJyb3JDb3VudCIsImZ1enpGYWN0b3IiLCJtaW5MaW5lIiwib2Zmc2V0IiwicmVtb3ZlRU9GTkwiLCJhZGRFT0ZOTCIsImh1bmtGaXRzIiwiaHVuayIsInRvUG9zIiwiaiIsImNvbnRlbnQiLCJzdWJzdHIiLCJpIiwibWF4TGluZSIsIm9sZExpbmVzIiwibG9jYWxPZmZzZXQiLCJvbGRTdGFydCIsIml0ZXJhdG9yIiwiZGlzdGFuY2VJdGVyYXRvciIsInVuZGVmaW5lZCIsImRpZmZPZmZzZXQiLCJuZXdMaW5lcyIsImRlbGltaXRlciIsImxpbmVkZWxpbWl0ZXJzIiwic3BsaWNlIiwicHJldmlvdXNPcGVyYXRpb24iLCJwb3AiLCJwdXNoIiwiX2siLCJqb2luIiwiYXBwbHlQYXRjaGVzIiwiY3VycmVudEluZGV4IiwicHJvY2Vzc0luZGV4IiwiaW5kZXgiLCJjb21wbGV0ZSIsImxvYWRGaWxlIiwiZXJyIiwiZGF0YSIsInVwZGF0ZWRDb250ZW50IiwicGF0Y2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxTQUFTQSxVQUFULENBQW9CQyxNQUFwQixFQUE0QkMsT0FBNUIsRUFBbUQ7QUFBQTtBQUFBO0FBQUE7QUFBZEMsRUFBQUEsT0FBYyx1RUFBSixFQUFJOztBQUN4RCxNQUFJLE9BQU9ELE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7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QUNEOztBQUVELE1BQUlnRCxZQUFZLEdBQUcsQ0FBbkI7O0FBQ0EsV0FBU0MsWUFBVCxHQUF3QjtBQUN0QixRQUFJQyxLQUFLLEdBQUdsRCxPQUFPLENBQUNnRCxZQUFZLEVBQWIsQ0FBbkI7O0FBQ0EsUUFBSSxDQUFDRSxLQUFMLEVBQVk7QUFDVixhQUFPakQsT0FBTyxDQUFDa0QsUUFBUixFQUFQO0FBQ0Q7O0FBRURsRCxJQUFBQSxPQUFPLENBQUNtRCxRQUFSLENBQWlCRixLQUFqQixFQUF3QixVQUFTRyxHQUFULEVBQWNDLElBQWQsRUFBb0I7QUFDMUMsVUFBSUQsR0FBSixFQUFTO0FBQ1AsZUFBT3BELE9BQU8sQ0FBQ2tELFFBQVIsQ0FBaUJFLEdBQWpCLENBQVA7QUFDRDs7QUFFRCxVQUFJRSxjQUFjLEdBQUd6RCxVQUFVLENBQUN3RCxJQUFELEVBQU9KLEtBQVAsRUFBY2pELE9BQWQsQ0FBL0I7QUFDQUEsTUFBQUEsT0FBTyxDQUFDdUQsT0FBUixDQUFnQk4sS0FBaEIsRUFBdUJLLGNBQXZCLEVBQXVDLFVBQVNGLEdBQVQsRUFBYztBQUNuRCxZQUFJQSxHQUFKLEVBQVM7QUFDUCxpQkFBT3BELE9BQU8sQ0FBQ2tELFFBQVIsQ0FBaUJFLEdBQWpCLENBQVA7QUFDRDs7QUFFREosUUFBQUEsWUFBWTtBQUNiLE9BTkQ7QUFPRCxLQWJEO0FBY0Q7O0FBQ0RBLEVBQUFBLFlBQVk7QUFDYiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQgZGlzdGFuY2VJdGVyYXRvciBmcm9tICcuLi91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcbiAgICBpZiAodW5pRGlmZi5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgIH1cblxuICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xuICB9XG5cbiAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuXG4gICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgKChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkgPT4gbGluZSA9PT0gcGF0Y2hDb250ZW50KSxcbiAgICAgIGVycm9yQ291bnQgPSAwLFxuICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxuICAgICAgbWluTGluZSA9IDAsXG4gICAgICBvZmZzZXQgPSAwLFxuXG4gICAgICByZW1vdmVFT0ZOTCxcbiAgICAgIGFkZEVPRk5MO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBsaW5lID0gaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSAobGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyksXG4gICAgICAgICAgY29udGVudCA9IChsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUpO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcbiAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xuICAgICAgICAgIGVycm9yQ291bnQrKztcblxuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1BvcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGh1bmsgPSBodW5rc1tpXSxcbiAgICAgICAgbWF4TGluZSA9IGxpbmVzLmxlbmd0aCAtIGh1bmsub2xkTGluZXMsXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcblxuICAgIGxldCBpdGVyYXRvciA9IGRpc3RhbmNlSXRlcmF0b3IodG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xuXG4gICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xuICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XG4gICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XG4gICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcbiAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcbiAgfVxuXG4gIC8vIEFwcGx5IHBhdGNoIGh1bmtzXG4gIGxldCBkaWZmT2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBodW5rID0gaHVua3NbaV0sXG4gICAgICAgIHRvUG9zID0gaHVuay5vbGRTdGFydCArIGh1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XG4gICAgZGlmZk9mZnNldCArPSBodW5rLm5ld0xpbmVzIC0gaHVuay5vbGRMaW5lcztcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IChsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnKSxcbiAgICAgICAgICBjb250ZW50ID0gKGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZSksXG4gICAgICAgICAgZGVsaW1pdGVyID0gaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgIHRvUG9zKys7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMSk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAxKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZSh0b1BvcywgMCwgY29udGVudCk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKHRvUG9zLCAwLCBkZWxpbWl0ZXIpO1xuICAgICAgICB0b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICBsZXQgcHJldmlvdXNPcGVyYXRpb24gPSBodW5rLmxpbmVzW2ogLSAxXSA/IGh1bmsubGluZXNbaiAtIDFdWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXG4nKTtcbiAgfVxuICBmb3IgKGxldCBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xuICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICB9XG4gIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbn1cblxuLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgbGV0IGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NJbmRleCgpO1xufVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/patch/create.js":
/*!************************************************!*\
  !*** ../node_modules/diff/lib/patch/create.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.structuredPatch = structuredPatch;
exports.formatPatch = formatPatch;
exports.createTwoFilesPatch = createTwoFilesPatch;
exports.createPatch = createPatch;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ../diff/line */ "../node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _line
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  diffLines)
  /*istanbul ignore end*/
  (oldStr, newStr, options);
  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  /*istanbul ignore start*/
  var _loop = function _loop(
  /*istanbul ignore end*/
  i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_curRange =
      /*istanbul ignore end*/
      curRange).push.apply(
      /*istanbul ignore start*/
      _curRange
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange2 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange2
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange3 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange3
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              // however, if the old file is empty, do not output the no-nl line
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    /*istanbul ignore start*/
    _loop(
    /*istanbul ignore end*/
    i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}

function formatPatch(diff) {
  var ret = [];

  if (diff.oldFileName == diff.newFileName) {
    ret.push('Index: ' + diff.oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }

    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}

function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}

function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9jcmVhdGUuanMiXSwibmFtZXMiOlsic3RydWN0dXJlZFBhdGNoIiwib2xkRmlsZU5hbWUiLCJuZXdGaWxlTmFtZSIsIm9sZFN0ciIsIm5ld1N0ciIsIm9sZEhlYWRlciIsIm5ld0hlYWRlciIsIm9wdGlvbnMiLCJjb250ZXh0IiwiZGlmZiIsImRpZmZMaW5lcyIsInB1c2giLCJ2YWx1ZSIsImxpbmVzIiwiY29udGV4dExpbmVzIiwibWFwIiwiZW50cnkiLCJodW5rcyIsIm9sZFJhbmdlU3RhcnQiLCJuZXdSYW5nZVN0YXJ0IiwiY3VyUmFuZ2UiLCJvbGRMaW5lIiwibmV3TGluZSIsImkiLCJjdXJyZW50IiwicmVwbGFjZSIsInNwbGl0IiwiYWRkZWQiLCJyZW1vdmVkIiwicHJldiIsInNsaWNlIiwibGVuZ3RoIiwiY29udGV4dFNpemUiLCJNYXRoIiwibWluIiwiaHVuayIsIm9sZFN0YXJ0Iiwib2xkTGluZXMiLCJuZXdTdGFydCIsIm5ld0xpbmVzIiwib2xkRU9GTmV3bGluZSIsInRlc3QiLCJuZXdFT0ZOZXdsaW5lIiwibm9ObEJlZm9yZUFkZHMiLCJzcGxpY2UiLCJmb3JtYXRQYXRjaCIsInJldCIsImFwcGx5Iiwiam9pbiIsImNyZWF0ZVR3b0ZpbGVzUGF0Y2giLCJjcmVhdGVQYXRjaCIsImZpbGVOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFFTyxTQUFTQSxlQUFULENBQXlCQyxXQUF6QixFQUFzQ0MsV0FBdEMsRUFBbURDLE1BQW5ELEVBQTJEQyxNQUEzRCxFQUFtRUMsU0FBbkUsRUFBOEVDLFNBQTlFLEVBQXlGQyxPQUF6RixFQUFrRztBQUN2RyxNQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaQSxJQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEOztBQUNELE1BQUksT0FBT0EsT0FBTyxDQUFDQyxPQUFmLEtBQTJCLFdBQS9CLEVBQTRDO0FB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eHBvcnQgZnVuY3Rpb24gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgY29uc3QgZGlmZiA9IGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gIGRpZmYucHVzaCh7dmFsdWU6ICcnLCBsaW5lczogW119KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcblxuICBmdW5jdGlvbiBjb250ZXh0TGluZXMobGluZXMpIHtcbiAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAnICcgKyBlbnRyeTsgfSk7XG4gIH1cblxuICBsZXQgaHVua3MgPSBbXTtcbiAgbGV0IG9sZFJhbmdlU3RhcnQgPSAwLCBuZXdSYW5nZVN0YXJ0ID0gMCwgY3VyUmFuZ2UgPSBbXSxcbiAgICAgIG9sZExpbmUgPSAxLCBuZXdMaW5lID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgICAgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IGN1cnJlbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xuXG4gICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBkaWZmW2kgLSAxXTtcbiAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XG4gICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3V0cHV0IG91ciBjaGFuZ2VzXG4gICAgICBjdXJSYW5nZS5wdXNoKC4uLiBsaW5lcy5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGVudHJ5O1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xuICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXG4gICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCAqIDIgJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xuICAgICAgICAgIC8vIE92ZXJsYXBwaW5nXG4gICAgICAgICAgY3VyUmFuZ2UucHVzaCguLi4gY29udGV4dExpbmVzKGxpbmVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW5kIHRoZSByYW5nZSBhbmQgb3V0cHV0XG4gICAgICAgICAgbGV0IGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xuICAgICAgICAgIGN1clJhbmdlLnB1c2goLi4uIGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKTtcblxuICAgICAgICAgIGxldCBodW5rID0ge1xuICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICBvbGRMaW5lczogKG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUpLFxuICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXG4gICAgICAgICAgICBuZXdMaW5lczogKG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUpLFxuICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcbiAgICAgICAgICAgIGxldCBvbGRFT0ZOZXdsaW5lID0gKCgvXFxuJC8pLnRlc3Qob2xkU3RyKSk7XG4gICAgICAgICAgICBsZXQgbmV3RU9GTmV3bGluZSA9ICgoL1xcbiQvKS50ZXN0KG5ld1N0cikpO1xuICAgICAgICAgICAgbGV0IG5vTmxCZWZvcmVBZGRzID0gbGluZXMubGVuZ3RoID09IDAgJiYgY3VyUmFuZ2UubGVuZ3RoID4gaHVuay5vbGRMaW5lcztcbiAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiBub05sQmVmb3JlQWRkcyAmJiBvbGRTdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGlmIHRoZSBvbGQgZmlsZSBpcyBlbXB0eSwgZG8gbm90IG91dHB1dCB0aGUgbm8tbmwgbGluZVxuICAgICAgICAgICAgICBjdXJSYW5nZS5zcGxpY2UoaHVuay5vbGRMaW5lcywgMCwgJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghb2xkRU9GTmV3bGluZSAmJiAhbm9ObEJlZm9yZUFkZHMpIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuXG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxuICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLCBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICBodW5rczogaHVua3NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFBhdGNoKGRpZmYpIHtcbiAgY29uc3QgcmV0ID0gW107XG4gIGlmIChkaWZmLm9sZEZpbGVOYW1lID09IGRpZmYubmV3RmlsZU5hbWUpIHtcbiAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBkaWZmLm9sZEZpbGVOYW1lKTtcbiAgfVxuICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaHVuayA9IGRpZmYuaHVua3NbaV07XG4gICAgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgLT0gMTtcbiAgICB9XG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgLT0gMTtcbiAgICB9XG4gICAgcmV0LnB1c2goXG4gICAgICAnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lc1xuICAgICAgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXNcbiAgICAgICsgJyBAQCdcbiAgICApO1xuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUd29GaWxlc1BhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBmb3JtYXRQYXRjaChzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xufVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/patch/merge.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/merge.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calcLineCount = calcLineCount;
exports.merge = merge;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./create */ "../node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "../node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ../util/array */ "../node_modules/diff/lib/util/array.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function calcLineCount(hunk) {
  /*istanbul ignore start*/
  var _calcOldNewLineCount =
  /*istanbul ignore end*/
  calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}

function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return (
        /*istanbul ignore start*/
        (0,
        /*istanbul ignore end*/

        /*istanbul ignore start*/
        _parse
        /*istanbul ignore end*/
        .
        /*istanbul ignore start*/
        parsePatch)
        /*istanbul ignore end*/
        (param)[0]
      );
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return (
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/

      /*istanbul ignore start*/
      _create
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      structuredPatch)
      /*istanbul ignore end*/
      (undefined, undefined, base, param)
    );
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines;

      /*istanbul ignore end*/
      // Mine inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines2;

      /*istanbul ignore end*/
      // Theirs inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines2 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines2
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines3;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines3 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines3
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      myChanges));

      return;
    } else if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines4;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines4 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines4
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      theirChanges));

      return;
    }
  } else if (
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _array
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  arrayEqual)
  /*istanbul ignore end*/
  (myChanges, theirChanges)) {
    /*istanbul ignore start*/
    var _hunk$lines5;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines5 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines5
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    /*istanbul ignore start*/
    var _hunk$lines6;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines6 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines6
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9tZXJnZS5qcyJdLCJuYW1lcyI6WyJjYWxjTGluZUNvdW50IiwiaHVuayIsImNhbGNPbGROZXdMaW5lQ291bnQiLCJsaW5lcyIsIm9sZExpbmVzIiwibmV3TGluZXMiLCJ1bmRlZmluZWQiLCJtZXJnZSIsIm1pbmUiLCJ0aGVpcnMiLCJiYXNlIiwibG9hZFBhdGNoIiwicmV0IiwiaW5kZXgiLCJuZXdGaWxlTmFtZSIsImZpbGVOYW1lQ2hhbmdlZCIsIm9sZEZpbGVOYW1lIiwib2xkSGVhZGVyIiwibmV3SGVhZGVyIiwic2VsZWN0RmllbGQiLCJodW5rcyIsIm1pbmVJbmRleCIsInRoZWlyc0luZGV4IiwibWluZU9mZnNldCIsInRoZWlyc09mZnNldCIsImxlbmd0aCIsIm1pbmVDdXJyZW50Iiwib2xkU3RhcnQiLCJJbmZpbml0eSIsInRoZWlyc0N1cnJlbnQiLCJodW5rQmVmb3JlIiwicHVzaCIsImNsb25lSHVuayIsIm1lcmdlZEh1bmsiLCJNYXRoIiwibWluIiwibmV3U3RhcnQiLCJtZXJnZUxpbmVzIiwicGFyYW0iLCJ0ZXN0IiwicGFyc2VQYXRjaCIsIkVycm9yIiwic3RydWN0dXJlZFBhdGNoIiwicGF0Y2giLCJjb25mbGljdCIsImNoZWNrIiwib2Zmc2V0IiwibWluZUxpbmVzIiwidGhlaXJPZmZzZXQiLCJ0aGVpckxpbmVzIiwidGhlaXIiLCJpbnNlcnRMZWFkaW5nIiwidGhlaXJDdXJyZW50IiwibXV0dWFsQ2hhbmdlIiwiY29sbGVjdENoYW5nZSIsInJlbW92YWwiLCJpbnNlcnRUcmFpbGluZyIsIm15Q2hhbmdlcyIsInRoZWlyQ2hhbmdlcyIsImFsbFJlbW92ZXMiLCJhcnJheVN0YXJ0c1dpdGgiLCJza2lwUmVtb3ZlU3VwZXJzZXQiLCJhcnJheUVxdWFsIiwic3dhcCIsImNvbGxlY3RDb250ZXh0IiwibWVyZ2VkIiwiaW5zZXJ0IiwibGluZSIsInN0YXRlIiwib3BlcmF0aW9uIiwibWF0Y2hDaGFuZ2VzIiwiY2hhbmdlcyIsIm1hdGNoSW5kZXgiLCJjb250ZXh0Q2hhbmdlcyIsImNvbmZsaWN0ZWQiLCJjaGFuZ2UiLCJtYXRjaCIsInN1YnN0ciIsInJlZHVjZSIsInByZXYiLCJyZW1vdmVDaGFuZ2VzIiwiZGVsdGEiLCJpIiwiY2hhbmdlQ29udGVudCIsImZvckVhY2giLCJteUNvdW50IiwidGhlaXJDb3VudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFFTyxTQUFTQSxhQUFULENBQXVCQyxJQUF2QixFQUE2QjtBQUFBO0FBQUE7QUFBQTtBQUNMQyxFQUFBQSxtQkFBbUIsQ0FBQ0QsSUFBSSxDQUFDRSxLQUFOLENBRGQ7QUFBQSxNQUMzQkMsUUFEMkIsd0JBQzNCQSxRQUQyQjtBQUFBLE1BQ2pCQyxRQURpQix3QkFDakJBLFFBRGlCOztBQUdsQyxNQUFJRCxRQUFRLEtBQUtFLFNBQWpCLEVBQTRCO0FBQzFCTCxJQUFBQSxJQUFJLENBQUNHLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0gsSUFBSSxDQUFDRyxRQUFaO0FBQ0Q7O0FBRUQsTUFBSUMsUUFBUSxLQUFLQyxTQUFqQixFQUE0QjtBQUMxQkwsSUFBQUEsSUFBSSxDQUFDSSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9KLElBQUksQ0FBQ0ksUUFBWjtBQUNEO0FBQ0Y7O0FBRU0sU0FBU0UsS0FBVCxDQUFlQyxJQUFmLEVBQXFCQyxNQUFyQixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDeENGLEVBQUFBLElBQUksR0FBR0csU0FBUyxDQUFDSCxJQUFELEVBQU9FLElBQVAsQ0FBaEI7QUFDQUQsRUFBQUEsTUFBTSxHQUFHRSxTQUFTLENBQUNGLE1BQUQsRUFBU0MsSUFBVCxDQUFsQjtBQUVBLE1BQUlFLEdBQUcsR0FBRyxFQUFWLENBSndD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QUFKLEVBQW9FO0FBQ2xFL0QsUUFBQUEsUUFBUTtBQUNUO0FBQ0Y7QUFDRixHQTVCRDtBQThCQSxTQUFPO0FBQUNBLElBQUFBLFFBQVEsRUFBUkEsUUFBRDtBQUFXQyxJQUFBQSxRQUFRLEVBQVJBO0FBQVgsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzdHJ1Y3R1cmVkUGF0Y2h9IGZyb20gJy4vY3JlYXRlJztcbmltcG9ydCB7cGFyc2VQYXRjaH0gZnJvbSAnLi9wYXJzZSc7XG5cbmltcG9ydCB7YXJyYXlFcXVhbCwgYXJyYXlTdGFydHNXaXRofSBmcm9tICcuLi91dGlsL2FycmF5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNMaW5lQ291bnQoaHVuaykge1xuICBjb25zdCB7b2xkTGluZXMsIG5ld0xpbmVzfSA9IGNhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyk7XG5cbiAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gIH1cblxuICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XG4gIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gIHRoZWlycyA9IGxvYWRQYXRjaCh0aGVpcnMsIGJhc2UpO1xuXG4gIGxldCByZXQgPSB7fTtcblxuICAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXG4gIC8vIExlYXZpbmcgc2FuaXR5IGNoZWNrcyBvbiB0aGlzIHRvIHRoZSBBUEkgY29uc3VtZXIgdGhhdCBtYXkga25vdyBtb3JlIGFib3V0IHRoZVxuICAvLyBtZWFuaW5nIGluIHRoZWlyIG93biBjb250ZXh0LlxuICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcbiAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgfVxuXG4gIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xuICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldC5odW5rcyA9IFtdO1xuXG4gIGxldCBtaW5lSW5kZXggPSAwLFxuICAgICAgdGhlaXJzSW5kZXggPSAwLFxuICAgICAgbWluZU9mZnNldCA9IDAsXG4gICAgICB0aGVpcnNPZmZzZXQgPSAwO1xuXG4gIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcbiAgICBsZXQgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwge29sZFN0YXJ0OiBJbmZpbml0eX0sXG4gICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHtvbGRTdGFydDogSW5maW5pdHl9O1xuXG4gICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XG4gICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKG1pbmVDdXJyZW50LCBtaW5lT2Zmc2V0KSk7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSBpZiAoaHVua0JlZm9yZSh0aGVpcnNDdXJyZW50LCBtaW5lQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3ZlcmxhcCwgbWVyZ2UgYXMgYmVzdCB3ZSBjYW5cbiAgICAgIGxldCBtZXJnZWRIdW5rID0ge1xuICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICBvbGRMaW5lczogMCxcbiAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXG4gICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICBsaW5lczogW11cbiAgICAgIH07XG4gICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICB0aGVpcnNJbmRleCsrO1xuICAgICAgbWluZUluZGV4Kys7XG5cbiAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIGlmICgoL15AQC9tKS50ZXN0KHBhcmFtKSB8fCAoKC9eSW5kZXg6L20pLnRlc3QocGFyYW0pKSkge1xuICAgICAgcmV0dXJuIHBhcnNlUGF0Y2gocGFyYW0pWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRQYXRjaCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZSwgcGFyYW0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG5mdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcbiAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xuICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgcmV0dXJuIG1pbmU7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgIHJldHVybiB7bWluZSwgdGhlaXJzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XG4gIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnRcbiAgICAmJiAodGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMpIDwgY2hlY2sub2xkU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCwgb2xkTGluZXM6IGh1bmsub2xkTGluZXMsXG4gICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsIG5ld0xpbmVzOiBodW5rLm5ld0xpbmVzLFxuICAgIGxpbmVzOiBodW5rLmxpbmVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlTGluZXMoaHVuaywgbWluZU9mZnNldCwgbWluZUxpbmVzLCB0aGVpck9mZnNldCwgdGhlaXJMaW5lcykge1xuICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxuICAvLyBpcyB0aGUgb25seSBvdmVybGFwIHdoZXJlIHdlIGNhbiBzdWNjZXNzZnVsbHkgbWVyZ2UgdGhlIGNvbnRlbnQgaGVyZS5cbiAgbGV0IG1pbmUgPSB7b2Zmc2V0OiBtaW5lT2Zmc2V0LCBsaW5lczogbWluZUxpbmVzLCBpbmRleDogMH0sXG4gICAgICB0aGVpciA9IHtvZmZzZXQ6IHRoZWlyT2Zmc2V0LCBsaW5lczogdGhlaXJMaW5lcywgaW5kZXg6IDB9O1xuXG4gIC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG4gIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xuICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTtcblxuICAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG4gIHdoaWxlIChtaW5lLmluZGV4IDwgbWluZS5saW5lcy5sZW5ndGggJiYgdGhlaXIuaW5kZXggPCB0aGVpci5saW5lcy5sZW5ndGgpIHtcbiAgICBsZXQgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxuICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJylcbiAgICAgICAgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xuICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cbiAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBNaW5lIGluc2VydGVkXG4gICAgICBodW5rLmxpbmVzLnB1c2goLi4uIGNvbGxlY3RDaGFuZ2UobWluZSkpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnKycgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXJzIGluc2VydGVkXG4gICAgICBodW5rLmxpbmVzLnB1c2goLi4uIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgIHJlbW92YWwoaHVuaywgdGhlaXIsIG1pbmUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgaHVuay5saW5lcy5wdXNoKG1pbmVDdXJyZW50KTtcbiAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICB9XG4gIH1cblxuICAvLyBOb3cgcHVzaCBhbnl0aGluZyB0aGF0IG1heSBiZSByZW1haW5pbmdcbiAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgbWluZSk7XG4gIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcblxuICBjYWxjTGluZUNvdW50KGh1bmspO1xufVxuXG5mdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgbGV0IG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcylcbiAgICAgICAgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgaHVuay5saW5lcy5wdXNoKC4uLiBteUNoYW5nZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYXJyYXlTdGFydHNXaXRoKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKVxuICAgICAgICAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIGh1bmsubGluZXMucHVzaCguLi4gdGhlaXJDaGFuZ2VzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJyYXlFcXVhbChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykpIHtcbiAgICBodW5rLmxpbmVzLnB1c2goLi4uIG15Q2hhbmdlcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gIGxldCBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XG4gIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XG4gICAgaHVuay5saW5lcy5wdXNoKC4uLiB0aGVpckNoYW5nZXMubWVyZ2VkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xuICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgaHVuay5saW5lcy5wdXNoKHtcbiAgICBjb25mbGljdDogdHJ1ZSxcbiAgICBtaW5lOiBtaW5lLFxuICAgIHRoZWlyczogdGhlaXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICB3aGlsZSAoaW5zZXJ0Lm9mZnNldCA8IHRoZWlyLm9mZnNldCAmJiBpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgbGV0IGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICBpbnNlcnQub2Zmc2V0Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xuICB3aGlsZSAoaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xuICBsZXQgcmV0ID0gW10sXG4gICAgICBvcGVyYXRpb24gPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF1bMF07XG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIGxldCBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdO1xuXG4gICAgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuICAgIGlmIChvcGVyYXRpb24gPT09ICctJyAmJiBsaW5lWzBdID09PSAnKycpIHtcbiAgICAgIG9wZXJhdGlvbiA9ICcrJztcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0aW9uID09PSBsaW5lWzBdKSB7XG4gICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gIGxldCBjaGFuZ2VzID0gW10sXG4gICAgICBtZXJnZWQgPSBbXSxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcbiAgICAgIGNvbmZsaWN0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoXG4gICAgICAgICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgbGV0IGNoYW5nZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XSxcbiAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07XG5cbiAgICAvLyBPbmNlIHdlJ3ZlIGhpdCBvdXIgYWRkLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG5cbiAgICBtZXJnZWQucHVzaChtYXRjaCk7XG4gICAgbWF0Y2hJbmRleCsrO1xuXG4gICAgLy8gQ29uc3VtZSBhbnkgYWRkaXRpb25zIGluIHRoZSBvdGhlciBibG9jayBhcyBhIGNvbmZsaWN0IHRvIGF0dGVtcHRcbiAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG4gICAgaWYgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnXG4gICAgICAmJiBjb250ZXh0Q2hhbmdlcykge1xuICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNvbmZsaWN0ZWQpIHtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCkge1xuICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVyZ2VkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxsUmVtb3ZlcyhjaGFuZ2VzKSB7XG4gIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjaGFuZ2UpIHtcbiAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcbiAgfSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgIGxldCBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuICAgIGlmIChzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleCArIGldICE9PSAnICcgKyBjaGFuZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gIGxldCBvbGRMaW5lcyA9IDA7XG4gIGxldCBuZXdMaW5lcyA9IDA7XG5cbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XG4gICAgICBsZXQgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xuXG4gICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xuICAgICAgICAgIG9sZExpbmVzICs9IG15Q291bnQub2xkTGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQubmV3TGluZXMgPT09IHRoZWlyQ291bnQubmV3TGluZXMpIHtcbiAgICAgICAgICBuZXdMaW5lcyArPSBteUNvdW50Lm5ld0xpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnKycgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICBuZXdMaW5lcysrO1xuICAgICAgfVxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG9sZExpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge29sZExpbmVzLCBuZXdMaW5lc307XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/patch/parse.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/patch/parse.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parsePatch = parsePatch;

/*istanbul ignore end*/
function parsePatch(uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
      lines: [],
      linedelimiters: []
    }; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }

    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXRjaC9wYXJzZS5qcyJdLCJuYW1lcyI6WyJwYXJzZVBhdGNoIiwidW5pRGlmZiIsIm9wdGlvbnMiLCJkaWZmc3RyIiwic3BsaXQiLCJkZWxpbWl0ZXJzIiwibWF0Y2giLCJsaXN0IiwiaSIsInBhcnNlSW5kZXgiLCJpbmRleCIsInB1c2giLCJsZW5ndGgiLCJsaW5lIiwidGVzdCIsImhlYWRlciIsImV4ZWMiLCJwYXJzZUZpbGVIZWFkZXIiLCJodW5rcyIsInBhcnNlSHVuayIsInN0cmljdCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpbGVIZWFkZXIiLCJrZXlQcmVmaXgiLCJkYXRhIiwiZmlsZU5hbWUiLCJyZXBsYWNlIiwic3Vic3RyIiwidHJpbSIsImNodW5rSGVhZGVySW5kZXgiLCJjaHVua0hlYWRlckxpbmUiLCJjaHVua0hlYWRlciIsImh1bmsiLCJvbGRTdGFydCIsIm9sZExpbmVzIiwibmV3U3RhcnQiLCJuZXdMaW5lcyIsImxpbmVzIiwibGluZWRlbGltaXRlcnMiLCJhZGRDb3VudCIsInJlbW92ZUNvdW50IiwiaW5kZXhPZiIsIm9wZXJhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsVUFBVCxDQUFvQkMsT0FBcEIsRUFBMkM7QUFBQTtBQUFBO0FBQUE7QUFBZEMsRUFBQUEsT0FBYyx1RUFBSixFQUFJO0FBQ2hELE1BQUlDLE9BQU8sR0FBR0YsT0FBTyxDQUFDRyxLQUFSLENBQWMscUJBQWQsQ0FBZDtBQUFBLE1BQ0lDLFVBQVUsR0FBR0osT0FBTyxDQUFDSyxLQUFSLENBQWMsc0JBQWQsS0FBeUMsRUFEMUQ7QUFBQSxNQUVJQyxJQUFJLEdBQUcsRUFGWDtBQUFBLE1BR0lDLENBQUMsR0FBRyxDQUhSOztBQUtBLFdBQVNDLFVBQVQsR0FBc0I7QUFDcEIsUUFBSUMsS0FBSyxHQUFHLEVBQVo7QUFDQUgsSUFBQUEsSUFBSSxDQUFDSSxJQUFMLENBQVVELEtBQVYsRUFGb0IsQ0FJcEI7O0FB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QUwsS0FBa0IsQ0FBbkMsRUFBc0M7QUFDcENKLE1BQUFBLElBQUksQ0FBQ0ksUUFBTCxHQUFnQixDQUFoQjtBQUNEOztBQUNELFFBQUksQ0FBQ0ksV0FBRCxJQUFnQlIsSUFBSSxDQUFDRSxRQUFMLEtBQWtCLENBQXRDLEVBQXlDO0FBQ3ZDRixNQUFBQSxJQUFJLENBQUNFLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRCxLQTVEa0IsQ0E4RG5COzs7QUFDQSxRQUFJbEMsT0FBTyxDQUFDa0IsTUFBWixFQUFvQjtBQUNsQixVQUFJcUIsUUFBUSxLQUFLUCxJQUFJLENBQUNJLFFBQXRCLEVBQWdDO0FBQzlCLGNBQU0sSUFBSWpCLEtBQUosQ0FBVSxzREFBc0RVLGdCQUFnQixHQUFHLENBQXpFLENBQVYsQ0FBTjtBQUNEOztBQUNELFVBQUlXLFdBQVcsS0FBS1IsSUFBSSxDQUFDRSxRQUF6QixFQUFtQztBQUNqQyxjQUFNLElBQUlmLEtBQUosQ0FBVSx3REFBd0RVLGdCQUFnQixHQUFHLENBQTNFLENBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0csSUFBUDtBQUNEOztBQUVELFNBQU8xQixDQUFDLEdBQUdMLE9BQU8sQ0FBQ1MsTUFBbkIsRUFBMkI7QUFDekJILElBQUFBLFVBQVU7QUFDWDs7QUFFRCxTQUFPRixJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgbGlzdCA9IFtdLFxuICAgICAgaSA9IDA7XG5cbiAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICBsZXQgaW5kZXggPSB7fTtcbiAgICBsaXN0LnB1c2goaW5kZXgpO1xuXG4gICAgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcbiAgICAgIGlmICgoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvKS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBEaWZmIGluZGV4XG4gICAgICBsZXQgaGVhZGVyID0gKC9eKD86SW5kZXg6fGRpZmYoPzogLXIgXFx3KykrKVxccysoLis/KVxccyokLykuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcblxuICAgIC8vIFBhcnNlIGh1bmtzXG4gICAgaW5kZXguaHVua3MgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgaWYgKCgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8pLnRlc3QobGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKCgvXkBALykudGVzdChsaW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAobGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KGxpbmUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgIGNvbnN0IGZpbGVIZWFkZXIgPSAoL14oLS0tfFxcK1xcK1xcKylcXHMrKC4qKSQvKS5leGVjKGRpZmZzdHJbaV0pO1xuICAgIGlmIChmaWxlSGVhZGVyKSB7XG4gICAgICBsZXQga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgY29uc3QgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgbGV0IGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgaWYgKCgvXlwiLipcIiQvKS50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIH1cbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuXG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2VzIGEgaHVua1xuICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cbiAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xuICAgIGxldCBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxuICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXGQrKSg/OiwoXFxkKykpPyBcXCsoXFxkKykoPzosKFxcZCspKT8gQEAvKTtcblxuICAgIGxldCBodW5rID0ge1xuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgIG9sZExpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbMl0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlclsyXSxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICBsaW5lczogW10sXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICB9O1xuXG4gICAgLy8gVW5pZmllZCBEaWZmIEZvcm1hdCBxdWlyazogSWYgdGhlIGNodW5rIHNpemUgaXMgMCxcbiAgICAvLyB0aGUgZmlyc3QgbnVtYmVyIGlzIG9uZSBsb3dlciB0aGFuIG9uZSB3b3VsZCBleHBlY3QuXG4gICAgLy8gaHR0cHM6Ly93d3cuYXJ0aW1hLmNvbS93ZWJsb2dzL3ZpZXdwb3N0LmpzcD90aHJlYWQ9MTY0MjkzXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICBsZXQgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG4gICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgLy8gQnV0IHRoZXkgY291bGQgYmUgdGhlIGhlYWRlciBmb3IgdGhlIG5leHQgZmlsZS4gVGhlcmVmb3JlIHBydW5lIHN1Y2ggY2FzZXMgb3V0LlxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwXG4gICAgICAgICAgICAmJiAoaSArIDIgPCBkaWZmc3RyLmxlbmd0aClcbiAgICAgICAgICAgICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMFxuICAgICAgICAgICAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IG9wZXJhdGlvbiA9IChkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gKGRpZmZzdHIubGVuZ3RoIC0gMSkpID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGh1bmsubGluZXMucHVzaChkaWZmc3RyW2ldKTtcbiAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIGVtcHR5IGJsb2NrIGNvdW50IGNhc2VcbiAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xuICAgIH1cbiAgICBpZiAoIXJlbW92ZUNvdW50ICYmIGh1bmsub2xkTGluZXMgPT09IDEpIHtcbiAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVuaztcbiAgfVxuXG4gIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICBwYXJzZUluZGV4KCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbiJdfQ==


/***/ }),

/***/ "../node_modules/diff/lib/util/array.js":
/*!**********************************************!*\
  !*** ../node_modules/diff/lib/util/array.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayEqual = arrayEqual;
exports.arrayStartsWith = arrayStartsWith;

/*istanbul ignore end*/
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}

function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2FycmF5LmpzIl0sIm5hbWVzIjpbImFycmF5RXF1YWwiLCJhIiwiYiIsImxlbmd0aCIsImFycmF5U3RhcnRzV2l0aCIsImFycmF5Iiwic3RhcnQiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU8sU0FBU0EsVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUJDLENBQXZCLEVBQTBCO0FBQy9CLE1BQUlELENBQUMsQ0FBQ0UsTUFBRixLQUFhRCxDQUFDLENBQUNDLE1BQW5CLEVBQTJCO0FBQ3pCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU9DLGVBQWUsQ0FBQ0gsQ0FBRCxFQUFJQyxDQUFKLENBQXRCO0FBQ0Q7O0FBRU0sU0FBU0UsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0NDLEtBQWhDLEVBQXVDO0FBQzVDLE1BQUlBLEtBQUssQ0FBQ0gsTUFBTixHQUFlRSxLQUFLLENBQUNGLE1BQXpCLEVBQWlDO0FBQy9CLFdBQU8sS0FBUDtBQUNEOztBQUVELE9BQUssSUFBSUksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDSCxNQUExQixFQUFrQ0ksQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJRCxLQUFLLENBQUNDLENBQUQsQ0FBTCxLQUFhRixLQUFLLENBQUNFLENBQUQsQ0FBdEIsRUFBMkI7QUFDekIsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XG4gIGlmIChzdGFydC5sZW5ndGggPiBhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIl19


/***/ }),

/***/ "../node_modules/diff/lib/util/distance-iterator.js":
/*!**********************************************************!*\
  !*** ../node_modules/diff/lib/util/distance-iterator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;

/*istanbul ignore end*/
// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function
/*istanbul ignore start*/
_default
/*istanbul ignore end*/
(start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIl0sIm5hbWVzIjpbInN0YXJ0IiwibWluTGluZSIsIm1heExpbmUiLCJ3YW50Rm9yd2FyZCIsImJhY2t3YXJkRXhoYXVzdGVkIiwiZm9yd2FyZEV4aGF1c3RlZCIsImxvY2FsT2Zmc2V0IiwiaXRlcmF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNlO0FBQUE7QUFBQTtBQUFBO0FBQUEsQ0FBU0EsS0FBVCxFQUFnQkMsT0FBaEIsRUFBeUJDLE9BQXpCLEVBQWtDO0FBQy9DLE1BQUlDLFdBQVcsR0FBRyxJQUFsQjtBQUFBLE1BQ0lDLGlCQUFpQixHQUFHLEtBRHhCO0FBQUEsTUFFSUMsZ0JBQWdCLEdBQUcsS0FGdkI7QUFBQSxNQUdJQyxXQUFXLEdBQUcsQ0FIbEI7QUFLQSxTQUFPLFNBQVNDLFFBQVQsR0FBb0I7QUFDekIsUUFBSUosV0FBVyxJQUFJLENBQUNFLGdCQUFwQixFQUFzQztBQUNwQyxVQUFJRCxpQkFBSixFQUF1QjtBQUNyQkUsUUFBQUEsV0FBVztBQUNaLE9BRkQsTUFFTztBQUNMSCxRQUFBQSxXQUFXLEdBQUcsS0FBZDtBQUNELE9BTG1DLENBT3BDO0FBQ0E7OztBQUNBLFVBQUlILEtBQUssR0FBR00sV0FBUixJQUF1QkosT0FBM0IsRUFBb0M7QUFDbEMsZUFBT0ksV0FBUDtBQUNEOztBQUVERCxNQUFBQSxnQkFBZ0IsR0FBRyxJQUFuQjtBQUNEOztBQUVELFFBQUksQ0FBQ0QsaUJBQUwsRUFBd0I7QUFDdEIsVUFBSSxDQUFDQyxnQkFBTCxFQUF1QjtBQUNyQkYsUUFBQUEsV0FBVyxHQUFHLElBQWQ7QUFDRCxPQUhxQixDQUt0QjtBQUNBOzs7QUFDQSxVQUFJRixPQUFPLElBQUlELEtBQUssR0FBR00sV0FBdkIsRUFBb0M7QUFDbEMsZUFBTyxDQUFDQSxXQUFXLEVBQW5CO0FBQ0Q7O0FBRURGLE1BQUFBLGlCQUFpQixHQUFHLElBQXBCO0FBQ0EsYUFBT0csUUFBUSxFQUFmO0FBQ0QsS0E5QndCLENBZ0N6QjtBQUNBOztBQUNELEdBbENEO0FBbUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSXRlcmF0b3IgdGhhdCB0cmF2ZXJzZXMgaW4gdGhlIHJhbmdlIG9mIFttaW4sIG1heF0sIHN0ZXBwaW5nXG4vLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XG4gIGxldCB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG4gICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgIHJldHVybiBsb2NhbE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/diff/lib/util/params.js":
/*!***********************************************!*\
  !*** ../node_modules/diff/lib/util/params.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateOptions = generateOptions;

/*istanbul ignore end*/
function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3BhcmFtcy5qcyJdLCJuYW1lcyI6WyJnZW5lcmF0ZU9wdGlvbnMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJjYWxsYmFjayIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sU0FBU0EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ2pELE1BQUksT0FBT0QsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ0MsSUFBQUEsUUFBUSxDQUFDQyxRQUFULEdBQW9CRixPQUFwQjtBQUNELEdBRkQsTUFFTyxJQUFJQSxPQUFKLEVBQWE7QUFDbEIsU0FBSyxJQUFJRyxJQUFULElBQWlCSCxPQUFqQixFQUEwQjtBQUN4QjtBQUNBLFVBQUlBLE9BQU8sQ0FBQ0ksY0FBUixDQUF1QkQsSUFBdkIsQ0FBSixFQUFrQztBQUNoQ0YsUUFBQUEsUUFBUSxDQUFDRSxJQUFELENBQVIsR0FBaUJILE9BQU8sQ0FBQ0csSUFBRCxDQUF4QjtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxTQUFPRixRQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG4iXX0=


/***/ }),

/***/ "../node_modules/escape-string-regexp/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/escape-string-regexp/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),

/***/ "../node_modules/events/events.js":
/*!****************************************!*\
  !*** ../node_modules/events/events.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "../node_modules/fdc3_1_2/dist/fdc3.esm.js":
/*!*************************************************!*\
  !*** ../node_modules/fdc3_1_2/dist/fdc3.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelError": () => (/* binding */ ChannelError),
/* harmony export */   "ContextTypes": () => (/* binding */ ContextTypes),
/* harmony export */   "Convert": () => (/* binding */ Convert),
/* harmony export */   "Intents": () => (/* binding */ Intents),
/* harmony export */   "OpenError": () => (/* binding */ OpenError),
/* harmony export */   "ResolveError": () => (/* binding */ ResolveError),
/* harmony export */   "addContextListener": () => (/* binding */ addContextListener),
/* harmony export */   "addIntentListener": () => (/* binding */ addIntentListener),
/* harmony export */   "broadcast": () => (/* binding */ broadcast),
/* harmony export */   "compareVersionNumbers": () => (/* binding */ compareVersionNumbers),
/* harmony export */   "fdc3Ready": () => (/* binding */ fdc3Ready),
/* harmony export */   "findIntent": () => (/* binding */ findIntent),
/* harmony export */   "findIntentsByContext": () => (/* binding */ findIntentsByContext),
/* harmony export */   "getCurrentChannel": () => (/* binding */ getCurrentChannel),
/* harmony export */   "getInfo": () => (/* binding */ getInfo),
/* harmony export */   "getOrCreateChannel": () => (/* binding */ getOrCreateChannel),
/* harmony export */   "getSystemChannels": () => (/* binding */ getSystemChannels),
/* harmony export */   "joinChannel": () => (/* binding */ joinChannel),
/* harmony export */   "leaveCurrentChannel": () => (/* binding */ leaveCurrentChannel),
/* harmony export */   "open": () => (/* binding */ open),
/* harmony export */   "raiseIntent": () => (/* binding */ raiseIntent),
/* harmony export */   "raiseIntentForContext": () => (/* binding */ raiseIntentForContext),
/* harmony export */   "versionIsAtLeast": () => (/* binding */ versionIsAtLeast)
/* harmony export */ });
/**
 * SPDX-License-Identifier: Apache-2.0
 * Copyright 2019 FINOS FDC3 contributors - see NOTICE file
 */
var OpenError;

(function (OpenError) {
  OpenError["AppNotFound"] = "AppNotFound";
  OpenError["ErrorOnLaunch"] = "ErrorOnLaunch";
  OpenError["AppTimeout"] = "AppTimeout";
  OpenError["ResolverUnavailable"] = "ResolverUnavailable";
})(OpenError || (OpenError = {}));

var ResolveError;

(function (ResolveError) {
  ResolveError["NoAppsFound"] = "NoAppsFound";
  ResolveError["ResolverUnavailable"] = "ResolverUnavailable";
  ResolveError["ResolverTimeout"] = "ResolverTimeout";
})(ResolveError || (ResolveError = {}));

var ChannelError;

(function (ChannelError) {
  ChannelError["NoChannelFound"] = "NoChannelFound";
  ChannelError["AccessDenied"] = "AccessDenied";
  ChannelError["CreationFailed"] = "CreationFailed";
})(ChannelError || (ChannelError = {}));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var DEFAULT_TIMEOUT = 5000;
var UnavailableError = /*#__PURE__*/new Error('FDC3 DesktopAgent not available at `window.fdc3`.');
var TimeoutError = /*#__PURE__*/new Error('Timed out waiting for `fdc3Ready` event.');
var UnexpectedError = /*#__PURE__*/new Error('`fdc3Ready` event fired, but `window.fdc3` not set to DesktopAgent.');

function rejectIfNoGlobal(f) {
  return window.fdc3 ? f() : Promise.reject(UnavailableError);
}

function throwIfNoGlobal(f) {
  if (!window.fdc3) {
    throw UnavailableError;
  }

  return f();
}

var fdc3Ready = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(waitForMs) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (waitForMs === void 0) {
              waitForMs = DEFAULT_TIMEOUT;
            }

            return _context.abrupt("return", new Promise(function (resolve, reject) {
              // if the global is already available resolve immediately
              if (window.fdc3) {
                resolve();
              } else {
                // if its not available setup a timeout to return a rejected promise
                var timeout = setTimeout(function () {
                  return window.fdc3 ? resolve() : reject(TimeoutError);
                }, waitForMs); // listen for the fdc3Ready event

                window.addEventListener('fdc3Ready', function () {
                  clearTimeout(timeout);
                  window.fdc3 ? resolve() : reject(UnexpectedError);
                }, {
                  once: true
                });
              }
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function fdc3Ready(_x) {
    return _ref.apply(this, arguments);
  };
}();
function open(app, context) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.open(app, context);
  });
}
function findIntent(intent, context) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.findIntent(intent, context);
  });
}
function findIntentsByContext(context) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.findIntentsByContext(context);
  });
}
function broadcast(context) {
  throwIfNoGlobal(function () {
    return window.fdc3.broadcast(context);
  });
}
function raiseIntent(intent, context, app) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.raiseIntent(intent, context, app);
  });
}
function raiseIntentForContext(context, app) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.raiseIntentForContext(context, app);
  });
}
function addIntentListener(intent, handler) {
  return throwIfNoGlobal(function () {
    return window.fdc3.addIntentListener(intent, handler);
  });
}
function addContextListener(contextTypeOrHandler, handler) {
  if (typeof contextTypeOrHandler !== 'function') {
    return throwIfNoGlobal(function () {
      return window.fdc3.addContextListener(contextTypeOrHandler, handler);
    });
  } else {
    return throwIfNoGlobal(function () {
      return window.fdc3.addContextListener(contextTypeOrHandler);
    });
  }
}
function getSystemChannels() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getSystemChannels();
  });
}
function joinChannel(channelId) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.joinChannel(channelId);
  });
}
function getOrCreateChannel(channelId) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getOrCreateChannel(channelId);
  });
}
function getCurrentChannel() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getCurrentChannel();
  });
}
function leaveCurrentChannel() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.leaveCurrentChannel();
  });
}
function getInfo() {
  return throwIfNoGlobal(function () {
    return window.fdc3.getInfo();
  });
}
/**
 * Compare numeric semver version number strings (in the form `1.2.3`).
 *
 * Returns `-1` if the first argument is a lower version number than the second,
 * `1` if the first argument is greater than the second, 0 if the arguments are
 * equal and `null` if an error occurred during the comparison.
 *
 * @param a
 * @param b
 */

var compareVersionNumbers = function compareVersionNumbers(a, b) {
  try {
    var aVerArr = a.split('.').map(Number);
    var bVerArr = b.split('.').map(Number);

    for (var index = 0; index < Math.max(aVerArr.length, bVerArr.length); index++) {
      /* If one version number has more digits and the other does not, and they are otherwise equal,
         assume the longer is greater. E.g. 1.1.1 > 1.1 */
      if (index === aVerArr.length || aVerArr[index] < bVerArr[index]) {
        return -1;
      } else if (index === bVerArr.length || aVerArr[index] > bVerArr[index]) {
        return 1;
      }
    }

    return 0;
  } catch (e) {
    console.error('Failed to compare version strings', e);
    return null;
  }
};
/**
 * Check if the FDC3 version in an ImplementationMetadata object is greater than
 * or equal to the supplied numeric semver version number string (in the form `1.2.3`).
 *
 * Returns a boolean or null if an error occurred while comparing the version numbers.
 *
 * @param metadata
 * @param version
 */

var versionIsAtLeast = function versionIsAtLeast(metadata, version) {
  var comparison = compareVersionNumbers(metadata.fdc3Version, version);
  return comparison === null ? null : comparison >= 0 ? true : false;
};

var ContextTypes;

(function (ContextTypes) {
  ContextTypes["Contact"] = "fdc3.contact";
  ContextTypes["ContactList"] = "fdc3.contactList";
  ContextTypes["Country"] = "fdc3.country";
  ContextTypes["Instrument"] = "fdc3.instrument";
  ContextTypes["Organization"] = "fdc3.organization";
  ContextTypes["Portfolio"] = "fdc3.portfolio";
  ContextTypes["Position"] = "fdc3.position";
})(ContextTypes || (ContextTypes = {}));

// To parse this data:
//
//   import { Convert, Context, Contact, ContactList, Instrument, InstrumentList, Country, Organization, Portfolio, Position } from "./file";
//
//   const context = Convert.toContext(json);
//   const contact = Convert.toContact(json);
//   const contactList = Convert.toContactList(json);
//   const instrument = Convert.toInstrument(json);
//   const instrumentList = Convert.toInstrumentList(json);
//   const country = Convert.toCountry(json);
//   const organization = Convert.toOrganization(json);
//   const portfolio = Convert.toPortfolio(json);
//   const position = Convert.toPosition(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.
// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
var Convert = /*#__PURE__*/function () {
  function Convert() {}

  Convert.toContext = function toContext(json) {
    return cast(JSON.parse(json), r('Context'));
  };

  Convert.contextToJson = function contextToJson(value) {
    return JSON.stringify(uncast(value, r('Context')), null, 2);
  };

  Convert.toContact = function toContact(json) {
    return cast(JSON.parse(json), r('Contact'));
  };

  Convert.contactToJson = function contactToJson(value) {
    return JSON.stringify(uncast(value, r('Contact')), null, 2);
  };

  Convert.toContactList = function toContactList(json) {
    return cast(JSON.parse(json), r('ContactList'));
  };

  Convert.contactListToJson = function contactListToJson(value) {
    return JSON.stringify(uncast(value, r('ContactList')), null, 2);
  };

  Convert.toInstrument = function toInstrument(json) {
    return cast(JSON.parse(json), r('Instrument'));
  };

  Convert.instrumentToJson = function instrumentToJson(value) {
    return JSON.stringify(uncast(value, r('Instrument')), null, 2);
  };

  Convert.toInstrumentList = function toInstrumentList(json) {
    return cast(JSON.parse(json), r('InstrumentList'));
  };

  Convert.instrumentListToJson = function instrumentListToJson(value) {
    return JSON.stringify(uncast(value, r('InstrumentList')), null, 2);
  };

  Convert.toCountry = function toCountry(json) {
    return cast(JSON.parse(json), r('Country'));
  };

  Convert.countryToJson = function countryToJson(value) {
    return JSON.stringify(uncast(value, r('Country')), null, 2);
  };

  Convert.toOrganization = function toOrganization(json) {
    return cast(JSON.parse(json), r('Organization'));
  };

  Convert.organizationToJson = function organizationToJson(value) {
    return JSON.stringify(uncast(value, r('Organization')), null, 2);
  };

  Convert.toPortfolio = function toPortfolio(json) {
    return cast(JSON.parse(json), r('Portfolio'));
  };

  Convert.portfolioToJson = function portfolioToJson(value) {
    return JSON.stringify(uncast(value, r('Portfolio')), null, 2);
  };

  Convert.toPosition = function toPosition(json) {
    return cast(JSON.parse(json), r('Position'));
  };

  Convert.positionToJson = function positionToJson(value) {
    return JSON.stringify(uncast(value, r('Position')), null, 2);
  };

  return Convert;
}();

function invalidValue(typ, val, key) {
  if (key === void 0) {
    key = '';
  }

  if (key) {
    throw Error("Invalid value for key \"" + key + "\". Expected type " + JSON.stringify(typ) + " but got " + JSON.stringify(val));
  }

  throw Error("Invalid value " + JSON.stringify(val) + " for type " + JSON.stringify(typ));
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.json] = {
        key: p.js,
        typ: p.typ
      };
    });
    typ.jsonToJS = map;
  }

  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.js] = {
        key: p.json,
        typ: p.typ
      };
    });
    typ.jsToJSON = map;
  }

  return typ.jsToJSON;
}

function transform(val, typ, getProps, key) {
  if (key === void 0) {
    key = '';
  }

  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    var l = typs.length;

    for (var i = 0; i < l; i++) {
      var _typ = typs[i];

      try {
        return transform(val, _typ, getProps);
      } catch (_) {}
    }

    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map(function (el) {
      return transform(el, typ, getProps);
    });
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }

    var d = new Date(val);

    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }

    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }

    var result = {};
    Object.getOwnPropertyNames(props).forEach(function (key) {
      var prop = props[key];
      var v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;

  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }

  if (typ === false) return invalidValue(typ, val);

  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }

  if (Array.isArray(typ)) return transformEnum(typ, val);

  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers') ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty('arrayItems') ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty('props') ? transformObject(getProps(typ), typ.additional, val) : invalidValue(typ, val);
  } // Numbers can be parsed by Date but shouldn't be.


  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return {
    arrayItems: typ
  };
}

function u() {
  for (var _len = arguments.length, typs = new Array(_len), _key = 0; _key < _len; _key++) {
    typs[_key] = arguments[_key];
  }

  return {
    unionMembers: typs
  };
}

function o(props, additional) {
  return {
    props: props,
    additional: additional
  };
}

function m(additional) {
  return {
    props: [],
    additional: additional
  };
}

function r(name) {
  return {
    ref: name
  };
}

var typeMap = {
  Context: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }], 'any'),
  ContactList: /*#__PURE__*/o([{
    json: 'contacts',
    js: 'contacts',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Contact'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Contact: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('ContactID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  ContactID: /*#__PURE__*/o([{
    json: 'email',
    js: 'email',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  InstrumentList: /*#__PURE__*/o([{
    json: 'instruments',
    js: 'instruments',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Instrument'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Instrument: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('InstrumentID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  InstrumentID: /*#__PURE__*/o([{
    json: 'BBG',
    js: 'BBG',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'CUSIP',
    js: 'CUSIP',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FIGI',
    js: 'FIGI',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ISIN',
    js: 'ISIN',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'PERMID',
    js: 'PERMID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'RIC',
    js: 'RIC',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'SEDOL',
    js: 'SEDOL',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ticker',
    js: 'ticker',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Country: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('CountryID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  CountryID: /*#__PURE__*/o([{
    json: 'ISOALPHA2',
    js: 'ISOALPHA2',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ISOALPHA3',
    js: 'ISOALPHA3',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Organization: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('OrganizationID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  OrganizationID: /*#__PURE__*/o([{
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'LEI',
    js: 'LEI',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'PERMID',
    js: 'PERMID',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Portfolio: /*#__PURE__*/o([{
    json: 'positions',
    js: 'positions',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Position'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Position: /*#__PURE__*/o([{
    json: 'holding',
    js: 'holding',
    typ: 3.14
  }, {
    json: 'instrument',
    js: 'instrument',
    typ: /*#__PURE__*/r('Instrument')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any')
};

var Intents;

(function (Intents) {
  Intents["StartCall"] = "StartCall";
  Intents["StartChat"] = "StartChat";
  Intents["ViewChart"] = "ViewChart";
  Intents["ViewContact"] = "ViewContact";
  Intents["ViewQuote"] = "ViewQuote";
  Intents["ViewNews"] = "ViewNews";
  Intents["ViewInstrument"] = "ViewInstrument";
  Intents["ViewAnalysis"] = "ViewAnalysis";
})(Intents || (Intents = {}));


//# sourceMappingURL=fdc3.esm.js.map


/***/ }),

/***/ "../node_modules/fdc3_2_0/dist/fdc3.esm.js":
/*!*************************************************!*\
  !*** ../node_modules/fdc3_2_0/dist/fdc3.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChannelError": () => (/* binding */ ChannelError),
/* harmony export */   "ContextTypes": () => (/* binding */ ContextTypes),
/* harmony export */   "Convert": () => (/* binding */ Convert),
/* harmony export */   "Intents": () => (/* binding */ Intents),
/* harmony export */   "OpenError": () => (/* binding */ OpenError),
/* harmony export */   "ResolveError": () => (/* binding */ ResolveError),
/* harmony export */   "ResultError": () => (/* binding */ ResultError),
/* harmony export */   "Style": () => (/* binding */ Style),
/* harmony export */   "addContextListener": () => (/* binding */ addContextListener),
/* harmony export */   "addIntentListener": () => (/* binding */ addIntentListener),
/* harmony export */   "broadcast": () => (/* binding */ broadcast),
/* harmony export */   "compareVersionNumbers": () => (/* binding */ compareVersionNumbers),
/* harmony export */   "fdc3Ready": () => (/* binding */ fdc3Ready),
/* harmony export */   "findIntent": () => (/* binding */ findIntent),
/* harmony export */   "findIntentsByContext": () => (/* binding */ findIntentsByContext),
/* harmony export */   "getAppMetadata": () => (/* binding */ getAppMetadata),
/* harmony export */   "getCurrentChannel": () => (/* binding */ getCurrentChannel),
/* harmony export */   "getInfo": () => (/* binding */ getInfo),
/* harmony export */   "getOrCreateChannel": () => (/* binding */ getOrCreateChannel),
/* harmony export */   "getSystemChannels": () => (/* binding */ getSystemChannels),
/* harmony export */   "getUserChannels": () => (/* binding */ getUserChannels),
/* harmony export */   "joinChannel": () => (/* binding */ joinChannel),
/* harmony export */   "joinUserChannel": () => (/* binding */ joinUserChannel),
/* harmony export */   "leaveCurrentChannel": () => (/* binding */ leaveCurrentChannel),
/* harmony export */   "open": () => (/* binding */ open),
/* harmony export */   "raiseIntent": () => (/* binding */ raiseIntent),
/* harmony export */   "raiseIntentForContext": () => (/* binding */ raiseIntentForContext),
/* harmony export */   "versionIsAtLeast": () => (/* binding */ versionIsAtLeast)
/* harmony export */ });
/**
 * SPDX-License-Identifier: Apache-2.0
 * Copyright FINOS FDC3 contributors - see NOTICE file
 */

/** Constants representing the errors that can be encountered when calling the `open` method on the DesktopAgent object (`fdc3`). */
var OpenError;

(function (OpenError) {
  /** Returned if the specified application is not found.*/
  OpenError["AppNotFound"] = "AppNotFound";
  /** Returned if the specified application fails to launch correctly.*/

  OpenError["ErrorOnLaunch"] = "ErrorOnLaunch";
  /** Returned if the specified application launches but fails to add a context listener in order to receive the context passed to the `fdc3.open` call.*/

  OpenError["AppTimeout"] = "AppTimeout";
  /** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/

  OpenError["ResolverUnavailable"] = "ResolverUnavailable";
})(OpenError || (OpenError = {}));
/** Constants representing the errors that can be encountered when calling the `findIntent`, `findIntentsByContext`, `raiseIntent` or `raiseIntentForContext` methods on the DesktopAgent (`fdc3`). */


var ResolveError;

(function (ResolveError) {
  /** SHOULD be returned if no apps are available that can resolve the intent and context combination.*/
  ResolveError["NoAppsFound"] = "NoAppsFound";
  /** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/

  ResolveError["ResolverUnavailable"] = "ResolverUnavailable";
  /** Returned if the user cancelled the resolution request, for example by closing or cancelling a resolver UI.*/

  ResolveError["UserCancelled"] = "UserCancelledResolution";
  /** SHOULD be returned if a timeout cancels an intent resolution that required user interaction. Please use `ResolverUnavailable` instead for situations where a resolver UI or similar fails.*/

  ResolveError["ResolverTimeout"] = "ResolverTimeout";
  /** Returned if a specified target application is not available or a new instance of it cannot be opened. */

  ResolveError["TargetAppUnavailable"] = "TargetAppUnavailable";
  /** Returned if a specified target application instance is not available, for example because it has been closed. */

  ResolveError["TargetInstanceUnavailable"] = "TargetInstanceUnavailable";
  /** Returned if the intent and context could not be delivered to the selected application or instance, for example because it has not added an intent handler within a timeout.*/

  ResolveError["IntentDeliveryFailed"] = "IntentDeliveryFailed";
})(ResolveError || (ResolveError = {}));

var ResultError;

(function (ResultError) {
  /** Returned if the intent handler exited without returning a Promise or that Promise was not resolved with a Context or Channel object. */
  ResultError["NoResultReturned"] = "NoResultReturned";
  /** Returned if the Intent handler function processing the raised intent throws an error or rejects the Promise it returned. */

  ResultError["IntentHandlerRejected"] = "IntentHandlerRejected";
})(ResultError || (ResultError = {}));

var ChannelError;

(function (ChannelError) {
  /** Returned if the specified channel is not found when attempting to join a channel via the `joinUserChannel` function  of the DesktopAgent (`fdc3`).*/
  ChannelError["NoChannelFound"] = "NoChannelFound";
  /** SHOULD be returned when a request to join a user channel or to a retrieve a Channel object via the `joinUserChannel` or `getOrCreateChannel` methods of the DesktopAgent (`fdc3`) object is denied. */

  ChannelError["AccessDenied"] = "AccessDenied";
  /** SHOULD be returned when a channel cannot be created or retrieved via the `getOrCreateChannel` method of the DesktopAgent (`fdc3`).*/

  ChannelError["CreationFailed"] = "CreationFailed";
})(ChannelError || (ChannelError = {}));

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var DEFAULT_TIMEOUT = 5000;
var UnavailableError = /*#__PURE__*/new Error('FDC3 DesktopAgent not available at `window.fdc3`.');
var TimeoutError = /*#__PURE__*/new Error('Timed out waiting for `fdc3Ready` event.');
var UnexpectedError = /*#__PURE__*/new Error('`fdc3Ready` event fired, but `window.fdc3` not set to DesktopAgent.');

function rejectIfNoGlobal(f) {
  return window.fdc3 ? f() : Promise.reject(UnavailableError);
}
/**
 * Utility function that returns a promise that will resolve immeadiately
 * if the desktop agent API is found at `window.fdc3`. If the API is found,
 * the promise will resolve when the `fdc3Ready` event is received or if it
 * is found at the end of the specified timeout. If the API is not found, it
 * will reject with an error.
 *
 * ```javascript
 * await fdc3Ready();
 * const intentListener = await addIntentListener("ViewChart", intentHandlerFn);
 * ```
 *
 * @param waitForMs The number of milliseconds to wait for the FDC3 API to be
 * ready. Defaults to 5 seconds.
 */


var fdc3Ready = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(waitForMs) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (waitForMs === void 0) {
              waitForMs = DEFAULT_TIMEOUT;
            }

            return _context.abrupt("return", new Promise(function (resolve, reject) {
              // if the global is already available resolve immediately
              if (window.fdc3) {
                resolve();
              } else {
                // if its not available setup a timeout to return a rejected promise
                var timeout = setTimeout(function () {
                  return window.fdc3 ? resolve() : reject(TimeoutError);
                }, waitForMs); // listen for the fdc3Ready event

                window.addEventListener('fdc3Ready', function () {
                  clearTimeout(timeout);
                  window.fdc3 ? resolve() : reject(UnexpectedError);
                }, {
                  once: true
                });
              }
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function fdc3Ready(_x) {
    return _ref.apply(this, arguments);
  };
}();

function isString(app) {
  return typeof app === 'string';
}

function open(app, context) {
  if (isString(app)) {
    return rejectIfNoGlobal(function () {
      return window.fdc3.open(app, context);
    });
  } else {
    return rejectIfNoGlobal(function () {
      return window.fdc3.open(app, context);
    });
  }
}
function findIntent(intent, context, resultType) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.findIntent(intent, context, resultType);
  });
}
function findIntentsByContext(context, resultType) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.findIntentsByContext(context, resultType);
  });
}
function broadcast(context) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.broadcast(context);
  });
}
function raiseIntent(intent, context, app) {
  if (app && isString(app)) {
    return rejectIfNoGlobal(function () {
      return window.fdc3.raiseIntent(intent, context, app);
    });
  } else {
    return rejectIfNoGlobal(function () {
      return window.fdc3.raiseIntent(intent, context, app);
    });
  }
}
function raiseIntentForContext(context, app) {
  if (app && isString(app)) {
    return rejectIfNoGlobal(function () {
      return window.fdc3.raiseIntentForContext(context, app);
    });
  } else {
    return rejectIfNoGlobal(function () {
      return window.fdc3.raiseIntentForContext(context, app);
    });
  }
}
function addIntentListener(intent, handler) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.addIntentListener(intent, handler);
  });
}
function addContextListener(contextTypeOrHandler, handler) {
  //Handle (deprecated) function signature that allowed contextType argument to be omitted
  if (typeof contextTypeOrHandler !== 'function') {
    return rejectIfNoGlobal(function () {
      return window.fdc3.addContextListener(contextTypeOrHandler, handler);
    });
  } else {
    return rejectIfNoGlobal(function () {
      return window.fdc3.addContextListener(null, contextTypeOrHandler);
    });
  }
}
function getUserChannels() {
  return rejectIfNoGlobal(function () {
    //fallback to getSystemChannels for FDC3 <2.0 implementations
    if (window.fdc3.getUserChannels) {
      return window.fdc3.getUserChannels();
    } else {
      return window.fdc3.getSystemChannels();
    }
  });
}
function getSystemChannels() {
  //fallforward to getUserChannels for FDC3 2.0+ implementations
  return getUserChannels();
}
function joinUserChannel(channelId) {
  return rejectIfNoGlobal(function () {
    //fallback to joinChannel for FDC3 <2.0 implementations
    if (window.fdc3.joinUserChannel) {
      return window.fdc3.joinUserChannel(channelId);
    } else {
      return window.fdc3.joinChannel(channelId);
    }
  });
}
function joinChannel(channelId) {
  //fallforward to joinUserChannel for FDC3 2.0+ implementations
  return joinUserChannel(channelId);
}
function getOrCreateChannel(channelId) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getOrCreateChannel(channelId);
  });
}
function getCurrentChannel() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getCurrentChannel();
  });
}
function leaveCurrentChannel() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.leaveCurrentChannel();
  });
}
function getInfo() {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getInfo();
  });
}
function getAppMetadata(app) {
  return rejectIfNoGlobal(function () {
    return window.fdc3.getAppMetadata(app);
  });
}
/**
 * Compare numeric semver version number strings (in the form `1.2.3`).
 *
 * Returns `-1` if the first argument is a lower version number than the second,
 * `1` if the first argument is greater than the second, 0 if the arguments are
 * equal and `null` if an error occurred during the comparison.
 *
 * @param a
 * @param b
 */

var compareVersionNumbers = function compareVersionNumbers(a, b) {
  try {
    var aVerArr = a.split('.').map(Number);
    var bVerArr = b.split('.').map(Number);

    for (var index = 0; index < Math.max(aVerArr.length, bVerArr.length); index++) {
      /* If one version number has more digits and the other does not, and they are otherwise equal,
         assume the longer is greater. E.g. 1.1.1 > 1.1 */
      if (index === aVerArr.length || aVerArr[index] < bVerArr[index]) {
        return -1;
      } else if (index === bVerArr.length || aVerArr[index] > bVerArr[index]) {
        return 1;
      }
    }

    return 0;
  } catch (e) {
    console.error('Failed to compare version strings', e);
    return null;
  }
};
/**
 * Check if the FDC3 version in an ImplementationMetadata object is greater than
 * or equal to the supplied numeric semver version number string (in the form `1.2.3`).
 *
 * Returns a boolean or null if an error occurred while comparing the version numbers.
 *
 * @param metadata
 * @param version
 */

var versionIsAtLeast = function versionIsAtLeast(metadata, version) {
  var comparison = compareVersionNumbers(metadata.fdc3Version, version);
  return comparison === null ? null : comparison >= 0 ? true : false;
};

var ContextTypes;

(function (ContextTypes) {
  ContextTypes["Chart"] = "fdc3.chart";
  ContextTypes["ChatInitSettings"] = "fdc3.chat.initSettings";
  ContextTypes["Contact"] = "fdc3.contact";
  ContextTypes["ContactList"] = "fdc3.contactList";
  ContextTypes["Country"] = "fdc3.country";
  ContextTypes["Currency"] = "fdc3.currency";
  ContextTypes["Email"] = "fdc3.email";
  ContextTypes["Instrument"] = "fdc3.instrument";
  ContextTypes["InstrumentList"] = "fdc3.instrumentList";
  ContextTypes["Organization"] = "fdc3.organization";
  ContextTypes["Portfolio"] = "fdc3.portfolio";
  ContextTypes["Position"] = "fdc3.position";
  ContextTypes["Nothing"] = "fdc3.nothing";
  ContextTypes["TimeRange"] = "fdc3.timerange";
  ContextTypes["Valuation"] = "fdc3.valuation";
})(ContextTypes || (ContextTypes = {}));

// To parse this data:
//
//   import { Convert, Context, Chart, ChatInitSettings, Contact, ContactList, Country, Currency, Email, Instrument, InstrumentList, Nothing, Organization, Portfolio, Position, TimeRange, Valuation } from "./file";
//
//   const context = Convert.toContext(json);
//   const chart = Convert.toChart(json);
//   const chatInitSettings = Convert.toChatInitSettings(json);
//   const contact = Convert.toContact(json);
//   const contactList = Convert.toContactList(json);
//   const country = Convert.toCountry(json);
//   const currency = Convert.toCurrency(json);
//   const email = Convert.toEmail(json);
//   const instrument = Convert.toInstrument(json);
//   const instrumentList = Convert.toInstrumentList(json);
//   const nothing = Convert.toNothing(json);
//   const organization = Convert.toOrganization(json);
//   const portfolio = Convert.toPortfolio(json);
//   const position = Convert.toPosition(json);
//   const timeRange = Convert.toTimeRange(json);
//   const valuation = Convert.toValuation(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.
var Style;

(function (Style) {
  Style["Bar"] = "bar";
  Style["Candle"] = "candle";
  Style["Custom"] = "custom";
  Style["Heatmap"] = "heatmap";
  Style["Histogram"] = "histogram";
  Style["Line"] = "line";
  Style["Mountain"] = "mountain";
  Style["Pie"] = "pie";
  Style["Scatter"] = "scatter";
  Style["StackedBar"] = "stacked-bar";
})(Style || (Style = {})); // Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime


var Convert = /*#__PURE__*/function () {
  function Convert() {}

  Convert.toContext = function toContext(json) {
    return cast(JSON.parse(json), r('Context'));
  };

  Convert.contextToJson = function contextToJson(value) {
    return JSON.stringify(uncast(value, r('Context')), null, 2);
  };

  Convert.toChart = function toChart(json) {
    return cast(JSON.parse(json), r('Chart'));
  };

  Convert.chartToJson = function chartToJson(value) {
    return JSON.stringify(uncast(value, r('Chart')), null, 2);
  };

  Convert.toChatInitSettings = function toChatInitSettings(json) {
    return cast(JSON.parse(json), r('ChatInitSettings'));
  };

  Convert.chatInitSettingsToJson = function chatInitSettingsToJson(value) {
    return JSON.stringify(uncast(value, r('ChatInitSettings')), null, 2);
  };

  Convert.toContact = function toContact(json) {
    return cast(JSON.parse(json), r('Contact'));
  };

  Convert.contactToJson = function contactToJson(value) {
    return JSON.stringify(uncast(value, r('Contact')), null, 2);
  };

  Convert.toContactList = function toContactList(json) {
    return cast(JSON.parse(json), r('ContactList'));
  };

  Convert.contactListToJson = function contactListToJson(value) {
    return JSON.stringify(uncast(value, r('ContactList')), null, 2);
  };

  Convert.toCountry = function toCountry(json) {
    return cast(JSON.parse(json), r('Country'));
  };

  Convert.countryToJson = function countryToJson(value) {
    return JSON.stringify(uncast(value, r('Country')), null, 2);
  };

  Convert.toCurrency = function toCurrency(json) {
    return cast(JSON.parse(json), r('Currency'));
  };

  Convert.currencyToJson = function currencyToJson(value) {
    return JSON.stringify(uncast(value, r('Currency')), null, 2);
  };

  Convert.toEmail = function toEmail(json) {
    return cast(JSON.parse(json), r('Email'));
  };

  Convert.emailToJson = function emailToJson(value) {
    return JSON.stringify(uncast(value, r('Email')), null, 2);
  };

  Convert.toInstrument = function toInstrument(json) {
    return cast(JSON.parse(json), r('Instrument'));
  };

  Convert.instrumentToJson = function instrumentToJson(value) {
    return JSON.stringify(uncast(value, r('Instrument')), null, 2);
  };

  Convert.toInstrumentList = function toInstrumentList(json) {
    return cast(JSON.parse(json), r('InstrumentList'));
  };

  Convert.instrumentListToJson = function instrumentListToJson(value) {
    return JSON.stringify(uncast(value, r('InstrumentList')), null, 2);
  };

  Convert.toNothing = function toNothing(json) {
    return cast(JSON.parse(json), r('Nothing'));
  };

  Convert.nothingToJson = function nothingToJson(value) {
    return JSON.stringify(uncast(value, r('Nothing')), null, 2);
  };

  Convert.toOrganization = function toOrganization(json) {
    return cast(JSON.parse(json), r('Organization'));
  };

  Convert.organizationToJson = function organizationToJson(value) {
    return JSON.stringify(uncast(value, r('Organization')), null, 2);
  };

  Convert.toPortfolio = function toPortfolio(json) {
    return cast(JSON.parse(json), r('Portfolio'));
  };

  Convert.portfolioToJson = function portfolioToJson(value) {
    return JSON.stringify(uncast(value, r('Portfolio')), null, 2);
  };

  Convert.toPosition = function toPosition(json) {
    return cast(JSON.parse(json), r('Position'));
  };

  Convert.positionToJson = function positionToJson(value) {
    return JSON.stringify(uncast(value, r('Position')), null, 2);
  };

  Convert.toTimeRange = function toTimeRange(json) {
    return cast(JSON.parse(json), r('TimeRange'));
  };

  Convert.timeRangeToJson = function timeRangeToJson(value) {
    return JSON.stringify(uncast(value, r('TimeRange')), null, 2);
  };

  Convert.toValuation = function toValuation(json) {
    return cast(JSON.parse(json), r('Valuation'));
  };

  Convert.valuationToJson = function valuationToJson(value) {
    return JSON.stringify(uncast(value, r('Valuation')), null, 2);
  };

  return Convert;
}();

function invalidValue(typ, val, key) {
  if (key === void 0) {
    key = '';
  }

  if (key) {
    throw Error("Invalid value for key \"" + key + "\". Expected type " + JSON.stringify(typ) + " but got " + JSON.stringify(val));
  }

  throw Error("Invalid value " + JSON.stringify(val) + " for type " + JSON.stringify(typ));
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.json] = {
        key: p.js,
        typ: p.typ
      };
    });
    typ.jsonToJS = map;
  }

  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.js] = {
        key: p.json,
        typ: p.typ
      };
    });
    typ.jsToJSON = map;
  }

  return typ.jsToJSON;
}

function transform(val, typ, getProps, key) {
  if (key === void 0) {
    key = '';
  }

  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    var l = typs.length;

    for (var i = 0; i < l; i++) {
      var _typ = typs[i];

      try {
        return transform(val, _typ, getProps);
      } catch (_) {}
    }

    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map(function (el) {
      return transform(el, typ, getProps);
    });
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }

    var d = new Date(val);

    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }

    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }

    var result = {};
    Object.getOwnPropertyNames(props).forEach(function (key) {
      var prop = props[key];
      var v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;

  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }

  if (typ === false) return invalidValue(typ, val);

  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }

  if (Array.isArray(typ)) return transformEnum(typ, val);

  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers') ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty('arrayItems') ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty('props') ? transformObject(getProps(typ), typ.additional, val) : invalidValue(typ, val);
  } // Numbers can be parsed by Date but shouldn't be.


  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return {
    arrayItems: typ
  };
}

function u() {
  for (var _len = arguments.length, typs = new Array(_len), _key = 0; _key < _len; _key++) {
    typs[_key] = arguments[_key];
  }

  return {
    unionMembers: typs
  };
}

function o(props, additional) {
  return {
    props: props,
    additional: additional
  };
}

function m(additional) {
  return {
    props: [],
    additional: additional
  };
}

function r(name) {
  return {
    ref: name
  };
}

var typeMap = {
  Context: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }], 'any'),
  Chart: /*#__PURE__*/o([{
    json: 'instruments',
    js: 'instruments',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Instrument'))
  }, {
    json: 'otherConfig',
    js: 'otherConfig',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m('any'))
  }, {
    json: 'range',
    js: 'range',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/r('TimeRange'))
  }, {
    json: 'style',
    js: 'style',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/r('Style'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Instrument: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('InstrumentID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  InstrumentID: /*#__PURE__*/o([{
    json: 'BBG',
    js: 'BBG',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'CUSIP',
    js: 'CUSIP',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FIGI',
    js: 'FIGI',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ISIN',
    js: 'ISIN',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'PERMID',
    js: 'PERMID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'RIC',
    js: 'RIC',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'SEDOL',
    js: 'SEDOL',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ticker',
    js: 'ticker',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  TimeRange: /*#__PURE__*/o([{
    json: 'endTime',
    js: 'endTime',
    typ: /*#__PURE__*/u(undefined, Date)
  }, {
    json: 'startTime',
    js: 'startTime',
    typ: /*#__PURE__*/u(undefined, Date)
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  ChatInitSettings: /*#__PURE__*/o([{
    json: 'chatName',
    js: 'chatName',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'initMessage',
    js: 'initMessage',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'members',
    js: 'members',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/r('ContactList'))
  }, {
    json: 'options',
    js: 'options',
    typ: /*#__PURE__*/u(undefined, 'any')
  }, {
    json: 'type',
    js: 'type',
    typ: 'any'
  }], 'any'),
  ContactList: /*#__PURE__*/o([{
    json: 'contacts',
    js: 'contacts',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Contact'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Contact: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('ContactID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  ContactID: /*#__PURE__*/o([{
    json: 'email',
    js: 'email',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Country: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('CountryID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  CountryID: /*#__PURE__*/o([{
    json: 'COUNTRY_ISOALPHA2',
    js: 'COUNTRY_ISOALPHA2',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'COUNTRY_ISOALPHA3',
    js: 'COUNTRY_ISOALPHA3',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ISOALPHA2',
    js: 'ISOALPHA2',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'ISOALPHA3',
    js: 'ISOALPHA3',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Currency: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('CurrencyID')
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }], 'any'),
  CurrencyID: /*#__PURE__*/o([{
    json: 'CURRENCY_ISOCODE',
    js: 'CURRENCY_ISOCODE',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Email: /*#__PURE__*/o([{
    json: 'recipients',
    js: 'recipients',
    typ: /*#__PURE__*/r('RecipientsObject')
  }, {
    json: 'subject',
    js: 'subject',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'textBody',
    js: 'textBody',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  RecipientsObject: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/r('RecipientsID'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'contacts',
    js: 'contacts',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/a( /*#__PURE__*/r('Contact')))
  }], 'any'),
  RecipientsID: /*#__PURE__*/o([{
    json: 'email',
    js: 'email',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  InstrumentList: /*#__PURE__*/o([{
    json: 'instruments',
    js: 'instruments',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Instrument'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Nothing: /*#__PURE__*/o([{
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Organization: /*#__PURE__*/o([{
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/r('OrganizationID')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  OrganizationID: /*#__PURE__*/o([{
    json: 'FDS_ID',
    js: 'FDS_ID',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'LEI',
    js: 'LEI',
    typ: /*#__PURE__*/u(undefined, '')
  }, {
    json: 'PERMID',
    js: 'PERMID',
    typ: /*#__PURE__*/u(undefined, '')
  }], ''),
  Portfolio: /*#__PURE__*/o([{
    json: 'positions',
    js: 'positions',
    typ: /*#__PURE__*/a( /*#__PURE__*/r('Position'))
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Position: /*#__PURE__*/o([{
    json: 'holding',
    js: 'holding',
    typ: 3.14
  }, {
    json: 'instrument',
    js: 'instrument',
    typ: /*#__PURE__*/r('Instrument')
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Valuation: /*#__PURE__*/o([{
    json: 'CURRENCY_ISOCODE',
    js: 'CURRENCY_ISOCODE',
    typ: ''
  }, {
    json: 'expiryTime',
    js: 'expiryTime',
    typ: /*#__PURE__*/u(undefined, Date)
  }, {
    json: 'price',
    js: 'price',
    typ: /*#__PURE__*/u(undefined, 3.14)
  }, {
    json: 'type',
    js: 'type',
    typ: ''
  }, {
    json: 'valuationTime',
    js: 'valuationTime',
    typ: /*#__PURE__*/u(undefined, Date)
  }, {
    json: 'value',
    js: 'value',
    typ: 3.14
  }, {
    json: 'id',
    js: 'id',
    typ: /*#__PURE__*/u(undefined, /*#__PURE__*/m(''))
  }, {
    json: 'name',
    js: 'name',
    typ: /*#__PURE__*/u(undefined, '')
  }], 'any'),
  Style: ['bar', 'candle', 'custom', 'heatmap', 'histogram', 'line', 'mountain', 'pie', 'scatter', 'stacked-bar']
};

var Intents;

(function (Intents) {
  Intents["StartCall"] = "StartCall";
  Intents["StartChat"] = "StartChat";
  Intents["StartEmail"] = "StartEmail";
  Intents["ViewAnalysis"] = "ViewAnalysis";
  Intents["ViewChart"] = "ViewChart";
  Intents["ViewContact"] = "ViewContact";
  Intents["ViewHoldings"] = "ViewHoldings";
  Intents["ViewInstrument"] = "ViewInstrument";
  Intents["ViewInteractions"] = "ViewInteractions";
  Intents["ViewNews"] = "ViewNews";
  Intents["ViewOrders"] = "ViewOrders";
  Intents["ViewProfile"] = "ViewProfile";
  Intents["ViewQuote"] = "ViewQuote";
  Intents["ViewResearch"] = "ViewResearch";
})(Intents || (Intents = {}));


//# sourceMappingURL=fdc3.esm.js.map


/***/ }),

/***/ "../node_modules/for-each/index.js":
/*!*****************************************!*\
  !*** ../node_modules/for-each/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "../node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ "../node_modules/function-bind/implementation.js":
/*!*******************************************************!*\
  !*** ../node_modules/function-bind/implementation.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "../node_modules/function-bind/index.js":
/*!**********************************************!*\
  !*** ../node_modules/function-bind/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "../node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "../node_modules/get-func-name/index.js":
/*!**********************************************!*\
  !*** ../node_modules/get-func-name/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';
  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);
    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

module.exports = getFuncName;


/***/ }),

/***/ "../node_modules/get-intrinsic/index.js":
/*!**********************************************!*\
  !*** ../node_modules/get-intrinsic/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "../node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "../node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "../node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "../node_modules/has-symbols/index.js":
/*!********************************************!*\
  !*** ../node_modules/has-symbols/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "../node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "../node_modules/has-symbols/shams.js":
/*!********************************************!*\
  !*** ../node_modules/has-symbols/shams.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "../node_modules/has-tostringtag/shams.js":
/*!************************************************!*\
  !*** ../node_modules/has-tostringtag/shams.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "../node_modules/has-symbols/shams.js");

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "../node_modules/has/src/index.js":
/*!****************************************!*\
  !*** ../node_modules/has/src/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "../node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "../node_modules/he/he.js":
/*!********************************!*\
  !*** ../node_modules/he/he.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports =  true && exports;

	// Detect free variable `module`.
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	// All astral symbols.
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// All ASCII symbols (not just printable ASCII) except those listed in the
	// first column of the overrides table.
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
	var regexAsciiWhitelist = /[\x01-\x7F]/g;
	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
	// code points listed in the first column of the overrides table on
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
	var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

	var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
	var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

	var regexEscape = /["&'<>`]/g;
	var escapeMap = {
		'"': '&quot;',
		'&': '&amp;',
		'\'': '&#x27;',
		'<': '&lt;',
		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
		// following is not strictly necessary unless its part of a tag or an
		// unquoted attribute value. Were only escaping it to support those
		// situations, and for XML support.
		'>': '&gt;',
		// In Internet Explorer  8, the backtick character can be used
		// to break out of (un)quoted attribute values or HTML comments.
		// See http://html5sec.org/#102, http://html5sec.org/#108, and
		// http://html5sec.org/#133.
		'`': '&#x60;'
	};

	var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
	var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
	var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
	var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
	var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
	var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var has = function(object, propertyName) {
		return hasOwnProperty.call(object, propertyName);
	};

	var contains = function(array, value) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			if (array[index] == value) {
				return true;
			}
		}
		return false;
	};

	var merge = function(options, defaults) {
		if (!options) {
			return defaults;
		}
		var result = {};
		var key;
		for (key in defaults) {
			// A `hasOwnProperty` check is not needed here, since only recognized
			// option names are used anyway. Any others are ignored.
			result[key] = has(options, key) ? options[key] : defaults[key];
		}
		return result;
	};

	// Modified version of `ucs2encode`; see https://mths.be/punycode.
	var codePointToSymbol = function(codePoint, strict) {
		var output = '';
		if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
			// See issue #4:
			// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
			// REPLACEMENT CHARACTER.
			if (strict) {
				parseError('character reference outside the permissible Unicode range');
			}
			return '\uFFFD';
		}
		if (has(decodeMapNumeric, codePoint)) {
			if (strict) {
				parseError('disallowed character reference');
			}
			return decodeMapNumeric[codePoint];
		}
		if (strict && contains(invalidReferenceCodePoints, codePoint)) {
			parseError('disallowed character reference');
		}
		if (codePoint > 0xFFFF) {
			codePoint -= 0x10000;
			output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
		output += stringFromCharCode(codePoint);
		return output;
	};

	var hexEscape = function(codePoint) {
		return '&#x' + codePoint.toString(16).toUpperCase() + ';';
	};

	var decEscape = function(codePoint) {
		return '&#' + codePoint + ';';
	};

	var parseError = function(message) {
		throw Error('Parse error: ' + message);
	};

	/*--------------------------------------------------------------------------*/

	var encode = function(string, options) {
		options = merge(options, encode.options);
		var strict = options.strict;
		if (strict && regexInvalidRawCodePoint.test(string)) {
			parseError('forbidden code point');
		}
		var encodeEverything = options.encodeEverything;
		var useNamedReferences = options.useNamedReferences;
		var allowUnsafeSymbols = options.allowUnsafeSymbols;
		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

		var escapeBmpSymbol = function(symbol) {
			return escapeCodePoint(symbol.charCodeAt(0));
		};

		if (encodeEverything) {
			// Encode ASCII symbols.
			string = string.replace(regexAsciiWhitelist, function(symbol) {
				// Use named references if requested & possible.
				if (useNamedReferences && has(encodeMap, symbol)) {
					return '&' + encodeMap[symbol] + ';';
				}
				return escapeBmpSymbol(symbol);
			});
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
			if (useNamedReferences) {
				string = string
					.replace(/&gt;\u20D2/g, '&nvgt;')
					.replace(/&lt;\u20D2/g, '&nvlt;')
					.replace(/&#x66;&#x6A;/g, '&fjlig;');
			}
			// Encode non-ASCII symbols.
			if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
				string = string.replace(regexEncodeNonAscii, function(string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
					return '&' + encodeMap[string] + ';';
				});
			}
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
		} else if (useNamedReferences) {
			// Apply named character references.
			// Encode `<>"'&` using named character references.
			if (!allowUnsafeSymbols) {
				string = string.replace(regexEscape, function(string) {
					return '&' + encodeMap[string] + ';'; // no need to check `has()` here
				});
			}
			// Shorten escapes that represent two symbols, of which at least one is
			// `<>"'&`.
			string = string
				.replace(/&gt;\u20D2/g, '&nvgt;')
				.replace(/&lt;\u20D2/g, '&nvlt;');
			// Encode non-ASCII symbols that can be replaced with a named reference.
			string = string.replace(regexEncodeNonAscii, function(string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
				return '&' + encodeMap[string] + ';';
			});
		} else if (!allowUnsafeSymbols) {
			// Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
			// using named character references.
			string = string.replace(regexEscape, escapeBmpSymbol);
		}
		return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				var high = $0.charCodeAt(0);
				var low = $0.charCodeAt(1);
				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
				return escapeCodePoint(codePoint);
			})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol);
	};
	// Expose default options (so they can be overridden globally).
	encode.options = {
		'allowUnsafeSymbols': false,
		'encodeEverything': false,
		'strict': false,
		'useNamedReferences': false,
		'decimal' : false
	};

	var decode = function(html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict && regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;

			if ($1) {
				reference = $1;
				// Note: there is no need to check `has(decodeMap, reference)`.
				return decodeMap[reference];
			}

			if ($2) {
				// Decode named character references without trailing `;`, e.g. `&amp`.
				// This is only a parse error if it gets converted to `&`, or if it is
				// followed by `=` in an attribute context.
				reference = $2;
				next = $3;
				if (next && options.isAttributeValue) {
					if (strict && next == '=') {
						parseError('`&` did not start a character reference');
					}
					return $0;
				} else {
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					// Note: there is no need to check `has(decodeMapLegacy, reference)`.
					return decodeMapLegacy[reference] + (next || '');
				}
			}

			if ($4) {
				// Decode decimal escapes, e.g. `&#119558;`.
				decDigits = $4;
				semicolon = $5;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}

			if ($6) {
				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
				hexDigits = $6;
				semicolon = $7;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}

			// If were still here, `if ($7)` is implied; its an ambiguous
			// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
			if (strict) {
				parseError(
					'named character reference was not terminated by a semicolon'
				);
			}
			return $0;
		});
	};
	// Expose default options (so they can be overridden globally).
	decode.options = {
		'isAttributeValue': false,
		'strict': false
	};

	var escape = function(string) {
		return string.replace(regexEscape, function($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
			return escapeMap[$0];
		});
	};

	/*--------------------------------------------------------------------------*/

	var he = {
		'version': '1.2.0',
		'encode': encode,
		'decode': decode,
		'escape': escape,
		'unescape': decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return he;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else { var key; }

}(this));


/***/ }),

/***/ "../node_modules/ieee754/index.js":
/*!****************************************!*\
  !*** ../node_modules/ieee754/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/*!****************************************************!*\
  !*** ../node_modules/inherits/inherits_browser.js ***!
  \****************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "../node_modules/is-arguments/index.js":
/*!*********************************************!*\
  !*** ../node_modules/is-arguments/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "../node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "../node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "../node_modules/is-callable/index.js":
/*!********************************************!*\
  !*** ../node_modules/is-callable/index.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
/* globals document: false */
var documentDotAll = typeof document === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};

module.exports = reflectApply
	? function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value);
	}
	: function isCallable(value) {
		if (value === documentDotAll) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (typeof value === 'function' && !value.prototype) { return true; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ }),

/***/ "../node_modules/is-generator-function/index.js":
/*!******************************************************!*\
  !*** ../node_modules/is-generator-function/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "../node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "../node_modules/is-typed-array/index.js":
/*!***********************************************!*\
  !*** ../node_modules/is-typed-array/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "../node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "../node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "../node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "../node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "../node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "../node_modules/log-symbols/browser.js":
/*!**********************************************!*\
  !*** ../node_modules/log-symbols/browser.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";


module.exports = {
	info: '',
	success: '',
	warning: '',
	error: ''
};


/***/ }),

/***/ "../node_modules/loupe/loupe.js":
/*!**************************************!*\
  !*** ../node_modules/loupe/loupe.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var ansiColors = {
    bold: ['1', '22'],
    dim: ['2', '22'],
    italic: ['3', '23'],
    underline: ['4', '24'],
    // 5 & 6 are blinking
    inverse: ['7', '27'],
    hidden: ['8', '28'],
    strike: ['9', '29'],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: ['30', '39'],
    red: ['31', '39'],
    green: ['32', '39'],
    yellow: ['33', '39'],
    blue: ['34', '39'],
    magenta: ['35', '39'],
    cyan: ['36', '39'],
    white: ['37', '39'],
    brightblack: ['30;1', '39'],
    brightred: ['31;1', '39'],
    brightgreen: ['32;1', '39'],
    brightyellow: ['33;1', '39'],
    brightblue: ['34;1', '39'],
    brightmagenta: ['35;1', '39'],
    brightcyan: ['36;1', '39'],
    brightwhite: ['37;1', '39'],
    grey: ['90', '39']
  };
  var styles = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red'
  };
  var truncator = '';

  function colorise(value, styleType) {
    var color = ansiColors[styles[styleType]] || ansiColors[styleType];

    if (!color) {
      return String(value);
    }

    return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
  }

  function normaliseOptions() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$showHidden = _ref.showHidden,
        showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden,
        _ref$depth = _ref.depth,
        depth = _ref$depth === void 0 ? 2 : _ref$depth,
        _ref$colors = _ref.colors,
        colors = _ref$colors === void 0 ? false : _ref$colors,
        _ref$customInspect = _ref.customInspect,
        customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect,
        _ref$showProxy = _ref.showProxy,
        showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy,
        _ref$maxArrayLength = _ref.maxArrayLength,
        maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength,
        _ref$breakLength = _ref.breakLength,
        breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength,
        _ref$seen = _ref.seen,
        seen = _ref$seen === void 0 ? [] : _ref$seen,
        _ref$truncate = _ref.truncate,
        truncate = _ref$truncate === void 0 ? Infinity : _ref$truncate,
        _ref$stylize = _ref.stylize,
        stylize = _ref$stylize === void 0 ? String : _ref$stylize;

    var options = {
      showHidden: Boolean(showHidden),
      depth: Number(depth),
      colors: Boolean(colors),
      customInspect: Boolean(customInspect),
      showProxy: Boolean(showProxy),
      maxArrayLength: Number(maxArrayLength),
      breakLength: Number(breakLength),
      truncate: Number(truncate),
      seen: seen,
      stylize: stylize
    };

    if (options.colors) {
      options.stylize = colorise;
    }

    return options;
  }
  function truncate(string, length) {
    var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : truncator;
    string = String(string);
    var tailLength = tail.length;
    var stringLength = string.length;

    if (tailLength > length && stringLength > tailLength) {
      return tail;
    }

    if (stringLength > length && stringLength > tailLength) {
      return "".concat(string.slice(0, length - tailLength)).concat(tail);
    }

    return string;
  } // eslint-disable-next-line complexity

  function inspectList(list, options, inspectItem) {
    var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ', ';
    inspectItem = inspectItem || options.inspect;
    var size = list.length;
    if (size === 0) return '';
    var originalLength = options.truncate;
    var output = '';
    var peek = '';
    var truncated = '';

    for (var i = 0; i < size; i += 1) {
      var last = i + 1 === list.length;
      var secondToLast = i + 2 === list.length;
      truncated = "".concat(truncator, "(").concat(list.length - i, ")");
      var value = list[i]; // If there is more than one remaining we need to account for a separator of `, `

      options.truncate = originalLength - output.length - (last ? 0 : separator.length);
      var string = peek || inspectItem(value, options) + (last ? '' : separator);
      var nextLength = output.length + string.length;
      var truncatedLength = nextLength + truncated.length; // If this is the last element, and adding it would
      // take us over length, but adding the truncator wouldn't - then break now

      if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
        break;
      } // If this isn't the last or second to last element to scan,
      // but the string is already over length then break here


      if (!last && !secondToLast && truncatedLength > originalLength) {
        break;
      } // Peek at the next string to determine if we should
      // break early before adding this item to the output


      peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator); // If we have one element left, but this element and
      // the next takes over length, the break early

      if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
        break;
      }

      output += string; // If the next element takes us to length -
      // but there are more after that, then we should truncate now

      if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
        truncated = "".concat(truncator, "(").concat(list.length - i - 1, ")");
        break;
      }

      truncated = '';
    }

    return "".concat(output).concat(truncated);
  }

  function quoteComplexKey(key) {
    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
      return key;
    }

    return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
  }

  function inspectProperty(_ref2, options) {
    var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    options.truncate -= 2;

    if (typeof key === 'string') {
      key = quoteComplexKey(key);
    } else if (typeof key !== 'number') {
      key = "[".concat(options.inspect(key, options), "]");
    }

    options.truncate -= key.length;
    value = options.inspect(value, options);
    return "".concat(key, ": ").concat(value);
  }

  function inspectArray(array, options) {
    // Object.keys will always output the Array indices first, so we can slice by
    // `array.length` to get non-index properties
    var nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return '[]';
    options.truncate -= 4;
    var listContents = inspectList(array, options);
    options.truncate -= listContents.length;
    var propertyContents = '';

    if (nonIndexProperties.length) {
      propertyContents = inspectList(nonIndexProperties.map(function (key) {
        return [key, array[key]];
      }), options, inspectProperty);
    }

    return "[ ".concat(listContents).concat(propertyContents ? ", ".concat(propertyContents) : '', " ]");
  }

  /* !
   * Chai - getFuncName utility
   * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  /**
   * ### .getFuncName(constructorFn)
   *
   * Returns the name of a function.
   * When a non-function instance is passed, returns `null`.
   * This also includes a polyfill function if `aFunc.name` is not defined.
   *
   * @name getFuncName
   * @param {Function} funct
   * @namespace Utils
   * @api public
   */

  var toString = Function.prototype.toString;
  var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
  function getFuncName(aFunc) {
    if (typeof aFunc !== 'function') {
      return null;
    }

    var name = '';
    if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
      // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
      var match = toString.call(aFunc).match(functionNameMatch);
      if (match) {
        name = match[1];
      }
    } else {
      // If we've got a `name` property we just use it
      name = aFunc.name;
    }

    return name;
  }

  var getFuncName_1 = getFuncName;

  var getArrayName = function getArrayName(array) {
    // We need to special case Node.js' Buffers, which report to be Uint8Array
    if (typeof Buffer === 'function' && array instanceof Buffer) {
      return 'Buffer';
    }

    if (array[Symbol.toStringTag]) {
      return array[Symbol.toStringTag];
    }

    return getFuncName_1(array.constructor);
  };

  function inspectTypedArray(array, options) {
    var name = getArrayName(array);
    options.truncate -= name.length + 4; // Object.keys will always output the Array indices first, so we can slice by
    // `array.length` to get non-index properties

    var nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return "".concat(name, "[]"); // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
    // stylise the toString() value of them

    var output = '';

    for (var i = 0; i < array.length; i++) {
      var string = "".concat(options.stylize(truncate(array[i], options.truncate), 'number')).concat(i === array.length - 1 ? '' : ', ');
      options.truncate -= string.length;

      if (array[i] !== array.length && options.truncate <= 3) {
        output += "".concat(truncator, "(").concat(array.length - array[i] + 1, ")");
        break;
      }

      output += string;
    }

    var propertyContents = '';

    if (nonIndexProperties.length) {
      propertyContents = inspectList(nonIndexProperties.map(function (key) {
        return [key, array[key]];
      }), options, inspectProperty);
    }

    return "".concat(name, "[ ").concat(output).concat(propertyContents ? ", ".concat(propertyContents) : '', " ]");
  }

  function inspectDate(dateObject, options) {
    // If we need to - truncate the time portion, but never the date
    var split = dateObject.toJSON().split('T');
    var date = split[0];
    return options.stylize("".concat(date, "T").concat(truncate(split[1], options.truncate - date.length - 1)), 'date');
  }

  function inspectFunction(func, options) {
    var name = getFuncName_1(func);

    if (!name) {
      return options.stylize('[Function]', 'special');
    }

    return options.stylize("[Function ".concat(truncate(name, options.truncate - 11), "]"), 'special');
  }

  function inspectMapEntry(_ref, options) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    options.truncate -= 4;
    key = options.inspect(key, options);
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return "".concat(key, " => ").concat(value);
  } // IE11 doesn't support `map.entries()`


  function mapToEntries(map) {
    var entries = [];
    map.forEach(function (value, key) {
      entries.push([key, value]);
    });
    return entries;
  }

  function inspectMap(map, options) {
    var size = map.size - 1;

    if (size <= 0) {
      return 'Map{}';
    }

    options.truncate -= 7;
    return "Map{ ".concat(inspectList(mapToEntries(map), options, inspectMapEntry), " }");
  }

  var isNaN = Number.isNaN || function (i) {
    return i !== i;
  }; // eslint-disable-line no-self-compare


  function inspectNumber(number, options) {
    if (isNaN(number)) {
      return options.stylize('NaN', 'number');
    }

    if (number === Infinity) {
      return options.stylize('Infinity', 'number');
    }

    if (number === -Infinity) {
      return options.stylize('-Infinity', 'number');
    }

    if (number === 0) {
      return options.stylize(1 / number === Infinity ? '+0' : '-0', 'number');
    }

    return options.stylize(truncate(number, options.truncate), 'number');
  }

  function inspectBigInt(number, options) {
    var nums = truncate(number.toString(), options.truncate - 1);
    if (nums !== truncator) nums += 'n';
    return options.stylize(nums, 'bigint');
  }

  function inspectRegExp(value, options) {
    var flags = value.toString().split('/')[2];
    var sourceLength = options.truncate - (2 + flags.length);
    var source = value.source;
    return options.stylize("/".concat(truncate(source, sourceLength), "/").concat(flags), 'regexp');
  }

  function arrayFromSet(set) {
    var values = [];
    set.forEach(function (value) {
      values.push(value);
    });
    return values;
  }

  function inspectSet(set, options) {
    if (set.size === 0) return 'Set{}';
    options.truncate -= 7;
    return "Set{ ".concat(inspectList(arrayFromSet(set), options), " }");
  }

  var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5" + "\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", 'g');
  var escapeCharacters = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    "'": "\\'",
    '\\': '\\\\'
  };
  var hex = 16;
  var unicodeLength = 4;

  function escape(char) {
    return escapeCharacters[char] || "\\u".concat("0000".concat(char.charCodeAt(0).toString(hex)).slice(-unicodeLength));
  }

  function inspectString(string, options) {
    if (stringEscapeChars.test(string)) {
      string = string.replace(stringEscapeChars, escape);
    }

    return options.stylize("'".concat(truncate(string, options.truncate - 2), "'"), 'string');
  }

  function inspectSymbol(value) {
    if ('description' in Symbol.prototype) {
      return value.description ? "Symbol(".concat(value.description, ")") : 'Symbol()';
    }

    return value.toString();
  }

  var getPromiseValue = function getPromiseValue() {
    return 'Promise{}';
  };

  try {
    var _process$binding = process.binding('util'),
        getPromiseDetails = _process$binding.getPromiseDetails,
        kPending = _process$binding.kPending,
        kRejected = _process$binding.kRejected;

    if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
      getPromiseValue = function getPromiseValue(value, options) {
        var _getPromiseDetails = getPromiseDetails(value),
            _getPromiseDetails2 = _slicedToArray(_getPromiseDetails, 2),
            state = _getPromiseDetails2[0],
            innerValue = _getPromiseDetails2[1];

        if (state === kPending) {
          return 'Promise{<pending>}';
        }

        return "Promise".concat(state === kRejected ? '!' : '', "{").concat(options.inspect(innerValue, options), "}");
      };
    }
  } catch (notNode) {
    /* ignore */
  }

  var inspectPromise = getPromiseValue;

  function inspectObject(object, options) {
    var properties = Object.getOwnPropertyNames(object);
    var symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];

    if (properties.length === 0 && symbols.length === 0) {
      return '{}';
    }

    options.truncate -= 4;
    options.seen = options.seen || [];

    if (options.seen.indexOf(object) >= 0) {
      return '[Circular]';
    }

    options.seen.push(object);
    var propertyContents = inspectList(properties.map(function (key) {
      return [key, object[key]];
    }), options, inspectProperty);
    var symbolContents = inspectList(symbols.map(function (key) {
      return [key, object[key]];
    }), options, inspectProperty);
    options.seen.pop();
    var sep = '';

    if (propertyContents && symbolContents) {
      sep = ', ';
    }

    return "{ ".concat(propertyContents).concat(sep).concat(symbolContents, " }");
  }

  var toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag ? Symbol.toStringTag : false;
  function inspectClass(value, options) {
    var name = '';

    if (toStringTag && toStringTag in value) {
      name = value[toStringTag];
    }

    name = name || getFuncName_1(value.constructor); // Babel transforms anonymous classes to the name `_class`

    if (!name || name === '_class') {
      name = '<Anonymous Class>';
    }

    options.truncate -= name.length;
    return "".concat(name).concat(inspectObject(value, options));
  }

  function inspectArguments(args, options) {
    if (args.length === 0) return 'Arguments[]';
    options.truncate -= 13;
    return "Arguments[ ".concat(inspectList(args, options), " ]");
  }

  var errorKeys = ['stack', 'line', 'column', 'name', 'message', 'fileName', 'lineNumber', 'columnNumber', 'number', 'description'];
  function inspectObject$1(error, options) {
    var properties = Object.getOwnPropertyNames(error).filter(function (key) {
      return errorKeys.indexOf(key) === -1;
    });
    var name = error.name;
    options.truncate -= name.length;
    var message = '';

    if (typeof error.message === 'string') {
      message = truncate(error.message, options.truncate);
    } else {
      properties.unshift('message');
    }

    message = message ? ": ".concat(message) : '';
    options.truncate -= message.length + 5;
    var propertyContents = inspectList(properties.map(function (key) {
      return [key, error[key]];
    }), options, inspectProperty);
    return "".concat(name).concat(message).concat(propertyContents ? " { ".concat(propertyContents, " }") : '');
  }

  function inspectAttribute(_ref, options) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    options.truncate -= 3;

    if (!value) {
      return "".concat(options.stylize(key, 'yellow'));
    }

    return "".concat(options.stylize(key, 'yellow'), "=").concat(options.stylize("\"".concat(value, "\""), 'string'));
  }
  function inspectHTMLCollection(collection, options) {
    // eslint-disable-next-line no-use-before-define
    return inspectList(collection, options, inspectHTML, '\n');
  }
  function inspectHTML(element, options) {
    var properties = element.getAttributeNames();
    var name = element.tagName.toLowerCase();
    var head = options.stylize("<".concat(name), 'special');
    var headClose = options.stylize(">", 'special');
    var tail = options.stylize("</".concat(name, ">"), 'special');
    options.truncate -= name.length * 2 + 5;
    var propertyContents = '';

    if (properties.length > 0) {
      propertyContents += ' ';
      propertyContents += inspectList(properties.map(function (key) {
        return [key, element.getAttribute(key)];
      }), options, inspectAttribute, ' ');
    }

    options.truncate -= propertyContents.length;
    var truncate = options.truncate;
    var children = inspectHTMLCollection(element.children, options);

    if (children && children.length > truncate) {
      children = "".concat(truncator, "(").concat(element.children.length, ")");
    }

    return "".concat(head).concat(propertyContents).concat(headClose).concat(children).concat(tail);
  }

  var symbolsSupported = typeof Symbol === 'function' && typeof Symbol.for === 'function';
  var chaiInspect = symbolsSupported ? Symbol.for('chai/inspect') : '@@chai/inspect';
  var nodeInspect = false;

  try {
    // eslint-disable-next-line global-require
    var nodeUtil = __webpack_require__(/*! util */ "?9a07");

    nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
  } catch (noNodeInspect) {
    nodeInspect = false;
  }

  var constructorMap = new WeakMap();
  var stringTagMap = {};
  var baseTypesMap = {
    undefined: function undefined$1(value, options) {
      return options.stylize('undefined', 'undefined');
    },
    null: function _null(value, options) {
      return options.stylize(null, 'null');
    },
    boolean: function boolean(value, options) {
      return options.stylize(value, 'boolean');
    },
    Boolean: function Boolean(value, options) {
      return options.stylize(value, 'boolean');
    },
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: inspectPromise,
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: function WeakSet(value, options) {
      return options.stylize('WeakSet{}', 'special');
    },
    WeakMap: function WeakMap(value, options) {
      return options.stylize('WeakMap{}', 'special');
    },
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: function Generator() {
      return '';
    },
    DataView: function DataView() {
      return '';
    },
    ArrayBuffer: function ArrayBuffer() {
      return '';
    },
    Error: inspectObject$1,
    HTMLCollection: inspectHTMLCollection,
    NodeList: inspectHTMLCollection
  }; // eslint-disable-next-line complexity

  var inspectCustom = function inspectCustom(value, options, type) {
    if (chaiInspect in value && typeof value[chaiInspect] === 'function') {
      return value[chaiInspect](options);
    }

    if (nodeInspect && nodeInspect in value && typeof value[nodeInspect] === 'function') {
      return value[nodeInspect](options.depth, options);
    }

    if ('inspect' in value && typeof value.inspect === 'function') {
      return value.inspect(options.depth, options);
    }

    if ('constructor' in value && constructorMap.has(value.constructor)) {
      return constructorMap.get(value.constructor)(value, options);
    }

    if (stringTagMap[type]) {
      return stringTagMap[type](value, options);
    }

    return '';
  };

  var toString$1 = Object.prototype.toString; // eslint-disable-next-line complexity

  function inspect(value, options) {
    options = normaliseOptions(options);
    options.inspect = inspect;
    var _options = options,
        customInspect = _options.customInspect;
    var type = value === null ? 'null' : _typeof(value);

    if (type === 'object') {
      type = toString$1.call(value).slice(8, -1);
    } // If it is a base value that we already support, then use Loupe's inspector


    if (baseTypesMap[type]) {
      return baseTypesMap[type](value, options);
    } // If `options.customInspect` is set to true then try to use the custom inspector


    if (customInspect && value) {
      var output = inspectCustom(value, options, type);

      if (output) {
        if (typeof output === 'string') return output;
        return inspect(output, options);
      }
    }

    var proto = value ? Object.getPrototypeOf(value) : false; // If it's a plain Object then use Loupe's inspector

    if (proto === Object.prototype || proto === null) {
      return inspectObject(value, options);
    } // Specifically account for HTMLElements
    // eslint-disable-next-line no-undef


    if (value && typeof HTMLElement === 'function' && value instanceof HTMLElement) {
      return inspectHTML(value, options);
    }

    if ('constructor' in value) {
      // If it is a class, inspect it like an object but add the constructor name
      if (value.constructor !== Object) {
        return inspectClass(value, options);
      } // If it is an object with an anonymous prototype, display it as an object.


      return inspectObject(value, options);
    } // last chance to check if it's an object


    if (value === Object(value)) {
      return inspectObject(value, options);
    } // We have run out of options! Just stringify the value


    return options.stylize(String(value), type);
  }
  function registerConstructor(constructor, inspector) {
    if (constructorMap.has(constructor)) {
      return false;
    }

    constructorMap.add(constructor, inspector);
    return true;
  }
  function registerStringTag(stringTag, inspector) {
    if (stringTag in stringTagMap) {
      return false;
    }

    stringTagMap[stringTag] = inspector;
    return true;
  }
  var custom = chaiInspect;

  exports.custom = custom;
  exports.default = inspect;
  exports.inspect = inspect;
  exports.registerConstructor = registerConstructor;
  exports.registerStringTag = registerStringTag;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "../node_modules/mocha/lib sync recursive":
/*!***************************************!*\
  !*** ../node_modules/mocha/lib/ sync ***!
  \***************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "../node_modules/mocha/lib sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "../node_modules/mocha/node_modules/debug/node_modules/ms/index.js":
/*!*************************************************************************!*\
  !*** ../node_modules/mocha/node_modules/debug/node_modules/ms/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../node_modules/mocha/node_modules/debug/src/browser.js":
/*!***************************************************************!*\
  !*** ../node_modules/mocha/node_modules/debug/src/browser.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../node_modules/mocha/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../node_modules/mocha/node_modules/debug/src/common.js":
/*!**************************************************************!*\
  !*** ../node_modules/mocha/node_modules/debug/src/common.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../node_modules/mocha/node_modules/debug/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../node_modules/ms/index.js":
/*!***********************************!*\
  !*** ../node_modules/ms/index.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../node_modules/pathval/index.js":
/*!****************************************!*\
  !*** ../node_modules/pathval/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  }

  // The `in` operator does not work with primitives.
  return name in Object(obj);
}

/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    if (
      value === 'constructor' ||
      value === '__proto__' ||
      value === 'prototype'
    ) {
      return {};
    }
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value.replace(/\\([.[\]])/g, '$1') };
    }

    return parsed;
  });
}

/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */

function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];
    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}

/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */

function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null;
  // Here we iterate through every part of the path
  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i];

    // If it's the last part of the path, we set the 'propName' value with the property name
    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Now we set the property with the name held by 'propName' on object with the desired val
      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1];
      // Here we set the name of the property which will be defined
      propName = typeof part.p === 'undefined' ? part.i : part.p;
      // Here we decide if this property will be an array or a new object
      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}

/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent:
      parsed.length > 1 ?
        internalGetPathValue(obj, parsed, parsed.length - 1) :
        obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed),
  };
  info.exists = hasProperty(info.parent, info.name);

  return info;
}

/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */

function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}

/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */

function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

module.exports = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue,
};


/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/readable-stream/errors-browser.js":
/*!*********************************************************!*\
  !*** ../node_modules/readable-stream/errors-browser.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_duplex.js":
/*!*************************************************************!*\
  !*** ../node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(/*! ./_stream_readable */ "../node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "../node_modules/readable-stream/lib/_stream_writable.js");

__webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js")(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_passthrough.js":
/*!******************************************************************!*\
  !*** ../node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "../node_modules/readable-stream/lib/_stream_transform.js");

__webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js")(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_readable.js":
/*!***************************************************************!*\
  !*** ../node_modules/readable-stream/lib/_stream_readable.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "../node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(/*! util */ "?af24");

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "../node_modules/readable-stream/lib/internal/streams/buffer_list.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "../node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "../node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js")(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "../node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "../node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "../node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "../node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_transform.js":
/*!****************************************************************!*\
  !*** ../node_modules/readable-stream/lib/_stream_transform.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(/*! ../errors */ "../node_modules/readable-stream/errors-browser.js").codes),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "../node_modules/readable-stream/lib/_stream_duplex.js");

__webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js")(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_writable.js":
/*!***************************************************************!*\
  !*** ../node_modules/readable-stream/lib/_stream_writable.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "../node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "../node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "../node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "../node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js")(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!******************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(/*! ./end-of-stream */ "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js");

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!***************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(/*! buffer */ "../node_modules/buffer/index.js"),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(/*! util */ "?432f"),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!***********************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "../node_modules/readable-stream/errors-browser.js").codes.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!****************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(/*! ../../../errors */ "../node_modules/readable-stream/errors-browser.js").codes),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/state.js":
/*!*********************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/state.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "../node_modules/readable-stream/errors-browser.js").codes.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!******************************************************************************!*\
  !*** ../node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "../node_modules/safe-buffer/index.js":
/*!********************************************!*\
  !*** ../node_modules/safe-buffer/index.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../node_modules/stream-browserify/index.js":
/*!**************************************************!*\
  !*** ../node_modules/stream-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter);
var inherits = __webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/lib/_stream_readable.js */ "../node_modules/readable-stream/lib/_stream_readable.js");
Stream.Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ "../node_modules/readable-stream/lib/_stream_writable.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/lib/_stream_duplex.js */ "../node_modules/readable-stream/lib/_stream_duplex.js");
Stream.Transform = __webpack_require__(/*! readable-stream/lib/_stream_transform.js */ "../node_modules/readable-stream/lib/_stream_transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/lib/_stream_passthrough.js */ "../node_modules/readable-stream/lib/_stream_passthrough.js");
Stream.finished = __webpack_require__(/*! readable-stream/lib/internal/streams/end-of-stream.js */ "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js")
Stream.pipeline = __webpack_require__(/*! readable-stream/lib/internal/streams/pipeline.js */ "../node_modules/readable-stream/lib/internal/streams/pipeline.js")

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "../node_modules/string_decoder/lib/string_decoder.js":
/*!************************************************************!*\
  !*** ../node_modules/string_decoder/lib/string_decoder.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "../node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./src/apiDocuments.ts":
/*!*****************************!*\
  !*** ./src/apiDocuments.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Links to API documentation
 */
var APIDocumentation = {
    desktopAgent: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent",
    addContextListener: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#addcontextlistener",
    addIntentListener: "https://fdc3.finos.org/docs/api/ref/DesktopAgent#addintentlistener",
    broadcast: "https://fdc3.finos.org/docs/api/ref/DesktopAgent#broadcast",
    findIntent: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#findintent",
    findIntentsByContext: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#findintentsbycontext",
    getCurrentChannel: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#getcurrentchannel",
    getInfo: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#getinfo",
    getInfo2_0: "https://fdc3.finos.org/docs/api/ref/DesktopAgent#getinfo",
    getOrCreateChannel: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#getorcreatechannel",
    getSystemChannels: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#getsystemchannels",
    joinChannel: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#joinchannel",
    leaveCurrentChannel: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#leavecurrentchannel",
    open: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#open",
    raiseIntent: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#raiseintent",
    raiseIntentForContext: "https://fdc3.finos.org/docs/1.2/api/ref/DesktopAgent#raiseintentforcontext",
    appMetadata: "https://fdc3.finos.org/docs/api/ref/Metadata#appmetadata",
    findInstances: "https://fdc3.finos.org/docs/api/ref/DesktopAgent#findinstances",
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (APIDocumentation);


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Constants used in compliance testing
 */
var constants = {
    Fdc3Timeout: 500,
    TestTimeout: 9000,
    WaitTime: 3000,
    WindowCloseWaitTime: 100, // The amount of time to allow for clean-up of closed windows
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constants);


/***/ }),

/***/ "./src/test/testSuite.ts":
/*!*******************************!*\
  !*** ./src/test/testSuite.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "allTests": () => (/* binding */ allTests),
/* harmony export */   "executeTestsInBrowser": () => (/* binding */ executeTestsInBrowser),
/* harmony export */   "getPackMembers": () => (/* binding */ getPackMembers),
/* harmony export */   "getPackNames": () => (/* binding */ getPackNames),
/* harmony export */   "packs": () => (/* binding */ packs)
/* harmony export */ });
/* harmony import */ var mocha__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mocha */ "../node_modules/mocha/browser-entry.js");
/* harmony import */ var mocha__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mocha__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/* harmony import */ var _v1_2_basic_fdc3_addContextListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v1.2/basic/fdc3.addContextListener */ "./src/test/v1.2/basic/fdc3.addContextListener.ts");
/* harmony import */ var _v1_2_basic_fdc3_addIntentListener__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v1.2/basic/fdc3.addIntentListener */ "./src/test/v1.2/basic/fdc3.addIntentListener.ts");
/* harmony import */ var _v1_2_advanced_fdc3_broadcast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.2/advanced/fdc3.broadcast */ "./src/test/v1.2/advanced/fdc3.broadcast.ts");
/* harmony import */ var _v1_2_advanced_fdc3_findIntent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1.2/advanced/fdc3.findIntent */ "./src/test/v1.2/advanced/fdc3.findIntent.ts");
/* harmony import */ var _v1_2_advanced_fdc3_findIntentsByContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v1.2/advanced/fdc3.findIntentsByContext */ "./src/test/v1.2/advanced/fdc3.findIntentsByContext.ts");
/* harmony import */ var _v1_2_basic_fdc3_getCurrentChannel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v1.2/basic/fdc3.getCurrentChannel */ "./src/test/v1.2/basic/fdc3.getCurrentChannel.ts");
/* harmony import */ var _v1_2_basic_fdc3_getInfo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v1.2/basic/fdc3.getInfo */ "./src/test/v1.2/basic/fdc3.getInfo.ts");
/* harmony import */ var _v1_2_basic_fdc3_getOrCreateChannel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v1.2/basic/fdc3.getOrCreateChannel */ "./src/test/v1.2/basic/fdc3.getOrCreateChannel.ts");
/* harmony import */ var _v1_2_basic_fdc3_getSystemChannels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v1.2/basic/fdc3.getSystemChannels */ "./src/test/v1.2/basic/fdc3.getSystemChannels.ts");
/* harmony import */ var _v1_2_basic_fdc3_joinChannel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v1.2/basic/fdc3.joinChannel */ "./src/test/v1.2/basic/fdc3.joinChannel.ts");
/* harmony import */ var _v1_2_basic_fdc3_leaveCurrentChannel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./v1.2/basic/fdc3.leaveCurrentChannel */ "./src/test/v1.2/basic/fdc3.leaveCurrentChannel.ts");
/* harmony import */ var _v1_2_advanced_fdc3_open__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./v1.2/advanced/fdc3.open */ "./src/test/v1.2/advanced/fdc3.open.ts");
/* harmony import */ var _v1_2_advanced_fdc3_raiseIntent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./v1.2/advanced/fdc3.raiseIntent */ "./src/test/v1.2/advanced/fdc3.raiseIntent.ts");
/* harmony import */ var _v1_2_basic_fdc3_raiseIntentForContext__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./v1.2/basic/fdc3.raiseIntentForContext */ "./src/test/v1.2/basic/fdc3.raiseIntentForContext.ts");
/* harmony import */ var _v2_0_basic_fdc3_addContextListener__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./v2.0/basic/fdc3.addContextListener */ "./src/test/v2.0/basic/fdc3.addContextListener.ts");
/* harmony import */ var _v2_0_basic_fdc3_addIntentListener__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./v2.0/basic/fdc3.addIntentListener */ "./src/test/v2.0/basic/fdc3.addIntentListener.ts");
/* harmony import */ var _v2_0_advanced_fdc3_broadcast__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./v2.0/advanced/fdc3.broadcast */ "./src/test/v2.0/advanced/fdc3.broadcast.ts");
/* harmony import */ var _v2_0_basic_fdc3_getCurrentChannel__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./v2.0/basic/fdc3.getCurrentChannel */ "./src/test/v2.0/basic/fdc3.getCurrentChannel.ts");
/* harmony import */ var _v2_0_advanced_fdc3_getInfo__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./v2.0/advanced/fdc3.getInfo */ "./src/test/v2.0/advanced/fdc3.getInfo.ts");
/* harmony import */ var _v2_0_basic_fdc3_getOrCreateChannel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./v2.0/basic/fdc3.getOrCreateChannel */ "./src/test/v2.0/basic/fdc3.getOrCreateChannel.ts");
/* harmony import */ var _v2_0_basic_fdc3_getUserChannels__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./v2.0/basic/fdc3.getUserChannels */ "./src/test/v2.0/basic/fdc3.getUserChannels.ts");
/* harmony import */ var _v2_0_advanced_fdc3_getAppMetadata__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./v2.0/advanced/fdc3.getAppMetadata */ "./src/test/v2.0/advanced/fdc3.getAppMetadata.ts");
/* harmony import */ var _v2_0_advanced_fdc3_findInstances__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./v2.0/advanced/fdc3.findInstances */ "./src/test/v2.0/advanced/fdc3.findInstances.ts");
/* harmony import */ var _v2_0_basic_fdc3_joinUserChannel__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./v2.0/basic/fdc3.joinUserChannel */ "./src/test/v2.0/basic/fdc3.joinUserChannel.ts");
/* harmony import */ var _v2_0_basic_fdc3_leaveCurrentChannel__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./v2.0/basic/fdc3.leaveCurrentChannel */ "./src/test/v2.0/basic/fdc3.leaveCurrentChannel.ts");
/* harmony import */ var _v2_0_basic_fdc3_raiseIntentForContext__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./v2.0/basic/fdc3.raiseIntentForContext */ "./src/test/v2.0/basic/fdc3.raiseIntentForContext.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



















// import fdc3FindIntent_2_0 from "./v2.0/fdc3.findIntent";
// import fdc3FindIntentsByContext_2_0 from "./v2.0/fdc3.findIntentsByContext";








// import fdc3Open_2_0 from "./v2.0/fdc3.open";
// import fdc3RaiseIntent_2_0 from "./v2.0/fdc3.raiseIntent";

var basicSuite_1_2 = {
    fdc3AddContextListener_1_2: [_v1_2_basic_fdc3_addContextListener__WEBPACK_IMPORTED_MODULE_2__["default"]],
    fdc3AddIntentListener_1_2: [_v1_2_basic_fdc3_addIntentListener__WEBPACK_IMPORTED_MODULE_3__["default"]],
    fdc3GetCurrentChannel_1_2: [_v1_2_basic_fdc3_getCurrentChannel__WEBPACK_IMPORTED_MODULE_7__["default"]],
    fdc3GetInfo_1_2: [_v1_2_basic_fdc3_getInfo__WEBPACK_IMPORTED_MODULE_8__["default"]],
    fdc3GetOrCreateChannel_1_2: [_v1_2_basic_fdc3_getOrCreateChannel__WEBPACK_IMPORTED_MODULE_9__["default"]],
    fdc3GetSystemChannels_1_2: [_v1_2_basic_fdc3_getSystemChannels__WEBPACK_IMPORTED_MODULE_10__["default"]],
    fdc3JoinChannel_1_2: [_v1_2_basic_fdc3_joinChannel__WEBPACK_IMPORTED_MODULE_11__["default"]],
    fdc3LeaveCurrentChannel_1_2: [_v1_2_basic_fdc3_leaveCurrentChannel__WEBPACK_IMPORTED_MODULE_12__["default"]],
    fdc3RaiseIntentForContext_1_2: [_v1_2_basic_fdc3_raiseIntentForContext__WEBPACK_IMPORTED_MODULE_15__["default"]],
};
var basicSuite_2_0 = {
    fdc3AddContextListener_2_0: [_v2_0_basic_fdc3_addContextListener__WEBPACK_IMPORTED_MODULE_16__["default"]],
    fdc3AddIntentListener_2_0: [_v2_0_basic_fdc3_addIntentListener__WEBPACK_IMPORTED_MODULE_17__["default"]],
    fdc3GetCurrentChannel_2_0: [_v2_0_basic_fdc3_getCurrentChannel__WEBPACK_IMPORTED_MODULE_19__["default"]],
    fdc3GetInfo_2_0: [_v2_0_advanced_fdc3_getInfo__WEBPACK_IMPORTED_MODULE_20__["default"]],
    fdc3GetOrCreateChannel_2_0: [_v2_0_basic_fdc3_getOrCreateChannel__WEBPACK_IMPORTED_MODULE_21__["default"]],
    fdc3GetUserChannels_2_0: [_v2_0_basic_fdc3_getUserChannels__WEBPACK_IMPORTED_MODULE_22__["default"]],
    fdc3JoinUserChannel_2_0: [_v2_0_basic_fdc3_joinUserChannel__WEBPACK_IMPORTED_MODULE_25__["default"]],
    fdc3LeaveCurrentChannel_2_0: [_v2_0_basic_fdc3_leaveCurrentChannel__WEBPACK_IMPORTED_MODULE_26__["default"]],
    fdc3RaiseIntentForContext_2_0: [_v2_0_basic_fdc3_raiseIntentForContext__WEBPACK_IMPORTED_MODULE_27__["default"]],
};
var advancedSuite_1_2 = {
    fdc3Open_1_2: [_v1_2_advanced_fdc3_open__WEBPACK_IMPORTED_MODULE_13__["default"]],
    fdc3Broadcast_1_2: [_v1_2_advanced_fdc3_broadcast__WEBPACK_IMPORTED_MODULE_4__["default"]],
    fdc3FindIntent_1_2: [_v1_2_advanced_fdc3_findIntent__WEBPACK_IMPORTED_MODULE_5__["default"]],
    fdc3RaiseIntent_1_2: [_v1_2_advanced_fdc3_raiseIntent__WEBPACK_IMPORTED_MODULE_14__["default"]],
    fdc3FindIntentsByContext_1_2: [_v1_2_advanced_fdc3_findIntentsByContext__WEBPACK_IMPORTED_MODULE_6__["default"]],
};
var advancedSuite_2_0 = {
    fdc3Broadcast_2_0: [_v2_0_advanced_fdc3_broadcast__WEBPACK_IMPORTED_MODULE_18__["default"]],
    fdc3GetInfo_2_0: [_v2_0_advanced_fdc3_getInfo__WEBPACK_IMPORTED_MODULE_20__["default"]],
    fdc3FindInstances_2_0: [_v2_0_advanced_fdc3_findInstances__WEBPACK_IMPORTED_MODULE_24__["default"]],
    fdc3getAppMetadata_2_0: [_v2_0_advanced_fdc3_getAppMetadata__WEBPACK_IMPORTED_MODULE_23__["default"]],
};
function stripSuites(ts) {
    var out = [];
    ts.map(function (item) {
        var sets = Object.values(item);
        sets.forEach(function (set) { return set.forEach(function (test) { return out.push(test); }); });
    });
    return out;
}
var allTests = __assign(__assign(__assign(__assign({ "All 1.2": stripSuites([basicSuite_1_2, advancedSuite_1_2]), "All 2.0": stripSuites([basicSuite_2_0, advancedSuite_2_0]), "Basic 1.2": stripSuites([basicSuite_1_2]), "Basic 2.0": stripSuites([basicSuite_2_0]), "Advanced 1.2": stripSuites([advancedSuite_1_2]), "Advanced 2.0": stripSuites([advancedSuite_2_0]) }, basicSuite_1_2), advancedSuite_1_2), basicSuite_2_0), advancedSuite_2_0);
var packs = {
    "1.2 (Combined)": ["All 1.2", "Basic 1.2", "Advanced 1.2"],
    "1.2 (Individual Basic)": Object.keys(basicSuite_1_2),
    "1.2 (Individual Advanced)": Object.keys(advancedSuite_1_2),
    "2.0 (Combined)": ["All 2.0", "Basic 2.0", "Advanced 2.0"],
    "2.0 (Individual Basic)": Object.keys(basicSuite_2_0),
    "2.0 (Individual Advanced)": Object.keys(advancedSuite_2_0),
};
function getPackNames() {
    return Object.keys(packs);
}
function getPackMembers(packName) {
    return packs[packName];
}
/**
 * Intended for running tests in container with results shown
 * in HTML page
 */
var executeTestsInBrowser = function (pack) {
    mocha__WEBPACK_IMPORTED_MODULE_0___default().timeout(_constants__WEBPACK_IMPORTED_MODULE_1__["default"].TestTimeout);
    var suite = allTests[pack];
    suite.forEach(function (s) { return s(); });
    mocha__WEBPACK_IMPORTED_MODULE_0___default().run();
};


/***/ }),

/***/ "./src/test/v1.2/advanced/fdc3.broadcast.ts":
/*!**************************************************!*\
  !*** ./src/test/v1.2/advanced/fdc3.broadcast.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var documentation = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].desktopAgent + "\r\nCause:";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.broadcast", function () {
        var listener;
        var listener2;
        it("Broadcast method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                fdc3.broadcast({
                    type: "fdc3.instrument",
                    id: { ticker: "AAPL" },
                });
                return [2 /*return*/];
            });
        }); });
        describe("System channels", function () {
            beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, unsubscribeListeners()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            afterEach(function afterEach() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeChannelsAppWindow(this.currentTest.title)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
            var scTestId1 = "(UCBasicUsage1) Should receive context when adding a listener then joining a user channel before app B broadcasts context to the same channel";
            it(scTestId1, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- Add fdc3.instrument context listener to app A\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId1];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            listener = fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                    return [2 /*return*/];
                                });
                            }); });
                            validateListenerObject(listener);
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 2:
                            channel = _c.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId1,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //wait for ChannelsApp to execute
                            _c.sent();
                            //reject if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received" + errorMessage);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId2 = "(UCBasicUsage2) Should receive context when joining a user channel then adding a context listener before app B broadcasts context to the same channel";
            it(scTestId2, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channel, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A joins channel 1\r\n- Add listener of type fdc3.instrument to App A\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId2];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 2:
                            channel = _c.sent();
                            receivedContext = false;
                            //Add fdc3.instrument context listener
                            listener = fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                    return [2 /*return*/];
                                });
                            }); });
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId2,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId3 = "(UCBasicUsage3) Should receive context when app B joins then broadcasts context to a user channel before A joins and listens on the same channel";
            it(scTestId3, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channel, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context\r\n- App A joins channel 1\r\n- App A adds fdc3.instrument context listener".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId3];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, getUserChannel(1)];
                        case 2:
                            channel = _c.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId3,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Join system channel 1
                            return [4 /*yield*/, fdc3.joinChannel(channel.id)];
                        case 4:
                            //Join system channel 1
                            _c.sent();
                            receivedContext = false;
                            //Add fdc3.instrument context listener
                            listener = fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                    return [2 /*return*/];
                                });
                            }); });
                            validateListenerObject(listener);
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId4 = "(UCFilteredContext1) Should receive context when app A joins a user channel before adding a listener and app B broadcasts the listened type to the same user channel";
            it(scTestId4, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument context listener\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId4];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            //Add context listener
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) {
                                (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                receivedContext = true;
                            });
                            validateListenerObject(listener);
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 2:
                            channel = _c.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId4,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId5 = "(UCFilteredContext2) Should receive multiple contexts when app B broadcasts the listened types to the same user channel";
            it(scTestId5, function () { return __awaiter(void 0, void 0, void 0, function () {
                function checkIfBothContextsReceived() {
                    if (contextTypes.length === 2) {
                        if (!contextTypes.includes("fdc3.contact") ||
                            !contextTypes.includes("fdc3.instrument")) {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Incorrect context received", errorMessage);
                        }
                        else {
                            receivedContext = true;
                        }
                    }
                }
                var errorMessage, resolveExecutionCompleteListener, _a, _b, contextTypes, receivedContext, channel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument and fdc3.contact context listener\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts both context types".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId5];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            contextTypes = [];
                            receivedContext = false;
                            //Add context listener
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) {
                                contextTypes.push(context.type);
                                checkIfBothContextsReceived();
                            });
                            validateListenerObject(listener);
                            //Add second context listener to app A
                            listener2 = fdc3.addContextListener("fdc3.contact", function (context) {
                                contextTypes.push(context.type);
                                checkIfBothContextsReceived();
                            });
                            validateListenerObject(listener2);
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 2:
                            channel = _c.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId5,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("At least one context was not received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId6 = "(UCFilteredContext3) Should not receive context when A & B join different user channels and app B broadcasts a listened type";
            it(scTestId6, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, channels, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument and fdc3.contact context listener\r\n- App A joins channel 2\r\n- App B joins channel 1\r\n- App B broadcasts both context types".concat(documentation);
                            //Add fdc3.instrument context listener
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            //Add fdc3.contact context listener
                            listener2 = fdc3.addContextListener("fdc3.contact", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener2);
                            return [4 /*yield*/, fdc3.getSystemChannels()];
                        case 1:
                            channels = _a.sent();
                            if (channels.length < 1)
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available for app A");
                            //Join a different channel to the one passed to channelsApp
                            return [4 /*yield*/, fdc3.joinChannel(channels[0].id)];
                        case 2:
                            //Join a different channel to the one passed to channelsApp
                            _a.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId6,
                                userChannelId: channels[1].id,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            //Give listeners time to receive context
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)()];
                        case 4:
                            //Give listeners time to receive context
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId7 = "(UCUnsubscribe) Should not receive context when unsubscribing a user channel before app B broadcasts the listened type to that channel";
            it(scTestId7, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A unsubscribes the listener\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId7];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            //Add fdc3.instrument context listener
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 2:
                            channel = _c.sent();
                            if (!(listener !== undefined)) return [3 /*break*/, 4];
                            return [4 /*yield*/, listener.unsubscribe()];
                        case 3:
                            _c.sent();
                            listener = undefined;
                            return [3 /*break*/, 5];
                        case 4:
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Listener undefined", errorMessage);
                            _c.label = 5;
                        case 5:
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId7,
                                userChannelId: channel.id,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 6:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 7:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId8 = "(UCFilteredContext4) Should not receive context when joining two different user channels before app B broadcasts the listened type to the first channel that was joined";
            it(scTestId8, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, channels, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A joins channel 2\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            //Add fdc3.instrument context listener
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                    return [2 /*return*/];
                                });
                            }); });
                            return [4 /*yield*/, fdc3.getSystemChannels()];
                        case 1:
                            channels = _a.sent();
                            if (channels.length < 1)
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available for app A");
                            //Join a channel before joining a different channel
                            return [4 /*yield*/, fdc3.joinChannel(channels[0].id)];
                        case 2:
                            //Join a channel before joining a different channel
                            _a.sent();
                            return [4 /*yield*/, fdc3.joinChannel(channels[1].id)];
                        case 3:
                            _a.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId8,
                                userChannelId: channels[0].id,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            //Give listener time to receive context
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)()];
                        case 5:
                            //Give listener time to receive context
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId9 = "(UCFilteredContext5) Should not receive context when joining and then leaving a user channel before app B broadcasts the listened type to the same channel";
            it(scTestId9, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, channel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A leaves channel 1\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            //Add a context listeners to app A
                            listener = fdc3.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            return [4 /*yield*/, retrieveAndJoinChannel(1)];
                        case 1:
                            channel = _a.sent();
                            //App A leaves channel 1
                            return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 2:
                            //App A leaves channel 1
                            _a.sent();
                            channelsAppCommands = [
                                commands.joinRetrievedUserChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: scTestId9,
                                userChannelId: channel.id,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            //Give listener time to receive context
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)()];
                        case 4:
                            //Give listener time to receive context
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        describe("App channels", function () {
            beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, unsubscribeListeners()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            afterEach(function afterEach() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeChannelsAppWindow(this.currentTest.title)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
            var acTestId = "(ACBasicUsage1) Should receive context when app a adds a listener and app B broadcasts to the same app channel";
            it(acTestId, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds adds a context listener of type null\r\n- App B retrieves the same app channel as A\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            //Add context listener
                            listener = testChannel.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                    return [2 /*return*/];
                                });
                            }); });
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId2 = "(ACBasicUsage2) Should receive context when app B broadcasts context to an app channel before A retrieves current context";
            it(acTestId2, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A & B retrieve the same app channel\r\n- App B broadcasts context of type fdc3.instrument\r\n- App A retrieves current context of type null".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId2];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId2,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp the finish executing
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp the finish executing
                            _c.sent();
                            receivedContext = false;
                            //Retrieve current context from channel
                            return [4 /*yield*/, testChannel.getCurrentContext().then(function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 5:
                            //Retrieve current context from channel
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId4 = "(ACFilteredContext1) Should only receive the listened context when app B broadcasts multiple contexts to the same app channel";
            it(acTestId4, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves the same app channel as A\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId4];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            //Add context listener
                            listener = testChannel.addContextListener("fdc3.instrument", function (context) {
                                (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                receivedContext = true;
                            });
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId4,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId5 = "(ACFilteredContext2) Should receive multiple contexts when app B broadcasts the listened types to the same app channel";
            it(acTestId5, function () { return __awaiter(void 0, void 0, void 0, function () {
                function checkIfBothContextsReceived() {
                    if (contextTypes.length === 2) {
                        if (!contextTypes.includes("fdc3.contact") ||
                            !contextTypes.includes("fdc3.instrument")) {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Incorrect context received", errorMessage);
                        }
                        else {
                            receivedContext = true;
                        }
                    }
                }
                var errorMessage, contextTypes, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type fdc3.instrument and fdc3.contact\r\n- App B retrieves the same app channel as A\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact".concat(documentation);
                            contextTypes = [];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId5];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            //Add fdc3.instrument context listener
                            listener = testChannel.addContextListener("fdc3.instrument", function (context) {
                                contextTypes.push(context.type);
                                checkIfBothContextsReceived();
                            });
                            validateListenerObject(listener);
                            //Add fdc3.contact context listener
                            listener2 = testChannel.addContextListener("fdc3.contact", function (context) {
                                contextTypes.push(context.type);
                                checkIfBothContextsReceived();
                            });
                            validateListenerObject(listener2);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId5,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            receivedContext = false;
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId6 = "(ACUnsubscribe) Should not receive context when unsubscribing an app channel before app B broadcasts to that channel";
            it(acTestId6, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type null\r\n- App A unsubscribes the app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId6];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            //Add context listener
                            listener = testChannel.addContextListener(null, function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            //Unsubscribe from app channel
                            listener.unsubscribe();
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId6,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId7 = "(ACFilteredContext3) Should not receive context when app B broadcasts context to a different app channel";
            it(acTestId7, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves a different app channel\r\n- App B broadcasts a context of type fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("a-different-test-channel")];
                        case 1:
                            testChannel = _a.sent();
                            //Add context listener
                            listener = testChannel.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId7,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            //Give listener time to receive context
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)()];
                        case 3:
                            //Give listener time to receive context
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId8 = "(ACFilteredContext4) Should not receive context when retrieving two different app channels before app B broadcasts the listened type to the first channel that was retrieved";
            it(acTestId8, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A switches to a different app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves the first channel that A retrieved\r\n- App B broadcasts a context of type fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId8];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, fdc3.getOrCreateChannel("a-different-test-channel")];
                        case 3:
                            //App A retrieves a different app channel
                            testChannel = _c.sent();
                            //Add context listener
                            listener = testChannel.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            });
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId8,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId9 = "(ACContextHistoryTyped) Should receive both contexts when app B broadcasts both contexts to the same app channel and A gets current context for each type";
            it(acTestId9, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, channelsAppCommands, channelsAppConfig, context, contactContext;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact\r\n- App A gets current context for types fdc3.instrument and fdc3.contact".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _a.sent();
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId9,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.instrument")];
                        case 3:
                            context = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.name).to.be.equals("History-item-1", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.contact")];
                        case 4:
                            contactContext = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(contactContext.name).to.be.equals("History-item-1", errorMessage);
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId10 = "(ACContextHistoryMultiple) Should retrieve the last broadcast context item when app B broadcasts a context with multiple history items to the same app channel and A gets current context";
            it(acTestId10, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, context, context2;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts two different contexts of type fdc3.instrument\r\n- App A gets current context for types fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId10];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId10,
                                notifyAppAOnCompletion: true,
                                historyItems: 2,
                            };
                            //Open ChannelsApp and execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp and execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.instrument")];
                        case 5:
                            context = _c.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.name).to.be.equals("History-item-2", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.contact")];
                        case 6:
                            context2 = _c.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context2.type).to.be.equals("fdc3.contact", errorMessage);
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context2.name).to.be.equals("History-item-2", errorMessage);
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId11 = "(ACContextHistoryLast) Should retrieve the last broadcast context item when app B broadcasts two different contexts to the same app channel and A gets current context";
            it(acTestId11, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, context;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact\r\n- App B gets current context with no filter applied".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId11];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "1.2",
                                testId: acTestId11,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open("ChannelsApp", buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [4 /*yield*/, testChannel.getCurrentContext()];
                        case 5:
                            context = _c.sent();
                            if (context === null) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No Context retrieved", errorMessage);
                            }
                            else if (context.type === "fdc3.instrument") {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Did not retrieve last broadcast context from app B", errorMessage);
                            }
                            else {
                                (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.contact", errorMessage);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        var retrieveAndJoinChannel = function (channelNumber) { return __awaiter(void 0, void 0, void 0, function () {
            var channel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getUserChannel(channelNumber)];
                    case 1:
                        channel = _a.sent();
                        return [4 /*yield*/, fdc3.joinChannel(channel.id)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, channel];
                }
            });
        }); };
        var getUserChannel = function (channel) { return __awaiter(void 0, void 0, void 0, function () {
            var channels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getSystemChannels()];
                    case 1:
                        channels = _a.sent();
                        if (channels.length > 0) {
                            return [2 /*return*/, channels[channel - 1]];
                        }
                        else {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available for app A");
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        function validateListenerObject(listenerObject) {
            chai__WEBPACK_IMPORTED_MODULE_0__.assert.isTrue(typeof listenerObject === "object", "No listener object found");
            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof listenerObject.unsubscribe).to.be.equals("function", "Listener does not contain an unsubscribe method");
        }
        function closeChannelsAppWindow(testId) {
            return __awaiter(this, void 0, void 0, function () {
                var appControlChannel;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, broadcastAppChannelCloseWindow(testId)];
                        case 1:
                            appControlChannel = _a.sent();
                            //Wait for ChannelsApp to respond
                            return [4 /*yield*/, waitForContext("windowClosed", testId, appControlChannel)];
                        case 2:
                            //Wait for ChannelsApp to respond
                            _a.sent();
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)(_constants__WEBPACK_IMPORTED_MODULE_1__["default"].WindowCloseWaitTime)];
                        case 3:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        var broadcastAppChannelCloseWindow = function (testId) { return __awaiter(void 0, void 0, void 0, function () {
            var appControlChannel, closeContext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                    case 1:
                        appControlChannel = _a.sent();
                        closeContext = {
                            type: "closeWindow",
                            testId: testId,
                        };
                        appControlChannel.broadcast(closeContext);
                        return [2 /*return*/, appControlChannel];
                }
            });
        }); };
        function unsubscribeListeners() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(listener !== undefined)) return [3 /*break*/, 2];
                            return [4 /*yield*/, listener.unsubscribe()];
                        case 1:
                            _a.sent();
                            listener = undefined;
                            _a.label = 2;
                        case 2:
                            if (!(listener2 !== undefined)) return [3 /*break*/, 4];
                            return [4 /*yield*/, listener2.unsubscribe()];
                        case 3:
                            _a.sent();
                            listener2 = undefined;
                            _a.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        }
        var waitForContext = function (contextType, testId, channel) {
            var executionListener;
            return new Promise(function (resolve) { return __awaiter(void 0, void 0, void 0, function () {
                var handler, ccHandler;
                return __generator(this, function (_a) {
                    console.log(Date.now() +
                        " Waiting for type: \"".concat(contextType, "\", on channel: \"").concat(channel.id, "\" in test: \"").concat(testId, "\""));
                    handler = function (context) {
                        if (testId) {
                            if (testId == context.testId) {
                                console.log(Date.now() + " Received ".concat(contextType, " for test: ").concat(testId));
                                resolve(context);
                                if (executionListener)
                                    executionListener.unsubscribe();
                            }
                            else {
                                console.warn(Date.now() +
                                    " Ignoring \"".concat(contextType, "\" context due to mismatched testId (expected: \"").concat(testId, "\", got \"").concat(context.testId, "\")"));
                            }
                        }
                        else {
                            console.log(Date.now() +
                                " Received (without testId) \"".concat(contextType, "\" for test: \"").concat(testId, "\""));
                            resolve(context);
                            if (executionListener)
                                executionListener.unsubscribe();
                        }
                    };
                    if (channel === undefined) {
                        executionListener = fdc3.addContextListener(contextType, handler);
                    }
                    else {
                        executionListener = channel.addContextListener(contextType, handler);
                        ccHandler = function (context) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                if (context) {
                                    if (testId) {
                                        if (testId == (context === null || context === void 0 ? void 0 : context.testId) && (context === null || context === void 0 ? void 0 : context.type) == contextType) {
                                            console.log(Date.now() +
                                                " Received \"".concat(contextType, "\" (from current context) for test: \"").concat(testId, "\""));
                                            if (executionListener)
                                                executionListener.unsubscribe();
                                            resolve(context);
                                        } //do not warn as it will be ignoring mismatches which will be common
                                        else {
                                            console.log(Date.now() +
                                                " CHecking for current context of type \"".concat(contextType, "\" for test: \"").concat(testId, "\" Current context did ").concat(context ? "" : "NOT ", " exist, \n    had testId: \"").concat(context === null || context === void 0 ? void 0 : context.testId, "\" (").concat(testId == (context === null || context === void 0 ? void 0 : context.testId)
                                                    ? "did match"
                                                    : "did NOT match", ") \n    and type \"").concat(context === null || context === void 0 ? void 0 : context.type, "\" (").concat((context === null || context === void 0 ? void 0 : context.type) == contextType
                                                    ? "did match"
                                                    : "did NOT match", ")"));
                                        }
                                    }
                                    else {
                                        console.log(Date.now() +
                                            " Received \"".concat(contextType, "\" (from current context) for an unspecified test"));
                                        if (executionListener)
                                            executionListener.unsubscribe();
                                        resolve(context);
                                    }
                                }
                                return [2 /*return*/];
                            });
                        }); };
                        channel.getCurrentContext().then(ccHandler);
                    }
                    return [2 /*return*/];
                });
            }); });
        };
    });
});
function buildChannelsAppContext(mockAppCommands, config) {
    var _a, _b, _c;
    return {
        type: "channelsAppContext",
        commands: mockAppCommands,
        config: {
            fdc3ApiVersion: config.fdc3ApiVersion,
            testId: config.testId,
            notifyAppAOnCompletion: (_a = config.notifyAppAOnCompletion) !== null && _a !== void 0 ? _a : false,
            historyItems: (_b = config.historyItems) !== null && _b !== void 0 ? _b : 1,
            userChannelId: (_c = config.userChannelId) !== null && _c !== void 0 ? _c : null,
        },
    };
}
var commands = {
    joinRetrievedUserChannel: "joinRetrievedUserChannel",
    retrieveTestAppChannel: "retrieveTestAppChannel",
    broadcastInstrumentContext: "broadcastInstrumentContext",
    broadcastContactContext: "broadcastContactContext",
};


/***/ }),

/***/ "./src/test/v1.2/advanced/fdc3.findIntent.ts":
/*!***************************************************!*\
  !*** ./src/test/v1.2/advanced/fdc3.findIntent.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_1_2 */ "../node_modules/fdc3_1_2/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var findIntentDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].findIntent + "\r\nCause";
/**
 * Details on the mock apps used in these tests can be found in /mock/README.md
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.findIntent", function () {
        it("(IntentAppD) Should find intent 'aTestingIntent' belonging only to app intent-a", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIntent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.findIntent("aTestingIntent")];
                    case 1:
                        appIntent = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.intent).to.deep.eq({
                            name: "aTestingIntent",
                            displayName: "A Testing Intent",
                        }, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps).to.have.length(1, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[0]).to.have.property("name", "IntentAppA", findIntentDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        it("(WrongIntentAppD) Should throw NoAppsFound error when intent does not exist", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.findIntent("nonExistentIntent")];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was thrown", findIntentDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_1).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, findIntentDocs);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(IntentAppDRightContext) Should find intent 'aTestingIntent' belonging only to app intent-a with context 'testContextX'", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIntent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.findIntent("aTestingIntent", {
                            type: "testContextX",
                        })];
                    case 1:
                        appIntent = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.intent).to.deep.eq({
                            name: "aTestingIntent",
                            displayName: "A Testing Intent",
                        }, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps).to.have.length(1, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[0]).to.have.property("name", "IntentAppA", findIntentDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        it("(IntentAppDWrongContext) Should throw NoAppsFound error when intent exists but context does not", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.findIntent("aTestingIntent", {
                                type: "testContextY",
                            })];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was thrown", findIntentDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_2).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, findIntentDocs);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(IntentAppDMultiple1) Should find intent 'sharedTestingIntent1' belonging to multiple apps (intent-a & intent-b)", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIntent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.findIntent("sharedTestingIntent1")];
                    case 1:
                        appIntent = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.intent).to.deep.eq({
                            name: "sharedTestingIntent1",
                            displayName: "Shared Testing Intent",
                        }, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps).to.have.length(2, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[0]).to.have.property("name", "IntentAppA", findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[1]).to.have.property("name", "IntentAppB", findIntentDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        it("(IntentAppDMultiple2) Should find intent 'sharedTestingIntent1' belonging to multiple apps (intent-a & intent-b) filtered by specific context 'testContextX'", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIntent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.findIntent("sharedTestingIntent1", {
                            type: "testContextX",
                        })];
                    case 1:
                        appIntent = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.intent).to.deep.eq({
                            name: "sharedTestingIntent1",
                            displayName: "Shared Testing Intent",
                        }, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps).to.have.length(2, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[0]).to.have.property("name", "IntentAppA", findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[1]).to.have.property("name", "IntentAppB", findIntentDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        it("(IntentAppDMultiple3) Should find intent 'sharedTestingIntent1' belonging to app 'intent-b' when filtered by specific context 'testContextY'", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIntent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.findIntent("sharedTestingIntent1", {
                            type: "testContextY",
                        })];
                    case 1:
                        appIntent = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.intent).to.deep.eq({
                            name: "sharedTestingIntent1",
                            displayName: "Shared Testing Intent",
                        }, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps).to.have.length(1, findIntentDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(appIntent.apps[0]).to.have.property("name", "IntentAppB", findIntentDocs);
                        return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/advanced/fdc3.findIntentsByContext.ts":
/*!*************************************************************!*\
  !*** ./src/test/v1.2/advanced/fdc3.findIntentsByContext.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_1_2 */ "../node_modules/fdc3_1_2/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var findIntentsByContextDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].findIntentsByContext + "\r\nCause";
/**
 * Details on the mock apps used in these tests can be found in /mock/README.md
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.findIntentsByContext", function () {
        it("(SingleContext) Should find intents by context 'testContextX'", function () { return __awaiter(void 0, void 0, void 0, function () {
            var intents, intentNames, aTestingIntent, sharedTestingIntent1, sharedAppNames, cTestingIntent, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.findIntentsByContext({
                                type: "testContextX",
                            })];
                    case 1:
                        intents = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(intents).to.have.length(3, findIntentsByContextDocs);
                        intentNames = intents.map(function (appIntent) { return appIntent.intent.name; });
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(intentNames).to.have.all.members(["aTestingIntent", "sharedTestingIntent1", "cTestingIntent"], findIntentsByContextDocs);
                        aTestingIntent = intents.find(function (appIntent) { return appIntent.intent.name === "aTestingIntent"; });
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(aTestingIntent.apps).to.have.length(1, findIntentsByContextDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(aTestingIntent.apps[0].name).to.eq("IntentAppA", findIntentsByContextDocs);
                        sharedTestingIntent1 = intents.find(function (appIntent) { return appIntent.intent.name === "sharedTestingIntent1"; });
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(sharedTestingIntent1.apps).to.have.length(2, findIntentsByContextDocs);
                        sharedAppNames = sharedTestingIntent1.apps.map(function (app) { return app.name; });
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(sharedAppNames).to.have.all.members(["IntentAppA", "IntentAppB"], findIntentsByContextDocs);
                        cTestingIntent = intents.find(function (appIntent) { return appIntent.intent.name === "cTestingIntent"; });
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(cTestingIntent.apps).to.have.length(1, findIntentsByContextDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(cTestingIntent.apps[0].name).to.eq("IntentAppC", findIntentsByContextDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail(findIntentsByContextDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(NoContext) Passing an invalid context causes a NoAppsFound error to be thrown", function () { return __awaiter(void 0, void 0, void 0, function () {
            var context, ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context = {
                            type: "ThisContextDoesNotExist",
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fdc3.findIntentsByContext(context)];
                    case 2:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Expected error NoAppsFound not thrown", findIntentsByContextDocs);
                        return [3 /*break*/, 4];
                    case 3:
                        ex_2 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_2).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, findIntentsByContextDocs);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/advanced/fdc3.open.ts":
/*!*********************************************!*\
  !*** ./src/test/v1.2/advanced/fdc3.open.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_1_2 */ "../node_modules/fdc3_1_2/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var appBName = "MockApp";
var appBId = "MockAppId";
var noListenerAppId = "IntentAppAId";
var noListenerAppName = "IntentAppA";
var genericListenerAppId = "IntentAppCId";
var genericListenerAppName = "IntentAppC";
var openDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].open + "\r\nCause";
/**
 * Details on the mock apps used in these tests can be found in /mock/README.md
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.open", function () {
        beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensB1Test = "(AOpensB1) Can open app B from app A with no context and string as target";
        it(AOpensB1Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        result = createReceiver("fdc3-conformance-opened");
                        return [4 /*yield*/, fdc3.open(appBName)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, result];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, closeAppWindows(AOpensB1Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensB2Test = "(AOpensB2) Can open app B from app A with no context and AppMetadata (name) as target";
        it(AOpensB2Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        result = createReceiver("fdc3-conformance-opened");
                        return [4 /*yield*/, fdc3.open({ name: appBName })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, result];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, closeAppWindows(AOpensB2Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensB3Test = "(AOpensB3) Can open app B from app A with no context and AppMetadata (name and appId) as target";
        it(AOpensB3Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        result = createReceiver("fdc3-conformance-opened");
                        return [4 /*yield*/, fdc3.open({ name: appBName, appId: appBId })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, result];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, closeAppWindows(AOpensB3Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AFailsToOpenB1Test = "(AFailsToOpenB1) Receive AppNotFound error when targeting non-existent app name as target";
        it(AFailsToOpenB1Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.open("ThisAppDoesNotExist")];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was not thrown", openDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_1).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.OpenError.AppNotFound, openDocs);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        var AFailsToOpenB2Test = "(AFailsToOpenB2) Receive AppNotFound error when targeting non-existent app AppMetadata (name) as target";
        it(AFailsToOpenB2Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.open({
                                name: "ThisAppDoesNotExist",
                            })];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was not thrown", openDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_2).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.OpenError.AppNotFound, openDocs);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        var AFailsToOpenB3 = "(AFailsToOpenB3) Receive AppNotFound error when targeting non-existent app AppMetadata (name and appId) as target";
        it(AFailsToOpenB3, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.open({
                                name: "ThisAppDoesNotExist",
                                appId: "ThisAppDoesNotExist",
                            })];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was not thrown", openDocs);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_3 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_3).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.OpenError.AppNotFound, openDocs);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithSpecificContext1Test = "(AOpensBWithSpecificContext1) Can open app B from app A with context and string as target, app B adds specific listener";
        it(AOpensBWithSpecificContext1Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open(appBName, {
                                name: "context",
                                type: "fdc3.testReceiver",
                            })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.testReceiver", openDocs);
                        return [4 /*yield*/, closeAppWindows(AOpensBWithSpecificContext1Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithSpecificContext2Test = "(AOpensBWithSpecificContext2) Can open app B from app A with context and AppMetadata (name) as target, app B adds specific listener";
        it(AOpensBWithSpecificContext2Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open({ name: appBName }, { name: "context", type: "fdc3.testReceiver" })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.testReceiver", openDocs);
                        return [4 /*yield*/, closeAppWindows(AOpensBWithSpecificContext2Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithSpecificContext3Test = "(AOpensBWithSpecificContext3) Can open app B from app A with context and AppMetadata (name and appId) as target, app B adds specific listener";
        it(AOpensBWithSpecificContext3Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open({ name: appBName, appId: appBId }, { name: "context", type: "fdc3.testReceiver" })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.testReceiver", openDocs);
                        return [4 /*yield*/, closeAppWindows(AOpensBWithSpecificContext3Test)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithContext1Test = "(AOpensBWithContext1) Can open app B from app A with context and string as target, app B adds generic listener";
        it(AOpensBWithContext1Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("fdc3.raiseIntent")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open(genericListenerAppName, {
                                name: "context",
                                type: "fdc3.genericListener",
                            })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        return [4 /*yield*/, closeAppWindows(AOpensBWithContext1Test)];
                    case 4:
                        _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.genericListener", openDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithContext2Test = "(AOpensBWithContext2) Can open app B from app A with context and AppMetadata (name) as target, app B adds generic listener";
        it(AOpensBWithContext2Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("fdc3.raiseIntent")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open({ name: genericListenerAppName }, { name: "context", type: "fdc3.genericListener" })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        return [4 /*yield*/, closeAppWindows(AOpensBWithContext2Test)];
                    case 4:
                        _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.genericListener", openDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithContext3Test = "(AOpensBWithContext3) Can open app B from app A with context and AppMetadata (name and appId) as target, app B adds generic listener";
        it(AOpensBWithContext3Test, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("fdc3.raiseIntent")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received");
                        return [4 /*yield*/, fdc3.open({ name: genericListenerAppName, appId: genericListenerAppId }, { name: "context", type: "fdc3.genericListener" })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        return [4 /*yield*/, closeAppWindows(AOpensBWithContext3Test)];
                    case 4:
                        _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.genericListener", openDocs);
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBWithWrongContextTest = "(AOpensBWithWrongContext) Receive AppTimeout error when targeting app with wrong context";
        it(AOpensBWithWrongContextTest, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, fdc3.open({ name: appBName }, { name: "context", type: "fdc3.thisContextDoesNotExist" })];
                    case 3:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was not thrown", openDocs);
                        return [3 /*break*/, 5];
                    case 4:
                        ex_4 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_4).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.OpenError.AppTimeout, openDocs);
                        return [3 /*break*/, 5];
                    case 5: return [4 /*yield*/, closeAppWindows(AOpensBWithWrongContextTest)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBNoListenTest = "(AOpensBNoListen) Receive AppTimeout error when targeting app with no listeners";
        it(AOpensBNoListenTest, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("fdc3.raiseIntent")];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, fdc3.open({ name: noListenerAppName, appId: noListenerAppId }, { name: "context", type: "fdc3.testReceiver" })];
                    case 3:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("No error was not thrown", openDocs);
                        return [3 /*break*/, 5];
                    case 4:
                        ex_5 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_5).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.OpenError.AppTimeout, openDocs);
                        return [3 /*break*/, 5];
                    case 5: return [4 /*yield*/, closeAppWindows(AOpensBNoListenTest)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var AOpensBMultipleListenTest = "(AOpensBMultipleListen) Can open app B from app A with context and AppMetadata (name and appId) as target, app B has opened multiple listeners";
        it(AOpensBMultipleListenTest, function () { return __awaiter(void 0, void 0, void 0, function () {
            var receiver, receivedValue;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.joinChannel("FDC3-Conformance-Channel")];
                    case 1:
                        _a.sent();
                        receiver = createReceiver("fdc3-conformance-context-received-multiple");
                        return [4 /*yield*/, fdc3.open({ name: appBName, appId: appBId }, { name: "context", type: "fdc3.testReceiverMultiple" })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, receiver];
                    case 3:
                        receivedValue = (_a.sent());
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.name).to.eq("context", openDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(receivedValue.context.type).to.eq("fdc3.testReceiverMultiple", openDocs);
                        return [4 /*yield*/, closeAppWindows(AOpensBMultipleListenTest)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
// creates a channel and subscribes for broadcast contexts. This is
// used by the 'mock app' to send messages back to the test runner for validation
var createReceiver = function (contextType) {
    var timeout;
    var messageReceived = new Promise(function (resolve, reject) { return __awaiter(void 0, void 0, void 0, function () {
        var listener, _a, thePromise, theTimeout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    listener = fdc3.addContextListener(contextType, function (context) {
                        resolve(context);
                        clearTimeout(timeout);
                        listener.unsubscribe();
                    });
                    _a = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.sleep)(), thePromise = _a.promise, theTimeout = _a.timeout;
                    timeout = theTimeout;
                    return [4 /*yield*/, thePromise];
                case 1:
                    _b.sent();
                    reject(new Error("No context received from app B"));
                    return [2 /*return*/];
            }
        });
    }); });
    return messageReceived;
};
function closeAppWindows(testId) {
    return __awaiter(this, void 0, void 0, function () {
        var appControlChannel;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, broadcastCloseWindow(testId)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                case 2:
                    appControlChannel = _a.sent();
                    return [4 /*yield*/, waitForContext("windowClosed", testId, appControlChannel)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_4__.wait)(_constants__WEBPACK_IMPORTED_MODULE_3__["default"].WindowCloseWaitTime)];
                case 4:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var broadcastCloseWindow = function (currentTest) { return __awaiter(void 0, void 0, void 0, function () {
    var appControlChannel;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
            case 1:
                appControlChannel = _a.sent();
                appControlChannel.broadcast({
                    type: "closeWindow",
                    testId: currentTest,
                });
                return [2 /*return*/];
        }
    });
}); };
var waitForContext = function (contextType, testId, channel) {
    var executionListener;
    return new Promise(function (resolve) { return __awaiter(void 0, void 0, void 0, function () {
        var handler, ccHandler;
        return __generator(this, function (_a) {
            console.log(Date.now() +
                " Waiting for type: \"".concat(contextType, "\", on channel: \"").concat(channel.id, "\" in test: \"").concat(testId, "\""));
            handler = function (context) {
                console.log(" waitforcontext hander reached");
                if (testId) {
                    console.log(" ".concat(testId, " VS ").concat(context.testId));
                    if (testId == context.testId) {
                        console.log(Date.now() + " Received ".concat(contextType, " for test: ").concat(testId));
                        resolve(context);
                        if (executionListener)
                            executionListener.unsubscribe();
                    }
                    else {
                        console.warn(Date.now() +
                            " Ignoring \"".concat(contextType, "\" context due to mismatched testId (expected: \"").concat(testId, "\", got \"").concat(context.testId, "\")"));
                    }
                }
                else {
                    console.log(Date.now() +
                        " Received (without testId) \"".concat(contextType, "\" for test: \"").concat(testId, "\""));
                    resolve(context);
                    if (executionListener)
                        executionListener.unsubscribe();
                }
            };
            if (channel === undefined) {
                executionListener = fdc3.addContextListener(contextType, handler);
            }
            else {
                console.log("adding listener in waitforcontext");
                executionListener = channel.addContextListener(contextType, handler);
                ccHandler = function (context) { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        if (context) {
                            if (testId) {
                                if (testId == (context === null || context === void 0 ? void 0 : context.testId) && (context === null || context === void 0 ? void 0 : context.type) == contextType) {
                                    console.log(Date.now() +
                                        " Received \"".concat(contextType, "\" (from current context) for test: \"").concat(testId, "\""));
                                    if (executionListener)
                                        executionListener.unsubscribe();
                                    resolve(context);
                                } //do not warn as it will be ignoring mismatches which will be common
                                else {
                                    console.log(Date.now() +
                                        " CHecking for current context of type \"".concat(contextType, "\" for test: \"").concat(testId, "\" Current context did ").concat(context ? "" : "NOT ", " exist,\n            had testId: \"").concat(context === null || context === void 0 ? void 0 : context.testId, "\" (").concat(testId == (context === null || context === void 0 ? void 0 : context.testId) ? "did match" : "did NOT match", ")\n            and type \"").concat(context === null || context === void 0 ? void 0 : context.type, "\" vs ").concat(contextType, " (").concat((context === null || context === void 0 ? void 0 : context.type) == contextType ? "did match" : "did NOT match", ")"));
                                }
                            }
                            else {
                                console.log(Date.now() +
                                    " Received \"".concat(contextType, "\" (from current context) for an unspecified test"));
                                if (executionListener)
                                    executionListener.unsubscribe();
                                resolve(context);
                            }
                        }
                        return [2 /*return*/];
                    });
                }); };
                channel.getCurrentContext().then(ccHandler);
            }
            return [2 /*return*/];
        });
    }); });
};


/***/ }),

/***/ "./src/test/v1.2/advanced/fdc3.raiseIntent.ts":
/*!****************************************************!*\
  !*** ./src/test/v1.2/advanced/fdc3.raiseIntent.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_1_2 */ "../node_modules/fdc3_1_2/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var raiseIntentDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].raiseIntent + "\r\nCause";
/**
 * Details on the mock apps used in these tests can be found in /mock/README.md
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.raiseIntent", function () {
        before(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("fdc3.raiseIntent")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, fdc3.joinChannel("fdc3.raiseIntent")];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        afterEach(function afterEach() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, closeIntentAppsWindows(this.currentTest.title)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
        var test1 = "(SingleResolve1) Should start app intent-b when raising intent 'sharedTestingIntent1' with context 'testContextY'";
        it(test1, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result, intentResolution;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = createReceiver("fdc3-intent-b-opened");
                        console.log("receiver added");
                        return [4 /*yield*/, fdc3.raiseIntent("sharedTestingIntent1", {
                                type: "testContextY",
                            })];
                    case 1:
                        intentResolution = _a.sent();
                        validateIntentResolution("IntentAppB", intentResolution);
                        return [4 /*yield*/, result];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var test2 = "(TargetedResolve1) Should start app intent-a when targeted by raising intent 'aTestingIntent' with context 'testContextX'";
        it(test2, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result, intentResolution;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = createReceiver("fdc3-intent-a-opened");
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextX",
                            }, "IntentAppA")];
                    case 1:
                        intentResolution = _a.sent();
                        validateIntentResolution("IntentAppA", intentResolution);
                        return [4 /*yield*/, result];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var test3 = "(TargetedResolve2) Should start app intent-a when targeted (name) by raising intent 'aTestingIntent' with context 'testContextX'";
        it(test3, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result, intentResolution;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = createReceiver("fdc3-intent-a-opened");
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextX",
                            }, { name: "IntentAppA" })];
                    case 1:
                        intentResolution = _a.sent();
                        validateIntentResolution("IntentAppA", intentResolution);
                        return [4 /*yield*/, result];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var test4 = "(TargetedResolve3) Should start app intent-a when targeted (name and appId) by raising intent 'aTestingIntent' with context 'testContextX'";
        it(test4, function () { return __awaiter(void 0, void 0, void 0, function () {
            var result, intentResolution;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = createReceiver("fdc3-intent-a-opened");
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextX",
                            }, { name: "IntentAppA", appId: "IntentAppAId" })];
                    case 1:
                        intentResolution = _a.sent();
                        validateIntentResolution("IntentAppA", intentResolution);
                        return [4 /*yield*/, result];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var test5 = "(FailedResolve1) Should fail to raise intent when targeted app intent-a, context 'testContextY' and intent 'aTestingIntent' do not correlate";
        it(test5, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextY",
                            }, "IntentAppA")];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Error was not thrown");
                        return [3 /*break*/, 4];
                    case 2:
                        ex_1 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_1).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound);
                        //raise intent so that afterEach resolves
                        return [4 /*yield*/, fdc3.raiseIntent("sharedTestingIntent1", {
                                type: "testContextY",
                            })];
                    case 3:
                        //raise intent so that afterEach resolves
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        var test6 = "(FailedResolve2) Should fail to raise intent when targeted app intent-a (name and appId), context 'testContextY' and intent 'aTestingIntent' do not correlate";
        it(test6, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextY",
                            }, { name: "IntentAppA", appId: "IntentAppAId" })];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Error was not thrown", raiseIntentDocs);
                        return [3 /*break*/, 4];
                    case 2:
                        ex_2 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_2).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, raiseIntentDocs);
                        //raise intent so that afterEach resolves
                        return [4 /*yield*/, fdc3.raiseIntent("sharedTestingIntent1", {
                                type: "testContextY",
                            })];
                    case 3:
                        //raise intent so that afterEach resolves
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        var test7 = "(FailedResolve3) Should fail to raise intent when targeted app intent-a (name), context 'testContextY' and intent 'aTestingIntent' do not correlate";
        it(test7, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextY",
                            }, { name: "IntentAppA" })];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Error was not thrown", raiseIntentDocs);
                        return [3 /*break*/, 4];
                    case 2:
                        ex_3 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_3).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, raiseIntentDocs);
                        //raise intent so that afterEach resolves
                        return [4 /*yield*/, fdc3.raiseIntent("sharedTestingIntent1", {
                                type: "testContextY",
                            })];
                    case 3:
                        //raise intent so that afterEach resolves
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        var test8 = "(FailedResolve4) Should fail to raise intent when targeted app intent-c, context 'testContextX' and intent 'aTestingIntent' do not correlate";
        it(test8, function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", {
                                type: "testContextX",
                            }, "IntentAppC")];
                    case 1:
                        _a.sent();
                        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Error was not thrown", raiseIntentDocs);
                        return [3 /*break*/, 4];
                    case 2:
                        ex_4 = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_4).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, raiseIntentDocs);
                        //raise intent so that afterEach resolves
                        return [4 /*yield*/, fdc3.raiseIntent("sharedTestingIntent1", {
                                type: "testContextY",
                            })];
                    case 3:
                        //raise intent so that afterEach resolves
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
    });
});
var validateIntentResolution = function (appName, intentResolution) {
    if (typeof intentResolution.source === "string") {
        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(intentResolution.source).to.eq(appName, raiseIntentDocs);
    }
    else if (typeof intentResolution.source === "object") {
        (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(intentResolution.source.name).to.eq(appName, raiseIntentDocs);
    }
    else
        chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Invalid intent resolution object");
};
var broadcastCloseWindow = function (currentTest) { return __awaiter(void 0, void 0, void 0, function () {
    var appControlChannel;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
            case 1:
                appControlChannel = _a.sent();
                appControlChannel.broadcast({
                    type: "closeWindow",
                    testId: currentTest,
                });
                return [2 /*return*/];
        }
    });
}); };
// creates a channel and subscribes for broadcast contexts. This is
// used by the 'mock app' to send messages back to the test runner for validation
var createReceiver = function (contextType) {
    var timeout;
    var messageReceived = new Promise(function (resolve, reject) { return __awaiter(void 0, void 0, void 0, function () {
        var listener, _a, sleepPromise, theTimeout;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    listener = fdc3.addContextListener(contextType, function (context) {
                        resolve(context);
                        clearTimeout(timeout);
                        listener.unsubscribe();
                    });
                    _a = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                    timeout = theTimeout;
                    return [4 /*yield*/, sleepPromise];
                case 1:
                    _b.sent();
                    reject(new Error("No context received from app B"));
                    return [2 /*return*/];
            }
        });
    }); });
    return messageReceived;
};
function closeIntentAppsWindows(testId) {
    return __awaiter(this, void 0, void 0, function () {
        var appControlChannel;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, broadcastCloseWindow(testId)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                case 2:
                    appControlChannel = _a.sent();
                    return [4 /*yield*/, waitForContext("windowClosed", testId, appControlChannel)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_4__.wait)(_constants__WEBPACK_IMPORTED_MODULE_3__["default"].WindowCloseWaitTime)];
                case 4:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var waitForContext = function (contextType, testId, channel) {
    var executionListener;
    return new Promise(function (resolve) { return __awaiter(void 0, void 0, void 0, function () {
        var handler, ccHandler;
        return __generator(this, function (_a) {
            console.log(Date.now() +
                " Waiting for type: \"".concat(contextType, "\", on channel: \"").concat(channel.id, "\" in test: \"").concat(testId, "\""));
            handler = function (context) {
                if (testId) {
                    if (testId == context.testId) {
                        console.log(Date.now() + " Received ".concat(contextType, " for test: ").concat(testId));
                        resolve(context);
                        if (executionListener)
                            executionListener.unsubscribe();
                    }
                    else {
                        console.warn(Date.now() +
                            " Ignoring \"".concat(contextType, "\" context due to mismatched testId (expected: \"").concat(testId, "\", got \"").concat(context.testId, "\")"));
                    }
                }
                else {
                    console.log(Date.now() +
                        " Received (without testId) \"".concat(contextType, "\" for test: \"").concat(testId, "\""));
                    resolve(context);
                    if (executionListener)
                        executionListener.unsubscribe();
                }
            };
            if (channel === undefined) {
                executionListener = fdc3.addContextListener(contextType, handler);
            }
            else {
                executionListener = channel.addContextListener(contextType, handler);
                ccHandler = function (context) { return __awaiter(void 0, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        if (context) {
                            if (testId) {
                                if (testId == (context === null || context === void 0 ? void 0 : context.testId) && (context === null || context === void 0 ? void 0 : context.type) == contextType) {
                                    console.log(Date.now() +
                                        " Received \"".concat(contextType, "\" (from current context) for test: \"").concat(testId, "\""));
                                    if (executionListener)
                                        executionListener.unsubscribe();
                                    resolve(context);
                                } //do not warn as it will be ignoring mismatches which will be common
                                else {
                                    console.log(Date.now() +
                                        " CHecking for current context of type \"".concat(contextType, "\" for test: \"").concat(testId, "\" Current context did ").concat(context ? "" : "NOT ", " exist, \nhad testId: \"").concat(context === null || context === void 0 ? void 0 : context.testId, "\" (").concat(testId == (context === null || context === void 0 ? void 0 : context.testId) ? "did match" : "did NOT match", ") \nand type \"").concat(context === null || context === void 0 ? void 0 : context.type, "\" (").concat((context === null || context === void 0 ? void 0 : context.type) == contextType ? "did match" : "did NOT match", ")"));
                                }
                            }
                            else {
                                console.log(Date.now() +
                                    " Received \"".concat(contextType, "\" (from current context) for an unspecified test"));
                                if (executionListener)
                                    executionListener.unsubscribe();
                                resolve(context);
                            }
                        }
                        return [2 /*return*/];
                    });
                }); };
                channel.getCurrentContext().then(ccHandler);
            }
            return [2 /*return*/];
        });
    }); });
};


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.addContextListener.ts":
/*!********************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.addContextListener.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var documentation = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].addContextListener + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.addContextListener", function () {
        var listener;
        afterEach(function () {
            if (listener !== undefined) {
                listener.unsubscribe();
                listener = undefined;
            }
        });
        it("(BasicCL1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var contextType;
            var _a;
            return __generator(this, function (_b) {
                contextType = "fdc3.contact";
                try {
                    listener = fdc3.addContextListener(contextType, function (info) {
                        console.log("Context listener of type ".concat(contextType, " triggered with result ").concat(info));
                    });
                }
                catch (ex) {
                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(documentation + ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
                }
                return [2 /*return*/];
            });
        }); });
        it("(BasicCL2) Returns listener object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                try {
                    listener = fdc3.addContextListener(null, function () { });
                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.isTrue(listener && typeof listener === "object", documentation);
                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof listener.unsubscribe, documentation).to.be.equals("function");
                }
                catch (ex) {
                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(documentation + ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
                }
                return [2 /*return*/];
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.addIntentListener.ts":
/*!*******************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.addIntentListener.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.addIntentListener", function () {
        var listener;
        afterEach(function () {
            if (listener !== undefined) {
                listener.unsubscribe();
                listener = undefined;
            }
        });
        it("(BasicIL1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var intentName;
            var _a;
            return __generator(this, function (_b) {
                intentName = "fdc3.conformanceListener";
                try {
                    listener = fdc3.addIntentListener(intentName, function (info) {
                        console.log("Intent listener for intent ".concat(intentName, " triggered with result ").concat(info));
                    });
                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(listener).to.have.property("unsubscribe").that.is.a("function");
                }
                catch (ex) {
                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("\r\nDocumentation: " +
                        _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].addIntentListener +
                        "\r\nCause" +
                        ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
                }
                return [2 /*return*/];
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.getCurrentChannel.ts":
/*!*******************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.getCurrentChannel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getCurrentChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getCurrentChannel + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getCurrentChannel", function () {
        it("(BasicCH1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 1:
                        channel = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getCurrentChannelDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(BasicCH2) getCurrentChannel() returns null if no channel has been joined", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 1:
                        channel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel).equals(null);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getCurrentChannelDocs + ((_a = ex_2.message) !== null && _a !== void 0 ? _a : ex_2));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.getInfo.ts":
/*!*********************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.getInfo.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getInfoDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getInfo + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getInfo", function () {
        it("(BasicGI1) Returns ImplementationMetadata object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var info;
            var _a;
            return __generator(this, function (_b) {
                try {
                    info = fdc3.getInfo();
                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(info, getInfoDocs).to.have.property("fdc3Version");
                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(info, getInfoDocs).to.have.property("provider");
                }
                catch (ex) {
                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getInfoDocs + ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
                }
                return [2 /*return*/];
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.getOrCreateChannel.ts":
/*!********************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.getOrCreateChannel.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getOrCreateChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getOrCreateChannel + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getOrCreateChannel", function () {
        it("(BasicAC1) Returns Channel object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getOrCreateChannel("FDC3Conformance")];
                    case 1:
                        channel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("id");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("type");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("broadcast");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("getCurrentContext");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("addContextListener");
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getOrCreateChannelDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.getSystemChannels.ts":
/*!*******************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.getSystemChannels.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getSystemChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getSystemChannels + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getSystemChannels", function () {
        it("(BasicUC1) Channel object is valid", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getSystemChannels()];
                    case 1:
                        channels = _a.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channels.length, getSystemChannelDocs).to.be.greaterThan(0);
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof channels).to.be.equals("object", getSystemChannelDocs);
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channels[0]).to.have.property("type");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channels[0]).to.have.property("id");
                        return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.joinChannel.ts":
/*!*************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.joinChannel.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

function wrapPromise() {
    var wrapperResolve;
    var wrapperReject;
    var promise = new Promise(function (resolve, reject) {
        wrapperResolve = resolve;
        wrapperReject = reject;
    });
    return { promise: promise, resolve: wrapperResolve, reject: wrapperReject };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.joinChannel", function () {
        afterEach(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it("(BasicJC1) Can join channel and broadcast", function () { return __awaiter(void 0, void 0, void 0, function () {
            var wrapper, channels, currentChannel, gotContext, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        wrapper = wrapPromise();
                        return [4 /*yield*/, fdc3.getSystemChannels()];
                    case 1:
                        channels = _b.sent();
                        if (!(channels.length > 0)) return [3 /*break*/, 8];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 6, , 7]);
                        return [4 /*yield*/, fdc3.joinChannel(channels[0].id)];
                    case 3:
                        _b.sent();
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 4:
                        currentChannel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(currentChannel).to.not.be.null;
                        gotContext = function (c) {
                            return true;
                        };
                        fdc3.addContextListener("someContext", function (ctx) {
                            if (ctx.type == "someContext") {
                                wrapper.resolve();
                            }
                            else {
                                wrapper.reject("wrong context type");
                            }
                        });
                        currentChannel.broadcast({
                            type: "someContext",
                            id: { name: "hello" },
                        });
                        return [4 /*yield*/, wrapper.promise];
                    case 5:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Error while joining channel: " + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 7];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available");
                        _b.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.leaveCurrentChannel.ts":
/*!*********************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.leaveCurrentChannel.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.leaveCurrentChannel", function () {
        var _a;
        try {
            it("(BasicLC1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
        }
        catch (ex) {
            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("\r\nDocumentation: " +
                _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].leaveCurrentChannel +
                "\r\nCause" +
                ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
        }
    });
});


/***/ }),

/***/ "./src/test/v1.2/basic/fdc3.raiseIntentForContext.ts":
/*!***********************************************************!*\
  !*** ./src/test/v1.2/basic/fdc3.raiseIntentForContext.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_1_2 */ "../node_modules/fdc3_1_2/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var docs = "\r\nDocumentation: " +
    _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].raiseIntentForContext +
    "\r\nCause: ";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.raiseIntentForContext", function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            it("(BasicRI1) Passing an invalid context causes a NoAppsFound error to be thrown", function () { return __awaiter(void 0, void 0, void 0, function () {
                var context, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            context = {
                                type: "ThisContextDoesNotExist",
                            };
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, fdc3.raiseIntentForContext(context)];
                        case 2:
                            _a.sent();
                            chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Expected error NoAppsFound not thrown", docs);
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_1).to.have.property("message", fdc3_1_2__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, docs);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/];
        });
    }); });
});


/***/ }),

/***/ "./src/test/v2.0/advanced/fdc3.broadcast.ts":
/*!**************************************************!*\
  !*** ./src/test/v2.0/advanced/fdc3.broadcast.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var documentation = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].desktopAgent + "\r\nCause:";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.broadcast", function () {
        var listener;
        var listener2;
        var executionListener;
        it("Broadcast method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.broadcast({
                            type: "fdc3.instrument",
                            id: { ticker: "AAPL" },
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        describe("System channels", function () {
            beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, unsubscribeListeners()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            afterEach(function afterEach() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeChannelsAppWindow(this.currentTest.title)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
            var scTestId1 = "(UCBasicUsage1) Should receive context when adding a listener then joining a user channel before app B broadcasts context to the same channel";
            it(scTestId1, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- Add fdc3.instrument context listener to app A\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId1];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 2:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Join user channel 1
                            return [4 /*yield*/, joinChannel(1)];
                        case 3:
                            //Join user channel 1
                            _c.sent();
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId1,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //wait for ChannelsApp to execute
                            _c.sent();
                            //reject if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received" + errorMessage);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId2 = "(UCBasicUsage2) Should receive context when joining a user channel then adding a context listener before app B broadcasts context to the same channel";
            it(scTestId2, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A joins channel 1\r\n- Add listener of type fdc3.instrument to App A\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId2];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            //Join user channel 1
                            return [4 /*yield*/, joinChannel(1)];
                        case 2:
                            //Join user channel 1
                            _c.sent();
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 3:
                            //Add fdc3.instrument context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId2,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId3 = "(UCBasicUsage3) Should receive context when app B joins then broadcasts context to a user channel before A joins and listens on the same channel";
            it(scTestId3, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App B joins channel 1\r\n- App B broadcasts fdc3.instrument context\r\n- App A joins channel 1\r\n- App A adds fdc3.instrument context listener".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId3];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId3,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Join user channel 1
                            return [4 /*yield*/, joinChannel(1)];
                        case 3:
                            //Join user channel 1
                            _c.sent();
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 4:
                            //Add fdc3.instrument context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId4 = "(UCFilteredContext1) Should receive context when app A adds a listener before joining a user channel, then app B broadcasts the listened type to the same user channel";
            it(scTestId4, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument context listener\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId4];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                })];
                        case 2:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Join user channel 1
                            joinChannel(1);
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId4,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId5 = "(UCFilteredContext2) Should receive context when app A joins a user channel before adding a context listener, then app B broadcasts the listened type to the same user channel";
            it(scTestId5, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A joins channel 1\r\n- App A adds fdc3.instrument context listener\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId5];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            //Join user channel 1
                            joinChannel(1);
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                })];
                        case 2:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId5,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //reject if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received" + errorMessage);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId6 = "(UCFilteredContext3) Should receive context when app B broadcasts context to a user channel before A adds a listener of the same type broadcast by B and joins the same user channel";
            it(scTestId6, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument context listener\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId6];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId6,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 3:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                })];
                        case 4:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Join user channel 1
                            joinChannel(1);
                            //reject if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received" + errorMessage);
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId7 = "(UCFilteredContext4) Should receive context when app B broadcasts context to a user channel before A joins the same user channel and adds a listener of the same type that was broadcast by B";
            it(scTestId7, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A joins channel 1\r\n- App A adds fdc3.instrument context listener\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId7];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId7,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 3:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Join user channel 1
                            joinChannel(1);
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                })];
                        case 4:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId8 = "(UCFilteredContext5) Should receive multiple contexts when app B broadcasts the listened types to the same user channel";
            it(scTestId7, function () { return __awaiter(void 0, void 0, void 0, function () {
                function checkIfBothContextsReceived() {
                    if (contextTypes.length === 2) {
                        if (!contextTypes.includes("fdc3.contact") ||
                            !contextTypes.includes("fdc3.instrument")) {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Incorrect context received", errorMessage);
                        }
                        else {
                            receivedContext = true;
                        }
                    }
                }
                var errorMessage, resolveExecutionCompleteListener, _a, _b, contextTypes, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument and fdc3.contact context listener\r\n- App A joins channel 1\r\n- App B joins channel 1\r\n- App B broadcasts both context types".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                scTestId8];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            contextTypes = [];
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    contextTypes.push(context.type);
                                    checkIfBothContextsReceived();
                                })];
                        case 2:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.contact", function (context) {
                                    contextTypes.push(context.type);
                                    checkIfBothContextsReceived();
                                })];
                        case 3:
                            //Add second context listener to app A
                            listener2 = _c.sent();
                            validateListenerObject(listener2);
                            //Join user channel 1
                            return [4 /*yield*/, joinChannel(1)];
                        case 4:
                            //Join user channel 1
                            _c.sent();
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId8,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 5:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 6:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Reject if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " At least one context was not received"));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var scTestId9 = "(UCFilteredContext6) Should not receive context when A & B join different user channels and app B broadcasts a listened type";
            it(scTestId9, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, timeout, channelsAppCommands, channelsAppConfig, _a, sleepPromise, theTimeout;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A adds fdc3.instrument and fdc3.contact context listener\r\n- App A joins channel 2\r\n- App B joins channel 1\r\n- App B broadcasts both context types".concat(documentation);
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                    clearTimeout(timeout);
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 1:
                            //Add fdc3.instrument context listener
                            listener = _b.sent();
                            validateListenerObject(listener);
                            return [4 /*yield*/, fdc3.addContextListener("fdc3.contact", function (context) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 2:
                            //Add fdc3.contact context listener
                            listener2 = _b.sent();
                            validateListenerObject(listener2);
                            //ChannelsApp joins channel 2
                            return [4 /*yield*/, joinChannel(2)];
                        case 3:
                            //ChannelsApp joins channel 2
                            _b.sent();
                            channelsAppCommands = [
                                commands.joinUserChannelOne,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: scTestId9,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _b.sent();
                            _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                            timeout = theTimeout;
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        var scTestId10 = "(UCFilteredContext7) Should not receive context when unsubscribing a user channel before app B broadcasts the listened type to that channel";
        it(scTestId10, function () { return __awaiter(void 0, void 0, void 0, function () {
            var errorMessage, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A unsubscribes the listener\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                        _a = waitForContext;
                        _b = ["executionComplete",
                            scTestId10];
                        return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                    case 1:
                        resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                        return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            })];
                    case 2:
                        //Add fdc3.instrument context listener
                        listener = _c.sent();
                        validateListenerObject(listener);
                        //Join user channel 1
                        return [4 /*yield*/, joinChannel(1)];
                    case 3:
                        //Join user channel 1
                        _c.sent();
                        if (!(listener !== undefined)) return [3 /*break*/, 5];
                        return [4 /*yield*/, listener.unsubscribe()];
                    case 4:
                        _c.sent();
                        listener = undefined;
                        return [3 /*break*/, 6];
                    case 5:
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Listener undefined", errorMessage);
                        _c.label = 6;
                    case 6:
                        channelsAppCommands = [
                            commands.joinUserChannelOne,
                            commands.broadcastInstrumentContext,
                        ];
                        channelsAppConfig = {
                            fdc3ApiVersion: "2.0",
                            testId: scTestId10,
                            notifyAppAOnCompletion: true,
                        };
                        //Open ChannelsApp then execute commands in order
                        return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                    case 7:
                        //Open ChannelsApp then execute commands in order
                        _c.sent();
                        //Wait for ChannelsApp to execute
                        return [4 /*yield*/, resolveExecutionCompleteListener];
                    case 8:
                        //Wait for ChannelsApp to execute
                        _c.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var scTestId11 = "(UCFilteredContext8) Should not receive context when joining two different user channels before app B broadcasts the listened type to the first channel that was joined";
        it(scTestId11, function () { return __awaiter(void 0, void 0, void 0, function () {
            var errorMessage, timeout, channelsAppCommands, channelsAppConfig, _a, sleepPromise, theTimeout;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A joins channel 2\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                        return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                    return [2 /*return*/];
                                });
                            }); })];
                    case 1:
                        //Add fdc3.instrument context listener
                        listener = _b.sent();
                        //ChannelsApp joins a channel and then joins another
                        return [4 /*yield*/, joinChannel(1)];
                    case 2:
                        //ChannelsApp joins a channel and then joins another
                        _b.sent();
                        return [4 /*yield*/, joinChannel(2)];
                    case 3:
                        _b.sent();
                        channelsAppCommands = [
                            commands.joinUserChannelOne,
                            commands.broadcastInstrumentContext,
                        ];
                        channelsAppConfig = {
                            fdc3ApiVersion: "2.0",
                            testId: scTestId11,
                        };
                        //Open ChannelsApp then execute commands in order
                        return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                    case 4:
                        //Open ChannelsApp then execute commands in order
                        _b.sent();
                        _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                        timeout = theTimeout;
                        return [4 /*yield*/, sleepPromise];
                    case 5:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        var scTestId12 = "(UCFilteredContext9) Should not receive context when joining and then leaving a user channel before app B broadcasts the listened type to the same channel";
        it(scTestId12, function () { return __awaiter(void 0, void 0, void 0, function () {
            var errorMessage, timeout, channelsAppCommands, channelsAppConfig, _a, sleepPromise, theTimeout;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        errorMessage = "\r\nSteps to reproduce:\r\n- App A adds context listener of type fdc3.instrument\r\n- App A joins channel 1\r\n- App A leaves channel 1\r\n- App B joins channel 1\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                        return [4 /*yield*/, fdc3.addContextListener("fdc3.instrument", function (context) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                            })];
                    case 1:
                        //Add a context listeners to app A
                        listener = _b.sent();
                        validateListenerObject(listener);
                        //Join user channel 1
                        return [4 /*yield*/, joinChannel(1)];
                    case 2:
                        //Join user channel 1
                        _b.sent();
                        //App A leaves channel 1
                        return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                    case 3:
                        //App A leaves channel 1
                        _b.sent();
                        channelsAppCommands = [
                            commands.joinUserChannelOne,
                            commands.broadcastInstrumentContext,
                        ];
                        channelsAppConfig = {
                            fdc3ApiVersion: "2.0",
                            testId: scTestId12,
                            notifyAppAOnCompletion: true,
                        };
                        //Open ChannelsApp then execute commands in order
                        return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                    case 4:
                        //Open ChannelsApp then execute commands in order
                        _b.sent();
                        _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                        timeout = theTimeout;
                        return [4 /*yield*/, sleepPromise];
                    case 5:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        describe("App channels", function () {
            beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, unsubscribeListeners()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            afterEach(function afterEach() {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, closeChannelsAppWindow(this.currentTest.title)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
            var acTestId = "(ACBasicUsage1) Should receive context when app a adds a listener and app B broadcasts to the same app channel";
            it(acTestId, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, testChannel, receivedContext, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds adds a context listener of type null\r\n- App B retrieves the same app channel as A\r\n- App B broadcasts context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 2:
                            testChannel = _c.sent();
                            receivedContext = false;
                            return [4 /*yield*/, testChannel.addContextListener(null, function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 3:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("At least one context was not received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId2 = "(ACBasicUsage2) Should receive context when app B broadcasts context to an app channel before A retrieves current context";
            it(acTestId2, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, testChannel, channelsAppCommands, channelsAppConfig, receivedContext;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A & B retrieve the same app channel\r\n- App B broadcasts context of type fdc3.instrument\r\n- App A retrieves current context of type null".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId2];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 2:
                            testChannel = _c.sent();
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId2,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            receivedContext = false;
                            //Retrieve current context from channel
                            return [4 /*yield*/, testChannel.getCurrentContext().then(function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                        receivedContext = true;
                                        return [2 /*return*/];
                                    });
                                }); })];
                        case 4:
                            //Retrieve current context from channel
                            _c.sent();
                            //Wait for ChannelsApp the finish executing
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp the finish executing
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId4 = "(ACFilteredContext1) Should only receive the listened context when app B broadcasts multiple contexts to the same app channel";
            it(acTestId4, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, receivedContext, testChannel, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves the same app channel as A\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId4];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            receivedContext = false;
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 2:
                            testChannel = _c.sent();
                            return [4 /*yield*/, testChannel.addContextListener("fdc3.instrument", function (context) {
                                    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                                    receivedContext = true;
                                })];
                        case 3:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId4,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            //Fail if no context received
                            if (!receivedContext) {
                                chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No context received!\n".concat(errorMessage));
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId7 = "(ACFilteredContext2) Should not receive context when app B broadcasts context to a different app channel";
            it(acTestId7, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, timeout, testChannel, channelsAppCommands, channelsAppConfig, _a, sleepPromise, theTimeout;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves a different app channel\r\n- App B broadcasts a context of type fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("a-different-test-channel")];
                        case 1:
                            testChannel = _b.sent();
                            return [4 /*yield*/, testChannel.addContextListener("fdc3.instrument", function (context) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 2:
                            //Add context listener
                            listener = _b.sent();
                            validateListenerObject(listener);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId7,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp then execute commands in order
                            _b.sent();
                            _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                            timeout = theTimeout;
                            return [4 /*yield*/, sleepPromise];
                        case 4:
                            _b.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId6 = "(ACUnsubscribe) Should not receive context when unsubscribing an app channel before app B broadcasts to that channel";
            it(acTestId6, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A adds a context listener of type null\r\n- App A unsubscribes the app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId6];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, testChannel.addContextListener(null, function (context) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 3:
                            //Add context listener
                            listener = _c.sent();
                            validateListenerObject(listener);
                            //Unsubscribe from app channel
                            listener.unsubscribe();
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId6,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 4:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 5:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId10 = "(ACFilteredContext3) Should not receive context when retrieving two different app channels before app B broadcasts the listened type to the first channel that was retrieved";
            it(acTestId10, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, resolveExecutionCompleteListener, _a, _b, testChannel, testChannel2, channelsAppCommands, channelsAppConfig;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App A switches to a different app channel\r\n- App A adds a context listener of type fdc3.instrument\r\n- App B retrieves the first channel that A retrieved\r\n- App B broadcasts a context of type fdc3.instrument".concat(documentation);
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId10];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 2:
                            testChannel = _c.sent();
                            return [4 /*yield*/, testChannel.addContextListener("fdc3.instrument", function (context) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 3:
                            listener = _c.sent();
                            validateListenerObject(listener);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("a-different-test-channel")];
                        case 4:
                            testChannel2 = _c.sent();
                            return [4 /*yield*/, testChannel2.addContextListener("fdc3.instrument", function (context) {
                                    chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("".concat(errorMessage, " ").concat(context.type, " context received"));
                                })];
                        case 5:
                            //Add context listener
                            listener2 = _c.sent();
                            validateListenerObject(listener2);
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId10,
                                notifyAppAOnCompletion: true,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsAppId" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 6:
                            //Open ChannelsApp then execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 7:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId11 = "(ACContextHistoryTyped) Should receive both contexts when app B broadcasts both contexts to the same app channel and A gets current context for each type";
            it(acTestId11, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, channelsAppCommands, channelsAppConfig, context, contactContext, contextLatest;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts a context of type fdc3.instrument and fdc3.contact\r\n- App A gets current context for types fdc3.instrument and fdc3.contact".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _a.sent();
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId11,
                            };
                            //Open ChannelsApp then execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsApp" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 2:
                            //Open ChannelsApp then execute commands in order
                            _a.sent();
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.instrument")];
                        case 3:
                            context = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.name).to.be.equals("History-item-1", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.contact")];
                        case 4:
                            contactContext = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(contactContext.name).to.be.equals("History-item-1", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext()];
                        case 5:
                            contextLatest = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(contextLatest.type).to.be.equals("fdc3.contact", errorMessage);
                            return [2 /*return*/];
                    }
                });
            }); });
            var acTestId13 = "(ACContextHistoryMultiple) Should retrieve the last broadcast context item when app B broadcasts a context with multiple history items to the same app channel and A gets current context";
            it(acTestId13, function () { return __awaiter(void 0, void 0, void 0, function () {
                var errorMessage, testChannel, resolveExecutionCompleteListener, _a, _b, channelsAppCommands, channelsAppConfig, context, context2, contextLatest;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            errorMessage = "\r\nSteps to reproduce:\r\n- App A retrieves an app channel\r\n- App B retrieves the same app channel\r\n- App B broadcasts two different contexts of type fdc3.instrument\r\n- App A gets current context for types fdc3.instrument".concat(documentation);
                            return [4 /*yield*/, fdc3.getOrCreateChannel("test-channel")];
                        case 1:
                            testChannel = _c.sent();
                            _a = waitForContext;
                            _b = ["executionComplete",
                                acTestId13];
                            return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 2:
                            resolveExecutionCompleteListener = _a.apply(void 0, _b.concat([_c.sent()]));
                            channelsAppCommands = [
                                commands.retrieveTestAppChannel,
                                commands.broadcastInstrumentContext,
                                commands.broadcastContactContext,
                            ];
                            channelsAppConfig = {
                                fdc3ApiVersion: "2.0",
                                testId: acTestId13,
                                notifyAppAOnCompletion: true,
                                historyItems: 2,
                            };
                            //Open ChannelsApp and execute commands in order
                            return [4 /*yield*/, fdc3.open({ appId: "ChannelsApp" }, buildChannelsAppContext(channelsAppCommands, channelsAppConfig))];
                        case 3:
                            //Open ChannelsApp and execute commands in order
                            _c.sent();
                            //Wait for ChannelsApp to execute
                            return [4 /*yield*/, resolveExecutionCompleteListener];
                        case 4:
                            //Wait for ChannelsApp to execute
                            _c.sent();
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.instrument")];
                        case 5:
                            context = _c.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.type).to.be.equals("fdc3.instrument", errorMessage);
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.name).to.be.equals("History-item-2", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext("fdc3.contact")];
                        case 6:
                            context2 = _c.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context2.type).to.be.equals("fdc3.contact", errorMessage);
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context2.name).to.be.equals("History-item-2", errorMessage);
                            return [4 /*yield*/, testChannel.getCurrentContext()];
                        case 7:
                            contextLatest = _c.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(contextLatest.type).to.be.equals("fdc3.contact", errorMessage);
                            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(contextLatest.name).to.be.equals("History-item-2", errorMessage);
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        var joinChannel = function (channel) { return __awaiter(void 0, void 0, void 0, function () {
            var channels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getUserChannels()];
                    case 1:
                        channels = _a.sent();
                        if (!(channels.length > 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, fdc3.joinUserChannel(channels[channel - 1].id)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available for app A");
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        function validateListenerObject(listenerObject) {
            chai__WEBPACK_IMPORTED_MODULE_0__.assert.isTrue(typeof listenerObject === "object", "No listener object found");
            (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof listenerObject.unsubscribe).to.be.equals("function", "Listener does not contain an unsubscribe method");
        }
        function closeChannelsAppWindow(testId) {
            return __awaiter(this, void 0, void 0, function () {
                var appControlChannel;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, broadcastAppChannelCloseWindow(testId)];
                        case 1:
                            appControlChannel = _a.sent();
                            //Wait for ChannelsApp to respond
                            return [4 /*yield*/, waitForContext("windowClosed", testId, appControlChannel)];
                        case 2:
                            //Wait for ChannelsApp to respond
                            _a.sent();
                            return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)(_constants__WEBPACK_IMPORTED_MODULE_1__["default"].WindowCloseWaitTime)];
                        case 3:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        var broadcastAppChannelCloseWindow = function (testId) { return __awaiter(void 0, void 0, void 0, function () {
            var appControlChannel, closeContext;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                    case 1:
                        appControlChannel = _a.sent();
                        closeContext = {
                            type: "closeWindow",
                            testId: testId,
                        };
                        return [4 /*yield*/, appControlChannel.broadcast(closeContext)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, appControlChannel];
                }
            });
        }); };
        function unsubscribeListeners() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(listener !== undefined)) return [3 /*break*/, 2];
                            return [4 /*yield*/, listener.unsubscribe()];
                        case 1:
                            _a.sent();
                            listener = undefined;
                            _a.label = 2;
                        case 2:
                            if (!(listener2 !== undefined)) return [3 /*break*/, 4];
                            return [4 /*yield*/, listener2.unsubscribe()];
                        case 3:
                            _a.sent();
                            listener2 = undefined;
                            _a.label = 4;
                        case 4:
                            if (!(executionListener != undefined)) return [3 /*break*/, 6];
                            return [4 /*yield*/, executionListener.unsubscribe()];
                        case 5:
                            _a.sent();
                            executionListener = undefined;
                            _a.label = 6;
                        case 6: return [2 /*return*/];
                    }
                });
            });
        }
        var waitForContext = function (contextType, testId, channel) {
            var executionListener;
            return new Promise(function (resolve) { return __awaiter(void 0, void 0, void 0, function () {
                var handler, ccHandler;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            console.log(Date.now() +
                                " Waiting for type: \"".concat(contextType, "\", on channel: \"").concat(channel.id, "\" in test: \"").concat(testId, "\""));
                            handler = function (context) {
                                if (testId) {
                                    if (testId == context.testId) {
                                        console.log(Date.now() + " Received ".concat(contextType, " for test: ").concat(testId));
                                        resolve(context);
                                        if (executionListener)
                                            executionListener.unsubscribe();
                                    }
                                    else {
                                        console.warn(Date.now() +
                                            " Ignoring \"".concat(contextType, "\" context due to mismatched testId (expected: \"").concat(testId, "\", got \"").concat(context.testId, "\")"));
                                    }
                                }
                                else {
                                    console.log(Date.now() +
                                        " Received (without testId) \"".concat(contextType, "\" for test: \"").concat(testId, "\""));
                                    resolve(context);
                                    if (executionListener)
                                        executionListener.unsubscribe();
                                }
                            };
                            if (!(channel === undefined)) return [3 /*break*/, 2];
                            return [4 /*yield*/, fdc3.addContextListener(contextType, handler)];
                        case 1:
                            executionListener = _a.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, channel.addContextListener(contextType, handler)];
                        case 3:
                            executionListener = _a.sent();
                            ccHandler = function (context) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    if (context) {
                                        if (testId) {
                                            if (testId == (context === null || context === void 0 ? void 0 : context.testId) && (context === null || context === void 0 ? void 0 : context.type) == contextType) {
                                                console.log(Date.now() +
                                                    " Received \"".concat(contextType, "\" (from current context) for test: \"").concat(testId, "\""));
                                                if (executionListener)
                                                    executionListener.unsubscribe();
                                                resolve(context);
                                            } //do not warn as it will be ignoring mismatches which will be common
                                            else {
                                                console.log(Date.now() +
                                                    " CHecking for current context of type \"".concat(contextType, "\" for test: \"").concat(testId, "\" Current context did ").concat(context ? "" : "NOT ", " exist, \n    had testId: \"").concat(context === null || context === void 0 ? void 0 : context.testId, "\" (").concat(testId == (context === null || context === void 0 ? void 0 : context.testId)
                                                        ? "did match"
                                                        : "did NOT match", ") \n    and type \"").concat(context === null || context === void 0 ? void 0 : context.type, "\" (").concat((context === null || context === void 0 ? void 0 : context.type) == contextType
                                                        ? "did match"
                                                        : "did NOT match", ")"));
                                            }
                                        }
                                        else {
                                            console.log(Date.now() +
                                                " Received \"".concat(contextType, "\" (from current context) for an unspecified test"));
                                            if (executionListener)
                                                executionListener.unsubscribe();
                                            resolve(context);
                                        }
                                    }
                                    return [2 /*return*/];
                                });
                            }); };
                            channel.getCurrentContext().then(ccHandler);
                            _a.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
        };
    });
});
function buildChannelsAppContext(mockAppCommands, config) {
    var _a, _b;
    return {
        type: "channelsAppContext",
        commands: mockAppCommands,
        config: {
            fdc3ApiVersion: config.fdc3ApiVersion,
            testId: config.testId,
            notifyAppAOnCompletion: (_a = config.notifyAppAOnCompletion) !== null && _a !== void 0 ? _a : false,
            historyItems: (_b = config.historyItems) !== null && _b !== void 0 ? _b : 1,
        },
    };
}
var commands = {
    joinUserChannelOne: "joinUserChannelOne",
    retrieveTestAppChannel: "retrieveTestAppChannel",
    broadcastInstrumentContext: "broadcastInstrumentContext",
    broadcastContactContext: "broadcastContactContext",
};


/***/ }),

/***/ "./src/test/v2.0/advanced/fdc3.findInstances.ts":
/*!******************************************************!*\
  !*** ./src/test/v2.0/advanced/fdc3.findInstances.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetadataAppCommand": () => (/* binding */ MetadataAppCommand),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var findInstancesDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].findInstances + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.findInstances", function () {
        afterEach(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, broadcastCloseWindow()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, waitForMockAppToClose()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-FindInstances) valid metadata", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIdentifier_1, appIdentifier2, instances, timeout_1, wrapper_1, metadataAppContext, resolution, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 8, , 9]);
                        return [4 /*yield*/, fdc3.open({
                                appId: "MetadataAppId",
                            })];
                    case 1:
                        appIdentifier_1 = _b.sent();
                        return [4 /*yield*/, fdc3.open({
                                appId: "MetadataAppId",
                            })];
                    case 2:
                        appIdentifier2 = _b.sent();
                        //confirm that the instanceId for both app instantiations is different
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier_1.instanceId, "The AppIdentifier's instanceId property for both instances of the opened app should not be the same.".concat(findInstancesDocs)).to.not.equal(appIdentifier2.instanceId);
                        return [4 /*yield*/, fdc3.findInstances({ appId: "MetadataAppId" })];
                    case 3:
                        instances = _b.sent();
                        if (!instances.includes(appIdentifier_1) ||
                            !instances.includes(appIdentifier2)) {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("At least one AppIdentifier object is missing from the AppIdentifier array returned after calling fdc3.findInstances(app: AppIdentifier)".concat(findInstancesDocs));
                        }
                        wrapper_1 = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wrapPromise)();
                        //ensure appIdentifier received the raised intent
                        return [4 /*yield*/, fdc3.addContextListener("metadataContext", function (context) {
                                clearTimeout(timeout_1);
                                (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(context.contextMetadata.source, "ContextMetadata.source did not match the AppIdentifier of the first mock app that was opened").to.be.equals(appIdentifier_1);
                                wrapper_1.resolve();
                            })];
                    case 4:
                        //ensure appIdentifier received the raised intent
                        _b.sent();
                        metadataAppContext = {
                            type: "metadataAppContext",
                            command: MetadataAppCommand.confirmRaisedIntentReceived,
                        };
                        return [4 /*yield*/, fdc3.raiseIntent("aTestingIntent", metadataAppContext, appIdentifier_1)];
                    case 5:
                        resolution = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(resolution.source, "IntentResolution.source did not match the mock app's AppIdentifier").to.be.equal(appIdentifier_1);
                        return [4 /*yield*/, window.setTimeout(function () {
                                wrapper_1.reject("did not receive MetadataContext from metadata app");
                            }, _constants__WEBPACK_IMPORTED_MODULE_2__["default"].WaitTime)];
                    case 6:
                        //fail if no metadataContext received
                        timeout_1 = _b.sent();
                        //wait for raised intent
                        return [4 /*yield*/, wrapper_1.promise];
                    case 7:
                        //wait for raised intent
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(findInstancesDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 9];
                    case 9: return [2 /*return*/];
                }
            });
        }); });
    });
});
function waitForMockAppToClose() {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, messageReceived;
        var _this = this;
        return __generator(this, function (_a) {
            messageReceived = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                var appControlChannel, listener, _a, sleepPromise, theTimeout;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            appControlChannel = _b.sent();
                            return [4 /*yield*/, appControlChannel.addContextListener("windowClosed", function (context) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wait)(_constants__WEBPACK_IMPORTED_MODULE_2__["default"].WindowCloseWaitTime)];
                                            case 1:
                                                _a.sent();
                                                resolve(context);
                                                listener.unsubscribe();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            listener = _b.sent();
                            _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                            timeout = theTimeout;
                            return [4 /*yield*/, sleepPromise];
                        case 3:
                            _b.sent();
                            reject(new Error("windowClosed context not received from app B"));
                            return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/, messageReceived];
        });
    });
}
var broadcastCloseWindow = function () { return __awaiter(void 0, void 0, void 0, function () {
    var appControlChannel;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
            case 1:
                appControlChannel = _a.sent();
                return [4 /*yield*/, appControlChannel.broadcast({ type: "closeWindow" })];
            case 2:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var MetadataAppCommand;
(function (MetadataAppCommand) {
    MetadataAppCommand["sendGetInfoMetadataToTests"] = "sendGetInfoMetadataToTests";
    MetadataAppCommand["confirmRaisedIntentReceived"] = "confirmRaisedIntentReceived";
})(MetadataAppCommand || (MetadataAppCommand = {}));


/***/ }),

/***/ "./src/test/v2.0/advanced/fdc3.getAppMetadata.ts":
/*!*******************************************************!*\
  !*** ./src/test/v2.0/advanced/fdc3.getAppMetadata.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "validateAppMetadata": () => (/* binding */ validateAppMetadata)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var getMetadataDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].appMetadata + "\r\nCause: ";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getAppMetadata", function () {
        after(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, broadcastCloseWindow()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, waitForMockAppToClose()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it("Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getAppMetadata({
                                appId: "MetadataAppId",
                            })];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getMetadataDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(GetAppMetadata) Valid metadata object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var metadata, ex_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getAppMetadata({ appId: "MetadataAppId" })];
                    case 1:
                        metadata = _b.sent();
                        validateAppMetadata(metadata);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getMetadataDocs + ((_a = ex_2.message) !== null && _a !== void 0 ? _a : ex_2));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-AppInstanceMetadata) App instance metadata is valid", function () { return __awaiter(void 0, void 0, void 0, function () {
            var appIdentifier1, appIdentifier2, metadata1, metadata2, ex_3;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, fdc3.open({ appId: "MetadataAppId" })];
                    case 1:
                        appIdentifier1 = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier1, "The AppIdentifier object retrieved after calling fdc3.open() should contain an appId property.".concat(getMetadataDocs)).to.have.property("appId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier1, "The AppIdentifier object retrieved after calling fdc3.open() should contain an instanceId property.".concat(getMetadataDocs)).to.have.property("instanceId");
                        if (typeof appIdentifier1.instanceId !== "string") {
                            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("The instanceId property is not of type string");
                        }
                        return [4 /*yield*/, fdc3.open({ appId: "MetadataAppId" })];
                    case 2:
                        appIdentifier2 = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier2, "The AppIdentifier object retrieved after calling fdc3.open() should contain an appId property.".concat(getMetadataDocs)).to.have.property("appId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier2, "The AppIdentifier object retrieved after calling fdc3.open() should contain an instanceId property.".concat(getMetadataDocs)).to.have.property("instanceId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof appIdentifier2.instanceId, "The AppIdentifier.instanceId property should be of type string. Got ".concat(typeof appIdentifier2.instanceId)).to.be.equal("string");
                        //check instanceId is different for both instantiations of the app
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier1.instanceId, "The AppIdentifier's instanceId property for both instances of the opened app should not be the same.".concat(getMetadataDocs)).to.not.equal(appIdentifier2.instanceId);
                        return [4 /*yield*/, fdc3.getAppMetadata(appIdentifier1)];
                    case 3:
                        metadata1 = _b.sent();
                        validateAppMetadata(metadata1);
                        //check that metadata instanceId is the same as the appIdentifyer instanceId
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata1.instanceId, "The AppMetaData's instanceId property that was retrieved when calling open() does not match AppIdentifier's instanceId property that was retrieved when calling getAppMetadata() for the same app instance").to.be.equal(appIdentifier1.instanceId);
                        return [4 /*yield*/, fdc3.getAppMetadata(appIdentifier2)];
                    case 4:
                        metadata2 = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata2, "The AppIdentifier object retrieved after calling fdc3.open() should contain an instanceId property.".concat(getMetadataDocs)).to.have.property("instanceId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata2.instanceId, "The AppMetaData's instanceId property retrieved when calling open() does not match AppIdentifier's instanceId property retrieved when calling getAppMetadata() for the same app").to.be.equal(appIdentifier2.instanceId);
                        return [3 /*break*/, 6];
                    case 5:
                        ex_3 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getMetadataDocs + ((_a = ex_3.message) !== null && _a !== void 0 ? _a : ex_3));
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        }); });
    });
});
function waitForMockAppToClose() {
    return __awaiter(this, void 0, void 0, function () {
        var timeout, messageReceived;
        var _this = this;
        return __generator(this, function (_a) {
            messageReceived = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                var appControlChannel, listener, _a, sleepPromise, theTimeout;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                        case 1:
                            appControlChannel = _b.sent();
                            return [4 /*yield*/, appControlChannel.addContextListener("windowClosed", function (context) {
                                    resolve(context);
                                    clearTimeout(timeout);
                                    listener.unsubscribe();
                                })];
                        case 2:
                            listener = _b.sent();
                            _a = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                            timeout = theTimeout;
                            return [4 /*yield*/, sleepPromise];
                        case 3:
                            _b.sent();
                            reject(new Error("windowClosed context not received from app B"));
                            return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/, messageReceived];
        });
    });
}
function validateAppMetadata(metadata) {
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no name property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("name");
    if (typeof metadata.name !== "string") {
        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Incorrect type detected for AppMetadata.name. Expected a string, got ".concat(typeof metadata.name));
    }
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no version property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("version");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof metadata.version, "Incorrect type detected for AppMetadata.version. Expected a string, got ".concat(typeof metadata.version)).to.be.equal("string");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no title property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("title");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof metadata.title, "Incorrect type detected for AppMetadata.title. Expected a string, got ".concat(typeof metadata.title)).to.be.equal("string");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no tooltip property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("tooltip");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof metadata.tooltip, "Incorrect type detected for AppMetadata.tooltip. Expected a string, got ".concat(typeof metadata.tooltip)).to.be.equal("string");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no description property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("description");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof metadata.description, "Incorrect type detected for AppMetadata.description. Expected a string, got ".concat(typeof metadata.description)).to.be.equal("string");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, "no icons property found on AppMetadata object".concat(getMetadataDocs)).to.have.property("icons");
    if (!Array.isArray(metadata.icons)) {
        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Incorrect type detected for AppMetadata.icons. Expected an Array, got ".concat(typeof metadata.description));
    }
    //ensure icons property contains an array of objects
    var isObjectArray = isArrayOfObjects(metadata.icons);
    if (!isObjectArray)
        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("AppMetadata.icons should contain an Array of objects");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(metadata, getMetadataDocs).to.have.property("screenshots");
    (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof metadata.screenshots, "Incorrect type detected for AppMetadata.screenshots. Expected an Array, got ".concat(typeof metadata.description)).to.be.equal("Array");
    //ensure screenshots property contains an array of objects
    var isObjectArray2 = isArrayOfObjects(metadata.screenshots);
    if (!isObjectArray2)
        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("AppMetadata.screenshots should contain an Array of objects");
}
var broadcastCloseWindow = function () { return __awaiter(void 0, void 0, void 0, function () {
    var appControlChannel;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
            case 1:
                appControlChannel = _a.sent();
                return [4 /*yield*/, appControlChannel.broadcast({ type: "closeWindow" })];
            case 2:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var isArrayOfObjects = function (array) {
    return (array.length > 0 &&
        array.screenshots.every(function (value) {
            return typeof value === "object";
        }));
};


/***/ }),

/***/ "./src/test/v2.0/advanced/fdc3.getInfo.ts":
/*!************************************************!*\
  !*** ./src/test/v2.0/advanced/fdc3.getInfo.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ "./src/constants.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils */ "./src/utils.ts");
/* harmony import */ var fdc3_2_0__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fdc3_2_0 */ "../node_modules/fdc3_2_0/dist/fdc3.esm.js");
/* harmony import */ var _fdc3_getAppMetadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fdc3.getAppMetadata */ "./src/test/v2.0/advanced/fdc3.getAppMetadata.ts");
/* harmony import */ var _fdc3_findInstances__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fdc3.findInstances */ "./src/test/v2.0/advanced/fdc3.findInstances.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var getInfoDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getInfo2_0 + "\r\nCause";
var getMetadataDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].appMetadata + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getInfo", function () {
        after(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, broadcastCloseWindow()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, waitForMockAppToClose()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it("Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getInfo()];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("\r\nDocumentation: " +
                            _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getInfo +
                            "\r\nCause" +
                            ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-GetInfo1) Returns a valid ImplementationMetadata object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var implMetadata, ex_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getInfo()];
                    case 1:
                        implMetadata = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata, "ImplementationMetadata did not have property fdc3Version".concat(getInfoDocs)).to.have.property("fdc3Version");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(parseFloat(implMetadata.fdc3Version)).to.be.greaterThanOrEqual(2);
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata, "ImplementationMetadata did not have property provider".concat(getInfoDocs)).to.have.property("provider");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.provider).to.not.be.equal("");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.optionalFeatures, "ImplementationMetadata.optionalFeatures did not have property OriginatingAppMetadata".concat(getInfoDocs)).to.have.property("OriginatingAppMetadata");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.optionalFeatures, "ImplementationMetadata.optionalFeatures did not have property UserChannelMembershipAPIs".concat(getInfoDocs)).to.have.property("UserChannelMembershipAPIs");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof implMetadata.optionalFeatures.OriginatingAppMetadata, "ImplementationMetadata.optionalFeatures.OriginatingAppMetadata should be of type boolean").to.be.equal("boolean");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof implMetadata.optionalFeatures.UserChannelMembershipAPIs, "ImplementationMetadata.optionalFeatures.UserChannelMembershipAPIs should be of type boolean").to.be.equal("boolean");
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getInfoDocs + ((_a = ex_2.message) !== null && _a !== void 0 ? _a : ex_2));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-GetInfo2) Returns a valid ImplementationMetadata object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var implMetadata, appControlChannel, metadataAppContext, timeout, wrapper, appIdentifier, metadata;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log("startstart");
                        return [4 /*yield*/, (0,fdc3_2_0__WEBPACK_IMPORTED_MODULE_4__.getOrCreateChannel)("app-control")];
                    case 1:
                        appControlChannel = _a.sent();
                        metadataAppContext = {
                            type: "metadataAppContext",
                            command: _fdc3_findInstances__WEBPACK_IMPORTED_MODULE_6__.MetadataAppCommand.sendGetInfoMetadataToTests,
                        };
                        wrapper = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.wrapPromise)();
                        appControlChannel.addContextListener("metadataContext", function (context) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                implMetadata = context.implMetadata;
                                wrapper.resolve();
                                clearTimeout(timeout);
                                return [2 /*return*/];
                            });
                        }); });
                        return [4 /*yield*/, fdc3.open({ appId: "MetadataAppId" }, metadataAppContext)];
                    case 2:
                        appIdentifier = _a.sent();
                        return [4 /*yield*/, window.setTimeout(function () {
                                wrapper.reject("did not receive MetadataContext from metadata app");
                            }, _constants__WEBPACK_IMPORTED_MODULE_2__["default"].WaitTime)];
                    case 3:
                        //fail if no metadataContext received
                        timeout = _a.sent();
                        //wait for listener to receive context
                        return [4 /*yield*/, wrapper.promise];
                    case 4:
                        //wait for listener to receive context
                        _a.sent();
                        //validate AppIdentifier
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier, "AppIdentifier did not have property appId".concat(getInfoDocs)).to.have.property("appId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(appIdentifier, "AppIdentifier did not have property instanceId".concat(getInfoDocs)).to.have.property("instanceId");
                        //validate ImplementationMetadata
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata, "ImplementationMetadata did not have property appMetadata".concat(getInfoDocs)).to.have.property("appMetadata");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.appMetadata, "ImplementationMetadata did not have property appId".concat(getInfoDocs)).to.have.property("appId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.appMetadata, "ImplementationMetadata did not have property instanceId".concat(getInfoDocs)).to.have.property("instanceId");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.appMetadata.appId, "ImplementationMetadata.appMetadata.appId did not match the ApplicationIdentifier.appId retrieved from the opened app").to.be.equal(appIdentifier.appId);
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(implMetadata.appMetadata.instanceId, "ImplementationMetadata.appMetadata.instanceId did not match the ApplicationIdentifier.instanceId retrieved from the opened app").to.be.equal(appIdentifier.instanceId);
                        console.log("validating");
                        return [4 /*yield*/, fdc3.getAppMetadata(appIdentifier)];
                    case 5:
                        metadata = _a.sent();
                        console.log(JSON.stringify(metadata));
                        (0,_fdc3_getAppMetadata__WEBPACK_IMPORTED_MODULE_5__.validateAppMetadata)(metadata);
                        console.log("vefore cleartimeout");
                        return [2 /*return*/];
                }
            });
        }); });
        function waitForMockAppToClose() {
            return __awaiter(this, void 0, void 0, function () {
                var timeout, messageReceived;
                var _this = this;
                return __generator(this, function (_a) {
                    messageReceived = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var appControlChannel, listener, _a, sleepPromise, theTimeout;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                                case 1:
                                    appControlChannel = _b.sent();
                                    return [4 /*yield*/, appControlChannel.addContextListener("windowClosed", function (context) {
                                            resolve(context);
                                            clearTimeout(timeout);
                                            listener.unsubscribe();
                                        })];
                                case 2:
                                    listener = _b.sent();
                                    _a = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sleep)(), sleepPromise = _a.promise, theTimeout = _a.timeout;
                                    timeout = theTimeout;
                                    return [4 /*yield*/, sleepPromise];
                                case 3:
                                    _b.sent();
                                    reject(new Error("windowClosed context not received from app B"));
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return [2 /*return*/, messageReceived];
                });
            });
        }
        var broadcastCloseWindow = function () { return __awaiter(void 0, void 0, void 0, function () {
            var appControlChannel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.getOrCreateChannel("app-control")];
                    case 1:
                        appControlChannel = _a.sent();
                        return [4 /*yield*/, appControlChannel.broadcast({ type: "closeWindow" })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.addContextListener.ts":
/*!********************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.addContextListener.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var documentation = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].addContextListener + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.addContextListener", function () {
        var listener;
        afterEach(function () {
            if (listener !== undefined) {
                listener.unsubscribe();
            }
        });
        it("(2.0-BasicCL1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var contextType, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        contextType = "fdc3.contact";
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fdc3.addContextListener(contextType, function (info) {
                                console.log("Context listener of type ".concat(contextType, " triggered with result ").concat(info));
                            })];
                    case 2:
                        listener = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(documentation + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-BasicCL2) Returns listener object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.addContextListener(null, function () { })];
                    case 1:
                        listener = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.isTrue(listener && typeof listener === "object", documentation);
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(typeof listener.unsubscribe, documentation).to.be.equals("function");
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(documentation + ((_a = ex_2.message) !== null && _a !== void 0 ? _a : ex_2));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.addIntentListener.ts":
/*!*******************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.addIntentListener.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.addIntentListener", function () {
        var listener;
        afterEach(function () {
            if (listener !== undefined) {
                listener.unsubscribe();
                listener = undefined;
            }
        });
        it("(2.0-BasicIL1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var intentName, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        intentName = "fdc3.conformanceListener";
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fdc3.addIntentListener(intentName, function (info) {
                                console.log("Intent listener for intent ".concat(intentName, " triggered with result ").concat(info));
                            })];
                    case 2:
                        listener = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(listener).to.have.property("unsubscribe").that.is.a("function");
                        return [3 /*break*/, 4];
                    case 3:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("\r\nDocumentation: " +
                            _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].addIntentListener +
                            "\r\nCause" +
                            ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.getCurrentChannel.ts":
/*!*******************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.getCurrentChannel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getCurrentChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getCurrentChannel + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getCurrentChannel", function () {
        it("(2.0-BasicCH1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 1:
                        channel = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getCurrentChannelDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-BasicCH2) getCurrentChannel() returns null if no channel has been joined", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 1:
                        channel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel).equals(null);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getCurrentChannelDocs + ((_a = ex_2.message) !== null && _a !== void 0 ? _a : ex_2));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.getOrCreateChannel.ts":
/*!********************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.getOrCreateChannel.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getOrCreateChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getOrCreateChannel + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getOrCreateChannel", function () {
        it("(2.0-BasicAC1) Returns Channel object", function () { return __awaiter(void 0, void 0, void 0, function () {
            var channel, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getOrCreateChannel("FDC3Conformance")];
                    case 1:
                        channel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("id");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("type");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("broadcast");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("getCurrentContext");
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(channel, getOrCreateChannelDocs).to.have.property("addContextListener");
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getOrCreateChannelDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.getUserChannels.ts":
/*!*****************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.getUserChannels.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var getSystemChannelDocs = "\r\nDocumentation: " + _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].getSystemChannels + "\r\nCause";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.getUserChannels", function () {
        it("(2.0-BasicUC1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
            var ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fdc3.getUserChannels()];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail(getSystemChannelDocs + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.joinUserChannel.ts":
/*!*****************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.joinUserChannel.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

function wrapPromise() {
    var wrapperResolve;
    var wrapperReject;
    var promise = new Promise(function (resolve, reject) {
        wrapperResolve = resolve;
        wrapperReject = reject;
    });
    return { promise: promise, resolve: wrapperResolve, reject: wrapperReject };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.joinChannel", function () {
        afterEach(function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it("(2.0-BasicJC1) Can join channel and broadcast", function () { return __awaiter(void 0, void 0, void 0, function () {
            var wrapper, channels, currentChannel, gotContext, ex_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        wrapper = wrapPromise();
                        return [4 /*yield*/, fdc3.getUserChannels()];
                    case 1:
                        channels = _b.sent();
                        if (!(channels.length > 0)) return [3 /*break*/, 8];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 6, , 7]);
                        return [4 /*yield*/, fdc3.joinUserChannel(channels[0].id)];
                    case 3:
                        _b.sent();
                        return [4 /*yield*/, fdc3.getCurrentChannel()];
                    case 4:
                        currentChannel = _b.sent();
                        (0,chai__WEBPACK_IMPORTED_MODULE_0__.expect)(currentChannel).to.not.be.null;
                        gotContext = function (c) {
                            console.log("Received" + c);
                            return true;
                        };
                        fdc3.addContextListener("someContext", function (ctx) {
                            if (ctx.type == "someContext") {
                                console.log("resolved");
                                wrapper.resolve();
                            }
                            else {
                                wrapper.reject("wrong context type");
                            }
                        });
                        currentChannel.broadcast({
                            type: "someContext",
                            id: { name: "hello" },
                        });
                        return [4 /*yield*/, wrapper.promise];
                    case 5:
                        _b.sent();
                        console.log("done");
                        return [3 /*break*/, 7];
                    case 6:
                        ex_1 = _b.sent();
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("Error while joining channel: " + ((_a = ex_1.message) !== null && _a !== void 0 ? _a : ex_1));
                        return [3 /*break*/, 7];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("No system channels available");
                        _b.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        }); });
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.leaveCurrentChannel.ts":
/*!*********************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.leaveCurrentChannel.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.leaveCurrentChannel", function () {
        var _a;
        try {
            it("(2.0-BasicLC1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fdc3.leaveCurrentChannel()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
        }
        catch (ex) {
            chai__WEBPACK_IMPORTED_MODULE_0__.assert.fail("\r\nDocumentation: " +
                _apiDocuments__WEBPACK_IMPORTED_MODULE_1__["default"].leaveCurrentChannel +
                "\r\nCause" +
                ((_a = ex.message) !== null && _a !== void 0 ? _a : ex));
        }
    });
});


/***/ }),

/***/ "./src/test/v2.0/basic/fdc3.raiseIntentForContext.ts":
/*!***********************************************************!*\
  !*** ./src/test/v2.0/basic/fdc3.raiseIntentForContext.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var fdc3_2_0__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fdc3_2_0 */ "../node_modules/fdc3_2_0/dist/fdc3.esm.js");
/* harmony import */ var chai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chai */ "../node_modules/chai/index.mjs");
/* harmony import */ var _apiDocuments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../apiDocuments */ "./src/apiDocuments.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var docs = "\r\nDocumentation: " +
    _apiDocuments__WEBPACK_IMPORTED_MODULE_2__["default"].raiseIntentForContext +
    "\r\nCause: ";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {
    return describe("fdc3.raiseIntentForContext", function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            it("(2.0-BasicRI1) Method is callable", function () { return __awaiter(void 0, void 0, void 0, function () {
                var context, ex_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            context = {
                                type: "ThisContextDoesNotExist",
                                name: "Name",
                                id: {
                                    ticker: "ticker",
                                    ISIN: "US0378331005",
                                    CUSIP: "037833100",
                                    FIGI: "BBG000B9XRY4",
                                },
                            };
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, fdc3.raiseIntentForContext(context)];
                        case 2:
                            _a.sent();
                            chai__WEBPACK_IMPORTED_MODULE_1__.assert.fail("Expected error NoAppsFound not thrown", docs);
                            return [3 /*break*/, 4];
                        case 3:
                            ex_1 = _a.sent();
                            (0,chai__WEBPACK_IMPORTED_MODULE_1__.expect)(ex_1).to.have.property("message", fdc3_2_0__WEBPACK_IMPORTED_MODULE_0__.ResolveError.NoAppsFound, docs);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/];
        });
    }); });
});


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sleep": () => (/* binding */ sleep),
/* harmony export */   "wait": () => (/* binding */ wait),
/* harmony export */   "wrapPromise": () => (/* binding */ wrapPromise)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/constants.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

function sleep(timeoutMs) {
    if (timeoutMs === void 0) { timeoutMs = _constants__WEBPACK_IMPORTED_MODULE_0__["default"].WaitTime; }
    var timeout;
    var promise = new Promise(function (resolve) {
        timeout = window.setTimeout(function () {
            resolve();
        }, timeoutMs);
    });
    return { promise: promise, timeout: timeout };
}
function wait(timeoutMs) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, promise, timeout;
        return __generator(this, function (_b) {
            _a = sleep(timeoutMs), promise = _a.promise, timeout = _a.timeout;
            return [2 /*return*/, promise];
        });
    });
}
function wrapPromise() {
    var wrapperResolve;
    var wrapperReject;
    var promise = new Promise(function (resolve, reject) {
        wrapperResolve = resolve;
        wrapperReject = reject;
    });
    return { promise: promise, resolve: wrapperResolve, reject: wrapperReject };
}


/***/ }),

/***/ "../node_modules/type-detect/type-detect.js":
/*!**************************************************!*\
  !*** ../node_modules/type-detect/type-detect.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

/* !
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var promiseExists = typeof Promise === 'function';

/* eslint-disable no-undef */
var globalObject = typeof self === 'object' ? self : __webpack_require__.g; // eslint-disable-line id-blacklist

var symbolExists = typeof Symbol !== 'undefined';
var mapExists = typeof Map !== 'undefined';
var setExists = typeof Set !== 'undefined';
var weakMapExists = typeof WeakMap !== 'undefined';
var weakSetExists = typeof WeakSet !== 'undefined';
var dataViewExists = typeof DataView !== 'undefined';
var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
var toStringLeftSliceLength = 8;
var toStringRightSliceLength = -1;
/**
 * ### typeOf (obj)
 *
 * Uses `Object.prototype.toString` to determine the type of an object,
 * normalising behaviour across engine versions & well optimised.
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
function typeDetect(obj) {
  /* ! Speed optimisation
   * Pre:
   *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
   *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
   *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
   *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
   *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
   * Post:
   *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
   *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
   *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
   *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
   *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
   */
  var typeofObj = typeof obj;
  if (typeofObj !== 'object') {
    return typeofObj;
  }

  /* ! Speed optimisation
   * Pre:
   *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
   * Post:
   *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
   */
  if (obj === null) {
    return 'null';
  }

  /* ! Spec Conformance
   * Test: `Object.prototype.toString.call(window)``
   *  - Node === "[object global]"
   *  - Chrome === "[object global]"
   *  - Firefox === "[object Window]"
   *  - PhantomJS === "[object Window]"
   *  - Safari === "[object Window]"
   *  - IE 11 === "[object Window]"
   *  - IE Edge === "[object Window]"
   * Test: `Object.prototype.toString.call(this)``
   *  - Chrome Worker === "[object global]"
   *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
   *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
   *  - IE 11 Worker === "[object WorkerGlobalScope]"
   *  - IE Edge Worker === "[object WorkerGlobalScope]"
   */
  if (obj === globalObject) {
    return 'global';
  }

  /* ! Speed optimisation
   * Pre:
   *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
   * Post:
   *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
   */
  if (
    Array.isArray(obj) &&
    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
  ) {
    return 'Array';
  }

  // Not caching existence of `window` and related properties due to potential
  // for `window` to be unset before tests in quasi-browser environments.
  if (typeof window === 'object' && window !== null) {
    /* ! Spec Conformance
     * (https://html.spec.whatwg.org/multipage/browsers.html#location)
     * WhatWG HTML$7.7.3 - The `Location` interface
     * Test: `Object.prototype.toString.call(window.location)``
     *  - IE <=11 === "[object Object]"
     *  - IE Edge <=13 === "[object Object]"
     */
    if (typeof window.location === 'object' && obj === window.location) {
      return 'Location';
    }

    /* ! Spec Conformance
     * (https://html.spec.whatwg.org/#document)
     * WhatWG HTML$3.1.1 - The `Document` object
     * Note: Most browsers currently adher to the W3C DOM Level 2 spec
     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
     *       which suggests that browsers should use HTMLTableCellElement for
     *       both TD and TH elements. WhatWG separates these.
     *       WhatWG HTML states:
     *         > For historical reasons, Window objects must also have a
     *         > writable, configurable, non-enumerable property named
     *         > HTMLDocument whose value is the Document interface object.
     * Test: `Object.prototype.toString.call(document)``
     *  - Chrome === "[object HTMLDocument]"
     *  - Firefox === "[object HTMLDocument]"
     *  - Safari === "[object HTMLDocument]"
     *  - IE <=10 === "[object Document]"
     *  - IE 11 === "[object HTMLDocument]"
     *  - IE Edge <=13 === "[object HTMLDocument]"
     */
    if (typeof window.document === 'object' && obj === window.document) {
      return 'Document';
    }

    if (typeof window.navigator === 'object') {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */
      if (typeof window.navigator.mimeTypes === 'object' &&
          obj === window.navigator.mimeTypes) {
        return 'MimeTypeArray';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */
      if (typeof window.navigator.plugins === 'object' &&
          obj === window.navigator.plugins) {
        return 'PluginArray';
      }
    }

    if ((typeof window.HTMLElement === 'function' ||
        typeof window.HTMLElement === 'object') &&
        obj instanceof window.HTMLElement) {
      /* ! Spec Conformance
      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
      *  - IE <=10 === "[object HTMLBlockElement]"
      */
      if (obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */
      if (obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */
      if (obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
  }

  /* ! Speed optimisation
  * Pre:
  *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
  *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
  *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
  *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
  *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
  *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
  *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
  *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
  *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
  * Post:
  *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
  *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
  *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
  *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
  *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
  *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
  *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
  *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
  *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
  */
  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
  if (typeof stringTag === 'string') {
    return stringTag;
  }

  var objPrototype = Object.getPrototypeOf(obj);
  /* ! Speed optimisation
  * Pre:
  *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
  *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
  * Post:
  *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
  *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
  */
  if (objPrototype === RegExp.prototype) {
    return 'RegExp';
  }

  /* ! Speed optimisation
  * Pre:
  *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
  * Post:
  *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
  */
  if (objPrototype === Date.prototype) {
    return 'Date';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
   * Test: `Object.prototype.toString.call(Promise.resolve())``
   *  - Chrome <=47 === "[object Object]"
   *  - Edge <=20 === "[object Object]"
   *  - Firefox 29-Latest === "[object Promise]"
   *  - Safari 7.1-Latest === "[object Promise]"
   */
  if (promiseExists && objPrototype === Promise.prototype) {
    return 'Promise';
  }

  /* ! Speed optimisation
  * Pre:
  *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
  * Post:
  *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
  */
  if (setExists && objPrototype === Set.prototype) {
    return 'Set';
  }

  /* ! Speed optimisation
  * Pre:
  *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
  * Post:
  *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
  */
  if (mapExists && objPrototype === Map.prototype) {
    return 'Map';
  }

  /* ! Speed optimisation
  * Pre:
  *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
  * Post:
  *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
  */
  if (weakSetExists && objPrototype === WeakSet.prototype) {
    return 'WeakSet';
  }

  /* ! Speed optimisation
  * Pre:
  *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
  * Post:
  *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
  */
  if (weakMapExists && objPrototype === WeakMap.prototype) {
    return 'WeakMap';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
   *  - Edge <=13 === "[object Object]"
   */
  if (dataViewExists && objPrototype === DataView.prototype) {
    return 'DataView';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
   * Test: `Object.prototype.toString.call(new Map().entries())``
   *  - Edge <=13 === "[object Object]"
   */
  if (mapExists && objPrototype === mapIteratorPrototype) {
    return 'Map Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
   * Test: `Object.prototype.toString.call(new Set().entries())``
   *  - Edge <=13 === "[object Object]"
   */
  if (setExists && objPrototype === setIteratorPrototype) {
    return 'Set Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
   *  - Edge <=13 === "[object Object]"
   */
  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
    return 'Array Iterator';
  }

  /* ! Spec Conformance
   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
   *  - Edge <=13 === "[object Object]"
   */
  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
    return 'String Iterator';
  }

  /* ! Speed optimisation
  * Pre:
  *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
  * Post:
  *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
  */
  if (objPrototype === null) {
    return 'Object';
  }

  return Object
    .prototype
    .toString
    .call(obj)
    .slice(toStringLeftSliceLength, toStringRightSliceLength);
}

return typeDetect;

})));


/***/ }),

/***/ "../node_modules/util-deprecate/browser.js":
/*!*************************************************!*\
  !*** ../node_modules/util-deprecate/browser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ "../node_modules/util/support/isBufferBrowser.js":
/*!*******************************************************!*\
  !*** ../node_modules/util/support/isBufferBrowser.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../node_modules/util/support/types.js":
/*!*********************************************!*\
  !*** ../node_modules/util/support/types.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "../node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "../node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "../node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "../node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "../node_modules/util/util.js":
/*!************************************!*\
  !*** ../node_modules/util/util.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "../node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "../node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "../node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "../node_modules/which-typed-array/index.js":
/*!**************************************************!*\
  !*** ../node_modules/which-typed-array/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "../node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "../node_modules/available-typed-arrays/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "../node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "../node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ "../node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js");
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(/*! is-typed-array */ "../node_modules/is-typed-array/index.js");

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ "?9a07":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b9ec":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4389":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f7c4":
/*!********************************!*\
  !*** supports-color (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8140":
/*!************************************!*\
  !*** ./nodejs/esm-utils (ignored) ***!
  \************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?20a6":
/*!****************************************!*\
  !*** ./nodejs/file-unloader (ignored) ***!
  \****************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?fd6e":
/*!***************************************************!*\
  !*** ./nodejs/parallel-buffered-runner (ignored) ***!
  \***************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?147c":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?432f":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?af24":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "../node_modules/available-typed-arrays/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/available-typed-arrays/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "../node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!***********************************************************************!*\
  !*** ../node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "../node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "../node_modules/mocha/browser-entry.js":
/*!**********************************************!*\
  !*** ../node_modules/mocha/browser-entry.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");


/* eslint no-unused-vars: off */
/* eslint-env commonjs */

/**
 * Shim process.stdout.
 */

process.stdout = __webpack_require__(/*! browser-stdout */ "../node_modules/browser-stdout/index.js")({label: false});

var parseQuery = __webpack_require__(/*! ./lib/browser/parse-query */ "../node_modules/mocha/lib/browser/parse-query.js");
var highlightTags = __webpack_require__(/*! ./lib/browser/highlight-tags */ "../node_modules/mocha/lib/browser/highlight-tags.js");
var Mocha = __webpack_require__(/*! ./lib/mocha */ "../node_modules/mocha/lib/mocha.js");

/**
 * Create a Mocha instance.
 *
 * @return {undefined}
 */

var mocha = new Mocha({reporter: 'html'});

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = __webpack_require__.g.Date;
var setTimeout = __webpack_require__.g.setTimeout;
var setInterval = __webpack_require__.g.setInterval;
var clearTimeout = __webpack_require__.g.clearTimeout;
var clearInterval = __webpack_require__.g.clearInterval;

var uncaughtExceptionHandlers = [];

var originalOnerrorHandler = __webpack_require__.g.onerror;

/**
 * Remove uncaughtException listener.
 * Revert to original onerror handler if previously defined.
 */

process.removeListener = function (e, fn) {
  if (e === 'uncaughtException') {
    if (originalOnerrorHandler) {
      __webpack_require__.g.onerror = originalOnerrorHandler;
    } else {
      __webpack_require__.g.onerror = function () {};
    }
    var i = uncaughtExceptionHandlers.indexOf(fn);
    if (i !== -1) {
      uncaughtExceptionHandlers.splice(i, 1);
    }
  }
};

/**
 * Implements listenerCount for 'uncaughtException'.
 */

process.listenerCount = function (name) {
  if (name === 'uncaughtException') {
    return uncaughtExceptionHandlers.length;
  }
  return 0;
};

/**
 * Implements uncaughtException listener.
 */

process.on = function (e, fn) {
  if (e === 'uncaughtException') {
    __webpack_require__.g.onerror = function (err, url, line) {
      fn(new Error(err + ' (' + url + ':' + line + ')'));
      return !mocha.options.allowUncaught;
    };
    uncaughtExceptionHandlers.push(fn);
  }
};

process.listeners = function (e) {
  if (e === 'uncaughtException') {
    return uncaughtExceptionHandlers;
  }
  return [];
};

// The BDD UI is registered by default, but no UI will be functional in the
// browser without an explicit call to the overridden `mocha.ui` (see below).
// Ensure that this default UI does not expose its methods to the global scope.
mocha.suite.removeAllListeners('pre-require');

var immediateQueue = [];
var immediateTimeout;

function timeslice() {
  var immediateStart = new Date().getTime();
  while (immediateQueue.length && new Date().getTime() - immediateStart < 100) {
    immediateQueue.shift()();
  }
  if (immediateQueue.length) {
    immediateTimeout = setTimeout(timeslice, 0);
  } else {
    immediateTimeout = null;
  }
}

/**
 * High-performance override of Runner.immediately.
 */

Mocha.Runner.immediately = function (callback) {
  immediateQueue.push(callback);
  if (!immediateTimeout) {
    immediateTimeout = setTimeout(timeslice, 0);
  }
};

/**
 * Function to allow assertion libraries to throw errors directly into mocha.
 * This is useful when running tests in a browser because window.onerror will
 * only receive the 'message' attribute of the Error.
 */
mocha.throwError = function (err) {
  uncaughtExceptionHandlers.forEach(function (fn) {
    fn(err);
  });
  throw err;
};

/**
 * Override ui to ensure that the ui functions are initialized.
 * Normally this would happen in Mocha.prototype.loadFiles.
 */

mocha.ui = function (ui) {
  Mocha.prototype.ui.call(this, ui);
  this.suite.emit('pre-require', __webpack_require__.g, null, this);
  return this;
};

/**
 * Setup mocha with the given setting options.
 */

mocha.setup = function (opts) {
  if (typeof opts === 'string') {
    opts = {ui: opts};
  }
  if (opts.delay === true) {
    this.delay();
  }
  var self = this;
  Object.keys(opts)
    .filter(function (opt) {
      return opt !== 'delay';
    })
    .forEach(function (opt) {
      if (Object.prototype.hasOwnProperty.call(opts, opt)) {
        self[opt](opts[opt]);
      }
    });
  return this;
};

/**
 * Run mocha, returning the Runner.
 */

mocha.run = function (fn) {
  var options = mocha.options;
  mocha.globals('location');

  var query = parseQuery(__webpack_require__.g.location.search || '');
  if (query.grep) {
    mocha.grep(query.grep);
  }
  if (query.fgrep) {
    mocha.fgrep(query.fgrep);
  }
  if (query.invert) {
    mocha.invert();
  }

  return Mocha.prototype.run.call(mocha, function (err) {
    // The DOM Document is not available in Web Workers.
    var document = __webpack_require__.g.document;
    if (
      document &&
      document.getElementById('mocha') &&
      options.noHighlighting !== true
    ) {
      highlightTags('code');
    }
    if (fn) {
      fn(err);
    }
  });
};

/**
 * Expose the process shim.
 * https://github.com/mochajs/mocha/pull/916
 */

Mocha.process = process;

/**
 * Expose mocha.
 */
__webpack_require__.g.Mocha = Mocha;
__webpack_require__.g.mocha = mocha;

// for bundlers: enable `import {describe, it} from 'mocha'`
// `bdd` interface only
// prettier-ignore
[ 
  'describe', 'context', 'it', 'specify',
  'xdescribe', 'xcontext', 'xit', 'xspecify',
  'before', 'beforeEach', 'afterEach', 'after'
].forEach(function(key) {
  mocha[key] = __webpack_require__.g[key];
});

module.exports = mocha;


/***/ }),

/***/ "../node_modules/mocha/lib/browser/highlight-tags.js":
/*!***********************************************************!*\
  !*** ../node_modules/mocha/lib/browser/highlight-tags.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Highlight the given string of `js`.
 *
 * @private
 * @param {string} js
 * @return {string}
 */
function highlight(js) {
  return js
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
    .replace(/('.*?')/gm, '<span class="string">$1</span>')
    .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
    .replace(/(\d+)/gm, '<span class="number">$1</span>')
    .replace(
      /\bnew[ \t]+(\w+)/gm,
      '<span class="keyword">new</span> <span class="init">$1</span>'
    )
    .replace(
      /\b(function|new|throw|return|var|if|else)\b/gm,
      '<span class="keyword">$1</span>'
    );
}

/**
 * Highlight the contents of tag `name`.
 *
 * @private
 * @param {string} name
 */
module.exports = function highlightTags(name) {
  var code = document.getElementById('mocha').getElementsByTagName(name);
  for (var i = 0, len = code.length; i < len; ++i) {
    code[i].innerHTML = highlight(code[i].innerHTML);
  }
};


/***/ }),

/***/ "../node_modules/mocha/lib/browser/parse-query.js":
/*!********************************************************!*\
  !*** ../node_modules/mocha/lib/browser/parse-query.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Parse the given `qs`.
 *
 * @private
 * @param {string} qs
 * @return {Object<string, string>}
 */
module.exports = function parseQuery(qs) {
  return qs
    .replace('?', '')
    .split('&')
    .reduce(function (obj, pair) {
      var i = pair.indexOf('=');
      var key = pair.slice(0, i);
      var val = pair.slice(++i);

      // Due to how the URLSearchParams API treats spaces
      obj[key] = decodeURIComponent(val.replace(/\+/g, '%20'));

      return obj;
    }, {});
};


/***/ }),

/***/ "../node_modules/mocha/lib/browser/progress.js":
/*!*****************************************************!*\
  !*** ../node_modules/mocha/lib/browser/progress.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 @module browser/Progress
*/

/**
 * Expose `Progress`.
 */

module.exports = Progress;

/**
 * Initialize a new `Progress` indicator.
 */
function Progress() {
  this.percent = 0;
  this.size(0);
  this.fontSize(11);
  this.font('helvetica, arial, sans-serif');
}

/**
 * Set progress size to `size`.
 *
 * @public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
Progress.prototype.size = function (size) {
  this._size = size;
  return this;
};

/**
 * Set text to `text`.
 *
 * @public
 * @param {string} text
 * @return {Progress} Progress instance.
 */
Progress.prototype.text = function (text) {
  this._text = text;
  return this;
};

/**
 * Set font size to `size`.
 *
 * @public
 * @param {number} size
 * @return {Progress} Progress instance.
 */
Progress.prototype.fontSize = function (size) {
  this._fontSize = size;
  return this;
};

/**
 * Set font to `family`.
 *
 * @param {string} family
 * @return {Progress} Progress instance.
 */
Progress.prototype.font = function (family) {
  this._font = family;
  return this;
};

/**
 * Update percentage to `n`.
 *
 * @param {number} n
 * @return {Progress} Progress instance.
 */
Progress.prototype.update = function (n) {
  this.percent = n;
  return this;
};

/**
 * Draw on `ctx`.
 *
 * @param {CanvasRenderingContext2d} ctx
 * @return {Progress} Progress instance.
 */
Progress.prototype.draw = function (ctx) {
  try {
    var percent = Math.min(this.percent, 100);
    var size = this._size;
    var half = size / 2;
    var x = half;
    var y = half;
    var rad = half - 1;
    var fontSize = this._fontSize;

    ctx.font = fontSize + 'px ' + this._font;

    var angle = Math.PI * 2 * (percent / 100);
    ctx.clearRect(0, 0, size, size);

    // outer circle
    ctx.strokeStyle = '#9f9f9f';
    ctx.beginPath();
    ctx.arc(x, y, rad, 0, angle, false);
    ctx.stroke();

    // inner circle
    ctx.strokeStyle = '#eee';
    ctx.beginPath();
    ctx.arc(x, y, rad - 1, 0, angle, true);
    ctx.stroke();

    // text
    var text = this._text || (percent | 0) + '%';
    var w = ctx.measureText(text).width;

    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
  } catch (ignore) {
    // don't fail if we can't render progress
  }
  return this;
};


/***/ }),

/***/ "../node_modules/mocha/lib/context.js":
/*!********************************************!*\
  !*** ../node_modules/mocha/lib/context.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";

/**
 * @module Context
 */
/**
 * Expose `Context`.
 */

module.exports = Context;

/**
 * Initialize a new `Context`.
 *
 * @private
 */
function Context() {}

/**
 * Set or get the context `Runnable` to `runnable`.
 *
 * @private
 * @param {Runnable} runnable
 * @return {Context} context
 */
Context.prototype.runnable = function (runnable) {
  if (!arguments.length) {
    return this._runnable;
  }
  this.test = this._runnable = runnable;
  return this;
};

/**
 * Set or get test timeout `ms`.
 *
 * @private
 * @param {number} ms
 * @return {Context} self
 */
Context.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this.runnable().timeout();
  }
  this.runnable().timeout(ms);
  return this;
};

/**
 * Set or get test slowness threshold `ms`.
 *
 * @private
 * @param {number} ms
 * @return {Context} self
 */
Context.prototype.slow = function (ms) {
  if (!arguments.length) {
    return this.runnable().slow();
  }
  this.runnable().slow(ms);
  return this;
};

/**
 * Mark a test as skipped.
 *
 * @private
 * @throws Pending
 */
Context.prototype.skip = function () {
  this.runnable().skip();
};

/**
 * Set or get a number of allowed retries on failed tests
 *
 * @private
 * @param {number} n
 * @return {Context} self
 */
Context.prototype.retries = function (n) {
  if (!arguments.length) {
    return this.runnable().retries();
  }
  this.runnable().retries(n);
  return this;
};


/***/ }),

/***/ "../node_modules/mocha/lib/errors.js":
/*!*******************************************!*\
  !*** ../node_modules/mocha/lib/errors.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");


const {format} = __webpack_require__(/*! util */ "../node_modules/util/util.js");

/**
 * Contains error codes, factory functions to create throwable error objects,
 * and warning/deprecation functions.
 * @module
 */

/**
 * process.emitWarning or a polyfill
 * @see https://nodejs.org/api/process.html#process_process_emitwarning_warning_options
 * @ignore
 */
const emitWarning = (msg, type) => {
  if (process.emitWarning) {
    process.emitWarning(msg, type);
  } else {
    /* istanbul ignore next */
    process.nextTick(function () {
      console.warn(type + ': ' + msg);
    });
  }
};

/**
 * Show a deprecation warning. Each distinct message is only displayed once.
 * Ignores empty messages.
 *
 * @param {string} [msg] - Warning to print
 * @private
 */
const deprecate = msg => {
  msg = String(msg);
  if (msg && !deprecate.cache[msg]) {
    deprecate.cache[msg] = true;
    emitWarning(msg, 'DeprecationWarning');
  }
};
deprecate.cache = {};

/**
 * Show a generic warning.
 * Ignores empty messages.
 *
 * @param {string} [msg] - Warning to print
 * @private
 */
const warn = msg => {
  if (msg) {
    emitWarning(msg);
  }
};

/**
 * When Mocha throws exceptions (or rejects `Promise`s), it attempts to assign a `code` property to the `Error` object, for easier handling. These are the potential values of `code`.
 * @public
 * @namespace
 * @memberof module:lib/errors
 */
var constants = {
  /**
   * An unrecoverable error.
   * @constant
   * @default
   */
  FATAL: 'ERR_MOCHA_FATAL',

  /**
   * The type of an argument to a function call is invalid
   * @constant
   * @default
   */
  INVALID_ARG_TYPE: 'ERR_MOCHA_INVALID_ARG_TYPE',

  /**
   * The value of an argument to a function call is invalid
   * @constant
   * @default
   */
  INVALID_ARG_VALUE: 'ERR_MOCHA_INVALID_ARG_VALUE',

  /**
   * Something was thrown, but it wasn't an `Error`
   * @constant
   * @default
   */
  INVALID_EXCEPTION: 'ERR_MOCHA_INVALID_EXCEPTION',

  /**
   * An interface (e.g., `Mocha.interfaces`) is unknown or invalid
   * @constant
   * @default
   */
  INVALID_INTERFACE: 'ERR_MOCHA_INVALID_INTERFACE',

  /**
   * A reporter (.e.g, `Mocha.reporters`) is unknown or invalid
   * @constant
   * @default
   */
  INVALID_REPORTER: 'ERR_MOCHA_INVALID_REPORTER',

  /**
   * `done()` was called twice in a `Test` or `Hook` callback
   * @constant
   * @default
   */
  MULTIPLE_DONE: 'ERR_MOCHA_MULTIPLE_DONE',

  /**
   * No files matched the pattern provided by the user
   * @constant
   * @default
   */
  NO_FILES_MATCH_PATTERN: 'ERR_MOCHA_NO_FILES_MATCH_PATTERN',

  /**
   * Known, but unsupported behavior of some kind
   * @constant
   * @default
   */
  UNSUPPORTED: 'ERR_MOCHA_UNSUPPORTED',

  /**
   * Invalid state transition occurring in `Mocha` instance
   * @constant
   * @default
   */
  INSTANCE_ALREADY_RUNNING: 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING',

  /**
   * Invalid state transition occurring in `Mocha` instance
   * @constant
   * @default
   */
  INSTANCE_ALREADY_DISPOSED: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED',

  /**
   * Use of `only()` w/ `--forbid-only` results in this error.
   * @constant
   * @default
   */
  FORBIDDEN_EXCLUSIVITY: 'ERR_MOCHA_FORBIDDEN_EXCLUSIVITY',

  /**
   * To be thrown when a user-defined plugin implementation (e.g., `mochaHooks`) is invalid
   * @constant
   * @default
   */
  INVALID_PLUGIN_IMPLEMENTATION: 'ERR_MOCHA_INVALID_PLUGIN_IMPLEMENTATION',

  /**
   * To be thrown when a builtin or third-party plugin definition (the _definition_ of `mochaHooks`) is invalid
   * @constant
   * @default
   */
  INVALID_PLUGIN_DEFINITION: 'ERR_MOCHA_INVALID_PLUGIN_DEFINITION',

  /**
   * When a runnable exceeds its allowed run time.
   * @constant
   * @default
   */
  TIMEOUT: 'ERR_MOCHA_TIMEOUT',

  /**
   * Input file is not able to be parsed
   * @constant
   * @default
   */
  UNPARSABLE_FILE: 'ERR_MOCHA_UNPARSABLE_FILE'
};

/**
 * A set containing all string values of all Mocha error constants, for use by {@link isMochaError}.
 * @private
 */
const MOCHA_ERRORS = new Set(Object.values(constants));

/**
 * Creates an error object to be thrown when no files to be tested could be found using specified pattern.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} pattern - User-specified argument value.
 * @returns {Error} instance detailing the error condition
 */
function createNoFilesMatchPatternError(message, pattern) {
  var err = new Error(message);
  err.code = constants.NO_FILES_MATCH_PATTERN;
  err.pattern = pattern;
  return err;
}

/**
 * Creates an error object to be thrown when the reporter specified in the options was not found.
 *
 * @public
 * @param {string} message - Error message to be displayed.
 * @param {string} reporter - User-specified reporter value.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidReporterError(message, reporter) {
  var err = new TypeError(message);
  err.code = constants.INVALID_REPORTER;
  err.reporter = reporter;
  return err;
}

/**
 * Creates an error object to be thrown when the interface specified in the options was not found.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} ui - User-specified interface value.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidInterfaceError(message, ui) {
  var err = new Error(message);
  err.code = constants.INVALID_INTERFACE;
  err.interface = ui;
  return err;
}

/**
 * Creates an error object to be thrown when a behavior, option, or parameter is unsupported.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createUnsupportedError(message) {
  var err = new Error(message);
  err.code = constants.UNSUPPORTED;
  return err;
}

/**
 * Creates an error object to be thrown when an argument is missing.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} expected - Expected argument datatype.
 * @returns {Error} instance detailing the error condition
 */
function createMissingArgumentError(message, argument, expected) {
  return createInvalidArgumentTypeError(message, argument, expected);
}

/**
 * Creates an error object to be thrown when an argument did not use the supported type
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} expected - Expected argument datatype.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidArgumentTypeError(message, argument, expected) {
  var err = new TypeError(message);
  err.code = constants.INVALID_ARG_TYPE;
  err.argument = argument;
  err.expected = expected;
  err.actual = typeof argument;
  return err;
}

/**
 * Creates an error object to be thrown when an argument did not use the supported value
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} argument - Argument name.
 * @param {string} value - Argument value.
 * @param {string} [reason] - Why value is invalid.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidArgumentValueError(message, argument, value, reason) {
  var err = new TypeError(message);
  err.code = constants.INVALID_ARG_VALUE;
  err.argument = argument;
  err.value = value;
  err.reason = typeof reason !== 'undefined' ? reason : 'is invalid';
  return err;
}

/**
 * Creates an error object to be thrown when an exception was caught, but the `Error` is falsy or undefined.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createInvalidExceptionError(message, value) {
  var err = new Error(message);
  err.code = constants.INVALID_EXCEPTION;
  err.valueType = typeof value;
  err.value = value;
  return err;
}

/**
 * Creates an error object to be thrown when an unrecoverable error occurs.
 *
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @returns {Error} instance detailing the error condition
 */
function createFatalError(message, value) {
  var err = new Error(message);
  err.code = constants.FATAL;
  err.valueType = typeof value;
  err.value = value;
  return err;
}

/**
 * Dynamically creates a plugin-type-specific error based on plugin type
 * @param {string} message - Error message
 * @param {"reporter"|"ui"} pluginType - Plugin type. Future: expand as needed
 * @param {string} [pluginId] - Name/path of plugin, if any
 * @throws When `pluginType` is not known
 * @public
 * @static
 * @returns {Error}
 */
function createInvalidLegacyPluginError(message, pluginType, pluginId) {
  switch (pluginType) {
    case 'reporter':
      return createInvalidReporterError(message, pluginId);
    case 'ui':
      return createInvalidInterfaceError(message, pluginId);
    default:
      throw new Error('unknown pluginType "' + pluginType + '"');
  }
}

/**
 * **DEPRECATED**.  Use {@link createInvalidLegacyPluginError} instead  Dynamically creates a plugin-type-specific error based on plugin type
 * @deprecated
 * @param {string} message - Error message
 * @param {"reporter"|"interface"} pluginType - Plugin type. Future: expand as needed
 * @param {string} [pluginId] - Name/path of plugin, if any
 * @throws When `pluginType` is not known
 * @public
 * @static
 * @returns {Error}
 */
function createInvalidPluginError(...args) {
  deprecate('Use createInvalidLegacyPluginError() instead');
  return createInvalidLegacyPluginError(...args);
}

/**
 * Creates an error object to be thrown when a mocha object's `run` method is executed while it is already disposed.
 * @param {string} message The error message to be displayed.
 * @param {boolean} cleanReferencesAfterRun the value of `cleanReferencesAfterRun`
 * @param {Mocha} instance the mocha instance that throw this error
 * @static
 */
function createMochaInstanceAlreadyDisposedError(
  message,
  cleanReferencesAfterRun,
  instance
) {
  var err = new Error(message);
  err.code = constants.INSTANCE_ALREADY_DISPOSED;
  err.cleanReferencesAfterRun = cleanReferencesAfterRun;
  err.instance = instance;
  return err;
}

/**
 * Creates an error object to be thrown when a mocha object's `run` method is called while a test run is in progress.
 * @param {string} message The error message to be displayed.
 * @static
 * @public
 */
function createMochaInstanceAlreadyRunningError(message, instance) {
  var err = new Error(message);
  err.code = constants.INSTANCE_ALREADY_RUNNING;
  err.instance = instance;
  return err;
}

/**
 * Creates an error object to be thrown when done() is called multiple times in a test
 *
 * @public
 * @param {Runnable} runnable - Original runnable
 * @param {Error} [originalErr] - Original error, if any
 * @returns {Error} instance detailing the error condition
 * @static
 */
function createMultipleDoneError(runnable, originalErr) {
  var title;
  try {
    title = format('<%s>', runnable.fullTitle());
    if (runnable.parent.root) {
      title += ' (of root suite)';
    }
  } catch (ignored) {
    title = format('<%s> (of unknown suite)', runnable.title);
  }
  var message = format(
    'done() called multiple times in %s %s',
    runnable.type ? runnable.type : 'unknown runnable',
    title
  );
  if (runnable.file) {
    message += format(' of file %s', runnable.file);
  }
  if (originalErr) {
    message += format('; in addition, done() received error: %s', originalErr);
  }

  var err = new Error(message);
  err.code = constants.MULTIPLE_DONE;
  err.valueType = typeof originalErr;
  err.value = originalErr;
  return err;
}

/**
 * Creates an error object to be thrown when `.only()` is used with
 * `--forbid-only`.
 * @static
 * @public
 * @param {Mocha} mocha - Mocha instance
 * @returns {Error} Error with code {@link constants.FORBIDDEN_EXCLUSIVITY}
 */
function createForbiddenExclusivityError(mocha) {
  var err = new Error(
    mocha.isWorker
      ? '`.only` is not supported in parallel mode'
      : '`.only` forbidden by --forbid-only'
  );
  err.code = constants.FORBIDDEN_EXCLUSIVITY;
  return err;
}

/**
 * Creates an error object to be thrown when a plugin definition is invalid
 * @static
 * @param {string} msg - Error message
 * @param {PluginDefinition} [pluginDef] - Problematic plugin definition
 * @public
 * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}
 */
function createInvalidPluginDefinitionError(msg, pluginDef) {
  const err = new Error(msg);
  err.code = constants.INVALID_PLUGIN_DEFINITION;
  err.pluginDef = pluginDef;
  return err;
}

/**
 * Creates an error object to be thrown when a plugin implementation (user code) is invalid
 * @static
 * @param {string} msg - Error message
 * @param {Object} [opts] - Plugin definition and user-supplied implementation
 * @param {PluginDefinition} [opts.pluginDef] - Plugin Definition
 * @param {*} [opts.pluginImpl] - Plugin Implementation (user-supplied)
 * @public
 * @returns {Error} Error with code {@link constants.INVALID_PLUGIN_DEFINITION}
 */
function createInvalidPluginImplementationError(
  msg,
  {pluginDef, pluginImpl} = {}
) {
  const err = new Error(msg);
  err.code = constants.INVALID_PLUGIN_IMPLEMENTATION;
  err.pluginDef = pluginDef;
  err.pluginImpl = pluginImpl;
  return err;
}

/**
 * Creates an error object to be thrown when a runnable exceeds its allowed run time.
 * @static
 * @param {string} msg - Error message
 * @param {number} [timeout] - Timeout in ms
 * @param {string} [file] - File, if given
 * @returns {MochaTimeoutError}
 */
function createTimeoutError(msg, timeout, file) {
  const err = new Error(msg);
  err.code = constants.TIMEOUT;
  err.timeout = timeout;
  err.file = file;
  return err;
}

/**
 * Creates an error object to be thrown when file is unparsable
 * @public
 * @static
 * @param {string} message - Error message to be displayed.
 * @param {string} filename - File name
 * @returns {Error} Error with code {@link constants.UNPARSABLE_FILE}
 */
function createUnparsableFileError(message, filename) {
  var err = new Error(message);
  err.code = constants.UNPARSABLE_FILE;
  return err;
}

/**
 * Returns `true` if an error came out of Mocha.
 * _Can suffer from false negatives, but not false positives._
 * @static
 * @public
 * @param {*} err - Error, or anything
 * @returns {boolean}
 */
const isMochaError = err =>
  Boolean(err && typeof err === 'object' && MOCHA_ERRORS.has(err.code));

module.exports = {
  constants,
  createFatalError,
  createForbiddenExclusivityError,
  createInvalidArgumentTypeError,
  createInvalidArgumentValueError,
  createInvalidExceptionError,
  createInvalidInterfaceError,
  createInvalidLegacyPluginError,
  createInvalidPluginDefinitionError,
  createInvalidPluginError,
  createInvalidPluginImplementationError,
  createInvalidReporterError,
  createMissingArgumentError,
  createMochaInstanceAlreadyDisposedError,
  createMochaInstanceAlreadyRunningError,
  createMultipleDoneError,
  createNoFilesMatchPatternError,
  createTimeoutError,
  createUnparsableFileError,
  createUnsupportedError,
  deprecate,
  isMochaError,
  warn
};

/**
 * The error thrown when a Runnable times out
 * @memberof module:lib/errors
 * @typedef {Error} MochaTimeoutError
 * @property {constants.TIMEOUT} code - Error code
 * @property {number?} timeout Timeout in ms
 * @property {string?} file Filepath, if given
 */


/***/ }),

/***/ "../node_modules/mocha/lib/hook.js":
/*!*****************************************!*\
  !*** ../node_modules/mocha/lib/hook.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Runnable = __webpack_require__(/*! ./runnable */ "../node_modules/mocha/lib/runnable.js");
const {inherits, constants} = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
const {MOCHA_ID_PROP_NAME} = constants;

/**
 * Expose `Hook`.
 */

module.exports = Hook;

/**
 * Initialize a new `Hook` with the given `title` and callback `fn`
 *
 * @class
 * @extends Runnable
 * @param {String} title
 * @param {Function} fn
 */
function Hook(title, fn) {
  Runnable.call(this, title, fn);
  this.type = 'hook';
}

/**
 * Inherit from `Runnable.prototype`.
 */
inherits(Hook, Runnable);

/**
 * Resets the state for a next run.
 */
Hook.prototype.reset = function () {
  Runnable.prototype.reset.call(this);
  delete this._error;
};

/**
 * Get or set the test `err`.
 *
 * @memberof Hook
 * @public
 * @param {Error} err
 * @return {Error}
 */
Hook.prototype.error = function (err) {
  if (!arguments.length) {
    err = this._error;
    this._error = null;
    return err;
  }

  this._error = err;
};

/**
 * Returns an object suitable for IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Hook.prototype.serialize = function serialize() {
  return {
    $$currentRetry: this.currentRetry(),
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.isPending()),
    $$titlePath: this.titlePath(),
    ctx:
      this.ctx && this.ctx.currentTest
        ? {
            currentTest: {
              title: this.ctx.currentTest.title,
              [MOCHA_ID_PROP_NAME]: this.ctx.currentTest.id
            }
          }
        : {},
    duration: this.duration,
    file: this.file,
    parent: {
      $$fullTitle: this.parent.fullTitle(),
      [MOCHA_ID_PROP_NAME]: this.parent.id
    },
    state: this.state,
    title: this.title,
    type: this.type,
    [MOCHA_ID_PROP_NAME]: this.id
  };
};


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/bdd.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/bdd.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Test = __webpack_require__(/*! ../test */ "../node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  (__webpack_require__(/*! ../suite */ "../node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE);

/**
 * BDD-style interface:
 *
 *      describe('Array', function() {
 *        describe('#indexOf()', function() {
 *          it('should return -1 when not present', function() {
 *            // ...
 *          });
 *
 *          it('should return the index when present', function() {
 *            // ...
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function bddInterface(suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "../node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.before = common.before;
    context.after = common.after;
    context.beforeEach = common.beforeEach;
    context.afterEach = common.afterEach;
    context.run = mocha.options.delay && common.runWithSuite(suite);
    /**
     * Describe a "suite" with the given `title`
     * and callback `fn` containing nested suites
     * and/or tests.
     */

    context.describe = context.context = function (title, fn) {
      return common.suite.create({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Pending describe.
     */

    context.xdescribe =
      context.xcontext =
      context.describe.skip =
        function (title, fn) {
          return common.suite.skip({
            title: title,
            file: file,
            fn: fn
          });
        };

    /**
     * Exclusive suite.
     */

    context.describe.only = function (title, fn) {
      return common.suite.only({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.it = context.specify = function (title, fn) {
      var suite = suites[0];
      if (suite.isPending()) {
        fn = null;
      }
      var test = new Test(title, fn);
      test.file = file;
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.it.only = function (title, fn) {
      return common.test.only(mocha, context.it(title, fn));
    };

    /**
     * Pending test case.
     */

    context.xit =
      context.xspecify =
      context.it.skip =
        function (title) {
          return context.it(title);
        };
  });
};

module.exports.description = 'BDD or RSpec style [default]';


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/common.js":
/*!******************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/common.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 @module interfaces/common
*/

var Suite = __webpack_require__(/*! ../suite */ "../node_modules/mocha/lib/suite.js");
var errors = __webpack_require__(/*! ../errors */ "../node_modules/mocha/lib/errors.js");
var createMissingArgumentError = errors.createMissingArgumentError;
var createUnsupportedError = errors.createUnsupportedError;
var createForbiddenExclusivityError = errors.createForbiddenExclusivityError;

/**
 * Functions common to more than one interface.
 *
 * @private
 * @param {Suite[]} suites
 * @param {Context} context
 * @param {Mocha} mocha
 * @return {Object} An object containing common functions.
 */
module.exports = function (suites, context, mocha) {
  /**
   * Check if the suite should be tested.
   *
   * @private
   * @param {Suite} suite - suite to check
   * @returns {boolean}
   */
  function shouldBeTested(suite) {
    return (
      !mocha.options.grep ||
      (mocha.options.grep &&
        mocha.options.grep.test(suite.fullTitle()) &&
        !mocha.options.invert)
    );
  }

  return {
    /**
     * This is only present if flag --delay is passed into Mocha. It triggers
     * root suite execution.
     *
     * @param {Suite} suite The root suite.
     * @return {Function} A function which runs the root suite
     */
    runWithSuite: function runWithSuite(suite) {
      return function run() {
        suite.run();
      };
    },

    /**
     * Execute before running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
    before: function (name, fn) {
      suites[0].beforeAll(name, fn);
    },

    /**
     * Execute after running tests.
     *
     * @param {string} name
     * @param {Function} fn
     */
    after: function (name, fn) {
      suites[0].afterAll(name, fn);
    },

    /**
     * Execute before each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
    beforeEach: function (name, fn) {
      suites[0].beforeEach(name, fn);
    },

    /**
     * Execute after each test case.
     *
     * @param {string} name
     * @param {Function} fn
     */
    afterEach: function (name, fn) {
      suites[0].afterEach(name, fn);
    },

    suite: {
      /**
       * Create an exclusive Suite; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
      only: function only(opts) {
        if (mocha.options.forbidOnly) {
          throw createForbiddenExclusivityError(mocha);
        }
        opts.isOnly = true;
        return this.create(opts);
      },

      /**
       * Create a Suite, but skip it; convenience function
       * See docstring for create() below.
       *
       * @param {Object} opts
       * @returns {Suite}
       */
      skip: function skip(opts) {
        opts.pending = true;
        return this.create(opts);
      },

      /**
       * Creates a suite.
       *
       * @param {Object} opts Options
       * @param {string} opts.title Title of Suite
       * @param {Function} [opts.fn] Suite Function (not always applicable)
       * @param {boolean} [opts.pending] Is Suite pending?
       * @param {string} [opts.file] Filepath where this Suite resides
       * @param {boolean} [opts.isOnly] Is Suite exclusive?
       * @returns {Suite}
       */
      create: function create(opts) {
        var suite = Suite.create(suites[0], opts.title);
        suite.pending = Boolean(opts.pending);
        suite.file = opts.file;
        suites.unshift(suite);
        if (opts.isOnly) {
          suite.markOnly();
        }
        if (
          suite.pending &&
          mocha.options.forbidPending &&
          shouldBeTested(suite)
        ) {
          throw createUnsupportedError('Pending test forbidden');
        }
        if (typeof opts.fn === 'function') {
          opts.fn.call(suite);
          suites.shift();
        } else if (typeof opts.fn === 'undefined' && !suite.pending) {
          throw createMissingArgumentError(
            'Suite "' +
              suite.fullTitle() +
              '" was defined but no callback was supplied. ' +
              'Supply a callback or explicitly skip the suite.',
            'callback',
            'function'
          );
        } else if (!opts.fn && suite.pending) {
          suites.shift();
        }

        return suite;
      }
    },

    test: {
      /**
       * Exclusive test-case.
       *
       * @param {Object} mocha
       * @param {Function} test
       * @returns {*}
       */
      only: function (mocha, test) {
        if (mocha.options.forbidOnly) {
          throw createForbiddenExclusivityError(mocha);
        }
        test.markOnly();
        return test;
      },

      /**
       * Pending test case.
       *
       * @param {string} title
       */
      skip: function (title) {
        context.test(title);
      }
    }
  };
};


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/exports.js":
/*!*******************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/exports.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Suite = __webpack_require__(/*! ../suite */ "../node_modules/mocha/lib/suite.js");
var Test = __webpack_require__(/*! ../test */ "../node_modules/mocha/lib/test.js");

/**
 * Exports-style (as Node.js module) interface:
 *
 *     exports.Array = {
 *       '#indexOf()': {
 *         'should return -1 when the value is not present': function() {
 *
 *         },
 *
 *         'should return the correct index when the value is present': function() {
 *
 *         }
 *       }
 *     };
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function (suite) {
  var suites = [suite];

  suite.on(Suite.constants.EVENT_FILE_REQUIRE, visit);

  function visit(obj, file) {
    var suite;
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        var fn = obj[key];
        switch (key) {
          case 'before':
            suites[0].beforeAll(fn);
            break;
          case 'after':
            suites[0].afterAll(fn);
            break;
          case 'beforeEach':
            suites[0].beforeEach(fn);
            break;
          case 'afterEach':
            suites[0].afterEach(fn);
            break;
          default:
            var test = new Test(key, fn);
            test.file = file;
            suites[0].addTest(test);
        }
      } else {
        suite = Suite.create(suites[0], key);
        suites.unshift(suite);
        visit(obj[key], file);
        suites.shift();
      }
    }
  }
};

module.exports.description = 'Node.js module ("exports") style';


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.bdd = __webpack_require__(/*! ./bdd */ "../node_modules/mocha/lib/interfaces/bdd.js");
exports.tdd = __webpack_require__(/*! ./tdd */ "../node_modules/mocha/lib/interfaces/tdd.js");
exports.qunit = __webpack_require__(/*! ./qunit */ "../node_modules/mocha/lib/interfaces/qunit.js");
exports.exports = __webpack_require__(/*! ./exports */ "../node_modules/mocha/lib/interfaces/exports.js");


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/qunit.js":
/*!*****************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/qunit.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Test = __webpack_require__(/*! ../test */ "../node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  (__webpack_require__(/*! ../suite */ "../node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE);

/**
 * QUnit-style interface:
 *
 *     suite('Array');
 *
 *     test('#length', function() {
 *       var arr = [1,2,3];
 *       ok(arr.length == 3);
 *     });
 *
 *     test('#indexOf()', function() {
 *       var arr = [1,2,3];
 *       ok(arr.indexOf(1) == 0);
 *       ok(arr.indexOf(2) == 1);
 *       ok(arr.indexOf(3) == 2);
 *     });
 *
 *     suite('String');
 *
 *     test('#length', function() {
 *       ok('foo'.length == 3);
 *     });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function qUnitInterface(suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "../node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.before = common.before;
    context.after = common.after;
    context.beforeEach = common.beforeEach;
    context.afterEach = common.afterEach;
    context.run = mocha.options.delay && common.runWithSuite(suite);
    /**
     * Describe a "suite" with the given `title`.
     */

    context.suite = function (title) {
      if (suites.length > 1) {
        suites.shift();
      }
      return common.suite.create({
        title: title,
        file: file,
        fn: false
      });
    };

    /**
     * Exclusive Suite.
     */

    context.suite.only = function (title) {
      if (suites.length > 1) {
        suites.shift();
      }
      return common.suite.only({
        title: title,
        file: file,
        fn: false
      });
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.test = function (title, fn) {
      var test = new Test(title, fn);
      test.file = file;
      suites[0].addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function (title, fn) {
      return common.test.only(mocha, context.test(title, fn));
    };

    context.test.skip = common.test.skip;
  });
};

module.exports.description = 'QUnit style';


/***/ }),

/***/ "../node_modules/mocha/lib/interfaces/tdd.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/interfaces/tdd.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Test = __webpack_require__(/*! ../test */ "../node_modules/mocha/lib/test.js");
var EVENT_FILE_PRE_REQUIRE =
  (__webpack_require__(/*! ../suite */ "../node_modules/mocha/lib/suite.js").constants.EVENT_FILE_PRE_REQUIRE);

/**
 * TDD-style interface:
 *
 *      suite('Array', function() {
 *        suite('#indexOf()', function() {
 *          suiteSetup(function() {
 *
 *          });
 *
 *          test('should return -1 when not present', function() {
 *
 *          });
 *
 *          test('should return the index when present', function() {
 *
 *          });
 *
 *          suiteTeardown(function() {
 *
 *          });
 *        });
 *      });
 *
 * @param {Suite} suite Root suite.
 */
module.exports = function (suite) {
  var suites = [suite];

  suite.on(EVENT_FILE_PRE_REQUIRE, function (context, file, mocha) {
    var common = __webpack_require__(/*! ./common */ "../node_modules/mocha/lib/interfaces/common.js")(suites, context, mocha);

    context.setup = common.beforeEach;
    context.teardown = common.afterEach;
    context.suiteSetup = common.before;
    context.suiteTeardown = common.after;
    context.run = mocha.options.delay && common.runWithSuite(suite);

    /**
     * Describe a "suite" with the given `title` and callback `fn` containing
     * nested suites and/or tests.
     */
    context.suite = function (title, fn) {
      return common.suite.create({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Pending suite.
     */
    context.suite.skip = function (title, fn) {
      return common.suite.skip({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Exclusive test-case.
     */
    context.suite.only = function (title, fn) {
      return common.suite.only({
        title: title,
        file: file,
        fn: fn
      });
    };

    /**
     * Describe a specification or test-case with the given `title` and
     * callback `fn` acting as a thunk.
     */
    context.test = function (title, fn) {
      var suite = suites[0];
      if (suite.isPending()) {
        fn = null;
      }
      var test = new Test(title, fn);
      test.file = file;
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function (title, fn) {
      return common.test.only(mocha, context.test(title, fn));
    };

    context.test.skip = common.test.skip;
  });
};

module.exports.description =
  'traditional "suite"/"test" instead of BDD\'s "describe"/"it"';


/***/ }),

/***/ "../node_modules/mocha/lib/mocha.js":
/*!******************************************!*\
  !*** ../node_modules/mocha/lib/mocha.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


/*!
 * mocha
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var escapeRe = __webpack_require__(/*! escape-string-regexp */ "../node_modules/escape-string-regexp/index.js");
var path = __webpack_require__(/*! path */ "?147c");
var builtinReporters = __webpack_require__(/*! ./reporters */ "../node_modules/mocha/lib/reporters/index.js");
var utils = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
var mocharc = __webpack_require__(/*! ./mocharc.json */ "../node_modules/mocha/lib/mocharc.json");
var Suite = __webpack_require__(/*! ./suite */ "../node_modules/mocha/lib/suite.js");
var esmUtils = __webpack_require__(/*! ./nodejs/esm-utils */ "?8140");
var createStatsCollector = __webpack_require__(/*! ./stats-collector */ "../node_modules/mocha/lib/stats-collector.js");
const {
  createInvalidReporterError,
  createInvalidInterfaceError,
  createMochaInstanceAlreadyDisposedError,
  createMochaInstanceAlreadyRunningError,
  createUnsupportedError
} = __webpack_require__(/*! ./errors */ "../node_modules/mocha/lib/errors.js");
const {EVENT_FILE_PRE_REQUIRE, EVENT_FILE_POST_REQUIRE, EVENT_FILE_REQUIRE} =
  Suite.constants;
var debug = __webpack_require__(/*! debug */ "../node_modules/mocha/node_modules/debug/src/browser.js")('mocha:mocha');

exports = module.exports = Mocha;

/**
 * A Mocha instance is a finite state machine.
 * These are the states it can be in.
 * @private
 */
var mochaStates = utils.defineConstants({
  /**
   * Initial state of the mocha instance
   * @private
   */
  INIT: 'init',
  /**
   * Mocha instance is running tests
   * @private
   */
  RUNNING: 'running',
  /**
   * Mocha instance is done running tests and references to test functions and hooks are cleaned.
   * You can reset this state by unloading the test files.
   * @private
   */
  REFERENCES_CLEANED: 'referencesCleaned',
  /**
   * Mocha instance is disposed and can no longer be used.
   * @private
   */
  DISPOSED: 'disposed'
});

/**
 * To require local UIs and reporters when running in node.
 */

if (!utils.isBrowser() && typeof module.paths !== 'undefined') {
  var cwd = utils.cwd();
  module.paths.push(cwd, path.join(cwd, 'node_modules'));
}

/**
 * Expose internals.
 * @private
 */

exports.utils = utils;
exports.interfaces = __webpack_require__(/*! ./interfaces */ "../node_modules/mocha/lib/interfaces/index.js");
/**
 * @public
 * @memberof Mocha
 */
exports.reporters = builtinReporters;
exports.Runnable = __webpack_require__(/*! ./runnable */ "../node_modules/mocha/lib/runnable.js");
exports.Context = __webpack_require__(/*! ./context */ "../node_modules/mocha/lib/context.js");
/**
 *
 * @memberof Mocha
 */
exports.Runner = __webpack_require__(/*! ./runner */ "../node_modules/mocha/lib/runner.js");
exports.Suite = Suite;
exports.Hook = __webpack_require__(/*! ./hook */ "../node_modules/mocha/lib/hook.js");
exports.Test = __webpack_require__(/*! ./test */ "../node_modules/mocha/lib/test.js");

let currentContext;
exports.afterEach = function (...args) {
  return (currentContext.afterEach || currentContext.teardown).apply(
    this,
    args
  );
};
exports.after = function (...args) {
  return (currentContext.after || currentContext.suiteTeardown).apply(
    this,
    args
  );
};
exports.beforeEach = function (...args) {
  return (currentContext.beforeEach || currentContext.setup).apply(this, args);
};
exports.before = function (...args) {
  return (currentContext.before || currentContext.suiteSetup).apply(this, args);
};
exports.describe = function (...args) {
  return (currentContext.describe || currentContext.suite).apply(this, args);
};
exports.describe.only = function (...args) {
  return (currentContext.describe || currentContext.suite).only.apply(
    this,
    args
  );
};
exports.describe.skip = function (...args) {
  return (currentContext.describe || currentContext.suite).skip.apply(
    this,
    args
  );
};
exports.it = function (...args) {
  return (currentContext.it || currentContext.test).apply(this, args);
};
exports.it.only = function (...args) {
  return (currentContext.it || currentContext.test).only.apply(this, args);
};
exports.it.skip = function (...args) {
  return (currentContext.it || currentContext.test).skip.apply(this, args);
};
exports.xdescribe = exports.describe.skip;
exports.xit = exports.it.skip;
exports.setup = exports.beforeEach;
exports.suiteSetup = exports.before;
exports.suiteTeardown = exports.after;
exports.suite = exports.describe;
exports.teardown = exports.afterEach;
exports.test = exports.it;
exports.run = function (...args) {
  return currentContext.run.apply(this, args);
};

/**
 * Constructs a new Mocha instance with `options`.
 *
 * @public
 * @class Mocha
 * @param {Object} [options] - Settings object.
 * @param {boolean} [options.allowUncaught] - Propagate uncaught errors?
 * @param {boolean} [options.asyncOnly] - Force `done` callback or promise?
 * @param {boolean} [options.bail] - Bail after first test failure?
 * @param {boolean} [options.checkLeaks] - Check for global variable leaks?
 * @param {boolean} [options.color] - Color TTY output from reporter?
 * @param {boolean} [options.delay] - Delay root suite execution?
 * @param {boolean} [options.diff] - Show diff on failure?
 * @param {boolean} [options.dryRun] - Report tests without running them?
 * @param {boolean} [options.failZero] - Fail test run if zero tests?
 * @param {string} [options.fgrep] - Test filter given string.
 * @param {boolean} [options.forbidOnly] - Tests marked `only` fail the suite?
 * @param {boolean} [options.forbidPending] - Pending tests fail the suite?
 * @param {boolean} [options.fullTrace] - Full stacktrace upon failure?
 * @param {string[]} [options.global] - Variables expected in global scope.
 * @param {RegExp|string} [options.grep] - Test filter given regular expression.
 * @param {boolean} [options.inlineDiffs] - Display inline diffs?
 * @param {boolean} [options.invert] - Invert test filter matches?
 * @param {boolean} [options.noHighlighting] - Disable syntax highlighting?
 * @param {string|constructor} [options.reporter] - Reporter name or constructor.
 * @param {Object} [options.reporterOption] - Reporter settings object.
 * @param {number} [options.retries] - Number of times to retry failed tests.
 * @param {number} [options.slow] - Slow threshold value.
 * @param {number|string} [options.timeout] - Timeout threshold value.
 * @param {string} [options.ui] - Interface name.
 * @param {boolean} [options.parallel] - Run jobs in parallel.
 * @param {number} [options.jobs] - Max number of worker processes for parallel runs.
 * @param {MochaRootHookObject} [options.rootHooks] - Hooks to bootstrap the root suite with.
 * @param {string[]} [options.require] - Pathname of `rootHooks` plugin for parallel runs.
 * @param {boolean} [options.isWorker] - Should be `true` if `Mocha` process is running in a worker process.
 */
function Mocha(options = {}) {
  options = {...mocharc, ...options};
  this.files = [];
  this.options = options;
  // root suite
  this.suite = new exports.Suite('', new exports.Context(), true);
  this._cleanReferencesAfterRun = true;
  this._state = mochaStates.INIT;

  this.grep(options.grep)
    .fgrep(options.fgrep)
    .ui(options.ui)
    .reporter(
      options.reporter,
      options.reporterOption || options.reporterOptions // for backwards compatibility
    )
    .slow(options.slow)
    .global(options.global);

  // this guard exists because Suite#timeout does not consider `undefined` to be valid input
  if (typeof options.timeout !== 'undefined') {
    this.timeout(options.timeout === false ? 0 : options.timeout);
  }

  if ('retries' in options) {
    this.retries(options.retries);
  }

  [
    'allowUncaught',
    'asyncOnly',
    'bail',
    'checkLeaks',
    'color',
    'delay',
    'diff',
    'dryRun',
    'failZero',
    'forbidOnly',
    'forbidPending',
    'fullTrace',
    'inlineDiffs',
    'invert'
  ].forEach(function (opt) {
    if (options[opt]) {
      this[opt]();
    }
  }, this);

  if (options.rootHooks) {
    this.rootHooks(options.rootHooks);
  }

  /**
   * The class which we'll instantiate in {@link Mocha#run}.  Defaults to
   * {@link Runner} in serial mode; changes in parallel mode.
   * @memberof Mocha
   * @private
   */
  this._runnerClass = exports.Runner;

  /**
   * Whether or not to call {@link Mocha#loadFiles} implicitly when calling
   * {@link Mocha#run}.  If this is `true`, then it's up to the consumer to call
   * {@link Mocha#loadFiles} _or_ {@link Mocha#loadFilesAsync}.
   * @private
   * @memberof Mocha
   */
  this._lazyLoadFiles = false;

  /**
   * It's useful for a Mocha instance to know if it's running in a worker process.
   * We could derive this via other means, but it's helpful to have a flag to refer to.
   * @memberof Mocha
   * @private
   */
  this.isWorker = Boolean(options.isWorker);

  this.globalSetup(options.globalSetup)
    .globalTeardown(options.globalTeardown)
    .enableGlobalSetup(options.enableGlobalSetup)
    .enableGlobalTeardown(options.enableGlobalTeardown);

  if (
    options.parallel &&
    (typeof options.jobs === 'undefined' || options.jobs > 1)
  ) {
    debug('attempting to enable parallel mode');
    this.parallelMode(true);
  }
}

/**
 * Enables or disables bailing on the first failure.
 *
 * @public
 * @see [CLI option](../#-bail-b)
 * @param {boolean} [bail=true] - Whether to bail on first error.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.bail = function (bail) {
  this.suite.bail(bail !== false);
  return this;
};

/**
 * @summary
 * Adds `file` to be loaded for execution.
 *
 * @description
 * Useful for generic setup code that must be included within test suite.
 *
 * @public
 * @see [CLI option](../#-file-filedirectoryglob)
 * @param {string} file - Pathname of file to be loaded.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.addFile = function (file) {
  this.files.push(file);
  return this;
};

/**
 * Sets reporter to `reporter`, defaults to "spec".
 *
 * @public
 * @see [CLI option](../#-reporter-name-r-name)
 * @see [Reporters](../#reporters)
 * @param {String|Function} reporterName - Reporter name or constructor.
 * @param {Object} [reporterOptions] - Options used to configure the reporter.
 * @returns {Mocha} this
 * @chainable
 * @throws {Error} if requested reporter cannot be loaded
 * @example
 *
 * // Use XUnit reporter and direct its output to file
 * mocha.reporter('xunit', { output: '/path/to/testspec.xunit.xml' });
 */
Mocha.prototype.reporter = function (reporterName, reporterOptions) {
  if (typeof reporterName === 'function') {
    this._reporter = reporterName;
  } else {
    reporterName = reporterName || 'spec';
    var reporter;
    // Try to load a built-in reporter.
    if (builtinReporters[reporterName]) {
      reporter = builtinReporters[reporterName];
    }
    // Try to load reporters from process.cwd() and node_modules
    if (!reporter) {
      let foundReporter;
      try {
        foundReporter = /*require.resolve*/(__webpack_require__("../node_modules/mocha/lib sync recursive").resolve(reporterName));
        reporter = __webpack_require__("../node_modules/mocha/lib sync recursive")(foundReporter);
      } catch (err) {
        if (foundReporter) {
          throw createInvalidReporterError(err.message, foundReporter);
        }
        // Try to load reporters from a cwd-relative path
        try {
          reporter = __webpack_require__("../node_modules/mocha/lib sync recursive")(path.resolve(reporterName));
        } catch (e) {
          throw createInvalidReporterError(e.message, reporterName);
        }
      }
    }
    this._reporter = reporter;
  }
  this.options.reporterOption = reporterOptions;
  // alias option name is used in built-in reporters xunit/tap/progress
  this.options.reporterOptions = reporterOptions;
  return this;
};

/**
 * Sets test UI `name`, defaults to "bdd".
 *
 * @public
 * @see [CLI option](../#-ui-name-u-name)
 * @see [Interface DSLs](../#interfaces)
 * @param {string|Function} [ui=bdd] - Interface name or class.
 * @returns {Mocha} this
 * @chainable
 * @throws {Error} if requested interface cannot be loaded
 */
Mocha.prototype.ui = function (ui) {
  var bindInterface;
  if (typeof ui === 'function') {
    bindInterface = ui;
  } else {
    ui = ui || 'bdd';
    bindInterface = exports.interfaces[ui];
    if (!bindInterface) {
      try {
        bindInterface = __webpack_require__("../node_modules/mocha/lib sync recursive")(ui);
      } catch (err) {
        throw createInvalidInterfaceError(`invalid interface '${ui}'`, ui);
      }
    }
  }
  bindInterface(this.suite);

  this.suite.on(EVENT_FILE_PRE_REQUIRE, function (context) {
    currentContext = context;
  });

  return this;
};

/**
 * Loads `files` prior to execution. Does not support ES Modules.
 *
 * @description
 * The implementation relies on Node's `require` to execute
 * the test interface functions and will be subject to its cache.
 * Supports only CommonJS modules. To load ES modules, use Mocha#loadFilesAsync.
 *
 * @private
 * @see {@link Mocha#addFile}
 * @see {@link Mocha#run}
 * @see {@link Mocha#unloadFiles}
 * @see {@link Mocha#loadFilesAsync}
 * @param {Function} [fn] - Callback invoked upon completion.
 */
Mocha.prototype.loadFiles = function (fn) {
  var self = this;
  var suite = this.suite;
  this.files.forEach(function (file) {
    file = path.resolve(file);
    suite.emit(EVENT_FILE_PRE_REQUIRE, __webpack_require__.g, file, self);
    suite.emit(EVENT_FILE_REQUIRE, __webpack_require__("../node_modules/mocha/lib sync recursive")(file), file, self);
    suite.emit(EVENT_FILE_POST_REQUIRE, __webpack_require__.g, file, self);
  });
  fn && fn();
};

/**
 * Loads `files` prior to execution. Supports Node ES Modules.
 *
 * @description
 * The implementation relies on Node's `require` and `import` to execute
 * the test interface functions and will be subject to its cache.
 * Supports both CJS and ESM modules.
 *
 * @public
 * @see {@link Mocha#addFile}
 * @see {@link Mocha#run}
 * @see {@link Mocha#unloadFiles}
 * @returns {Promise}
 * @example
 *
 * // loads ESM (and CJS) test files asynchronously, then runs root suite
 * mocha.loadFilesAsync()
 *   .then(() => mocha.run(failures => process.exitCode = failures ? 1 : 0))
 *   .catch(() => process.exitCode = 1);
 */
Mocha.prototype.loadFilesAsync = function () {
  var self = this;
  var suite = this.suite;
  this.lazyLoadFiles(true);

  return esmUtils.loadFilesAsync(
    this.files,
    function (file) {
      suite.emit(EVENT_FILE_PRE_REQUIRE, __webpack_require__.g, file, self);
    },
    function (file, resultModule) {
      suite.emit(EVENT_FILE_REQUIRE, resultModule, file, self);
      suite.emit(EVENT_FILE_POST_REQUIRE, __webpack_require__.g, file, self);
    }
  );
};

/**
 * Removes a previously loaded file from Node's `require` cache.
 *
 * @private
 * @static
 * @see {@link Mocha#unloadFiles}
 * @param {string} file - Pathname of file to be unloaded.
 */
Mocha.unloadFile = function (file) {
  if (utils.isBrowser()) {
    throw createUnsupportedError(
      'unloadFile() is only supported in a Node.js environment'
    );
  }
  return (__webpack_require__(/*! ./nodejs/file-unloader */ "?20a6").unloadFile)(file);
};

/**
 * Unloads `files` from Node's `require` cache.
 *
 * @description
 * This allows required files to be "freshly" reloaded, providing the ability
 * to reuse a Mocha instance programmatically.
 * Note: does not clear ESM module files from the cache
 *
 * <strong>Intended for consumers &mdash; not used internally</strong>
 *
 * @public
 * @see {@link Mocha#run}
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.unloadFiles = function () {
  if (this._state === mochaStates.DISPOSED) {
    throw createMochaInstanceAlreadyDisposedError(
      'Mocha instance is already disposed, it cannot be used again.',
      this._cleanReferencesAfterRun,
      this
    );
  }

  this.files.forEach(function (file) {
    Mocha.unloadFile(file);
  });
  this._state = mochaStates.INIT;
  return this;
};

/**
 * Sets `grep` filter after escaping RegExp special characters.
 *
 * @public
 * @see {@link Mocha#grep}
 * @param {string} str - Value to be converted to a regexp.
 * @returns {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title begins with `"foo"` followed by a period
 * mocha.fgrep('foo.');
 */
Mocha.prototype.fgrep = function (str) {
  if (!str) {
    return this;
  }
  return this.grep(new RegExp(escapeRe(str)));
};

/**
 * @summary
 * Sets `grep` filter used to select specific tests for execution.
 *
 * @description
 * If `re` is a regexp-like string, it will be converted to regexp.
 * The regexp is tested against the full title of each test (i.e., the
 * name of the test preceded by titles of each its ancestral suites).
 * As such, using an <em>exact-match</em> fixed pattern against the
 * test name itself will not yield any matches.
 * <br>
 * <strong>Previous filter value will be overwritten on each call!</strong>
 *
 * @public
 * @see [CLI option](../#-grep-regexp-g-regexp)
 * @see {@link Mocha#fgrep}
 * @see {@link Mocha#invert}
 * @param {RegExp|String} re - Regular expression used to select tests.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title contains `"match"`, ignoring case
 * mocha.grep(/match/i);
 * @example
 *
 * // Same as above but with regexp-like string argument
 * mocha.grep('/match/i');
 * @example
 *
 * // ## Anti-example
 * // Given embedded test `it('only-this-test')`...
 * mocha.grep('/^only-this-test$/');    // NO! Use `.only()` to do this!
 */
Mocha.prototype.grep = function (re) {
  if (utils.isString(re)) {
    // extract args if it's regex-like, i.e: [string, pattern, flag]
    var arg = re.match(/^\/(.*)\/([gimy]{0,4})$|.*/);
    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);
  } else {
    this.options.grep = re;
  }
  return this;
};

/**
 * Inverts `grep` matches.
 *
 * @public
 * @see {@link Mocha#grep}
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Select tests whose full title does *not* contain `"match"`, ignoring case
 * mocha.grep(/match/i).invert();
 */
Mocha.prototype.invert = function () {
  this.options.invert = true;
  return this;
};

/**
 * Enables or disables checking for global variables leaked while running tests.
 *
 * @public
 * @see [CLI option](../#-check-leaks)
 * @param {boolean} [checkLeaks=true] - Whether to check for global variable leaks.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.checkLeaks = function (checkLeaks) {
  this.options.checkLeaks = checkLeaks !== false;
  return this;
};

/**
 * Enables or disables whether or not to dispose after each test run.
 * Disable this to ensure you can run the test suite multiple times.
 * If disabled, be sure to dispose mocha when you're done to prevent memory leaks.
 * @public
 * @see {@link Mocha#dispose}
 * @param {boolean} cleanReferencesAfterRun
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.cleanReferencesAfterRun = function (cleanReferencesAfterRun) {
  this._cleanReferencesAfterRun = cleanReferencesAfterRun !== false;
  return this;
};

/**
 * Manually dispose this mocha instance. Mark this instance as `disposed` and unable to run more tests.
 * It also removes function references to tests functions and hooks, so variables trapped in closures can be cleaned by the garbage collector.
 * @public
 */
Mocha.prototype.dispose = function () {
  if (this._state === mochaStates.RUNNING) {
    throw createMochaInstanceAlreadyRunningError(
      'Cannot dispose while the mocha instance is still running tests.'
    );
  }
  this.unloadFiles();
  this._previousRunner && this._previousRunner.dispose();
  this.suite.dispose();
  this._state = mochaStates.DISPOSED;
};

/**
 * Displays full stack trace upon test failure.
 *
 * @public
 * @see [CLI option](../#-full-trace)
 * @param {boolean} [fullTrace=true] - Whether to print full stacktrace upon failure.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.fullTrace = function (fullTrace) {
  this.options.fullTrace = fullTrace !== false;
  return this;
};

/**
 * Specifies whitelist of variable names to be expected in global scope.
 *
 * @public
 * @see [CLI option](../#-global-variable-name)
 * @see {@link Mocha#checkLeaks}
 * @param {String[]|String} global - Accepted global variable name(s).
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Specify variables to be expected in global scope
 * mocha.global(['jQuery', 'MyLib']);
 */
Mocha.prototype.global = function (global) {
  this.options.global = (this.options.global || [])
    .concat(global)
    .filter(Boolean)
    .filter(function (elt, idx, arr) {
      return arr.indexOf(elt) === idx;
    });
  return this;
};
// for backwards compatibility, 'globals' is an alias of 'global'
Mocha.prototype.globals = Mocha.prototype.global;

/**
 * Enables or disables TTY color output by screen-oriented reporters.
 *
 * @public
 * @see [CLI option](../#-color-c-colors)
 * @param {boolean} [color=true] - Whether to enable color output.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.color = function (color) {
  this.options.color = color !== false;
  return this;
};

/**
 * Enables or disables reporter to use inline diffs (rather than +/-)
 * in test failure output.
 *
 * @public
 * @see [CLI option](../#-inline-diffs)
 * @param {boolean} [inlineDiffs=true] - Whether to use inline diffs.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.inlineDiffs = function (inlineDiffs) {
  this.options.inlineDiffs = inlineDiffs !== false;
  return this;
};

/**
 * Enables or disables reporter to include diff in test failure output.
 *
 * @public
 * @see [CLI option](../#-diff)
 * @param {boolean} [diff=true] - Whether to show diff on failure.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.diff = function (diff) {
  this.options.diff = diff !== false;
  return this;
};

/**
 * @summary
 * Sets timeout threshold value.
 *
 * @description
 * A string argument can use shorthand (such as "2s") and will be converted.
 * If the value is `0`, timeouts will be disabled.
 *
 * @public
 * @see [CLI option](../#-timeout-ms-t-ms)
 * @see [Timeouts](../#timeouts)
 * @param {number|string} msecs - Timeout threshold value.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Sets timeout to one second
 * mocha.timeout(1000);
 * @example
 *
 * // Same as above but using string argument
 * mocha.timeout('1s');
 */
Mocha.prototype.timeout = function (msecs) {
  this.suite.timeout(msecs);
  return this;
};

/**
 * Sets the number of times to retry failed tests.
 *
 * @public
 * @see [CLI option](../#-retries-n)
 * @see [Retry Tests](../#retry-tests)
 * @param {number} retry - Number of times to retry failed tests.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Allow any failed test to retry one more time
 * mocha.retries(1);
 */
Mocha.prototype.retries = function (retry) {
  this.suite.retries(retry);
  return this;
};

/**
 * Sets slowness threshold value.
 *
 * @public
 * @see [CLI option](../#-slow-ms-s-ms)
 * @param {number} msecs - Slowness threshold value.
 * @return {Mocha} this
 * @chainable
 * @example
 *
 * // Sets "slow" threshold to half a second
 * mocha.slow(500);
 * @example
 *
 * // Same as above but using string argument
 * mocha.slow('0.5s');
 */
Mocha.prototype.slow = function (msecs) {
  this.suite.slow(msecs);
  return this;
};

/**
 * Forces all tests to either accept a `done` callback or return a promise.
 *
 * @public
 * @see [CLI option](../#-async-only-a)
 * @param {boolean} [asyncOnly=true] - Whether to force `done` callback or promise.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.asyncOnly = function (asyncOnly) {
  this.options.asyncOnly = asyncOnly !== false;
  return this;
};

/**
 * Disables syntax highlighting (in browser).
 *
 * @public
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.noHighlighting = function () {
  this.options.noHighlighting = true;
  return this;
};

/**
 * Enables or disables uncaught errors to propagate.
 *
 * @public
 * @see [CLI option](../#-allow-uncaught)
 * @param {boolean} [allowUncaught=true] - Whether to propagate uncaught errors.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.allowUncaught = function (allowUncaught) {
  this.options.allowUncaught = allowUncaught !== false;
  return this;
};

/**
 * @summary
 * Delays root suite execution.
 *
 * @description
 * Used to perform async operations before any suites are run.
 *
 * @public
 * @see [delayed root suite](../#delayed-root-suite)
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.delay = function delay() {
  this.options.delay = true;
  return this;
};

/**
 * Enables or disables running tests in dry-run mode.
 *
 * @public
 * @see [CLI option](../#-dry-run)
 * @param {boolean} [dryRun=true] - Whether to activate dry-run mode.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.dryRun = function (dryRun) {
  this.options.dryRun = dryRun !== false;
  return this;
};

/**
 * Fails test run if no tests encountered with exit-code 1.
 *
 * @public
 * @see [CLI option](../#-fail-zero)
 * @param {boolean} [failZero=true] - Whether to fail test run.
 * @return {Mocha} this
 * @chainable
 */
Mocha.prototype.failZero = function (failZero) {
  this.options.failZero = failZero !== false;
  return this;
};

/**
 * Causes tests marked `only` to fail the suite.
 *
 * @public
 * @see [CLI option](../#-forbid-only)
 * @param {boolean} [forbidOnly=true] - Whether tests marked `only` fail the suite.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.forbidOnly = function (forbidOnly) {
  this.options.forbidOnly = forbidOnly !== false;
  return this;
};

/**
 * Causes pending tests and tests marked `skip` to fail the suite.
 *
 * @public
 * @see [CLI option](../#-forbid-pending)
 * @param {boolean} [forbidPending=true] - Whether pending tests fail the suite.
 * @returns {Mocha} this
 * @chainable
 */
Mocha.prototype.forbidPending = function (forbidPending) {
  this.options.forbidPending = forbidPending !== false;
  return this;
};

/**
 * Throws an error if mocha is in the wrong state to be able to transition to a "running" state.
 * @private
 */
Mocha.prototype._guardRunningStateTransition = function () {
  if (this._state === mochaStates.RUNNING) {
    throw createMochaInstanceAlreadyRunningError(
      'Mocha instance is currently running tests, cannot start a next test run until this one is done',
      this
    );
  }
  if (
    this._state === mochaStates.DISPOSED ||
    this._state === mochaStates.REFERENCES_CLEANED
  ) {
    throw createMochaInstanceAlreadyDisposedError(
      'Mocha instance is already disposed, cannot start a new test run. Please create a new mocha instance. Be sure to set disable `cleanReferencesAfterRun` when you want to reuse the same mocha instance for multiple test runs.',
      this._cleanReferencesAfterRun,
      this
    );
  }
};

/**
 * Mocha version as specified by "package.json".
 *
 * @name Mocha#version
 * @type string
 * @readonly
 */
Object.defineProperty(Mocha.prototype, 'version', {
  value: (__webpack_require__(/*! ../package.json */ "../node_modules/mocha/package.json").version),
  configurable: false,
  enumerable: true,
  writable: false
});

/**
 * Callback to be invoked when test execution is complete.
 *
 * @private
 * @callback DoneCB
 * @param {number} failures - Number of failures that occurred.
 */

/**
 * Runs root suite and invokes `fn()` when complete.
 *
 * @description
 * To run tests multiple times (or to run tests in files that are
 * already in the `require` cache), make sure to clear them from
 * the cache first!
 *
 * @public
 * @see {@link Mocha#unloadFiles}
 * @see {@link Runner#run}
 * @param {DoneCB} [fn] - Callback invoked when test execution completed.
 * @returns {Runner} runner instance
 * @example
 *
 * // exit with non-zero status if there were test failures
 * mocha.run(failures => process.exitCode = failures ? 1 : 0);
 */
Mocha.prototype.run = function (fn) {
  this._guardRunningStateTransition();
  this._state = mochaStates.RUNNING;
  if (this._previousRunner) {
    this._previousRunner.dispose();
    this.suite.reset();
  }
  if (this.files.length && !this._lazyLoadFiles) {
    this.loadFiles();
  }
  var suite = this.suite;
  var options = this.options;
  options.files = this.files;
  const runner = new this._runnerClass(suite, {
    cleanReferencesAfterRun: this._cleanReferencesAfterRun,
    delay: options.delay,
    dryRun: options.dryRun,
    failZero: options.failZero
  });
  createStatsCollector(runner);
  var reporter = new this._reporter(runner, options);
  runner.checkLeaks = options.checkLeaks === true;
  runner.fullStackTrace = options.fullTrace;
  runner.asyncOnly = options.asyncOnly;
  runner.allowUncaught = options.allowUncaught;
  runner.forbidOnly = options.forbidOnly;
  runner.forbidPending = options.forbidPending;
  if (options.grep) {
    runner.grep(options.grep, options.invert);
  }
  if (options.global) {
    runner.globals(options.global);
  }
  if (options.color !== undefined) {
    exports.reporters.Base.useColors = options.color;
  }
  exports.reporters.Base.inlineDiffs = options.inlineDiffs;
  exports.reporters.Base.hideDiff = !options.diff;

  const done = failures => {
    this._previousRunner = runner;
    this._state = this._cleanReferencesAfterRun
      ? mochaStates.REFERENCES_CLEANED
      : mochaStates.INIT;
    fn = fn || utils.noop;
    if (typeof reporter.done === 'function') {
      reporter.done(failures, fn);
    } else {
      fn(failures);
    }
  };

  const runAsync = async runner => {
    const context =
      this.options.enableGlobalSetup && this.hasGlobalSetupFixtures()
        ? await this.runGlobalSetup(runner)
        : {};
    const failureCount = await runner.runAsync({
      files: this.files,
      options
    });
    if (this.options.enableGlobalTeardown && this.hasGlobalTeardownFixtures()) {
      await this.runGlobalTeardown(runner, {context});
    }
    return failureCount;
  };

  // no "catch" here is intentional. errors coming out of
  // Runner#run are considered uncaught/unhandled and caught
  // by the `process` event listeners.
  // also: returning anything other than `runner` would be a breaking
  // change
  runAsync(runner).then(done);

  return runner;
};

/**
 * Assigns hooks to the root suite
 * @param {MochaRootHookObject} [hooks] - Hooks to assign to root suite
 * @chainable
 */
Mocha.prototype.rootHooks = function rootHooks({
  beforeAll = [],
  beforeEach = [],
  afterAll = [],
  afterEach = []
} = {}) {
  beforeAll = utils.castArray(beforeAll);
  beforeEach = utils.castArray(beforeEach);
  afterAll = utils.castArray(afterAll);
  afterEach = utils.castArray(afterEach);
  beforeAll.forEach(hook => {
    this.suite.beforeAll(hook);
  });
  beforeEach.forEach(hook => {
    this.suite.beforeEach(hook);
  });
  afterAll.forEach(hook => {
    this.suite.afterAll(hook);
  });
  afterEach.forEach(hook => {
    this.suite.afterEach(hook);
  });
  return this;
};

/**
 * Toggles parallel mode.
 *
 * Must be run before calling {@link Mocha#run}. Changes the `Runner` class to
 * use; also enables lazy file loading if not already done so.
 *
 * Warning: when passed `false` and lazy loading has been enabled _via any means_ (including calling `parallelMode(true)`), this method will _not_ disable lazy loading. Lazy loading is a prerequisite for parallel
 * mode, but parallel mode is _not_ a prerequisite for lazy loading!
 * @param {boolean} [enable] - If `true`, enable; otherwise disable.
 * @throws If run in browser
 * @throws If Mocha not in `INIT` state
 * @returns {Mocha}
 * @chainable
 * @public
 */
Mocha.prototype.parallelMode = function parallelMode(enable = true) {
  if (utils.isBrowser()) {
    throw createUnsupportedError('parallel mode is only supported in Node.js');
  }
  const parallel = Boolean(enable);
  if (
    parallel === this.options.parallel &&
    this._lazyLoadFiles &&
    this._runnerClass !== exports.Runner
  ) {
    return this;
  }
  if (this._state !== mochaStates.INIT) {
    throw createUnsupportedError(
      'cannot change parallel mode after having called run()'
    );
  }
  this.options.parallel = parallel;

  // swap Runner class
  this._runnerClass = parallel
    ? __webpack_require__(/*! ./nodejs/parallel-buffered-runner */ "?fd6e")
    : exports.Runner;

  // lazyLoadFiles may have been set `true` otherwise (for ESM loading),
  // so keep `true` if so.
  return this.lazyLoadFiles(this._lazyLoadFiles || parallel);
};

/**
 * Disables implicit call to {@link Mocha#loadFiles} in {@link Mocha#run}. This
 * setting is used by watch mode, parallel mode, and for loading ESM files.
 * @todo This should throw if we've already loaded files; such behavior
 * necessitates adding a new state.
 * @param {boolean} [enable] - If `true`, disable eager loading of files in
 * {@link Mocha#run}
 * @chainable
 * @public
 */
Mocha.prototype.lazyLoadFiles = function lazyLoadFiles(enable) {
  this._lazyLoadFiles = enable === true;
  debug('set lazy load to %s', enable);
  return this;
};

/**
 * Configures one or more global setup fixtures.
 *
 * If given no parameters, _unsets_ any previously-set fixtures.
 * @chainable
 * @public
 * @param {MochaGlobalFixture|MochaGlobalFixture[]} [setupFns] - Global setup fixture(s)
 * @returns {Mocha}
 */
Mocha.prototype.globalSetup = function globalSetup(setupFns = []) {
  setupFns = utils.castArray(setupFns);
  this.options.globalSetup = setupFns;
  debug('configured %d global setup functions', setupFns.length);
  return this;
};

/**
 * Configures one or more global teardown fixtures.
 *
 * If given no parameters, _unsets_ any previously-set fixtures.
 * @chainable
 * @public
 * @param {MochaGlobalFixture|MochaGlobalFixture[]} [teardownFns] - Global teardown fixture(s)
 * @returns {Mocha}
 */
Mocha.prototype.globalTeardown = function globalTeardown(teardownFns = []) {
  teardownFns = utils.castArray(teardownFns);
  this.options.globalTeardown = teardownFns;
  debug('configured %d global teardown functions', teardownFns.length);
  return this;
};

/**
 * Run any global setup fixtures sequentially, if any.
 *
 * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalSetup` option is `false`; see {@link Mocha#enableGlobalSetup}.
 *
 * The context object this function resolves with should be consumed by {@link Mocha#runGlobalTeardown}.
 * @param {object} [context] - Context object if already have one
 * @public
 * @returns {Promise<object>} Context object
 */
Mocha.prototype.runGlobalSetup = async function runGlobalSetup(context = {}) {
  const {globalSetup} = this.options;
  if (globalSetup && globalSetup.length) {
    debug('run(): global setup starting');
    await this._runGlobalFixtures(globalSetup, context);
    debug('run(): global setup complete');
  }
  return context;
};

/**
 * Run any global teardown fixtures sequentially, if any.
 *
 * This is _automatically called_ by {@link Mocha#run} _unless_ the `runGlobalTeardown` option is `false`; see {@link Mocha#enableGlobalTeardown}.
 *
 * Should be called with context object returned by {@link Mocha#runGlobalSetup}, if applicable.
 * @param {object} [context] - Context object if already have one
 * @public
 * @returns {Promise<object>} Context object
 */
Mocha.prototype.runGlobalTeardown = async function runGlobalTeardown(
  context = {}
) {
  const {globalTeardown} = this.options;
  if (globalTeardown && globalTeardown.length) {
    debug('run(): global teardown starting');
    await this._runGlobalFixtures(globalTeardown, context);
  }
  debug('run(): global teardown complete');
  return context;
};

/**
 * Run global fixtures sequentially with context `context`
 * @private
 * @param {MochaGlobalFixture[]} [fixtureFns] - Fixtures to run
 * @param {object} [context] - context object
 * @returns {Promise<object>} context object
 */
Mocha.prototype._runGlobalFixtures = async function _runGlobalFixtures(
  fixtureFns = [],
  context = {}
) {
  for await (const fixtureFn of fixtureFns) {
    await fixtureFn.call(context);
  }
  return context;
};

/**
 * Toggle execution of any global setup fixture(s)
 *
 * @chainable
 * @public
 * @param {boolean } [enabled=true] - If `false`, do not run global setup fixture
 * @returns {Mocha}
 */
Mocha.prototype.enableGlobalSetup = function enableGlobalSetup(enabled = true) {
  this.options.enableGlobalSetup = Boolean(enabled);
  return this;
};

/**
 * Toggle execution of any global teardown fixture(s)
 *
 * @chainable
 * @public
 * @param {boolean } [enabled=true] - If `false`, do not run global teardown fixture
 * @returns {Mocha}
 */
Mocha.prototype.enableGlobalTeardown = function enableGlobalTeardown(
  enabled = true
) {
  this.options.enableGlobalTeardown = Boolean(enabled);
  return this;
};

/**
 * Returns `true` if one or more global setup fixtures have been supplied.
 * @public
 * @returns {boolean}
 */
Mocha.prototype.hasGlobalSetupFixtures = function hasGlobalSetupFixtures() {
  return Boolean(this.options.globalSetup.length);
};

/**
 * Returns `true` if one or more global teardown fixtures have been supplied.
 * @public
 * @returns {boolean}
 */
Mocha.prototype.hasGlobalTeardownFixtures =
  function hasGlobalTeardownFixtures() {
    return Boolean(this.options.globalTeardown.length);
  };

/**
 * An alternative way to define root hooks that works with parallel runs.
 * @typedef {Object} MochaRootHookObject
 * @property {Function|Function[]} [beforeAll] - "Before all" hook(s)
 * @property {Function|Function[]} [beforeEach] - "Before each" hook(s)
 * @property {Function|Function[]} [afterAll] - "After all" hook(s)
 * @property {Function|Function[]} [afterEach] - "After each" hook(s)
 */

/**
 * An function that returns a {@link MochaRootHookObject}, either sync or async.
   @callback MochaRootHookFunction
 * @returns {MochaRootHookObject|Promise<MochaRootHookObject>}
 */

/**
 * A function that's invoked _once_ which is either sync or async.
 * Can be a "teardown" or "setup".  These will all share the same context.
 * @callback MochaGlobalFixture
 * @returns {void|Promise<void>}
 */

/**
 * An object making up all necessary parts of a plugin loader and aggregator
 * @typedef {Object} PluginDefinition
 * @property {string} exportName - Named export to use
 * @property {string} [optionName] - Option name for Mocha constructor (use `exportName` if omitted)
 * @property {PluginValidator} [validate] - Validator function
 * @property {PluginFinalizer} [finalize] - Finalizer/aggregator function
 */

/**
 * A (sync) function to assert a user-supplied plugin implementation is valid.
 *
 * Defined in a {@link PluginDefinition}.

 * @callback PluginValidator
 * @param {*} value - Value to check
 * @this {PluginDefinition}
 * @returns {void}
 */

/**
 * A function to finalize plugins impls of a particular ilk
 * @callback PluginFinalizer
 * @param {Array<*>} impls - User-supplied implementations
 * @returns {Promise<*>|*}
 */


/***/ }),

/***/ "../node_modules/mocha/lib/pending.js":
/*!********************************************!*\
  !*** ../node_modules/mocha/lib/pending.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


/**
 @module Pending
*/

module.exports = Pending;

/**
 * Initialize a new `Pending` error with the given message.
 *
 * @param {string} message
 */
function Pending(message) {
  this.message = message;
}


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/base.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/base.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Base
 */
/**
 * Module dependencies.
 */

var diff = __webpack_require__(/*! diff */ "../node_modules/diff/lib/index.js");
var milliseconds = __webpack_require__(/*! ms */ "../node_modules/ms/index.js");
var utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var supportsColor = __webpack_require__(/*! supports-color */ "?f7c4");
var symbols = __webpack_require__(/*! log-symbols */ "../node_modules/log-symbols/browser.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;

const isBrowser = utils.isBrowser();

function getBrowserWindowSize() {
  if ('innerHeight' in __webpack_require__.g) {
    return [__webpack_require__.g.innerHeight, __webpack_require__.g.innerWidth];
  }
  // In a Web Worker, the DOM Window is not available.
  return [640, 480];
}

/**
 * Expose `Base`.
 */

exports = module.exports = Base;

/**
 * Check if both stdio streams are associated with a tty.
 */

var isatty = isBrowser || (process.stdout.isTTY && process.stderr.isTTY);

/**
 * Save log references to avoid tests interfering (see GH-3604).
 */
var consoleLog = console.log;

/**
 * Enable coloring by default, except in the browser interface.
 */

exports.useColors =
  !isBrowser &&
  (supportsColor.stdout || process.env.MOCHA_COLORS !== undefined);

/**
 * Inline diffs instead of +/-
 */

exports.inlineDiffs = false;

/**
 * Truncate diffs longer than this value to avoid slow performance
 */
exports.maxDiffSize = 8192;

/**
 * Default color map.
 */

exports.colors = {
  pass: 90,
  fail: 31,
  'bright pass': 92,
  'bright fail': 91,
  'bright yellow': 93,
  pending: 36,
  suite: 0,
  'error title': 0,
  'error message': 31,
  'error stack': 90,
  checkmark: 32,
  fast: 90,
  medium: 33,
  slow: 31,
  green: 32,
  light: 90,
  'diff gutter': 90,
  'diff added': 32,
  'diff removed': 31,
  'diff added inline': '30;42',
  'diff removed inline': '30;41'
};

/**
 * Default symbol map.
 */

exports.symbols = {
  ok: symbols.success,
  err: symbols.error,
  dot: '.',
  comma: ',',
  bang: '!'
};

/**
 * Color `str` with the given `type`,
 * allowing colors to be disabled,
 * as well as user-defined color
 * schemes.
 *
 * @private
 * @param {string} type
 * @param {string} str
 * @return {string}
 */
var color = (exports.color = function (type, str) {
  if (!exports.useColors) {
    return String(str);
  }
  return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m';
});

/**
 * Expose term window size, with some defaults for when stderr is not a tty.
 */

exports.window = {
  width: 75
};

if (isatty) {
  if (isBrowser) {
    exports.window.width = getBrowserWindowSize()[1];
  } else {
    exports.window.width = process.stdout.getWindowSize(1)[0];
  }
}

/**
 * Expose some basic cursor interactions that are common among reporters.
 */

exports.cursor = {
  hide: function () {
    isatty && process.stdout.write('\u001b[?25l');
  },

  show: function () {
    isatty && process.stdout.write('\u001b[?25h');
  },

  deleteLine: function () {
    isatty && process.stdout.write('\u001b[2K');
  },

  beginningOfLine: function () {
    isatty && process.stdout.write('\u001b[0G');
  },

  CR: function () {
    if (isatty) {
      exports.cursor.deleteLine();
      exports.cursor.beginningOfLine();
    } else {
      process.stdout.write('\r');
    }
  }
};

var showDiff = (exports.showDiff = function (err) {
  return (
    err &&
    err.showDiff !== false &&
    sameType(err.actual, err.expected) &&
    err.expected !== undefined
  );
});

function stringifyDiffObjs(err) {
  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {
    err.actual = utils.stringify(err.actual);
    err.expected = utils.stringify(err.expected);
  }
}

/**
 * Returns a diff between 2 strings with coloured ANSI output.
 *
 * @description
 * The diff will be either inline or unified dependent on the value
 * of `Base.inlineDiff`.
 *
 * @param {string} actual
 * @param {string} expected
 * @return {string} Diff
 */

var generateDiff = (exports.generateDiff = function (actual, expected) {
  try {
    var maxLen = exports.maxDiffSize;
    var skipped = 0;
    if (maxLen > 0) {
      skipped = Math.max(actual.length - maxLen, expected.length - maxLen);
      actual = actual.slice(0, maxLen);
      expected = expected.slice(0, maxLen);
    }
    let result = exports.inlineDiffs
      ? inlineDiff(actual, expected)
      : unifiedDiff(actual, expected);
    if (skipped > 0) {
      result = `${result}\n      [mocha] output truncated to ${maxLen} characters, see "maxDiffSize" reporter-option\n`;
    }
    return result;
  } catch (err) {
    var msg =
      '\n      ' +
      color('diff added', '+ expected') +
      ' ' +
      color('diff removed', '- actual:  failed to generate Mocha diff') +
      '\n';
    return msg;
  }
});

/**
 * Outputs the given `failures` as a list.
 *
 * @public
 * @memberof Mocha.reporters.Base
 * @variation 1
 * @param {Object[]} failures - Each is Test instance with corresponding
 *     Error property
 */
exports.list = function (failures) {
  var multipleErr, multipleTest;
  Base.consoleLog();
  failures.forEach(function (test, i) {
    // format
    var fmt =
      color('error title', '  %s) %s:\n') +
      color('error message', '     %s') +
      color('error stack', '\n%s\n');

    // msg
    var msg;
    var err;
    if (test.err && test.err.multiple) {
      if (multipleTest !== test) {
        multipleTest = test;
        multipleErr = [test.err].concat(test.err.multiple);
      }
      err = multipleErr.shift();
    } else {
      err = test.err;
    }
    var message;
    if (typeof err.inspect === 'function') {
      message = err.inspect() + '';
    } else if (err.message && typeof err.message.toString === 'function') {
      message = err.message + '';
    } else {
      message = '';
    }
    var stack = err.stack || message;
    var index = message ? stack.indexOf(message) : -1;

    if (index === -1) {
      msg = message;
    } else {
      index += message.length;
      msg = stack.slice(0, index);
      // remove msg from stack
      stack = stack.slice(index + 1);
    }

    // uncaught
    if (err.uncaught) {
      msg = 'Uncaught ' + msg;
    }
    // explicitly show diff
    if (!exports.hideDiff && showDiff(err)) {
      stringifyDiffObjs(err);
      fmt =
        color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n');
      var match = message.match(/^([^:]+): expected/);
      msg = '\n      ' + color('error message', match ? match[1] : msg);

      msg += generateDiff(err.actual, err.expected);
    }

    // indent stack trace
    stack = stack.replace(/^/gm, '  ');

    // indented test title
    var testTitle = '';
    test.titlePath().forEach(function (str, index) {
      if (index !== 0) {
        testTitle += '\n     ';
      }
      for (var i = 0; i < index; i++) {
        testTitle += '  ';
      }
      testTitle += str;
    });

    Base.consoleLog(fmt, i + 1, testTitle, msg, stack);
  });
};

/**
 * Constructs a new `Base` reporter instance.
 *
 * @description
 * All other reporters generally inherit from this reporter.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Base(runner, options) {
  var failures = (this.failures = []);

  if (!runner) {
    throw new TypeError('Missing runner argument');
  }
  this.options = options || {};
  this.runner = runner;
  this.stats = runner.stats; // assigned so Reporters keep a closer reference

  var maxDiffSizeOpt =
    this.options.reporterOption && this.options.reporterOption.maxDiffSize;
  if (maxDiffSizeOpt !== undefined && !isNaN(Number(maxDiffSizeOpt))) {
    exports.maxDiffSize = Number(maxDiffSizeOpt);
  }

  runner.on(EVENT_TEST_PASS, function (test) {
    if (test.duration > test.slow()) {
      test.speed = 'slow';
    } else if (test.duration > test.slow() / 2) {
      test.speed = 'medium';
    } else {
      test.speed = 'fast';
    }
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    if (showDiff(err)) {
      stringifyDiffObjs(err);
    }
    // more than one error per test
    if (test.err && err instanceof Error) {
      test.err.multiple = (test.err.multiple || []).concat(err);
    } else {
      test.err = err;
    }
    failures.push(test);
  });
}

/**
 * Outputs common epilogue used by many of the bundled reporters.
 *
 * @public
 * @memberof Mocha.reporters
 */
Base.prototype.epilogue = function () {
  var stats = this.stats;
  var fmt;

  Base.consoleLog();

  // passes
  fmt =
    color('bright pass', ' ') +
    color('green', ' %d passing') +
    color('light', ' (%s)');

  Base.consoleLog(fmt, stats.passes || 0, milliseconds(stats.duration));

  // pending
  if (stats.pending) {
    fmt = color('pending', ' ') + color('pending', ' %d pending');

    Base.consoleLog(fmt, stats.pending);
  }

  // failures
  if (stats.failures) {
    fmt = color('fail', '  %d failing');

    Base.consoleLog(fmt, stats.failures);

    Base.list(this.failures);
    Base.consoleLog();
  }

  Base.consoleLog();
};

/**
 * Pads the given `str` to `len`.
 *
 * @private
 * @param {string} str
 * @param {string} len
 * @return {string}
 */
function pad(str, len) {
  str = String(str);
  return Array(len - str.length + 1).join(' ') + str;
}

/**
 * Returns inline diff between 2 strings with coloured ANSI output.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} Diff
 */
function inlineDiff(actual, expected) {
  var msg = errorDiff(actual, expected);

  // linenos
  var lines = msg.split('\n');
  if (lines.length > 4) {
    var width = String(lines.length).length;
    msg = lines
      .map(function (str, i) {
        return pad(++i, width) + ' |' + ' ' + str;
      })
      .join('\n');
  }

  // legend
  msg =
    '\n' +
    color('diff removed inline', 'actual') +
    ' ' +
    color('diff added inline', 'expected') +
    '\n\n' +
    msg +
    '\n';

  // indent
  msg = msg.replace(/^/gm, '      ');
  return msg;
}

/**
 * Returns unified diff between two strings with coloured ANSI output.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} The diff.
 */
function unifiedDiff(actual, expected) {
  var indent = '      ';
  function cleanUp(line) {
    if (line[0] === '+') {
      return indent + colorLines('diff added', line);
    }
    if (line[0] === '-') {
      return indent + colorLines('diff removed', line);
    }
    if (line.match(/@@/)) {
      return '--';
    }
    if (line.match(/\\ No newline/)) {
      return null;
    }
    return indent + line;
  }
  function notBlank(line) {
    return typeof line !== 'undefined' && line !== null;
  }
  var msg = diff.createPatch('string', actual, expected);
  var lines = msg.split('\n').splice(5);
  return (
    '\n      ' +
    colorLines('diff added', '+ expected') +
    ' ' +
    colorLines('diff removed', '- actual') +
    '\n\n' +
    lines.map(cleanUp).filter(notBlank).join('\n')
  );
}

/**
 * Returns character diff for `err`.
 *
 * @private
 * @param {String} actual
 * @param {String} expected
 * @return {string} the diff
 */
function errorDiff(actual, expected) {
  return diff
    .diffWordsWithSpace(actual, expected)
    .map(function (str) {
      if (str.added) {
        return colorLines('diff added inline', str.value);
      }
      if (str.removed) {
        return colorLines('diff removed inline', str.value);
      }
      return str.value;
    })
    .join('');
}

/**
 * Colors lines for `str`, using the color `name`.
 *
 * @private
 * @param {string} name
 * @param {string} str
 * @return {string}
 */
function colorLines(name, str) {
  return str
    .split('\n')
    .map(function (str) {
      return color(name, str);
    })
    .join('\n');
}

/**
 * Object#toString reference.
 */
var objToString = Object.prototype.toString;

/**
 * Checks that a / b have the same type.
 *
 * @private
 * @param {Object} a
 * @param {Object} b
 * @return {boolean}
 */
function sameType(a, b) {
  return objToString.call(a) === objToString.call(b);
}

Base.consoleLog = consoleLog;

Base.abstract = true;


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/doc.js":
/*!**************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/doc.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * @module Doc
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;

/**
 * Expose `Doc`.
 */

exports = module.exports = Doc;

/**
 * Constructs a new `Doc` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Doc(runner, options) {
  Base.call(this, runner, options);

  var indents = 2;

  function indent() {
    return Array(indents).join('  ');
  }

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    if (suite.root) {
      return;
    }
    ++indents;
    Base.consoleLog('%s<section class="suite">', indent());
    ++indents;
    Base.consoleLog('%s<h1>%s</h1>', indent(), utils.escape(suite.title));
    Base.consoleLog('%s<dl>', indent());
  });

  runner.on(EVENT_SUITE_END, function (suite) {
    if (suite.root) {
      return;
    }
    Base.consoleLog('%s</dl>', indent());
    --indents;
    Base.consoleLog('%s</section>', indent());
    --indents;
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.title));
    Base.consoleLog('%s  <dt>%s</dt>', indent(), utils.escape(test.file));
    var code = utils.escape(utils.clean(test.body));
    Base.consoleLog('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    Base.consoleLog(
      '%s  <dt class="error">%s</dt>',
      indent(),
      utils.escape(test.title)
    );
    Base.consoleLog(
      '%s  <dt class="error">%s</dt>',
      indent(),
      utils.escape(test.file)
    );
    var code = utils.escape(utils.clean(test.body));
    Base.consoleLog(
      '%s  <dd class="error"><pre><code>%s</code></pre></dd>',
      indent(),
      code
    );
    Base.consoleLog(
      '%s  <dd class="error">%s</dd>',
      indent(),
      utils.escape(err)
    );
  });
}

Doc.description = 'HTML documentation';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/dot.js":
/*!**************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/dot.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Dot
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `Dot`.
 */

exports = module.exports = Dot;

/**
 * Constructs a new `Dot` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Dot(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var n = -1;

  runner.on(EVENT_RUN_BEGIN, function () {
    process.stdout.write('\n');
  });

  runner.on(EVENT_TEST_PENDING, function () {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    process.stdout.write(Base.color('pending', Base.symbols.comma));
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    if (test.speed === 'slow') {
      process.stdout.write(Base.color('bright yellow', Base.symbols.dot));
    } else {
      process.stdout.write(Base.color(test.speed, Base.symbols.dot));
    }
  });

  runner.on(EVENT_TEST_FAIL, function () {
    if (++n % width === 0) {
      process.stdout.write('\n  ');
    }
    process.stdout.write(Base.color('fail', Base.symbols.bang));
  });

  runner.once(EVENT_RUN_END, function () {
    process.stdout.write('\n');
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Dot, Base);

Dot.description = 'dot matrix representation';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/html.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/html.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


/* eslint-env browser */
/**
 * @module HTML
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var Progress = __webpack_require__(/*! ../browser/progress */ "../node_modules/mocha/lib/browser/progress.js");
var escapeRe = __webpack_require__(/*! escape-string-regexp */ "../node_modules/escape-string-regexp/index.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = __webpack_require__.g.Date;

/**
 * Expose `HTML`.
 */

exports = module.exports = HTML;

/**
 * Stats template.
 */

var statsTemplate =
  '<ul id="mocha-stats">' +
  '<li class="progress"><canvas width="40" height="40"></canvas></li>' +
  '<li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li>' +
  '<li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li>' +
  '<li class="duration">duration: <em>0</em>s</li>' +
  '</ul>';

var playIcon = '&#x2023;';

/**
 * Constructs a new `HTML` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function HTML(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var stats = this.stats;
  var stat = fragment(statsTemplate);
  var items = stat.getElementsByTagName('li');
  var passes = items[1].getElementsByTagName('em')[0];
  var passesLink = items[1].getElementsByTagName('a')[0];
  var failures = items[2].getElementsByTagName('em')[0];
  var failuresLink = items[2].getElementsByTagName('a')[0];
  var duration = items[3].getElementsByTagName('em')[0];
  var canvas = stat.getElementsByTagName('canvas')[0];
  var report = fragment('<ul id="mocha-report"></ul>');
  var stack = [report];
  var progress;
  var ctx;
  var root = document.getElementById('mocha');

  if (canvas.getContext) {
    var ratio = window.devicePixelRatio || 1;
    canvas.style.width = canvas.width;
    canvas.style.height = canvas.height;
    canvas.width *= ratio;
    canvas.height *= ratio;
    ctx = canvas.getContext('2d');
    ctx.scale(ratio, ratio);
    progress = new Progress();
  }

  if (!root) {
    return error('#mocha div missing, add it to your document');
  }

  // pass toggle
  on(passesLink, 'click', function (evt) {
    evt.preventDefault();
    unhide();
    var name = /pass/.test(report.className) ? '' : ' pass';
    report.className = report.className.replace(/fail|pass/g, '') + name;
    if (report.className.trim()) {
      hideSuitesWithout('test pass');
    }
  });

  // failure toggle
  on(failuresLink, 'click', function (evt) {
    evt.preventDefault();
    unhide();
    var name = /fail/.test(report.className) ? '' : ' fail';
    report.className = report.className.replace(/fail|pass/g, '') + name;
    if (report.className.trim()) {
      hideSuitesWithout('test fail');
    }
  });

  root.appendChild(stat);
  root.appendChild(report);

  if (progress) {
    progress.size(40);
  }

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    if (suite.root) {
      return;
    }

    // suite
    var url = self.suiteURL(suite);
    var el = fragment(
      '<li class="suite"><h1><a href="%s">%s</a></h1></li>',
      url,
      escape(suite.title)
    );

    // container
    stack[0].appendChild(el);
    stack.unshift(document.createElement('ul'));
    el.appendChild(stack[0]);
  });

  runner.on(EVENT_SUITE_END, function (suite) {
    if (suite.root) {
      updateStats();
      return;
    }
    stack.shift();
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var url = self.testURL(test);
    var markup =
      '<li class="test pass %e"><h2>%e<span class="duration">%ems</span> ' +
      '<a href="%s" class="replay">' +
      playIcon +
      '</a></h2></li>';
    var el = fragment(markup, test.speed, test.title, test.duration, url);
    self.addCodeToggle(el, test.body);
    appendToStack(el);
    updateStats();
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    var el = fragment(
      '<li class="test fail"><h2>%e <a href="%e" class="replay">' +
        playIcon +
        '</a></h2></li>',
      test.title,
      self.testURL(test)
    );
    var stackString; // Note: Includes leading newline
    var message = test.err.toString();

    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
    // check for the result of the stringifying.
    if (message === '[object Error]') {
      message = test.err.message;
    }

    if (test.err.stack) {
      var indexOfMessage = test.err.stack.indexOf(test.err.message);
      if (indexOfMessage === -1) {
        stackString = test.err.stack;
      } else {
        stackString = test.err.stack.slice(
          test.err.message.length + indexOfMessage
        );
      }
    } else if (test.err.sourceURL && test.err.line !== undefined) {
      // Safari doesn't give you a stack. Let's at least provide a source line.
      stackString = '\n(' + test.err.sourceURL + ':' + test.err.line + ')';
    }

    stackString = stackString || '';

    if (test.err.htmlMessage && stackString) {
      el.appendChild(
        fragment(
          '<div class="html-error">%s\n<pre class="error">%e</pre></div>',
          test.err.htmlMessage,
          stackString
        )
      );
    } else if (test.err.htmlMessage) {
      el.appendChild(
        fragment('<div class="html-error">%s</div>', test.err.htmlMessage)
      );
    } else {
      el.appendChild(
        fragment('<pre class="error">%e%e</pre>', message, stackString)
      );
    }

    self.addCodeToggle(el, test.body);
    appendToStack(el);
    updateStats();
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var el = fragment(
      '<li class="test pass pending"><h2>%e</h2></li>',
      test.title
    );
    appendToStack(el);
    updateStats();
  });

  function appendToStack(el) {
    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
    if (stack[0]) {
      stack[0].appendChild(el);
    }
  }

  function updateStats() {
    // TODO: add to stats
    var percent = ((stats.tests / runner.total) * 100) | 0;
    if (progress) {
      progress.update(percent).draw(ctx);
    }

    // update stats
    var ms = new Date() - stats.start;
    text(passes, stats.passes);
    text(failures, stats.failures);
    text(duration, (ms / 1000).toFixed(2));
  }
}

/**
 * Makes a URL, preserving querystring ("search") parameters.
 *
 * @param {string} s
 * @return {string} A new URL.
 */
function makeUrl(s) {
  var search = window.location.search;

  // Remove previous grep query parameter if present
  if (search) {
    search = search.replace(/[?&]grep=[^&\s]*/g, '').replace(/^&/, '?');
  }

  return (
    window.location.pathname +
    (search ? search + '&' : '?') +
    'grep=' +
    encodeURIComponent(escapeRe(s))
  );
}

/**
 * Provide suite URL.
 *
 * @param {Object} [suite]
 */
HTML.prototype.suiteURL = function (suite) {
  return makeUrl(suite.fullTitle());
};

/**
 * Provide test URL.
 *
 * @param {Object} [test]
 */
HTML.prototype.testURL = function (test) {
  return makeUrl(test.fullTitle());
};

/**
 * Adds code toggle functionality for the provided test's list element.
 *
 * @param {HTMLLIElement} el
 * @param {string} contents
 */
HTML.prototype.addCodeToggle = function (el, contents) {
  var h2 = el.getElementsByTagName('h2')[0];

  on(h2, 'click', function () {
    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';
  });

  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));
  el.appendChild(pre);
  pre.style.display = 'none';
};

/**
 * Display error `msg`.
 *
 * @param {string} msg
 */
function error(msg) {
  document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
}

/**
 * Return a DOM fragment from `html`.
 *
 * @param {string} html
 */
function fragment(html) {
  var args = arguments;
  var div = document.createElement('div');
  var i = 1;

  div.innerHTML = html.replace(/%([se])/g, function (_, type) {
    switch (type) {
      case 's':
        return String(args[i++]);
      case 'e':
        return escape(args[i++]);
      // no default
    }
  });

  return div.firstChild;
}

/**
 * Check for suites that do not have elements
 * with `classname`, and hide them.
 *
 * @param {text} classname
 */
function hideSuitesWithout(classname) {
  var suites = document.getElementsByClassName('suite');
  for (var i = 0; i < suites.length; i++) {
    var els = suites[i].getElementsByClassName(classname);
    if (!els.length) {
      suites[i].className += ' hidden';
    }
  }
}

/**
 * Unhide .hidden suites.
 */
function unhide() {
  var els = document.getElementsByClassName('suite hidden');
  while (els.length > 0) {
    els[0].className = els[0].className.replace('suite hidden', 'suite');
  }
}

/**
 * Set an element's text contents.
 *
 * @param {HTMLElement} el
 * @param {string} contents
 */
function text(el, contents) {
  if (el.textContent) {
    el.textContent = contents;
  } else {
    el.innerText = contents;
  }
}

/**
 * Listen on `event` with callback `fn`.
 */
function on(el, event, fn) {
  if (el.addEventListener) {
    el.addEventListener(event, fn, false);
  } else {
    el.attachEvent('on' + event, fn);
  }
}

HTML.browserOnly = true;


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/index.js":
/*!****************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Alias exports to a their normalized format Mocha#reporter to prevent a need
// for dynamic (try/catch) requires, which Browserify doesn't handle.
exports.Base = exports.base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
exports.Dot = exports.dot = __webpack_require__(/*! ./dot */ "../node_modules/mocha/lib/reporters/dot.js");
exports.Doc = exports.doc = __webpack_require__(/*! ./doc */ "../node_modules/mocha/lib/reporters/doc.js");
exports.TAP = exports.tap = __webpack_require__(/*! ./tap */ "../node_modules/mocha/lib/reporters/tap.js");
exports.JSON = exports.json = __webpack_require__(/*! ./json */ "../node_modules/mocha/lib/reporters/json.js");
exports.HTML = exports.html = __webpack_require__(/*! ./html */ "../node_modules/mocha/lib/reporters/html.js");
exports.List = exports.list = __webpack_require__(/*! ./list */ "../node_modules/mocha/lib/reporters/list.js");
exports.Min = exports.min = __webpack_require__(/*! ./min */ "../node_modules/mocha/lib/reporters/min.js");
exports.Spec = exports.spec = __webpack_require__(/*! ./spec */ "../node_modules/mocha/lib/reporters/spec.js");
exports.Nyan = exports.nyan = __webpack_require__(/*! ./nyan */ "../node_modules/mocha/lib/reporters/nyan.js");
exports.XUnit = exports.xunit = __webpack_require__(/*! ./xunit */ "../node_modules/mocha/lib/reporters/xunit.js");
exports.Markdown = exports.markdown = __webpack_require__(/*! ./markdown */ "../node_modules/mocha/lib/reporters/markdown.js");
exports.Progress = exports.progress = __webpack_require__(/*! ./progress */ "../node_modules/mocha/lib/reporters/progress.js");
exports.Landing = exports.landing = __webpack_require__(/*! ./landing */ "../node_modules/mocha/lib/reporters/landing.js");
exports.JSONStream = exports["json-stream"] = __webpack_require__(/*! ./json-stream */ "../node_modules/mocha/lib/reporters/json-stream.js");


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/json-stream.js":
/*!**********************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/json-stream.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module JSONStream
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `JSONStream`.
 */

exports = module.exports = JSONStream;

/**
 * Constructs a new `JSONStream` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function JSONStream(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var total = runner.total;

  runner.once(EVENT_RUN_BEGIN, function () {
    writeEvent(['start', {total: total}]);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    writeEvent(['pass', clean(test)]);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    test = clean(test);
    test.err = err.message;
    test.stack = err.stack || null;
    writeEvent(['fail', test]);
  });

  runner.once(EVENT_RUN_END, function () {
    writeEvent(['end', self.stats]);
  });
}

/**
 * Mocha event to be written to the output stream.
 * @typedef {Array} JSONStream~MochaEvent
 */

/**
 * Writes Mocha event to reporter output stream.
 *
 * @private
 * @param {JSONStream~MochaEvent} event - Mocha event to be output.
 */
function writeEvent(event) {
  process.stdout.write(JSON.stringify(event) + '\n');
}

/**
 * Returns an object literal representation of `test`
 * free of cyclic properties, etc.
 *
 * @private
 * @param {Test} test - Instance used as data source.
 * @return {Object} object containing pared-down test instance data
 */
function clean(test) {
  return {
    title: test.title,
    fullTitle: test.fullTitle(),
    file: test.file,
    duration: test.duration,
    currentRetry: test.currentRetry(),
    speed: test.speed
  };
}

JSONStream.description = 'newline delimited JSON events';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/json.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/json.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module JSON
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var fs = __webpack_require__(/*! fs */ "?b9ec");
var path = __webpack_require__(/*! path */ "?4389");
const createUnsupportedError = (__webpack_require__(/*! ../errors */ "../node_modules/mocha/lib/errors.js").createUnsupportedError);
const utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var EVENT_RUN_END = constants.EVENT_RUN_END;

/**
 * Expose `JSON`.
 */

exports = module.exports = JSONReporter;

/**
 * Constructs a new `JSON` reporter instance.
 *
 * @public
 * @class JSON
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function JSONReporter(runner, options = {}) {
  Base.call(this, runner, options);

  var self = this;
  var tests = [];
  var pending = [];
  var failures = [];
  var passes = [];
  var output;

  if (options.reporterOption && options.reporterOption.output) {
    if (utils.isBrowser()) {
      throw createUnsupportedError('file output not supported in browser');
    }
    output = options.reporterOption.output;
  }

  runner.on(EVENT_TEST_END, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    passes.push(test);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    failures.push(test);
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    pending.push(test);
  });

  runner.once(EVENT_RUN_END, function () {
    var obj = {
      stats: self.stats,
      tests: tests.map(clean),
      pending: pending.map(clean),
      failures: failures.map(clean),
      passes: passes.map(clean)
    };

    runner.testResults = obj;

    var json = JSON.stringify(obj, null, 2);
    if (output) {
      try {
        fs.mkdirSync(path.dirname(output), {recursive: true});
        fs.writeFileSync(output, json);
      } catch (err) {
        console.error(
          `${Base.symbols.err} [mocha] writing output to "${output}" failed: ${err.message}\n`
        );
        process.stdout.write(json);
      }
    } else {
      process.stdout.write(json);
    }
  });
}

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @private
 * @param {Object} test
 * @return {Object}
 */
function clean(test) {
  var err = test.err || {};
  if (err instanceof Error) {
    err = errorJSON(err);
  }

  return {
    title: test.title,
    fullTitle: test.fullTitle(),
    file: test.file,
    duration: test.duration,
    currentRetry: test.currentRetry(),
    speed: test.speed,
    err: cleanCycles(err)
  };
}

/**
 * Replaces any circular references inside `obj` with '[object Object]'
 *
 * @private
 * @param {Object} obj
 * @return {Object}
 */
function cleanCycles(obj) {
  var cache = [];
  return JSON.parse(
    JSON.stringify(obj, function (key, value) {
      if (typeof value === 'object' && value !== null) {
        if (cache.indexOf(value) !== -1) {
          // Instead of going in a circle, we'll print [object Object]
          return '' + value;
        }
        cache.push(value);
      }

      return value;
    })
  );
}

/**
 * Transform an Error object into a JSON object.
 *
 * @private
 * @param {Error} err
 * @return {Object}
 */
function errorJSON(err) {
  var res = {};
  Object.getOwnPropertyNames(err).forEach(function (key) {
    res[key] = err[key];
  }, err);
  return res;
}

JSONReporter.description = 'single JSON object';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/landing.js":
/*!******************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/landing.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Landing
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var STATE_FAILED = (__webpack_require__(/*! ../runnable */ "../node_modules/mocha/lib/runnable.js").constants.STATE_FAILED);

var cursor = Base.cursor;
var color = Base.color;

/**
 * Expose `Landing`.
 */

exports = module.exports = Landing;

/**
 * Airplane color.
 */

Base.colors.plane = 0;

/**
 * Airplane crash color.
 */

Base.colors['plane crash'] = 31;

/**
 * Runway color.
 */

Base.colors.runway = 90;

/**
 * Constructs a new `Landing` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Landing(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var stream = process.stdout;

  var plane = color('plane', '');
  var crashed = -1;
  var n = 0;
  var total = 0;

  function runway() {
    var buf = Array(width).join('-');
    return '  ' + color('runway', buf);
  }

  runner.on(EVENT_RUN_BEGIN, function () {
    stream.write('\n\n\n  ');
    cursor.hide();
  });

  runner.on(EVENT_TEST_END, function (test) {
    // check if the plane crashed
    var col = crashed === -1 ? ((width * ++n) / ++total) | 0 : crashed;
    // show the crash
    if (test.state === STATE_FAILED) {
      plane = color('plane crash', '');
      crashed = col;
    }

    // render landing strip
    stream.write('\u001b[' + (width + 1) + 'D\u001b[2A');
    stream.write(runway());
    stream.write('\n  ');
    stream.write(color('runway', Array(col).join('')));
    stream.write(plane);
    stream.write(color('runway', Array(width - col).join('') + '\n'));
    stream.write(runway());
    stream.write('\u001b[0m');
  });

  runner.once(EVENT_RUN_END, function () {
    cursor.show();
    process.stdout.write('\n');
    self.epilogue();
  });

  // if cursor is hidden when we ctrl-C, then it will remain hidden unless...
  process.once('SIGINT', function () {
    cursor.show();
    process.nextTick(function () {
      process.kill(process.pid, 'SIGINT');
    });
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Landing, Base);

Landing.description = 'Unicode landing strip';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/list.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/list.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module List
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var color = Base.color;
var cursor = Base.cursor;

/**
 * Expose `List`.
 */

exports = module.exports = List;

/**
 * Constructs a new `List` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function List(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var n = 0;

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.consoleLog();
  });

  runner.on(EVENT_TEST_BEGIN, function (test) {
    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var fmt = color('checkmark', '  -') + color('pending', ' %s');
    Base.consoleLog(fmt, test.fullTitle());
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var fmt =
      color('checkmark', '  ' + Base.symbols.ok) +
      color('pass', ' %s: ') +
      color(test.speed, '%dms');
    cursor.CR();
    Base.consoleLog(fmt, test.fullTitle(), test.duration);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    cursor.CR();
    Base.consoleLog(color('fail', '  %d) %s'), ++n, test.fullTitle());
  });

  runner.once(EVENT_RUN_END, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(List, Base);

List.description = 'like "spec" reporter but flat';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/markdown.js":
/*!*******************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/markdown.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Markdown
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;

/**
 * Constants
 */

var SUITE_PREFIX = '$';

/**
 * Expose `Markdown`.
 */

exports = module.exports = Markdown;

/**
 * Constructs a new `Markdown` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Markdown(runner, options) {
  Base.call(this, runner, options);

  var level = 0;
  var buf = '';

  function title(str) {
    return Array(level).join('#') + ' ' + str;
  }

  function mapTOC(suite, obj) {
    var ret = obj;
    var key = SUITE_PREFIX + suite.title;

    obj = obj[key] = obj[key] || {suite: suite};
    suite.suites.forEach(function (suite) {
      mapTOC(suite, obj);
    });

    return ret;
  }

  function stringifyTOC(obj, level) {
    ++level;
    var buf = '';
    var link;
    for (var key in obj) {
      if (key === 'suite') {
        continue;
      }
      if (key !== SUITE_PREFIX) {
        link = ' - [' + key.substring(1) + ']';
        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\n';
        buf += Array(level).join('  ') + link;
      }
      buf += stringifyTOC(obj[key], level);
    }
    return buf;
  }

  function generateTOC(suite) {
    var obj = mapTOC(suite, {});
    return stringifyTOC(obj, 0);
  }

  generateTOC(runner.suite);

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    ++level;
    var slug = utils.slug(suite.fullTitle());
    buf += '<a name="' + slug + '"></a>' + '\n';
    buf += title(suite.title) + '\n';
  });

  runner.on(EVENT_SUITE_END, function () {
    --level;
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var code = utils.clean(test.body);
    buf += test.title + '.\n';
    buf += '\n```js\n';
    buf += code + '\n';
    buf += '```\n\n';
  });

  runner.once(EVENT_RUN_END, function () {
    process.stdout.write('# TOC\n');
    process.stdout.write(generateTOC(runner.suite));
    process.stdout.write(buf);
  });
}

Markdown.description = 'GitHub Flavored Markdown';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/min.js":
/*!**************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/min.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Min
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;

/**
 * Expose `Min`.
 */

exports = module.exports = Min;

/**
 * Constructs a new `Min` reporter instance.
 *
 * @description
 * This minimal test reporter is best used with '--watch'.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Min(runner, options) {
  Base.call(this, runner, options);

  runner.on(EVENT_RUN_BEGIN, function () {
    // clear screen
    process.stdout.write('\u001b[2J');
    // set cursor position
    process.stdout.write('\u001b[1;3H');
  });

  runner.once(EVENT_RUN_END, this.epilogue.bind(this));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Min, Base);

Min.description = 'essentially just a summary';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/nyan.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/nyan.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Nyan
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;

/**
 * Expose `Dot`.
 */

exports = module.exports = NyanCat;

/**
 * Constructs a new `Nyan` reporter instance.
 *
 * @public
 * @class Nyan
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function NyanCat(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.75) | 0;
  var nyanCatWidth = (this.nyanCatWidth = 11);

  this.colorIndex = 0;
  this.numberOfLines = 4;
  this.rainbowColors = self.generateColors();
  this.scoreboardWidth = 5;
  this.tick = 0;
  this.trajectories = [[], [], [], []];
  this.trajectoryWidthMax = width - nyanCatWidth;

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.cursor.hide();
    self.draw();
  });

  runner.on(EVENT_TEST_PENDING, function () {
    self.draw();
  });

  runner.on(EVENT_TEST_PASS, function () {
    self.draw();
  });

  runner.on(EVENT_TEST_FAIL, function () {
    self.draw();
  });

  runner.once(EVENT_RUN_END, function () {
    Base.cursor.show();
    for (var i = 0; i < self.numberOfLines; i++) {
      write('\n');
    }
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(NyanCat, Base);

/**
 * Draw the nyan cat
 *
 * @private
 */

NyanCat.prototype.draw = function () {
  this.appendRainbow();
  this.drawScoreboard();
  this.drawRainbow();
  this.drawNyanCat();
  this.tick = !this.tick;
};

/**
 * Draw the "scoreboard" showing the number
 * of passes, failures and pending tests.
 *
 * @private
 */

NyanCat.prototype.drawScoreboard = function () {
  var stats = this.stats;

  function draw(type, n) {
    write(' ');
    write(Base.color(type, n));
    write('\n');
  }

  draw('green', stats.passes);
  draw('fail', stats.failures);
  draw('pending', stats.pending);
  write('\n');

  this.cursorUp(this.numberOfLines);
};

/**
 * Append the rainbow.
 *
 * @private
 */

NyanCat.prototype.appendRainbow = function () {
  var segment = this.tick ? '_' : '-';
  var rainbowified = this.rainbowify(segment);

  for (var index = 0; index < this.numberOfLines; index++) {
    var trajectory = this.trajectories[index];
    if (trajectory.length >= this.trajectoryWidthMax) {
      trajectory.shift();
    }
    trajectory.push(rainbowified);
  }
};

/**
 * Draw the rainbow.
 *
 * @private
 */

NyanCat.prototype.drawRainbow = function () {
  var self = this;

  this.trajectories.forEach(function (line) {
    write('\u001b[' + self.scoreboardWidth + 'C');
    write(line.join(''));
    write('\n');
  });

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw the nyan cat
 *
 * @private
 */
NyanCat.prototype.drawNyanCat = function () {
  var self = this;
  var startWidth = this.scoreboardWidth + this.trajectories[0].length;
  var dist = '\u001b[' + startWidth + 'C';
  var padding = '';

  write(dist);
  write('_,------,');
  write('\n');

  write(dist);
  padding = self.tick ? '  ' : '   ';
  write('_|' + padding + '/\\_/\\ ');
  write('\n');

  write(dist);
  padding = self.tick ? '_' : '__';
  var tail = self.tick ? '~' : '^';
  write(tail + '|' + padding + this.face() + ' ');
  write('\n');

  write(dist);
  padding = self.tick ? ' ' : '  ';
  write(padding + '""  "" ');
  write('\n');

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw nyan cat face.
 *
 * @private
 * @return {string}
 */

NyanCat.prototype.face = function () {
  var stats = this.stats;
  if (stats.failures) {
    return '( x .x)';
  } else if (stats.pending) {
    return '( o .o)';
  } else if (stats.passes) {
    return '( ^ .^)';
  }
  return '( - .-)';
};

/**
 * Move cursor up `n`.
 *
 * @private
 * @param {number} n
 */

NyanCat.prototype.cursorUp = function (n) {
  write('\u001b[' + n + 'A');
};

/**
 * Move cursor down `n`.
 *
 * @private
 * @param {number} n
 */

NyanCat.prototype.cursorDown = function (n) {
  write('\u001b[' + n + 'B');
};

/**
 * Generate rainbow colors.
 *
 * @private
 * @return {Array}
 */
NyanCat.prototype.generateColors = function () {
  var colors = [];

  for (var i = 0; i < 6 * 7; i++) {
    var pi3 = Math.floor(Math.PI / 3);
    var n = i * (1.0 / 6);
    var r = Math.floor(3 * Math.sin(n) + 3);
    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
    colors.push(36 * r + 6 * g + b + 16);
  }

  return colors;
};

/**
 * Apply rainbow to the given `str`.
 *
 * @private
 * @param {string} str
 * @return {string}
 */
NyanCat.prototype.rainbowify = function (str) {
  if (!Base.useColors) {
    return str;
  }
  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
  this.colorIndex += 1;
  return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m';
};

/**
 * Stdout helper.
 *
 * @param {string} string A message to write to stdout.
 */
function write(string) {
  process.stdout.write(string);
}

NyanCat.description = '"nyan cat"';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/progress.js":
/*!*******************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/progress.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module Progress
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var color = Base.color;
var cursor = Base.cursor;

/**
 * Expose `Progress`.
 */

exports = module.exports = Progress;

/**
 * General progress bar color.
 */

Base.colors.progress = 90;

/**
 * Constructs a new `Progress` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Progress(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var width = (Base.window.width * 0.5) | 0;
  var total = runner.total;
  var complete = 0;
  var lastN = -1;

  // default chars
  options = options || {};
  var reporterOptions = options.reporterOptions || {};

  options.open = reporterOptions.open || '[';
  options.complete = reporterOptions.complete || '';
  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;
  options.close = reporterOptions.close || ']';
  options.verbose = reporterOptions.verbose || false;

  // tests started
  runner.on(EVENT_RUN_BEGIN, function () {
    process.stdout.write('\n');
    cursor.hide();
  });

  // tests complete
  runner.on(EVENT_TEST_END, function () {
    complete++;

    var percent = complete / total;
    var n = (width * percent) | 0;
    var i = width - n;

    if (n === lastN && !options.verbose) {
      // Don't re-render the line if it hasn't changed
      return;
    }
    lastN = n;

    cursor.CR();
    process.stdout.write('\u001b[J');
    process.stdout.write(color('progress', '  ' + options.open));
    process.stdout.write(Array(n).join(options.complete));
    process.stdout.write(Array(i).join(options.incomplete));
    process.stdout.write(color('progress', options.close));
    if (options.verbose) {
      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));
    }
  });

  // tests are complete, output some stats
  // and the failures if any
  runner.once(EVENT_RUN_END, function () {
    cursor.show();
    process.stdout.write('\n');
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Progress, Base);

Progress.description = 'a progress bar';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/spec.js":
/*!***************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/spec.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

/**
 * @module Spec
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_SUITE_END = constants.EVENT_SUITE_END;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var color = Base.color;

/**
 * Expose `Spec`.
 */

exports = module.exports = Spec;

/**
 * Constructs a new `Spec` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function Spec(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var indents = 0;
  var n = 0;

  function indent() {
    return Array(indents).join('  ');
  }

  runner.on(EVENT_RUN_BEGIN, function () {
    Base.consoleLog();
  });

  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    ++indents;
    Base.consoleLog(color('suite', '%s%s'), indent(), suite.title);
  });

  runner.on(EVENT_SUITE_END, function () {
    --indents;
    if (indents === 1) {
      Base.consoleLog();
    }
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    var fmt = indent() + color('pending', '  - %s');
    Base.consoleLog(fmt, test.title);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    var fmt;
    if (test.speed === 'fast') {
      fmt =
        indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s');
      Base.consoleLog(fmt, test.title);
    } else {
      fmt =
        indent() +
        color('checkmark', '  ' + Base.symbols.ok) +
        color('pass', ' %s') +
        color(test.speed, ' (%dms)');
      Base.consoleLog(fmt, test.title, test.duration);
    }
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    Base.consoleLog(indent() + color('fail', '  %d) %s'), ++n, test.title);
  });

  runner.once(EVENT_RUN_END, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(Spec, Base);

Spec.description = 'hierarchical & verbose [default]';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/tap.js":
/*!**************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/tap.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module TAP
 */
/**
 * Module dependencies.
 */

var util = __webpack_require__(/*! util */ "../node_modules/util/util.js");
var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_TEST_END = constants.EVENT_TEST_END;
var inherits = (__webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js").inherits);
var sprintf = util.format;

/**
 * Expose `TAP`.
 */

exports = module.exports = TAP;

/**
 * Constructs a new `TAP` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function TAP(runner, options) {
  Base.call(this, runner, options);

  var self = this;
  var n = 1;

  var tapVersion = '12';
  if (options && options.reporterOptions) {
    if (options.reporterOptions.tapVersion) {
      tapVersion = options.reporterOptions.tapVersion.toString();
    }
  }

  this._producer = createProducer(tapVersion);

  runner.once(EVENT_RUN_BEGIN, function () {
    self._producer.writeVersion();
  });

  runner.on(EVENT_TEST_END, function () {
    ++n;
  });

  runner.on(EVENT_TEST_PENDING, function (test) {
    self._producer.writePending(n, test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    self._producer.writePass(n, test);
  });

  runner.on(EVENT_TEST_FAIL, function (test, err) {
    self._producer.writeFail(n, test, err);
  });

  runner.once(EVENT_RUN_END, function () {
    self._producer.writeEpilogue(runner.stats);
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(TAP, Base);

/**
 * Returns a TAP-safe title of `test`.
 *
 * @private
 * @param {Test} test - Test instance.
 * @return {String} title with any hash character removed
 */
function title(test) {
  return test.fullTitle().replace(/#/g, '');
}

/**
 * Writes newline-terminated formatted string to reporter output stream.
 *
 * @private
 * @param {string} format - `printf`-like format string
 * @param {...*} [varArgs] - Format string arguments
 */
function println(format, varArgs) {
  var vargs = Array.from(arguments);
  vargs[0] += '\n';
  process.stdout.write(sprintf.apply(null, vargs));
}

/**
 * Returns a `tapVersion`-appropriate TAP producer instance, if possible.
 *
 * @private
 * @param {string} tapVersion - Version of TAP specification to produce.
 * @returns {TAPProducer} specification-appropriate instance
 * @throws {Error} if specification version has no associated producer.
 */
function createProducer(tapVersion) {
  var producers = {
    12: new TAP12Producer(),
    13: new TAP13Producer()
  };
  var producer = producers[tapVersion];

  if (!producer) {
    throw new Error(
      'invalid or unsupported TAP version: ' + JSON.stringify(tapVersion)
    );
  }

  return producer;
}

/**
 * @summary
 * Constructs a new TAPProducer.
 *
 * @description
 * <em>Only</em> to be used as an abstract base class.
 *
 * @private
 * @constructor
 */
function TAPProducer() {}

/**
 * Writes the TAP version to reporter output stream.
 *
 * @abstract
 */
TAPProducer.prototype.writeVersion = function () {};

/**
 * Writes the plan to reporter output stream.
 *
 * @abstract
 * @param {number} ntests - Number of tests that are planned to run.
 */
TAPProducer.prototype.writePlan = function (ntests) {
  println('%d..%d', 1, ntests);
};

/**
 * Writes that test passed to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that passed.
 * @param {Test} test - Instance containing test information.
 */
TAPProducer.prototype.writePass = function (n, test) {
  println('ok %d %s', n, title(test));
};

/**
 * Writes that test was skipped to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that was skipped.
 * @param {Test} test - Instance containing test information.
 */
TAPProducer.prototype.writePending = function (n, test) {
  println('ok %d %s # SKIP -', n, title(test));
};

/**
 * Writes that test failed to reporter output stream.
 *
 * @abstract
 * @param {number} n - Index of test that failed.
 * @param {Test} test - Instance containing test information.
 * @param {Error} err - Reason the test failed.
 */
TAPProducer.prototype.writeFail = function (n, test, err) {
  println('not ok %d %s', n, title(test));
};

/**
 * Writes the summary epilogue to reporter output stream.
 *
 * @abstract
 * @param {Object} stats - Object containing run statistics.
 */
TAPProducer.prototype.writeEpilogue = function (stats) {
  // :TBD: Why is this not counting pending tests?
  println('# tests ' + (stats.passes + stats.failures));
  println('# pass ' + stats.passes);
  // :TBD: Why are we not showing pending results?
  println('# fail ' + stats.failures);
  this.writePlan(stats.passes + stats.failures + stats.pending);
};

/**
 * @summary
 * Constructs a new TAP12Producer.
 *
 * @description
 * Produces output conforming to the TAP12 specification.
 *
 * @private
 * @constructor
 * @extends TAPProducer
 * @see {@link https://testanything.org/tap-specification.html|Specification}
 */
function TAP12Producer() {
  /**
   * Writes that test failed to reporter output stream, with error formatting.
   * @override
   */
  this.writeFail = function (n, test, err) {
    TAPProducer.prototype.writeFail.call(this, n, test, err);
    if (err.message) {
      println(err.message.replace(/^/gm, '  '));
    }
    if (err.stack) {
      println(err.stack.replace(/^/gm, '  '));
    }
  };
}

/**
 * Inherit from `TAPProducer.prototype`.
 */
inherits(TAP12Producer, TAPProducer);

/**
 * @summary
 * Constructs a new TAP13Producer.
 *
 * @description
 * Produces output conforming to the TAP13 specification.
 *
 * @private
 * @constructor
 * @extends TAPProducer
 * @see {@link https://testanything.org/tap-version-13-specification.html|Specification}
 */
function TAP13Producer() {
  /**
   * Writes the TAP version to reporter output stream.
   * @override
   */
  this.writeVersion = function () {
    println('TAP version 13');
  };

  /**
   * Writes that test failed to reporter output stream, with error formatting.
   * @override
   */
  this.writeFail = function (n, test, err) {
    TAPProducer.prototype.writeFail.call(this, n, test, err);
    var emitYamlBlock = err.message != null || err.stack != null;
    if (emitYamlBlock) {
      println(indent(1) + '---');
      if (err.message) {
        println(indent(2) + 'message: |-');
        println(err.message.replace(/^/gm, indent(3)));
      }
      if (err.stack) {
        println(indent(2) + 'stack: |-');
        println(err.stack.replace(/^/gm, indent(3)));
      }
      println(indent(1) + '...');
    }
  };

  function indent(level) {
    return Array(level + 1).join('  ');
  }
}

/**
 * Inherit from `TAPProducer.prototype`.
 */
inherits(TAP13Producer, TAPProducer);

TAP.description = 'TAP-compatible output';


/***/ }),

/***/ "../node_modules/mocha/lib/reporters/xunit.js":
/*!****************************************************!*\
  !*** ../node_modules/mocha/lib/reporters/xunit.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");

/**
 * @module XUnit
 */
/**
 * Module dependencies.
 */

var Base = __webpack_require__(/*! ./base */ "../node_modules/mocha/lib/reporters/base.js");
var utils = __webpack_require__(/*! ../utils */ "../node_modules/mocha/lib/utils.js");
var fs = __webpack_require__(/*! fs */ "?b9ec");
var path = __webpack_require__(/*! path */ "?4389");
var errors = __webpack_require__(/*! ../errors */ "../node_modules/mocha/lib/errors.js");
var createUnsupportedError = errors.createUnsupportedError;
var constants = (__webpack_require__(/*! ../runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var STATE_FAILED = (__webpack_require__(/*! ../runnable */ "../node_modules/mocha/lib/runnable.js").constants.STATE_FAILED);
var inherits = utils.inherits;
var escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */
var Date = __webpack_require__.g.Date;

/**
 * Expose `XUnit`.
 */

exports = module.exports = XUnit;

/**
 * Constructs a new `XUnit` reporter instance.
 *
 * @public
 * @class
 * @memberof Mocha.reporters
 * @extends Mocha.reporters.Base
 * @param {Runner} runner - Instance triggers reporter actions.
 * @param {Object} [options] - runner options
 */
function XUnit(runner, options) {
  Base.call(this, runner, options);

  var stats = this.stats;
  var tests = [];
  var self = this;

  // the name of the test suite, as it will appear in the resulting XML file
  var suiteName;

  // the default name of the test suite if none is provided
  var DEFAULT_SUITE_NAME = 'Mocha Tests';

  if (options && options.reporterOptions) {
    if (options.reporterOptions.output) {
      if (!fs.createWriteStream) {
        throw createUnsupportedError('file output not supported in browser');
      }

      fs.mkdirSync(path.dirname(options.reporterOptions.output), {
        recursive: true
      });
      self.fileStream = fs.createWriteStream(options.reporterOptions.output);
    }

    // get the suite name from the reporter options (if provided)
    suiteName = options.reporterOptions.suiteName;
  }

  // fall back to the default suite name
  suiteName = suiteName || DEFAULT_SUITE_NAME;

  runner.on(EVENT_TEST_PENDING, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_PASS, function (test) {
    tests.push(test);
  });

  runner.on(EVENT_TEST_FAIL, function (test) {
    tests.push(test);
  });

  runner.once(EVENT_RUN_END, function () {
    self.write(
      tag(
        'testsuite',
        {
          name: suiteName,
          tests: stats.tests,
          failures: 0,
          errors: stats.failures,
          skipped: stats.tests - stats.failures - stats.passes,
          timestamp: new Date().toUTCString(),
          time: stats.duration / 1000 || 0
        },
        false
      )
    );

    tests.forEach(function (t) {
      self.test(t);
    });

    self.write('</testsuite>');
  });
}

/**
 * Inherit from `Base.prototype`.
 */
inherits(XUnit, Base);

/**
 * Override done to close the stream (if it's a file).
 *
 * @param failures
 * @param {Function} fn
 */
XUnit.prototype.done = function (failures, fn) {
  if (this.fileStream) {
    this.fileStream.end(function () {
      fn(failures);
    });
  } else {
    fn(failures);
  }
};

/**
 * Write out the given line.
 *
 * @param {string} line
 */
XUnit.prototype.write = function (line) {
  if (this.fileStream) {
    this.fileStream.write(line + '\n');
  } else if (typeof process === 'object' && process.stdout) {
    process.stdout.write(line + '\n');
  } else {
    Base.consoleLog(line);
  }
};

/**
 * Output tag for the given `test.`
 *
 * @param {Test} test
 */
XUnit.prototype.test = function (test) {
  Base.useColors = false;

  var attrs = {
    classname: test.parent.fullTitle(),
    name: test.title,
    time: test.duration / 1000 || 0
  };

  if (test.state === STATE_FAILED) {
    var err = test.err;
    var diff =
      !Base.hideDiff && Base.showDiff(err)
        ? '\n' + Base.generateDiff(err.actual, err.expected)
        : '';
    this.write(
      tag(
        'testcase',
        attrs,
        false,
        tag(
          'failure',
          {},
          false,
          escape(err.message) + escape(diff) + '\n' + escape(err.stack)
        )
      )
    );
  } else if (test.isPending()) {
    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));
  } else {
    this.write(tag('testcase', attrs, true));
  }
};

/**
 * HTML tag helper.
 *
 * @param name
 * @param attrs
 * @param close
 * @param content
 * @return {string}
 */
function tag(name, attrs, close, content) {
  var end = close ? '/>' : '>';
  var pairs = [];
  var tag;

  for (var key in attrs) {
    if (Object.prototype.hasOwnProperty.call(attrs, key)) {
      pairs.push(key + '="' + escape(attrs[key]) + '"');
    }
  }

  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;
  if (content) {
    tag += content + '</' + name + end;
  }
  return tag;
}

XUnit.description = 'XUnit-compatible XML output';


/***/ }),

/***/ "../node_modules/mocha/lib/runnable.js":
/*!*********************************************!*\
  !*** ../node_modules/mocha/lib/runnable.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var EventEmitter = (__webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter);
var Pending = __webpack_require__(/*! ./pending */ "../node_modules/mocha/lib/pending.js");
var debug = __webpack_require__(/*! debug */ "../node_modules/mocha/node_modules/debug/src/browser.js")('mocha:runnable');
var milliseconds = __webpack_require__(/*! ms */ "../node_modules/ms/index.js");
var utils = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
const {
  createInvalidExceptionError,
  createMultipleDoneError,
  createTimeoutError
} = __webpack_require__(/*! ./errors */ "../node_modules/mocha/lib/errors.js");

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 * @private
 */
var Date = __webpack_require__.g.Date;
var setTimeout = __webpack_require__.g.setTimeout;
var clearTimeout = __webpack_require__.g.clearTimeout;
var toString = Object.prototype.toString;

module.exports = Runnable;

/**
 * Initialize a new `Runnable` with the given `title` and callback `fn`.
 *
 * @class
 * @extends external:EventEmitter
 * @public
 * @param {String} title
 * @param {Function} fn
 */
function Runnable(title, fn) {
  this.title = title;
  this.fn = fn;
  this.body = (fn || '').toString();
  this.async = fn && fn.length;
  this.sync = !this.async;
  this._timeout = 2000;
  this._slow = 75;
  this._retries = -1;
  utils.assignNewMochaID(this);
  Object.defineProperty(this, 'id', {
    get() {
      return utils.getMochaID(this);
    }
  });
  this.reset();
}

/**
 * Inherit from `EventEmitter.prototype`.
 */
utils.inherits(Runnable, EventEmitter);

/**
 * Resets the state initially or for a next run.
 */
Runnable.prototype.reset = function () {
  this.timedOut = false;
  this._currentRetry = 0;
  this.pending = false;
  delete this.state;
  delete this.err;
};

/**
 * Get current timeout value in msecs.
 *
 * @private
 * @returns {number} current timeout threshold value
 */
/**
 * @summary
 * Set timeout threshold value (msecs).
 *
 * @description
 * A string argument can use shorthand (e.g., "2s") and will be converted.
 * The value will be clamped to range [<code>0</code>, <code>2^<sup>31</sup>-1</code>].
 * If clamped value matches either range endpoint, timeouts will be disabled.
 *
 * @private
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value}
 * @param {number|string} ms - Timeout threshold value.
 * @returns {Runnable} this
 * @chainable
 */
Runnable.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this._timeout;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }

  // Clamp to range
  var INT_MAX = Math.pow(2, 31) - 1;
  var range = [0, INT_MAX];
  ms = utils.clamp(ms, range);

  // see #1652 for reasoning
  if (ms === range[0] || ms === range[1]) {
    this._timeout = 0;
  } else {
    this._timeout = ms;
  }
  debug('timeout %d', this._timeout);

  if (this.timer) {
    this.resetTimeout();
  }
  return this;
};

/**
 * Set or get slow `ms`.
 *
 * @private
 * @param {number|string} ms
 * @return {Runnable|number} ms or Runnable instance.
 */
Runnable.prototype.slow = function (ms) {
  if (!arguments.length || typeof ms === 'undefined') {
    return this._slow;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }
  debug('slow %d', ms);
  this._slow = ms;
  return this;
};

/**
 * Halt and mark as pending.
 *
 * @memberof Mocha.Runnable
 * @public
 */
Runnable.prototype.skip = function () {
  this.pending = true;
  throw new Pending('sync skip; aborting execution');
};

/**
 * Check if this runnable or its parent suite is marked as pending.
 *
 * @private
 */
Runnable.prototype.isPending = function () {
  return this.pending || (this.parent && this.parent.isPending());
};

/**
 * Return `true` if this Runnable has failed.
 * @return {boolean}
 * @private
 */
Runnable.prototype.isFailed = function () {
  return !this.isPending() && this.state === constants.STATE_FAILED;
};

/**
 * Return `true` if this Runnable has passed.
 * @return {boolean}
 * @private
 */
Runnable.prototype.isPassed = function () {
  return !this.isPending() && this.state === constants.STATE_PASSED;
};

/**
 * Set or get number of retries.
 *
 * @private
 */
Runnable.prototype.retries = function (n) {
  if (!arguments.length) {
    return this._retries;
  }
  this._retries = n;
};

/**
 * Set or get current retry
 *
 * @private
 */
Runnable.prototype.currentRetry = function (n) {
  if (!arguments.length) {
    return this._currentRetry;
  }
  this._currentRetry = n;
};

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @memberof Mocha.Runnable
 * @public
 * @return {string}
 */
Runnable.prototype.fullTitle = function () {
  return this.titlePath().join(' ');
};

/**
 * Return the title path generated by concatenating the parent's title path with the title.
 *
 * @memberof Mocha.Runnable
 * @public
 * @return {string}
 */
Runnable.prototype.titlePath = function () {
  return this.parent.titlePath().concat([this.title]);
};

/**
 * Clear the timeout.
 *
 * @private
 */
Runnable.prototype.clearTimeout = function () {
  clearTimeout(this.timer);
};

/**
 * Reset the timeout.
 *
 * @private
 */
Runnable.prototype.resetTimeout = function () {
  var self = this;
  var ms = this.timeout();

  if (ms === 0) {
    return;
  }
  this.clearTimeout();
  this.timer = setTimeout(function () {
    if (self.timeout() === 0) {
      return;
    }
    self.callback(self._timeoutError(ms));
    self.timedOut = true;
  }, ms);
};

/**
 * Set or get a list of whitelisted globals for this test run.
 *
 * @private
 * @param {string[]} globals
 */
Runnable.prototype.globals = function (globals) {
  if (!arguments.length) {
    return this._allowedGlobals;
  }
  this._allowedGlobals = globals;
};

/**
 * Run the test and invoke `fn(err)`.
 *
 * @param {Function} fn
 * @private
 */
Runnable.prototype.run = function (fn) {
  var self = this;
  var start = new Date();
  var ctx = this.ctx;
  var finished;
  var errorWasHandled = false;

  if (this.isPending()) return fn();

  // Sometimes the ctx exists, but it is not runnable
  if (ctx && ctx.runnable) {
    ctx.runnable(this);
  }

  // called multiple times
  function multiple(err) {
    if (errorWasHandled) {
      return;
    }
    errorWasHandled = true;
    self.emit('error', createMultipleDoneError(self, err));
  }

  // finished
  function done(err) {
    var ms = self.timeout();
    if (self.timedOut) {
      return;
    }

    if (finished) {
      return multiple(err);
    }

    self.clearTimeout();
    self.duration = new Date() - start;
    finished = true;
    if (!err && self.duration > ms && ms > 0) {
      err = self._timeoutError(ms);
    }
    fn(err);
  }

  // for .resetTimeout() and Runner#uncaught()
  this.callback = done;

  if (this.fn && typeof this.fn.call !== 'function') {
    done(
      new TypeError(
        'A runnable must be passed a function as its second argument.'
      )
    );
    return;
  }

  // explicit async with `done` argument
  if (this.async) {
    this.resetTimeout();

    // allows skip() to be used in an explicit async context
    this.skip = function asyncSkip() {
      this.pending = true;
      done();
      // halt execution, the uncaught handler will ignore the failure.
      throw new Pending('async skip; aborting execution');
    };

    try {
      callFnAsync(this.fn);
    } catch (err) {
      // handles async runnables which actually run synchronously
      errorWasHandled = true;
      if (err instanceof Pending) {
        return; // done() is already called in this.skip()
      } else if (this.allowUncaught) {
        throw err;
      }
      done(Runnable.toValueOrError(err));
    }
    return;
  }

  // sync or promise-returning
  try {
    callFn(this.fn);
  } catch (err) {
    errorWasHandled = true;
    if (err instanceof Pending) {
      return done();
    } else if (this.allowUncaught) {
      throw err;
    }
    done(Runnable.toValueOrError(err));
  }

  function callFn(fn) {
    var result = fn.call(ctx);
    if (result && typeof result.then === 'function') {
      self.resetTimeout();
      result.then(
        function () {
          done();
          // Return null so libraries like bluebird do not warn about
          // subsequently constructed Promises.
          return null;
        },
        function (reason) {
          done(reason || new Error('Promise rejected with no or falsy reason'));
        }
      );
    } else {
      if (self.asyncOnly) {
        return done(
          new Error(
            '--async-only option in use without declaring `done()` or returning a promise'
          )
        );
      }

      done();
    }
  }

  function callFnAsync(fn) {
    var result = fn.call(ctx, function (err) {
      if (err instanceof Error || toString.call(err) === '[object Error]') {
        return done(err);
      }
      if (err) {
        if (Object.prototype.toString.call(err) === '[object Object]') {
          return done(
            new Error('done() invoked with non-Error: ' + JSON.stringify(err))
          );
        }
        return done(new Error('done() invoked with non-Error: ' + err));
      }
      if (result && utils.isPromise(result)) {
        return done(
          new Error(
            'Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'
          )
        );
      }

      done();
    });
  }
};

/**
 * Instantiates a "timeout" error
 *
 * @param {number} ms - Timeout (in milliseconds)
 * @returns {Error} a "timeout" error
 * @private
 */
Runnable.prototype._timeoutError = function (ms) {
  let msg = `Timeout of ${ms}ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.`;
  if (this.file) {
    msg += ' (' + this.file + ')';
  }
  return createTimeoutError(msg, ms, this.file);
};

var constants = utils.defineConstants(
  /**
   * {@link Runnable}-related constants.
   * @public
   * @memberof Runnable
   * @readonly
   * @static
   * @alias constants
   * @enum {string}
   */
  {
    /**
     * Value of `state` prop when a `Runnable` has failed
     */
    STATE_FAILED: 'failed',
    /**
     * Value of `state` prop when a `Runnable` has passed
     */
    STATE_PASSED: 'passed',
    /**
     * Value of `state` prop when a `Runnable` has been skipped by user
     */
    STATE_PENDING: 'pending'
  }
);

/**
 * Given `value`, return identity if truthy, otherwise create an "invalid exception" error and return that.
 * @param {*} [value] - Value to return, if present
 * @returns {*|Error} `value`, otherwise an `Error`
 * @private
 */
Runnable.toValueOrError = function (value) {
  return (
    value ||
    createInvalidExceptionError(
      'Runnable failed with falsy or undefined exception. Please throw an Error instead.',
      value
    )
  );
};

Runnable.constants = constants;


/***/ }),

/***/ "../node_modules/mocha/lib/runner.js":
/*!*******************************************!*\
  !*** ../node_modules/mocha/lib/runner.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");


/**
 * Module dependencies.
 * @private
 */
var EventEmitter = (__webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter);
var Pending = __webpack_require__(/*! ./pending */ "../node_modules/mocha/lib/pending.js");
var utils = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
var debug = __webpack_require__(/*! debug */ "../node_modules/mocha/node_modules/debug/src/browser.js")('mocha:runner');
var Runnable = __webpack_require__(/*! ./runnable */ "../node_modules/mocha/lib/runnable.js");
var Suite = __webpack_require__(/*! ./suite */ "../node_modules/mocha/lib/suite.js");
var HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;
var HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;
var HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;
var HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;
var EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;
var STATE_FAILED = Runnable.constants.STATE_FAILED;
var STATE_PASSED = Runnable.constants.STATE_PASSED;
var STATE_PENDING = Runnable.constants.STATE_PENDING;
var stackFilter = utils.stackTraceFilter();
var stringify = utils.stringify;

const {
  createInvalidExceptionError,
  createUnsupportedError,
  createFatalError,
  isMochaError,
  constants: errorConstants
} = __webpack_require__(/*! ./errors */ "../node_modules/mocha/lib/errors.js");

/**
 * Non-enumerable globals.
 * @private
 * @readonly
 */
var globals = [
  'setTimeout',
  'clearTimeout',
  'setInterval',
  'clearInterval',
  'XMLHttpRequest',
  'Date',
  'setImmediate',
  'clearImmediate'
];

var constants = utils.defineConstants(
  /**
   * {@link Runner}-related constants.
   * @public
   * @memberof Runner
   * @readonly
   * @alias constants
   * @static
   * @enum {string}
   */
  {
    /**
     * Emitted when {@link Hook} execution begins
     */
    EVENT_HOOK_BEGIN: 'hook',
    /**
     * Emitted when {@link Hook} execution ends
     */
    EVENT_HOOK_END: 'hook end',
    /**
     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)
     */
    EVENT_RUN_BEGIN: 'start',
    /**
     * Emitted when Root {@link Suite} execution has been delayed via `delay` option
     */
    EVENT_DELAY_BEGIN: 'waiting',
    /**
     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`
     */
    EVENT_DELAY_END: 'ready',
    /**
     * Emitted when Root {@link Suite} execution ends
     */
    EVENT_RUN_END: 'end',
    /**
     * Emitted when {@link Suite} execution begins
     */
    EVENT_SUITE_BEGIN: 'suite',
    /**
     * Emitted when {@link Suite} execution ends
     */
    EVENT_SUITE_END: 'suite end',
    /**
     * Emitted when {@link Test} execution begins
     */
    EVENT_TEST_BEGIN: 'test',
    /**
     * Emitted when {@link Test} execution ends
     */
    EVENT_TEST_END: 'test end',
    /**
     * Emitted when {@link Test} execution fails
     */
    EVENT_TEST_FAIL: 'fail',
    /**
     * Emitted when {@link Test} execution succeeds
     */
    EVENT_TEST_PASS: 'pass',
    /**
     * Emitted when {@link Test} becomes pending
     */
    EVENT_TEST_PENDING: 'pending',
    /**
     * Emitted when {@link Test} execution has failed, but will retry
     */
    EVENT_TEST_RETRY: 'retry',
    /**
     * Initial state of Runner
     */
    STATE_IDLE: 'idle',
    /**
     * State set to this value when the Runner has started running
     */
    STATE_RUNNING: 'running',
    /**
     * State set to this value when the Runner has stopped
     */
    STATE_STOPPED: 'stopped'
  }
);

class Runner extends EventEmitter {
  /**
   * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.
   *
   * @extends external:EventEmitter
   * @public
   * @class
   * @param {Suite} suite - Root suite
   * @param {Object} [opts] - Settings object
   * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.
   * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.
   * @param {boolean} [opts.dryRun] - Whether to report tests without running them.
   * @param {boolean} [opts.failZero] - Whether to fail test run if zero tests encountered.
   */
  constructor(suite, opts = {}) {
    super();

    var self = this;
    this._globals = [];
    this._abort = false;
    this.suite = suite;
    this._opts = opts;
    this.state = constants.STATE_IDLE;
    this.total = suite.total();
    this.failures = 0;
    /**
     * @type {Map<EventEmitter,Map<string,Set<EventListener>>>}
     */
    this._eventListeners = new Map();
    this.on(constants.EVENT_TEST_END, function (test) {
      if (test.type === 'test' && test.retriedTest() && test.parent) {
        var idx =
          test.parent.tests && test.parent.tests.indexOf(test.retriedTest());
        if (idx > -1) test.parent.tests[idx] = test;
      }
      self.checkGlobals(test);
    });
    this.on(constants.EVENT_HOOK_END, function (hook) {
      self.checkGlobals(hook);
    });
    this._defaultGrep = /.*/;
    this.grep(this._defaultGrep);
    this.globals(this.globalProps());

    this.uncaught = this._uncaught.bind(this);
    this.unhandled = (reason, promise) => {
      if (isMochaError(reason)) {
        debug(
          'trapped unhandled rejection coming out of Mocha; forwarding to uncaught handler:',
          reason
        );
        this.uncaught(reason);
      } else {
        debug(
          'trapped unhandled rejection from (probably) user code; re-emitting on process'
        );
        this._removeEventListener(
          process,
          'unhandledRejection',
          this.unhandled
        );
        try {
          process.emit('unhandledRejection', reason, promise);
        } finally {
          this._addEventListener(process, 'unhandledRejection', this.unhandled);
        }
      }
    };
  }
}

/**
 * Wrapper for setImmediate, process.nextTick, or browser polyfill.
 *
 * @param {Function} fn
 * @private
 */
Runner.immediately = __webpack_require__.g.setImmediate || process.nextTick;

/**
 * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.
 * @param {EventEmitter} target - The `EventEmitter`
 * @param {string} eventName - The event name
 * @param {string} fn - Listener function
 * @private
 */
Runner.prototype._addEventListener = function (target, eventName, listener) {
  debug(
    '_addEventListener(): adding for event %s; %d current listeners',
    eventName,
    target.listenerCount(eventName)
  );
  /* istanbul ignore next */
  if (
    this._eventListeners.has(target) &&
    this._eventListeners.get(target).has(eventName) &&
    this._eventListeners.get(target).get(eventName).has(listener)
  ) {
    debug(
      'warning: tried to attach duplicate event listener for %s',
      eventName
    );
    return;
  }
  target.on(eventName, listener);
  const targetListeners = this._eventListeners.has(target)
    ? this._eventListeners.get(target)
    : new Map();
  const targetEventListeners = targetListeners.has(eventName)
    ? targetListeners.get(eventName)
    : new Set();
  targetEventListeners.add(listener);
  targetListeners.set(eventName, targetEventListeners);
  this._eventListeners.set(target, targetListeners);
};

/**
 * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.
 * @param {EventEmitter} target - The `EventEmitter`
 * @param {string} eventName - The event name
 * @param {function} listener - Listener function
 * @private
 */
Runner.prototype._removeEventListener = function (target, eventName, listener) {
  target.removeListener(eventName, listener);

  if (this._eventListeners.has(target)) {
    const targetListeners = this._eventListeners.get(target);
    if (targetListeners.has(eventName)) {
      const targetEventListeners = targetListeners.get(eventName);
      targetEventListeners.delete(listener);
      if (!targetEventListeners.size) {
        targetListeners.delete(eventName);
      }
    }
    if (!targetListeners.size) {
      this._eventListeners.delete(target);
    }
  } else {
    debug('trying to remove listener for untracked object %s', target);
  }
};

/**
 * Removes all event handlers set during a run on this instance.
 * Remark: this does _not_ clean/dispose the tests or suites themselves.
 */
Runner.prototype.dispose = function () {
  this.removeAllListeners();
  this._eventListeners.forEach((targetListeners, target) => {
    targetListeners.forEach((targetEventListeners, eventName) => {
      targetEventListeners.forEach(listener => {
        target.removeListener(eventName, listener);
      });
    });
  });
  this._eventListeners.clear();
};

/**
 * Run tests with full titles matching `re`. Updates runner.total
 * with number of tests matched.
 *
 * @public
 * @memberof Runner
 * @param {RegExp} re
 * @param {boolean} invert
 * @return {Runner} Runner instance.
 */
Runner.prototype.grep = function (re, invert) {
  debug('grep(): setting to %s', re);
  this._grep = re;
  this._invert = invert;
  this.total = this.grepTotal(this.suite);
  return this;
};

/**
 * Returns the number of tests matching the grep search for the
 * given suite.
 *
 * @memberof Runner
 * @public
 * @param {Suite} suite
 * @return {number}
 */
Runner.prototype.grepTotal = function (suite) {
  var self = this;
  var total = 0;

  suite.eachTest(function (test) {
    var match = self._grep.test(test.fullTitle());
    if (self._invert) {
      match = !match;
    }
    if (match) {
      total++;
    }
  });

  return total;
};

/**
 * Return a list of global properties.
 *
 * @return {Array}
 * @private
 */
Runner.prototype.globalProps = function () {
  var props = Object.keys(__webpack_require__.g);

  // non-enumerables
  for (var i = 0; i < globals.length; ++i) {
    if (~props.indexOf(globals[i])) {
      continue;
    }
    props.push(globals[i]);
  }

  return props;
};

/**
 * Allow the given `arr` of globals.
 *
 * @public
 * @memberof Runner
 * @param {Array} arr
 * @return {Runner} Runner instance.
 */
Runner.prototype.globals = function (arr) {
  if (!arguments.length) {
    return this._globals;
  }
  debug('globals(): setting to %O', arr);
  this._globals = this._globals.concat(arr);
  return this;
};

/**
 * Check for global variable leaks.
 *
 * @private
 */
Runner.prototype.checkGlobals = function (test) {
  if (!this.checkLeaks) {
    return;
  }
  var ok = this._globals;

  var globals = this.globalProps();
  var leaks;

  if (test) {
    ok = ok.concat(test._allowedGlobals || []);
  }

  if (this.prevGlobalsLength === globals.length) {
    return;
  }
  this.prevGlobalsLength = globals.length;

  leaks = filterLeaks(ok, globals);
  this._globals = this._globals.concat(leaks);

  if (leaks.length) {
    var msg = `global leak(s) detected: ${leaks.map(e => `'${e}'`).join(', ')}`;
    this.fail(test, new Error(msg));
  }
};

/**
 * Fail the given `test`.
 *
 * If `test` is a hook, failures work in the following pattern:
 * - If bail, run corresponding `after each` and `after` hooks,
 *   then exit
 * - Failed `before` hook skips all tests in a suite and subsuites,
 *   but jumps to corresponding `after` hook
 * - Failed `before each` hook skips remaining tests in a
 *   suite and jumps to corresponding `after each` hook,
 *   which is run only once
 * - Failed `after` hook does not alter execution order
 * - Failed `after each` hook skips remaining tests in a
 *   suite and subsuites, but executes other `after each`
 *   hooks
 *
 * @private
 * @param {Runnable} test
 * @param {Error} err
 * @param {boolean} [force=false] - Whether to fail a pending test.
 */
Runner.prototype.fail = function (test, err, force) {
  force = force === true;
  if (test.isPending() && !force) {
    return;
  }
  if (this.state === constants.STATE_STOPPED) {
    if (err.code === errorConstants.MULTIPLE_DONE) {
      throw err;
    }
    throw createFatalError(
      'Test failed after root suite execution completed!',
      err
    );
  }

  ++this.failures;
  debug('total number of failures: %d', this.failures);
  test.state = STATE_FAILED;

  if (!isError(err)) {
    err = thrown2Error(err);
  }

  try {
    err.stack =
      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);
  } catch (ignore) {
    // some environments do not take kindly to monkeying with the stack
  }

  this.emit(constants.EVENT_TEST_FAIL, test, err);
};

/**
 * Run hook `name` callbacks and then invoke `fn()`.
 *
 * @private
 * @param {string} name
 * @param {Function} fn
 */

Runner.prototype.hook = function (name, fn) {
  if (this._opts.dryRun) return fn();

  var suite = this.suite;
  var hooks = suite.getHooks(name);
  var self = this;

  function next(i) {
    var hook = hooks[i];
    if (!hook) {
      return fn();
    }
    self.currentRunnable = hook;

    if (name === HOOK_TYPE_BEFORE_ALL) {
      hook.ctx.currentTest = hook.parent.tests[0];
    } else if (name === HOOK_TYPE_AFTER_ALL) {
      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];
    } else {
      hook.ctx.currentTest = self.test;
    }

    setHookTitle(hook);

    hook.allowUncaught = self.allowUncaught;

    self.emit(constants.EVENT_HOOK_BEGIN, hook);

    if (!hook.listeners('error').length) {
      self._addEventListener(hook, 'error', function (err) {
        self.fail(hook, err);
      });
    }

    hook.run(function cbHookRun(err) {
      var testError = hook.error();
      if (testError) {
        self.fail(self.test, testError);
      }
      // conditional skip
      if (hook.pending) {
        if (name === HOOK_TYPE_AFTER_EACH) {
          // TODO define and implement use case
          if (self.test) {
            self.test.pending = true;
          }
        } else if (name === HOOK_TYPE_BEFORE_EACH) {
          if (self.test) {
            self.test.pending = true;
          }
          self.emit(constants.EVENT_HOOK_END, hook);
          hook.pending = false; // activates hook for next test
          return fn(new Error('abort hookDown'));
        } else if (name === HOOK_TYPE_BEFORE_ALL) {
          suite.tests.forEach(function (test) {
            test.pending = true;
          });
          suite.suites.forEach(function (suite) {
            suite.pending = true;
          });
          hooks = [];
        } else {
          hook.pending = false;
          var errForbid = createUnsupportedError('`this.skip` forbidden');
          self.fail(hook, errForbid);
          return fn(errForbid);
        }
      } else if (err) {
        self.fail(hook, err);
        // stop executing hooks, notify callee of hook err
        return fn(err);
      }
      self.emit(constants.EVENT_HOOK_END, hook);
      delete hook.ctx.currentTest;
      setHookTitle(hook);
      next(++i);
    });

    function setHookTitle(hook) {
      hook.originalTitle = hook.originalTitle || hook.title;
      if (hook.ctx && hook.ctx.currentTest) {
        hook.title = `${hook.originalTitle} for "${hook.ctx.currentTest.title}"`;
      } else {
        var parentTitle;
        if (hook.parent.title) {
          parentTitle = hook.parent.title;
        } else {
          parentTitle = hook.parent.root ? '{root}' : '';
        }
        hook.title = `${hook.originalTitle} in "${parentTitle}"`;
      }
    }
  }

  Runner.immediately(function () {
    next(0);
  });
};

/**
 * Run hook `name` for the given array of `suites`
 * in order, and callback `fn(err, errSuite)`.
 *
 * @private
 * @param {string} name
 * @param {Array} suites
 * @param {Function} fn
 */
Runner.prototype.hooks = function (name, suites, fn) {
  var self = this;
  var orig = this.suite;

  function next(suite) {
    self.suite = suite;

    if (!suite) {
      self.suite = orig;
      return fn();
    }

    self.hook(name, function (err) {
      if (err) {
        var errSuite = self.suite;
        self.suite = orig;
        return fn(err, errSuite);
      }

      next(suites.pop());
    });
  }

  next(suites.pop());
};

/**
 * Run 'afterEach' hooks from bottom up.
 *
 * @param {String} name
 * @param {Function} fn
 * @private
 */
Runner.prototype.hookUp = function (name, fn) {
  var suites = [this.suite].concat(this.parents()).reverse();
  this.hooks(name, suites, fn);
};

/**
 * Run 'beforeEach' hooks from top level down.
 *
 * @param {String} name
 * @param {Function} fn
 * @private
 */
Runner.prototype.hookDown = function (name, fn) {
  var suites = [this.suite].concat(this.parents());
  this.hooks(name, suites, fn);
};

/**
 * Return an array of parent Suites from
 * closest to furthest.
 *
 * @return {Array}
 * @private
 */
Runner.prototype.parents = function () {
  var suite = this.suite;
  var suites = [];
  while (suite.parent) {
    suite = suite.parent;
    suites.push(suite);
  }
  return suites;
};

/**
 * Run the current test and callback `fn(err)`.
 *
 * @param {Function} fn
 * @private
 */
Runner.prototype.runTest = function (fn) {
  if (this._opts.dryRun) return Runner.immediately(fn);

  var self = this;
  var test = this.test;

  if (!test) {
    return;
  }

  if (this.asyncOnly) {
    test.asyncOnly = true;
  }
  this._addEventListener(test, 'error', function (err) {
    self.fail(test, err);
  });
  if (this.allowUncaught) {
    test.allowUncaught = true;
    return test.run(fn);
  }
  try {
    test.run(fn);
  } catch (err) {
    fn(err);
  }
};

/**
 * Run tests in the given `suite` and invoke the callback `fn()` when complete.
 *
 * @private
 * @param {Suite} suite
 * @param {Function} fn
 */
Runner.prototype.runTests = function (suite, fn) {
  var self = this;
  var tests = suite.tests.slice();
  var test;

  function hookErr(_, errSuite, after) {
    // before/after Each hook for errSuite failed:
    var orig = self.suite;

    // for failed 'after each' hook start from errSuite parent,
    // otherwise start from errSuite itself
    self.suite = after ? errSuite.parent : errSuite;

    if (self.suite) {
      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {
        self.suite = orig;
        // some hooks may fail even now
        if (err2) {
          return hookErr(err2, errSuite2, true);
        }
        // report error suite
        fn(errSuite);
      });
    } else {
      // there is no need calling other 'after each' hooks
      self.suite = orig;
      fn(errSuite);
    }
  }

  function next(err, errSuite) {
    // if we bail after first err
    if (self.failures && suite._bail) {
      tests = [];
    }

    if (self._abort) {
      return fn();
    }

    if (err) {
      return hookErr(err, errSuite, true);
    }

    // next test
    test = tests.shift();

    // all done
    if (!test) {
      return fn();
    }

    // grep
    var match = self._grep.test(test.fullTitle());
    if (self._invert) {
      match = !match;
    }
    if (!match) {
      // Run immediately only if we have defined a grep. When we
      // define a grep  It can cause maximum callstack error if
      // the grep is doing a large recursive loop by neglecting
      // all tests. The run immediately function also comes with
      // a performance cost. So we don't want to run immediately
      // if we run the whole test suite, because running the whole
      // test suite don't do any immediate recursive loops. Thus,
      // allowing a JS runtime to breathe.
      if (self._grep !== self._defaultGrep) {
        Runner.immediately(next);
      } else {
        next();
      }
      return;
    }

    // static skip, no hooks are executed
    if (test.isPending()) {
      if (self.forbidPending) {
        self.fail(test, new Error('Pending test forbidden'), true);
      } else {
        test.state = STATE_PENDING;
        self.emit(constants.EVENT_TEST_PENDING, test);
      }
      self.emit(constants.EVENT_TEST_END, test);
      return next();
    }

    // execute test and hook(s)
    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));
    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {
      // conditional skip within beforeEach
      if (test.isPending()) {
        if (self.forbidPending) {
          self.fail(test, new Error('Pending test forbidden'), true);
        } else {
          test.state = STATE_PENDING;
          self.emit(constants.EVENT_TEST_PENDING, test);
        }
        self.emit(constants.EVENT_TEST_END, test);
        // skip inner afterEach hooks below errSuite level
        var origSuite = self.suite;
        self.suite = errSuite || self.suite;
        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {
          self.suite = origSuite;
          next(e, eSuite);
        });
      }
      if (err) {
        return hookErr(err, errSuite, false);
      }
      self.currentRunnable = self.test;
      self.runTest(function (err) {
        test = self.test;
        // conditional skip within it
        if (test.pending) {
          if (self.forbidPending) {
            self.fail(test, new Error('Pending test forbidden'), true);
          } else {
            test.state = STATE_PENDING;
            self.emit(constants.EVENT_TEST_PENDING, test);
          }
          self.emit(constants.EVENT_TEST_END, test);
          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
        } else if (err) {
          var retry = test.currentRetry();
          if (retry < test.retries()) {
            var clonedTest = test.clone();
            clonedTest.currentRetry(retry + 1);
            tests.unshift(clonedTest);

            self.emit(constants.EVENT_TEST_RETRY, test, err);

            // Early return + hook trigger so that it doesn't
            // increment the count wrong
            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
          } else {
            self.fail(test, err);
          }
          self.emit(constants.EVENT_TEST_END, test);
          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);
        }

        test.state = STATE_PASSED;
        self.emit(constants.EVENT_TEST_PASS, test);
        self.emit(constants.EVENT_TEST_END, test);
        self.hookUp(HOOK_TYPE_AFTER_EACH, next);
      });
    });
  }

  this.next = next;
  this.hookErr = hookErr;
  next();
};

/**
 * Run the given `suite` and invoke the callback `fn()` when complete.
 *
 * @private
 * @param {Suite} suite
 * @param {Function} fn
 */
Runner.prototype.runSuite = function (suite, fn) {
  var i = 0;
  var self = this;
  var total = this.grepTotal(suite);

  debug('runSuite(): running %s', suite.fullTitle());

  if (!total || (self.failures && suite._bail)) {
    debug('runSuite(): bailing');
    return fn();
  }

  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));

  function next(errSuite) {
    if (errSuite) {
      // current suite failed on a hook from errSuite
      if (errSuite === suite) {
        // if errSuite is current suite
        // continue to the next sibling suite
        return done();
      }
      // errSuite is among the parents of current suite
      // stop execution of errSuite and all sub-suites
      return done(errSuite);
    }

    if (self._abort) {
      return done();
    }

    var curr = suite.suites[i++];
    if (!curr) {
      return done();
    }

    // Avoid grep neglecting large number of tests causing a
    // huge recursive loop and thus a maximum call stack error.
    // See comment in `this.runTests()` for more information.
    if (self._grep !== self._defaultGrep) {
      Runner.immediately(function () {
        self.runSuite(curr, next);
      });
    } else {
      self.runSuite(curr, next);
    }
  }

  function done(errSuite) {
    self.suite = suite;
    self.nextSuite = next;

    // remove reference to test
    delete self.test;

    self.hook(HOOK_TYPE_AFTER_ALL, function () {
      self.emit(constants.EVENT_SUITE_END, suite);
      fn(errSuite);
    });
  }

  this.nextSuite = next;

  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {
    if (err) {
      return done();
    }
    self.runTests(suite, next);
  });
};

/**
 * Handle uncaught exceptions within runner.
 *
 * This function is bound to the instance as `Runner#uncaught` at instantiation
 * time. It's intended to be listening on the `Process.uncaughtException` event.
 * In order to not leak EE listeners, we need to ensure no more than a single
 * `uncaughtException` listener exists per `Runner`.  The only way to do
 * this--because this function needs the context (and we don't have lambdas)--is
 * to use `Function.prototype.bind`. We need strict equality to unregister and
 * _only_ unregister the _one_ listener we set from the
 * `Process.uncaughtException` event; would be poor form to just remove
 * everything. See {@link Runner#run} for where the event listener is registered
 * and unregistered.
 * @param {Error} err - Some uncaught error
 * @private
 */
Runner.prototype._uncaught = function (err) {
  // this is defensive to prevent future developers from mis-calling this function.
  // it's more likely that it'd be called with the incorrect context--say, the global
  // `process` object--than it would to be called with a context that is not a "subclass"
  // of `Runner`.
  if (!(this instanceof Runner)) {
    throw createFatalError(
      'Runner#uncaught() called with invalid context',
      this
    );
  }
  if (err instanceof Pending) {
    debug('uncaught(): caught a Pending');
    return;
  }
  // browser does not exit script when throwing in global.onerror()
  if (this.allowUncaught && !utils.isBrowser()) {
    debug('uncaught(): bubbling exception due to --allow-uncaught');
    throw err;
  }

  if (this.state === constants.STATE_STOPPED) {
    debug('uncaught(): throwing after run has completed!');
    throw err;
  }

  if (err) {
    debug('uncaught(): got truthy exception %O', err);
  } else {
    debug('uncaught(): undefined/falsy exception');
    err = createInvalidExceptionError(
      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',
      err
    );
  }

  if (!isError(err)) {
    err = thrown2Error(err);
    debug('uncaught(): converted "error" %o to Error', err);
  }
  err.uncaught = true;

  var runnable = this.currentRunnable;

  if (!runnable) {
    runnable = new Runnable('Uncaught error outside test suite');
    debug('uncaught(): no current Runnable; created a phony one');
    runnable.parent = this.suite;

    if (this.state === constants.STATE_RUNNING) {
      debug('uncaught(): failing gracefully');
      this.fail(runnable, err);
    } else {
      // Can't recover from this failure
      debug('uncaught(): test run has not yet started; unrecoverable');
      this.emit(constants.EVENT_RUN_BEGIN);
      this.fail(runnable, err);
      this.emit(constants.EVENT_RUN_END);
    }

    return;
  }

  runnable.clearTimeout();

  if (runnable.isFailed()) {
    debug('uncaught(): Runnable has already failed');
    // Ignore error if already failed
    return;
  } else if (runnable.isPending()) {
    debug('uncaught(): pending Runnable wound up failing!');
    // report 'pending test' retrospectively as failed
    this.fail(runnable, err, true);
    return;
  }

  // we cannot recover gracefully if a Runnable has already passed
  // then fails asynchronously
  if (runnable.isPassed()) {
    debug('uncaught(): Runnable has already passed; bailing gracefully');
    this.fail(runnable, err);
    this.abort();
  } else {
    debug('uncaught(): forcing Runnable to complete with Error');
    return runnable.callback(err);
  }
};

/**
 * Run the root suite and invoke `fn(failures)`
 * on completion.
 *
 * @public
 * @memberof Runner
 * @param {Function} fn - Callback when finished
 * @param {Object} [opts] - For subclasses
 * @param {string[]} opts.files - Files to run
 * @param {Options} opts.options - command-line options
 * @returns {Runner} Runner instance.
 */
Runner.prototype.run = function (fn, opts = {}) {
  var rootSuite = this.suite;
  var options = opts.options || {};

  debug('run(): got options: %O', options);
  fn = fn || function () {};

  const end = () => {
    if (!this.total && this._opts.failZero) this.failures = 1;

    debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);
    this.emit(constants.EVENT_RUN_END);
  };

  const begin = () => {
    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);
    this.emit(constants.EVENT_RUN_BEGIN);
    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);

    this.runSuite(rootSuite, end);
  };

  const prepare = () => {
    debug('run(): starting');
    // If there is an `only` filter
    if (rootSuite.hasOnly()) {
      rootSuite.filterOnly();
      debug('run(): filtered exclusive Runnables');
    }
    this.state = constants.STATE_RUNNING;
    if (this._opts.delay) {
      this.emit(constants.EVENT_DELAY_END);
      debug('run(): "delay" ended');
    }

    return begin();
  };

  // references cleanup to avoid memory leaks
  if (this._opts.cleanReferencesAfterRun) {
    this.on(constants.EVENT_SUITE_END, suite => {
      suite.cleanReferences();
    });
  }

  // callback
  this.on(constants.EVENT_RUN_END, function () {
    this.state = constants.STATE_STOPPED;
    debug('run(): emitted %s', constants.EVENT_RUN_END);
    fn(this.failures);
  });

  this._removeEventListener(process, 'uncaughtException', this.uncaught);
  this._removeEventListener(process, 'unhandledRejection', this.unhandled);
  this._addEventListener(process, 'uncaughtException', this.uncaught);
  this._addEventListener(process, 'unhandledRejection', this.unhandled);

  if (this._opts.delay) {
    // for reporters, I guess.
    // might be nice to debounce some dots while we wait.
    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);
    rootSuite.once(EVENT_ROOT_SUITE_RUN, prepare);
    debug('run(): waiting for green light due to --delay');
  } else {
    Runner.immediately(prepare);
  }

  return this;
};

/**
 * Toggle partial object linking behavior; used for building object references from
 * unique ID's. Does nothing in serial mode, because the object references already exist.
 * Subclasses can implement this (e.g., `ParallelBufferedRunner`)
 * @abstract
 * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable
 * @returns {Runner}
 * @chainable
 * @public
 * @example
 * // this reporter needs proper object references when run in parallel mode
 * class MyReporter() {
 *   constructor(runner) {
 *     this.runner.linkPartialObjects(true)
 *       .on(EVENT_SUITE_BEGIN, suite => {
           // this Suite may be the same object...
 *       })
 *       .on(EVENT_TEST_BEGIN, test => {
 *         // ...as the `test.parent` property
 *       });
 *   }
 * }
 */
Runner.prototype.linkPartialObjects = function (value) {
  return this;
};

/*
 * Like {@link Runner#run}, but does not accept a callback and returns a `Promise` instead of a `Runner`.
 * This function cannot reject; an `unhandledRejection` event will bubble up to the `process` object instead.
 * @public
 * @memberof Runner
 * @param {Object} [opts] - Options for {@link Runner#run}
 * @returns {Promise<number>} Failure count
 */
Runner.prototype.runAsync = async function runAsync(opts = {}) {
  return new Promise(resolve => {
    this.run(resolve, opts);
  });
};

/**
 * Cleanly abort execution.
 *
 * @memberof Runner
 * @public
 * @return {Runner} Runner instance.
 */
Runner.prototype.abort = function () {
  debug('abort(): aborting');
  this._abort = true;

  return this;
};

/**
 * Returns `true` if Mocha is running in parallel mode.  For reporters.
 *
 * Subclasses should return an appropriate value.
 * @public
 * @returns {false}
 */
Runner.prototype.isParallelMode = function isParallelMode() {
  return false;
};

/**
 * Configures an alternate reporter for worker processes to use. Subclasses
 * using worker processes should implement this.
 * @public
 * @param {string} path - Absolute path to alternate reporter for worker processes to use
 * @returns {Runner}
 * @throws When in serial mode
 * @chainable
 * @abstract
 */
Runner.prototype.workerReporter = function () {
  throw createUnsupportedError('workerReporter() not supported in serial mode');
};

/**
 * Filter leaks with the given globals flagged as `ok`.
 *
 * @private
 * @param {Array} ok
 * @param {Array} globals
 * @return {Array}
 */
function filterLeaks(ok, globals) {
  return globals.filter(function (key) {
    // Firefox and Chrome exposes iframes as index inside the window object
    if (/^\d+/.test(key)) {
      return false;
    }

    // in firefox
    // if runner runs in an iframe, this iframe's window.getInterface method
    // not init at first it is assigned in some seconds
    if (__webpack_require__.g.navigator && /^getInterface/.test(key)) {
      return false;
    }

    // an iframe could be approached by window[iframeIndex]
    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
    if (__webpack_require__.g.navigator && /^\d+/.test(key)) {
      return false;
    }

    // Opera and IE expose global variables for HTML element IDs (issue #243)
    if (/^mocha-/.test(key)) {
      return false;
    }

    var matched = ok.filter(function (ok) {
      if (~ok.indexOf('*')) {
        return key.indexOf(ok.split('*')[0]) === 0;
      }
      return key === ok;
    });
    return !matched.length && (!__webpack_require__.g.navigator || key !== 'onerror');
  });
}

/**
 * Check if argument is an instance of Error object or a duck-typed equivalent.
 *
 * @private
 * @param {Object} err - object to check
 * @param {string} err.message - error message
 * @returns {boolean}
 */
function isError(err) {
  return err instanceof Error || (err && typeof err.message === 'string');
}

/**
 *
 * Converts thrown non-extensible type into proper Error.
 *
 * @private
 * @param {*} thrown - Non-extensible type thrown by code
 * @return {Error}
 */
function thrown2Error(err) {
  return new Error(
    `the ${utils.canonicalType(err)} ${stringify(
      err
    )} was thrown, throw an Error :)`
  );
}

Runner.constants = constants;

/**
 * Node.js' `EventEmitter`
 * @external EventEmitter
 * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}
 */

module.exports = Runner;


/***/ }),

/***/ "../node_modules/mocha/lib/stats-collector.js":
/*!****************************************************!*\
  !*** ../node_modules/mocha/lib/stats-collector.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Provides a factory function for a {@link StatsCollector} object.
 * @module
 */

var constants = (__webpack_require__(/*! ./runner */ "../node_modules/mocha/lib/runner.js").constants);
var EVENT_TEST_PASS = constants.EVENT_TEST_PASS;
var EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;
var EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;
var EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;
var EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;
var EVENT_RUN_END = constants.EVENT_RUN_END;
var EVENT_TEST_END = constants.EVENT_TEST_END;

/**
 * Test statistics collector.
 *
 * @public
 * @typedef {Object} StatsCollector
 * @property {number} suites - integer count of suites run.
 * @property {number} tests - integer count of tests run.
 * @property {number} passes - integer count of passing tests.
 * @property {number} pending - integer count of pending tests.
 * @property {number} failures - integer count of failed tests.
 * @property {Date} start - time when testing began.
 * @property {Date} end - time when testing concluded.
 * @property {number} duration - number of msecs that testing took.
 */

var Date = __webpack_require__.g.Date;

/**
 * Provides stats such as test duration, number of tests passed / failed etc., by listening for events emitted by `runner`.
 *
 * @private
 * @param {Runner} runner - Runner instance
 * @throws {TypeError} If falsy `runner`
 */
function createStatsCollector(runner) {
  /**
   * @type StatsCollector
   */
  var stats = {
    suites: 0,
    tests: 0,
    passes: 0,
    pending: 0,
    failures: 0
  };

  if (!runner) {
    throw new TypeError('Missing runner argument');
  }

  runner.stats = stats;

  runner.once(EVENT_RUN_BEGIN, function () {
    stats.start = new Date();
  });
  runner.on(EVENT_SUITE_BEGIN, function (suite) {
    suite.root || stats.suites++;
  });
  runner.on(EVENT_TEST_PASS, function () {
    stats.passes++;
  });
  runner.on(EVENT_TEST_FAIL, function () {
    stats.failures++;
  });
  runner.on(EVENT_TEST_PENDING, function () {
    stats.pending++;
  });
  runner.on(EVENT_TEST_END, function () {
    stats.tests++;
  });
  runner.once(EVENT_RUN_END, function () {
    stats.end = new Date();
    stats.duration = stats.end - stats.start;
  });
}

module.exports = createStatsCollector;


/***/ }),

/***/ "../node_modules/mocha/lib/suite.js":
/*!******************************************!*\
  !*** ../node_modules/mocha/lib/suite.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 * @private
 */
const {EventEmitter} = __webpack_require__(/*! events */ "../node_modules/events/events.js");
const Hook = __webpack_require__(/*! ./hook */ "../node_modules/mocha/lib/hook.js");
var {
  assignNewMochaID,
  clamp,
  constants: utilsConstants,
  defineConstants,
  getMochaID,
  inherits,
  isString
} = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
const debug = __webpack_require__(/*! debug */ "../node_modules/mocha/node_modules/debug/src/browser.js")('mocha:suite');
const milliseconds = __webpack_require__(/*! ms */ "../node_modules/ms/index.js");
const errors = __webpack_require__(/*! ./errors */ "../node_modules/mocha/lib/errors.js");

const {MOCHA_ID_PROP_NAME} = utilsConstants;

/**
 * Expose `Suite`.
 */

exports = module.exports = Suite;

/**
 * Create a new `Suite` with the given `title` and parent `Suite`.
 *
 * @public
 * @param {Suite} parent - Parent suite (required!)
 * @param {string} title - Title
 * @return {Suite}
 */
Suite.create = function (parent, title) {
  var suite = new Suite(title, parent.ctx);
  suite.parent = parent;
  title = suite.fullTitle();
  parent.addSuite(suite);
  return suite;
};

/**
 * Constructs a new `Suite` instance with the given `title`, `ctx`, and `isRoot`.
 *
 * @public
 * @class
 * @extends EventEmitter
 * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}
 * @param {string} title - Suite title.
 * @param {Context} parentContext - Parent context instance.
 * @param {boolean} [isRoot=false] - Whether this is the root suite.
 */
function Suite(title, parentContext, isRoot) {
  if (!isString(title)) {
    throw errors.createInvalidArgumentTypeError(
      'Suite argument "title" must be a string. Received type "' +
        typeof title +
        '"',
      'title',
      'string'
    );
  }
  this.title = title;
  function Context() {}
  Context.prototype = parentContext;
  this.ctx = new Context();
  this.suites = [];
  this.tests = [];
  this.root = isRoot === true;
  this.pending = false;
  this._retries = -1;
  this._beforeEach = [];
  this._beforeAll = [];
  this._afterEach = [];
  this._afterAll = [];
  this._timeout = 2000;
  this._slow = 75;
  this._bail = false;
  this._onlyTests = [];
  this._onlySuites = [];
  assignNewMochaID(this);

  Object.defineProperty(this, 'id', {
    get() {
      return getMochaID(this);
    }
  });

  this.reset();
}

/**
 * Inherit from `EventEmitter.prototype`.
 */
inherits(Suite, EventEmitter);

/**
 * Resets the state initially or for a next run.
 */
Suite.prototype.reset = function () {
  this.delayed = false;
  function doReset(thingToReset) {
    thingToReset.reset();
  }
  this.suites.forEach(doReset);
  this.tests.forEach(doReset);
  this._beforeEach.forEach(doReset);
  this._afterEach.forEach(doReset);
  this._beforeAll.forEach(doReset);
  this._afterAll.forEach(doReset);
};

/**
 * Return a clone of this `Suite`.
 *
 * @private
 * @return {Suite}
 */
Suite.prototype.clone = function () {
  var suite = new Suite(this.title);
  debug('clone');
  suite.ctx = this.ctx;
  suite.root = this.root;
  suite.timeout(this.timeout());
  suite.retries(this.retries());
  suite.slow(this.slow());
  suite.bail(this.bail());
  return suite;
};

/**
 * Set or get timeout `ms` or short-hand such as "2s".
 *
 * @private
 * @todo Do not attempt to set value if `ms` is undefined
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
Suite.prototype.timeout = function (ms) {
  if (!arguments.length) {
    return this._timeout;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }

  // Clamp to range
  var INT_MAX = Math.pow(2, 31) - 1;
  var range = [0, INT_MAX];
  ms = clamp(ms, range);

  debug('timeout %d', ms);
  this._timeout = parseInt(ms, 10);
  return this;
};

/**
 * Set or get number of times to retry a failed test.
 *
 * @private
 * @param {number|string} n
 * @return {Suite|number} for chaining
 */
Suite.prototype.retries = function (n) {
  if (!arguments.length) {
    return this._retries;
  }
  debug('retries %d', n);
  this._retries = parseInt(n, 10) || 0;
  return this;
};

/**
 * Set or get slow `ms` or short-hand such as "2s".
 *
 * @private
 * @param {number|string} ms
 * @return {Suite|number} for chaining
 */
Suite.prototype.slow = function (ms) {
  if (!arguments.length) {
    return this._slow;
  }
  if (typeof ms === 'string') {
    ms = milliseconds(ms);
  }
  debug('slow %d', ms);
  this._slow = ms;
  return this;
};

/**
 * Set or get whether to bail after first error.
 *
 * @private
 * @param {boolean} bail
 * @return {Suite|number} for chaining
 */
Suite.prototype.bail = function (bail) {
  if (!arguments.length) {
    return this._bail;
  }
  debug('bail %s', bail);
  this._bail = bail;
  return this;
};

/**
 * Check if this suite or its parent suite is marked as pending.
 *
 * @private
 */
Suite.prototype.isPending = function () {
  return this.pending || (this.parent && this.parent.isPending());
};

/**
 * Generic hook-creator.
 * @private
 * @param {string} title - Title of hook
 * @param {Function} fn - Hook callback
 * @returns {Hook} A new hook
 */
Suite.prototype._createHook = function (title, fn) {
  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.retries(this.retries());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  hook.file = this.file;
  return hook;
};

/**
 * Run `fn(test[, done])` before running tests.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.beforeAll = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"before all" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._beforeAll.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_ALL, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after running tests.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.afterAll = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"after all" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._afterAll.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_ALL, hook);
  return this;
};

/**
 * Run `fn(test[, done])` before each test case.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.beforeEach = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"before each" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._beforeEach.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_BEFORE_EACH, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after each test case.
 *
 * @private
 * @param {string} title
 * @param {Function} fn
 * @return {Suite} for chaining
 */
Suite.prototype.afterEach = function (title, fn) {
  if (this.isPending()) {
    return this;
  }
  if (typeof title === 'function') {
    fn = title;
    title = fn.name;
  }
  title = '"after each" hook' + (title ? ': ' + title : '');

  var hook = this._createHook(title, fn);
  this._afterEach.push(hook);
  this.emit(constants.EVENT_SUITE_ADD_HOOK_AFTER_EACH, hook);
  return this;
};

/**
 * Add a test `suite`.
 *
 * @private
 * @param {Suite} suite
 * @return {Suite} for chaining
 */
Suite.prototype.addSuite = function (suite) {
  suite.parent = this;
  suite.root = false;
  suite.timeout(this.timeout());
  suite.retries(this.retries());
  suite.slow(this.slow());
  suite.bail(this.bail());
  this.suites.push(suite);
  this.emit(constants.EVENT_SUITE_ADD_SUITE, suite);
  return this;
};

/**
 * Add a `test` to this suite.
 *
 * @private
 * @param {Test} test
 * @return {Suite} for chaining
 */
Suite.prototype.addTest = function (test) {
  test.parent = this;
  test.timeout(this.timeout());
  test.retries(this.retries());
  test.slow(this.slow());
  test.ctx = this.ctx;
  this.tests.push(test);
  this.emit(constants.EVENT_SUITE_ADD_TEST, test);
  return this;
};

/**
 * Return the full title generated by recursively concatenating the parent's
 * full title.
 *
 * @memberof Suite
 * @public
 * @return {string}
 */
Suite.prototype.fullTitle = function () {
  return this.titlePath().join(' ');
};

/**
 * Return the title path generated by recursively concatenating the parent's
 * title path.
 *
 * @memberof Suite
 * @public
 * @return {string}
 */
Suite.prototype.titlePath = function () {
  var result = [];
  if (this.parent) {
    result = result.concat(this.parent.titlePath());
  }
  if (!this.root) {
    result.push(this.title);
  }
  return result;
};

/**
 * Return the total number of tests.
 *
 * @memberof Suite
 * @public
 * @return {number}
 */
Suite.prototype.total = function () {
  return (
    this.suites.reduce(function (sum, suite) {
      return sum + suite.total();
    }, 0) + this.tests.length
  );
};

/**
 * Iterates through each suite recursively to find all tests. Applies a
 * function in the format `fn(test)`.
 *
 * @private
 * @param {Function} fn
 * @return {Suite}
 */
Suite.prototype.eachTest = function (fn) {
  this.tests.forEach(fn);
  this.suites.forEach(function (suite) {
    suite.eachTest(fn);
  });
  return this;
};

/**
 * This will run the root suite if we happen to be running in delayed mode.
 * @private
 */
Suite.prototype.run = function run() {
  if (this.root) {
    this.emit(constants.EVENT_ROOT_SUITE_RUN);
  }
};

/**
 * Determines whether a suite has an `only` test or suite as a descendant.
 *
 * @private
 * @returns {Boolean}
 */
Suite.prototype.hasOnly = function hasOnly() {
  return (
    this._onlyTests.length > 0 ||
    this._onlySuites.length > 0 ||
    this.suites.some(function (suite) {
      return suite.hasOnly();
    })
  );
};

/**
 * Filter suites based on `isOnly` logic.
 *
 * @private
 * @returns {Boolean}
 */
Suite.prototype.filterOnly = function filterOnly() {
  if (this._onlyTests.length) {
    // If the suite contains `only` tests, run those and ignore any nested suites.
    this.tests = this._onlyTests;
    this.suites = [];
  } else {
    // Otherwise, do not run any of the tests in this suite.
    this.tests = [];
    this._onlySuites.forEach(function (onlySuite) {
      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.
      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.
      if (onlySuite.hasOnly()) {
        onlySuite.filterOnly();
      }
    });
    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.
    var onlySuites = this._onlySuites;
    this.suites = this.suites.filter(function (childSuite) {
      return onlySuites.indexOf(childSuite) !== -1 || childSuite.filterOnly();
    });
  }
  // Keep the suite only if there is something to run
  return this.tests.length > 0 || this.suites.length > 0;
};

/**
 * Adds a suite to the list of subsuites marked `only`.
 *
 * @private
 * @param {Suite} suite
 */
Suite.prototype.appendOnlySuite = function (suite) {
  this._onlySuites.push(suite);
};

/**
 * Marks a suite to be `only`.
 *
 * @private
 */
Suite.prototype.markOnly = function () {
  this.parent && this.parent.appendOnlySuite(this);
};

/**
 * Adds a test to the list of tests marked `only`.
 *
 * @private
 * @param {Test} test
 */
Suite.prototype.appendOnlyTest = function (test) {
  this._onlyTests.push(test);
};

/**
 * Returns the array of hooks by hook name; see `HOOK_TYPE_*` constants.
 * @private
 */
Suite.prototype.getHooks = function getHooks(name) {
  return this['_' + name];
};

/**
 * cleans all references from this suite and all child suites.
 */
Suite.prototype.dispose = function () {
  this.suites.forEach(function (suite) {
    suite.dispose();
  });
  this.cleanReferences();
};

/**
 * Cleans up the references to all the deferred functions
 * (before/after/beforeEach/afterEach) and tests of a Suite.
 * These must be deleted otherwise a memory leak can happen,
 * as those functions may reference variables from closures,
 * thus those variables can never be garbage collected as long
 * as the deferred functions exist.
 *
 * @private
 */
Suite.prototype.cleanReferences = function cleanReferences() {
  function cleanArrReferences(arr) {
    for (var i = 0; i < arr.length; i++) {
      delete arr[i].fn;
    }
  }

  if (Array.isArray(this._beforeAll)) {
    cleanArrReferences(this._beforeAll);
  }

  if (Array.isArray(this._beforeEach)) {
    cleanArrReferences(this._beforeEach);
  }

  if (Array.isArray(this._afterAll)) {
    cleanArrReferences(this._afterAll);
  }

  if (Array.isArray(this._afterEach)) {
    cleanArrReferences(this._afterEach);
  }

  for (var i = 0; i < this.tests.length; i++) {
    delete this.tests[i].fn;
  }
};

/**
 * Returns an object suitable for IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Suite.prototype.serialize = function serialize() {
  return {
    _bail: this._bail,
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.isPending()),
    root: this.root,
    title: this.title,
    [MOCHA_ID_PROP_NAME]: this.id,
    parent: this.parent ? {[MOCHA_ID_PROP_NAME]: this.parent.id} : null
  };
};

var constants = defineConstants(
  /**
   * {@link Suite}-related constants.
   * @public
   * @memberof Suite
   * @alias constants
   * @readonly
   * @static
   * @enum {string}
   */
  {
    /**
     * Event emitted after a test file has been loaded. Not emitted in browser.
     */
    EVENT_FILE_POST_REQUIRE: 'post-require',
    /**
     * Event emitted before a test file has been loaded. In browser, this is emitted once an interface has been selected.
     */
    EVENT_FILE_PRE_REQUIRE: 'pre-require',
    /**
     * Event emitted immediately after a test file has been loaded. Not emitted in browser.
     */
    EVENT_FILE_REQUIRE: 'require',
    /**
     * Event emitted when `global.run()` is called (use with `delay` option).
     */
    EVENT_ROOT_SUITE_RUN: 'run',

    /**
     * Namespace for collection of a `Suite`'s "after all" hooks.
     */
    HOOK_TYPE_AFTER_ALL: 'afterAll',
    /**
     * Namespace for collection of a `Suite`'s "after each" hooks.
     */
    HOOK_TYPE_AFTER_EACH: 'afterEach',
    /**
     * Namespace for collection of a `Suite`'s "before all" hooks.
     */
    HOOK_TYPE_BEFORE_ALL: 'beforeAll',
    /**
     * Namespace for collection of a `Suite`'s "before each" hooks.
     */
    HOOK_TYPE_BEFORE_EACH: 'beforeEach',

    /**
     * Emitted after a child `Suite` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_SUITE: 'suite',
    /**
     * Emitted after an "after all" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_AFTER_ALL: 'afterAll',
    /**
     * Emitted after an "after each" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_AFTER_EACH: 'afterEach',
    /**
     * Emitted after an "before all" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_BEFORE_ALL: 'beforeAll',
    /**
     * Emitted after an "before each" `Hook` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_HOOK_BEFORE_EACH: 'beforeEach',
    /**
     * Emitted after a `Test` has been added to a `Suite`.
     */
    EVENT_SUITE_ADD_TEST: 'test'
  }
);

Suite.constants = constants;


/***/ }),

/***/ "../node_modules/mocha/lib/test.js":
/*!*****************************************!*\
  !*** ../node_modules/mocha/lib/test.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Runnable = __webpack_require__(/*! ./runnable */ "../node_modules/mocha/lib/runnable.js");
var utils = __webpack_require__(/*! ./utils */ "../node_modules/mocha/lib/utils.js");
var errors = __webpack_require__(/*! ./errors */ "../node_modules/mocha/lib/errors.js");
var createInvalidArgumentTypeError = errors.createInvalidArgumentTypeError;
var isString = utils.isString;

const {MOCHA_ID_PROP_NAME} = utils.constants;

module.exports = Test;

/**
 * Initialize a new `Test` with the given `title` and callback `fn`.
 *
 * @public
 * @class
 * @extends Runnable
 * @param {String} title - Test title (required)
 * @param {Function} [fn] - Test callback.  If omitted, the Test is considered "pending"
 */
function Test(title, fn) {
  if (!isString(title)) {
    throw createInvalidArgumentTypeError(
      'Test argument "title" should be a string. Received type "' +
        typeof title +
        '"',
      'title',
      'string'
    );
  }
  this.type = 'test';
  Runnable.call(this, title, fn);
  this.reset();
}

/**
 * Inherit from `Runnable.prototype`.
 */
utils.inherits(Test, Runnable);

/**
 * Resets the state initially or for a next run.
 */
Test.prototype.reset = function () {
  Runnable.prototype.reset.call(this);
  this.pending = !this.fn;
  delete this.state;
};

/**
 * Set or get retried test
 *
 * @private
 */
Test.prototype.retriedTest = function (n) {
  if (!arguments.length) {
    return this._retriedTest;
  }
  this._retriedTest = n;
};

/**
 * Add test to the list of tests marked `only`.
 *
 * @private
 */
Test.prototype.markOnly = function () {
  this.parent.appendOnlyTest(this);
};

Test.prototype.clone = function () {
  var test = new Test(this.title, this.fn);
  test.timeout(this.timeout());
  test.slow(this.slow());
  test.retries(this.retries());
  test.currentRetry(this.currentRetry());
  test.retriedTest(this.retriedTest() || this);
  test.globals(this.globals());
  test.parent = this.parent;
  test.file = this.file;
  test.ctx = this.ctx;
  return test;
};

/**
 * Returns an minimal object suitable for transmission over IPC.
 * Functions are represented by keys beginning with `$$`.
 * @private
 * @returns {Object}
 */
Test.prototype.serialize = function serialize() {
  return {
    $$currentRetry: this._currentRetry,
    $$fullTitle: this.fullTitle(),
    $$isPending: Boolean(this.pending),
    $$retriedTest: this._retriedTest || null,
    $$slow: this._slow,
    $$titlePath: this.titlePath(),
    body: this.body,
    duration: this.duration,
    err: this.err,
    parent: {
      $$fullTitle: this.parent.fullTitle(),
      [MOCHA_ID_PROP_NAME]: this.parent.id
    },
    speed: this.speed,
    state: this.state,
    title: this.title,
    type: this.type,
    file: this.file,
    [MOCHA_ID_PROP_NAME]: this.id
  };
};


/***/ }),

/***/ "../node_modules/mocha/lib/utils.js":
/*!******************************************!*\
  !*** ../node_modules/mocha/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");


/**
 * Various utility functions used throughout Mocha's codebase.
 * @module utils
 */

/**
 * Module dependencies.
 */

const {nanoid} = __webpack_require__(/*! nanoid/non-secure */ "../node_modules/nanoid/non-secure/index.cjs");
var path = __webpack_require__(/*! path */ "?147c");
var util = __webpack_require__(/*! util */ "../node_modules/util/util.js");
var he = __webpack_require__(/*! he */ "../node_modules/he/he.js");

const MOCHA_ID_PROP_NAME = '__mocha_id__';

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * @param {function} ctor - Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor - Constructor function to inherit prototype from.
 * @throws {TypeError} if either constructor is null, or if super constructor
 *     lacks a prototype.
 */
exports.inherits = util.inherits;

/**
 * Escape special characters in the given string of html.
 *
 * @private
 * @param  {string} html
 * @return {string}
 */
exports.escape = function (html) {
  return he.encode(String(html), {useNamedReferences: false});
};

/**
 * Test if the given obj is type of string.
 *
 * @private
 * @param {Object} obj
 * @return {boolean}
 */
exports.isString = function (obj) {
  return typeof obj === 'string';
};

/**
 * Compute a slug from the given `str`.
 *
 * @private
 * @param {string} str
 * @return {string}
 */
exports.slug = function (str) {
  return str
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^-\w]/g, '')
    .replace(/-{2,}/g, '-');
};

/**
 * Strip the function definition from `str`, and re-indent for pre whitespace.
 *
 * @param {string} str
 * @return {string}
 */
exports.clean = function (str) {
  str = str
    .replace(/\r\n?|[\n\u2028\u2029]/g, '\n')
    .replace(/^\uFEFF/, '')
    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content
    .replace(
      /^function(?:\s*|\s+[^(]*)\([^)]*\)\s*\{((?:.|\n)*?)\s*\}$|^\([^)]*\)\s*=>\s*(?:\{((?:.|\n)*?)\s*\}|((?:.|\n)*))$/,
      '$1$2$3'
    );

  var spaces = str.match(/^\n?( *)/)[1].length;
  var tabs = str.match(/^\n?(\t*)/)[1].length;
  var re = new RegExp(
    '^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs || spaces) + '}',
    'gm'
  );

  str = str.replace(re, '');

  return str.trim();
};

/**
 * If a value could have properties, and has none, this function is called,
 * which returns a string representation of the empty value.
 *
 * Functions w/ no properties return `'[Function]'`
 * Arrays w/ length === 0 return `'[]'`
 * Objects w/ no properties return `'{}'`
 * All else: return result of `value.toString()`
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} typeHint The type of the value
 * @returns {string}
 */
function emptyRepresentation(value, typeHint) {
  switch (typeHint) {
    case 'function':
      return '[Function]';
    case 'object':
      return '{}';
    case 'array':
      return '[]';
    default:
      return value.toString();
  }
}

/**
 * Takes some variable and asks `Object.prototype.toString()` what it thinks it
 * is.
 *
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
 * @param {*} value The value to test.
 * @returns {string} Computed type
 * @example
 * canonicalType({}) // 'object'
 * canonicalType([]) // 'array'
 * canonicalType(1) // 'number'
 * canonicalType(false) // 'boolean'
 * canonicalType(Infinity) // 'number'
 * canonicalType(null) // 'null'
 * canonicalType(new Date()) // 'date'
 * canonicalType(/foo/) // 'regexp'
 * canonicalType('type') // 'string'
 * canonicalType(global) // 'global'
 * canonicalType(new String('foo') // 'object'
 * canonicalType(async function() {}) // 'asyncfunction'
 * canonicalType(await import(name)) // 'module'
 */
var canonicalType = (exports.canonicalType = function canonicalType(value) {
  if (value === undefined) {
    return 'undefined';
  } else if (value === null) {
    return 'null';
  } else if (Buffer.isBuffer(value)) {
    return 'buffer';
  }
  return Object.prototype.toString
    .call(value)
    .replace(/^\[.+\s(.+?)]$/, '$1')
    .toLowerCase();
});

/**
 *
 * Returns a general type or data structure of a variable
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures
 * @param {*} value The value to test.
 * @returns {string} One of undefined, boolean, number, string, bigint, symbol, object
 * @example
 * type({}) // 'object'
 * type([]) // 'array'
 * type(1) // 'number'
 * type(false) // 'boolean'
 * type(Infinity) // 'number'
 * type(null) // 'null'
 * type(new Date()) // 'object'
 * type(/foo/) // 'object'
 * type('type') // 'string'
 * type(global) // 'object'
 * type(new String('foo') // 'string'
 */
exports.type = function type(value) {
  // Null is special
  if (value === null) return 'null';
  const primitives = new Set([
    'undefined',
    'boolean',
    'number',
    'string',
    'bigint',
    'symbol'
  ]);
  const _type = typeof value;
  if (_type === 'function') return _type;
  if (primitives.has(_type)) return _type;
  if (value instanceof String) return 'string';
  if (value instanceof Error) return 'error';
  if (Array.isArray(value)) return 'array';

  return _type;
};

/**
 * Stringify `value`. Different behavior depending on type of value:
 *
 * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.
 * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
 * - If `value` is an *empty* object, function, or array, return result of function
 *   {@link emptyRepresentation}.
 * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
 *   JSON.stringify().
 *
 * @private
 * @see exports.type
 * @param {*} value
 * @return {string}
 */
exports.stringify = function (value) {
  var typeHint = canonicalType(value);

  if (!~['object', 'array', 'function'].indexOf(typeHint)) {
    if (typeHint === 'buffer') {
      var json = Buffer.prototype.toJSON.call(value);
      // Based on the toJSON result
      return jsonStringify(
        json.data && json.type ? json.data : json,
        2
      ).replace(/,(\n|$)/g, '$1');
    }

    // IE7/IE8 has a bizarre String constructor; needs to be coerced
    // into an array and back to obj.
    if (typeHint === 'string' && typeof value === 'object') {
      value = value.split('').reduce(function (acc, char, idx) {
        acc[idx] = char;
        return acc;
      }, {});
      typeHint = 'object';
    } else {
      return jsonStringify(value);
    }
  }

  for (var prop in value) {
    if (Object.prototype.hasOwnProperty.call(value, prop)) {
      return jsonStringify(
        exports.canonicalize(value, null, typeHint),
        2
      ).replace(/,(\n|$)/g, '$1');
    }
  }

  return emptyRepresentation(value, typeHint);
};

/**
 * like JSON.stringify but more sense.
 *
 * @private
 * @param {Object}  object
 * @param {number=} spaces
 * @param {number=} depth
 * @returns {*}
 */
function jsonStringify(object, spaces, depth) {
  if (typeof spaces === 'undefined') {
    // primitive types
    return _stringify(object);
  }

  depth = depth || 1;
  var space = spaces * depth;
  var str = Array.isArray(object) ? '[' : '{';
  var end = Array.isArray(object) ? ']' : '}';
  var length =
    typeof object.length === 'number'
      ? object.length
      : Object.keys(object).length;
  // `.repeat()` polyfill
  function repeat(s, n) {
    return new Array(n).join(s);
  }

  function _stringify(val) {
    switch (canonicalType(val)) {
      case 'null':
      case 'undefined':
        val = '[' + val + ']';
        break;
      case 'array':
      case 'object':
        val = jsonStringify(val, spaces, depth + 1);
        break;
      case 'boolean':
      case 'regexp':
      case 'symbol':
      case 'number':
        val =
          val === 0 && 1 / val === -Infinity // `-0`
            ? '-0'
            : val.toString();
        break;
      case 'bigint':
        val = val.toString() + 'n';
        break;
      case 'date':
        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();
        val = '[Date: ' + sDate + ']';
        break;
      case 'buffer':
        var json = val.toJSON();
        // Based on the toJSON result
        json = json.data && json.type ? json.data : json;
        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';
        break;
      default:
        val =
          val === '[Function]' || val === '[Circular]'
            ? val
            : JSON.stringify(val); // string
    }
    return val;
  }

  for (var i in object) {
    if (!Object.prototype.hasOwnProperty.call(object, i)) {
      continue; // not my business
    }
    --length;
    str +=
      '\n ' +
      repeat(' ', space) +
      (Array.isArray(object) ? '' : '"' + i + '": ') + // key
      _stringify(object[i]) + // value
      (length ? ',' : ''); // comma
  }

  return (
    str +
    // [], {}
    (str.length !== 1 ? '\n' + repeat(' ', --space) + end : end)
  );
}

/**
 * Return a new Thing that has the keys in sorted order. Recursive.
 *
 * If the Thing...
 * - has already been seen, return string `'[Circular]'`
 * - is `undefined`, return string `'[undefined]'`
 * - is `null`, return value `null`
 * - is some other primitive, return the value
 * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method
 * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
 * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
 *
 * @private
 * @see {@link exports.stringify}
 * @param {*} value Thing to inspect.  May or may not have properties.
 * @param {Array} [stack=[]] Stack of seen values
 * @param {string} [typeHint] Type hint
 * @return {(Object|Array|Function|string|undefined)}
 */
exports.canonicalize = function canonicalize(value, stack, typeHint) {
  var canonicalizedObj;
  /* eslint-disable no-unused-vars */
  var prop;
  /* eslint-enable no-unused-vars */
  typeHint = typeHint || canonicalType(value);
  function withStack(value, fn) {
    stack.push(value);
    fn();
    stack.pop();
  }

  stack = stack || [];

  if (stack.indexOf(value) !== -1) {
    return '[Circular]';
  }

  switch (typeHint) {
    case 'undefined':
    case 'buffer':
    case 'null':
      canonicalizedObj = value;
      break;
    case 'array':
      withStack(value, function () {
        canonicalizedObj = value.map(function (item) {
          return exports.canonicalize(item, stack);
        });
      });
      break;
    case 'function':
      /* eslint-disable-next-line no-unused-vars, no-unreachable-loop */
      for (prop in value) {
        canonicalizedObj = {};
        break;
      }
      /* eslint-enable guard-for-in */
      if (!canonicalizedObj) {
        canonicalizedObj = emptyRepresentation(value, typeHint);
        break;
      }
    /* falls through */
    case 'object':
      canonicalizedObj = canonicalizedObj || {};
      withStack(value, function () {
        Object.keys(value)
          .sort()
          .forEach(function (key) {
            canonicalizedObj[key] = exports.canonicalize(value[key], stack);
          });
      });
      break;
    case 'date':
    case 'number':
    case 'regexp':
    case 'boolean':
    case 'symbol':
      canonicalizedObj = value;
      break;
    default:
      canonicalizedObj = value + '';
  }

  return canonicalizedObj;
};

/**
 * @summary
 * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
 * @description
 * When invoking this function you get a filter function that get the Error.stack as an input,
 * and return a prettify output.
 * (i.e: strip Mocha and internal node functions from stack trace).
 * @returns {Function}
 */
exports.stackTraceFilter = function () {
  // TODO: Replace with `process.browser`
  var is = typeof document === 'undefined' ? {node: true} : {browser: true};
  var slash = path.sep;
  var cwd;
  if (is.node) {
    cwd = exports.cwd() + slash;
  } else {
    cwd = (
      typeof location === 'undefined' ? window.location : location
    ).href.replace(/\/[^/]*$/, '/');
    slash = '/';
  }

  function isMochaInternal(line) {
    return (
      ~line.indexOf('node_modules' + slash + 'mocha' + slash) ||
      ~line.indexOf(slash + 'mocha.js') ||
      ~line.indexOf(slash + 'mocha.min.js')
    );
  }

  function isNodeInternal(line) {
    return (
      ~line.indexOf('(timers.js:') ||
      ~line.indexOf('(events.js:') ||
      ~line.indexOf('(node.js:') ||
      ~line.indexOf('(module.js:') ||
      ~line.indexOf('GeneratorFunctionPrototype.next (native)') ||
      false
    );
  }

  return function (stack) {
    stack = stack.split('\n');

    stack = stack.reduce(function (list, line) {
      if (isMochaInternal(line)) {
        return list;
      }

      if (is.node && isNodeInternal(line)) {
        return list;
      }

      // Clean up cwd(absolute)
      if (/:\d+:\d+\)?$/.test(line)) {
        line = line.replace('(' + cwd, '(');
      }

      list.push(line);
      return list;
    }, []);

    return stack.join('\n');
  };
};

/**
 * Crude, but effective.
 * @public
 * @param {*} value
 * @returns {boolean} Whether or not `value` is a Promise
 */
exports.isPromise = function isPromise(value) {
  return (
    typeof value === 'object' &&
    value !== null &&
    typeof value.then === 'function'
  );
};

/**
 * Clamps a numeric value to an inclusive range.
 *
 * @param {number} value - Value to be clamped.
 * @param {number[]} range - Two element array specifying [min, max] range.
 * @returns {number} clamped value
 */
exports.clamp = function clamp(value, range) {
  return Math.min(Math.max(value, range[0]), range[1]);
};

/**
 * It's a noop.
 * @public
 */
exports.noop = function () {};

/**
 * Creates a map-like object.
 *
 * @description
 * A "map" is an object with no prototype, for our purposes. In some cases
 * this would be more appropriate than a `Map`, especially if your environment
 * doesn't support it. Recommended for use in Mocha's public APIs.
 *
 * @public
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Custom_and_Null_objects|MDN:Map}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Custom_and_Null_objects|MDN:Object.create - Custom objects}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Custom_and_Null_objects|MDN:Object.assign}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} An object with no prototype, having `...obj` properties
 */
exports.createMap = function (obj) {
  return Object.assign.apply(
    null,
    [Object.create(null)].concat(Array.prototype.slice.call(arguments))
  );
};

/**
 * Creates a read-only map-like object.
 *
 * @description
 * This differs from {@link module:utils.createMap createMap} only in that
 * the argument must be non-empty, because the result is frozen.
 *
 * @see {@link module:utils.createMap createMap}
 * @param {...*} [obj] - Arguments to `Object.assign()`.
 * @returns {Object} A frozen object with no prototype, having `...obj` properties
 * @throws {TypeError} if argument is not a non-empty object.
 */
exports.defineConstants = function (obj) {
  if (canonicalType(obj) !== 'object' || !Object.keys(obj).length) {
    throw new TypeError('Invalid argument; expected a non-empty object');
  }
  return Object.freeze(exports.createMap(obj));
};

/**
 * Returns current working directory
 *
 * Wrapper around `process.cwd()` for isolation
 * @private
 */
exports.cwd = function cwd() {
  return process.cwd();
};

/**
 * Returns `true` if Mocha is running in a browser.
 * Checks for `process.browser`.
 * @returns {boolean}
 * @private
 */
exports.isBrowser = function isBrowser() {
  return Boolean(process.browser);
};

/*
 * Casts `value` to an array; useful for optionally accepting array parameters
 *
 * It follows these rules, depending on `value`.  If `value` is...
 * 1. `undefined`: return an empty Array
 * 2. `null`: return an array with a single `null` element
 * 3. Any other object: return the value of `Array.from()` _if_ the object is iterable
 * 4. otherwise: return an array with a single element, `value`
 * @param {*} value - Something to cast to an Array
 * @returns {Array<*>}
 */
exports.castArray = function castArray(value) {
  if (value === undefined) {
    return [];
  }
  if (value === null) {
    return [null];
  }
  if (
    typeof value === 'object' &&
    (typeof value[Symbol.iterator] === 'function' || value.length !== undefined)
  ) {
    return Array.from(value);
  }
  return [value];
};

exports.constants = exports.defineConstants({
  MOCHA_ID_PROP_NAME
});

/**
 * Creates a new unique identifier
 * @returns {string} Unique identifier
 */
exports.uniqueID = () => nanoid();

exports.assignNewMochaID = obj => {
  const id = exports.uniqueID();
  Object.defineProperty(obj, MOCHA_ID_PROP_NAME, {
    get() {
      return id;
    }
  });
  return obj;
};

/**
 * Retrieves a Mocha ID from an object, if present.
 * @param {*} [obj] - Object
 * @returns {string|void}
 */
exports.getMochaID = obj =>
  obj && typeof obj === 'object' ? obj[MOCHA_ID_PROP_NAME] : undefined;


/***/ }),

/***/ "../node_modules/nanoid/non-secure/index.cjs":
/*!***************************************************!*\
  !*** ../node_modules/nanoid/non-secure/index.cjs ***!
  \***************************************************/
/***/ ((module) => {

let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
module.exports = { nanoid, customAlphabet }


/***/ }),

/***/ "../node_modules/chai/index.mjs":
/*!**************************************!*\
  !*** ../node_modules/chai/index.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Assertion": () => (/* binding */ Assertion),
/* harmony export */   "AssertionError": () => (/* binding */ AssertionError),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "config": () => (/* binding */ config),
/* harmony export */   "core": () => (/* binding */ core),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "expect": () => (/* binding */ expect),
/* harmony export */   "should": () => (/* binding */ should),
/* harmony export */   "use": () => (/* binding */ use),
/* harmony export */   "util": () => (/* binding */ util),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../node_modules/chai/index.js");


const expect = _index_js__WEBPACK_IMPORTED_MODULE_0__.expect;
const version = _index_js__WEBPACK_IMPORTED_MODULE_0__.version;
const Assertion = _index_js__WEBPACK_IMPORTED_MODULE_0__.Assertion;
const AssertionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AssertionError;
const util = _index_js__WEBPACK_IMPORTED_MODULE_0__.util;
const config = _index_js__WEBPACK_IMPORTED_MODULE_0__.config;
const use = _index_js__WEBPACK_IMPORTED_MODULE_0__.use;
const should = _index_js__WEBPACK_IMPORTED_MODULE_0__.should;
const assert = _index_js__WEBPACK_IMPORTED_MODULE_0__.assert;
const core = _index_js__WEBPACK_IMPORTED_MODULE_0__.core;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "../node_modules/mocha/lib/mocharc.json":
/*!**********************************************!*\
  !*** ../node_modules/mocha/lib/mocharc.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"diff":true,"extension":["js","cjs","mjs"],"package":"./package.json","reporter":"spec","slow":75,"timeout":2000,"ui":"bdd","watch-ignore":["node_modules",".git"]}');

/***/ }),

/***/ "../node_modules/mocha/package.json":
/*!******************************************!*\
  !*** ../node_modules/mocha/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"mocha","version":"10.0.0","type":"commonjs","description":"simple, flexible, fun test framework","keywords":["mocha","test","bdd","tdd","tap","testing","chai","assertion","ava","jest","tape","jasmine","karma"],"author":"TJ Holowaychuk <tj@vision-media.ca>","license":"MIT","repository":{"type":"git","url":"https://github.com/mochajs/mocha.git"},"bugs":{"url":"https://github.com/mochajs/mocha/issues/"},"funding":{"type":"opencollective","url":"https://opencollective.com/mochajs"},"gitter":"https://gitter.im/mochajs/mocha","homepage":"https://mochajs.org/","logo":"https://cldup.com/S9uQ-cOLYz.svg","notifyLogo":"https://ibin.co/4QuRuGjXvl36.png","bin":{"mocha":"./bin/mocha.js","_mocha":"./bin/_mocha"},"directories":{"lib":"./lib","test":"./test"},"engines":{"node":">= 14.0.0"},"scripts":{"prepublishOnly":"nps test clean build","start":"nps","test":"nps test","version":"nps version","test:smoke":"node ./bin/mocha --no-config test/smoke/smoke.spec.js"},"dependencies":{"@ungap/promise-all-settled":"1.1.2","ansi-colors":"4.1.1","browser-stdout":"1.3.1","chokidar":"3.5.3","debug":"4.3.4","diff":"5.0.0","escape-string-regexp":"4.0.0","find-up":"5.0.0","glob":"7.2.0","he":"1.2.0","js-yaml":"4.1.0","log-symbols":"4.1.0","minimatch":"5.0.1","ms":"2.1.3","nanoid":"3.3.3","serialize-javascript":"6.0.0","strip-json-comments":"3.1.1","supports-color":"8.1.1","workerpool":"6.2.1","yargs":"16.2.0","yargs-parser":"20.2.4","yargs-unparser":"2.0.0"},"devDependencies":{"@11ty/eleventy":"^1.0.0","@11ty/eleventy-plugin-inclusive-language":"^1.0.3","@babel/eslint-parser":"^7.16.5","@mocha/docdash":"^4.0.1","@rollup/plugin-commonjs":"^21.0.2","@rollup/plugin-json":"^4.1.0","@rollup/plugin-multi-entry":"^4.0.1","@rollup/plugin-node-resolve":"^13.1.3","assetgraph-builder":"^9.0.0","autoprefixer":"^9.8.6","canvas":"^2.9.0","chai":"^4.3.4","coffeescript":"^2.6.1","configstore":"^5.0.1","coveralls":"^3.1.1","cross-env":"^7.0.2","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","eslint-config-semistandard":"^16.0.0","eslint-config-standard":"^16.0.3","eslint-plugin-import":"^2.24.2","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.0.0","eslint-plugin-promise":"^5.1.0","fail-on-errors-webpack-plugin":"^3.0.0","fs-extra":"^10.0.0","husky":"^4.2.5","hyperlink":"^5.0.4","jsdoc":"^3.6.7","jsdoc-ts-utils":"^2.0.1","karma":"^6.3.11","karma-chrome-launcher":"^3.1.0","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sauce-launcher":"^4.3.6","lint-staged":"^10.2.11","markdown-it":"^12.3.2","markdown-it-anchor":"^8.4.1","markdown-it-attrs":"^4.1.3","markdown-it-emoji":"^2.0.0","markdown-it-prism":"^2.2.2","markdown-toc":"^1.2.0","markdownlint-cli":"^0.30.0","needle":"^2.5.0","nps":"^5.10.0","nyc":"^15.1.0","pidtree":"^0.5.0","prettier":"^2.4.1","remark":"^14.0.2","remark-github":"^11.2.2","remark-inline-links":"^6.0.1","rewiremock":"^3.14.3","rimraf":"^3.0.2","rollup":"^2.70.1","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-polyfill-node":"^0.8.0","rollup-plugin-visualizer":"^5.6.0","sinon":"^9.0.3","strip-ansi":"^6.0.0","svgo":"^1.3.2","through2":"^4.0.2","touch":"^3.1.0","unexpected":"^11.14.0","unexpected-eventemitter":"^2.2.0","unexpected-map":"^2.0.0","unexpected-set":"^3.0.0","unexpected-sinon":"^10.11.2","update-notifier":"^4.1.0","uslug":"^1.0.4","uuid":"^8.3.0","watchify":"^4.0.0","webpack":"^5.67.0","webpack-cli":"^4.9.1"},"files":["bin/*mocha*","lib/**/*.{js,html,json}","index.js","mocha.css","mocha.js","mocha.js.map","browser-entry.js"],"browser":{"./index.js":"./browser-entry.js","fs":false,"path":false,"supports-color":false,"./lib/nodejs/buffered-worker-pool.js":false,"./lib/nodejs/esm-utils.js":false,"./lib/nodejs/file-unloader.js":false,"./lib/nodejs/parallel-buffered-runner.js":false,"./lib/nodejs/serializer.js":false,"./lib/nodejs/worker.js":false,"./lib/nodejs/reporters/parallel-buffered.js":false,"./lib/cli/index.js":false},"prettier":{"arrowParens":"avoid","bracketSpacing":false,"endOfLine":"auto","singleQuote":true,"trailingComma":"none"},"husky":{"hooks":{"pre-commit":"lint-staged"}}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "allTests": () => (/* reexport safe */ _test_testSuite__WEBPACK_IMPORTED_MODULE_0__.allTests),
/* harmony export */   "executeTestsInBrowser": () => (/* reexport safe */ _test_testSuite__WEBPACK_IMPORTED_MODULE_0__.executeTestsInBrowser),
/* harmony export */   "getPackMembers": () => (/* reexport safe */ _test_testSuite__WEBPACK_IMPORTED_MODULE_0__.getPackMembers),
/* harmony export */   "getPackNames": () => (/* reexport safe */ _test_testSuite__WEBPACK_IMPORTED_MODULE_0__.getPackNames),
/* harmony export */   "packs": () => (/* reexport safe */ _test_testSuite__WEBPACK_IMPORTED_MODULE_0__.packs)
/* harmony export */ });
/* harmony import */ var _test_testSuite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./test/testSuite */ "./src/test/testSuite.ts");


})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBeUI7O0FBRXpCO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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TztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7QUN2SkEsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0Y0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYzs7Ozs7Ozs7Ozs7O0FDL0J6RDtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7Ozs7Ozs7Ozs7OztBQ3pDekQ7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQztBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7Ozs7Ozs7Ozs7OztBQzVDekQ7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDZCQUE2QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjOzs7Ozs7Ozs7Ozs7QUMvU3pEO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCO0FBQ2pCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMscURBQVE7QUFDL0M7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYzs7Ozs7Ozs7Ozs7O0FDcEN6RDtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLHFEQUFRO0FBQy9DO0FBQ0E7O0FBRUEsaUVBQWlFLHVDQUF1Qzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYzs7Ozs7Ozs7Ozs7O0FDeEN6RDtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMscURBQVE7QUFDeEI7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4Ryx3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxjQUFjOzs7Ozs7Ozs7Ozs7QUNsS3pEO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QixnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLHFEQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQywrREFBZ0I7QUFDbEM7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osa0JBQWtCLDZCQUE2QjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyxjQUFjOzs7Ozs7Ozs7Ozs7QUN4RnpEO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCO0FBQ3JCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMscURBQVE7QUFDL0M7QUFDQTs7QUFFQSxpRUFBaUUsdUNBQXVDOztBQUV4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7Ozs7Ozs7Ozs7OztBQ3hDekQ7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMscURBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLCtEQUFnQjtBQUNsQztBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7O0FBRS9ELGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjOzs7Ozs7Ozs7Ozs7QUMzR3pEO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLDBEQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQywwREFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsa0VBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sbUJBQU8sQ0FBQyx3REFBWTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsMERBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDREQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyw4REFBZTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsOERBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDhEQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLDhEQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sbUJBQU8sQ0FBQyw4REFBZTtBQUM5QjtBQUNBOztBQUVBLGlFQUFpRSx1Q0FBdUM7O0FBRXhHO0FBQ0EsMkNBQTJDLGNBQWM7Ozs7Ozs7Ozs7OztBQ3ZOekQ7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsd0RBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLG1CQUFPLENBQUMscUZBQTJCO0FBQzlFO0FBQ0E7O0FBRUEsaUVBQWlFLHVDQUF1Qzs7QUFFeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxjQUFjOzs7Ozs7Ozs7Ozs7QUM3T3pEO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQiwyQkFBMkI7QUFDM0IsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFPLENBQUMsMkRBQWM7QUFDOUI7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdELGdDQUFnQzs7QUFFaEMsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLGtDQUFrQzs7QUFFbEMsbUNBQW1DOztBQUVuQyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUs7OztBQUdaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qyw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYzs7Ozs7Ozs7Ozs7O0FDMVF6RDtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHFCQUFxQjtBQUNyQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQywwREFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsd0RBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDZEQUFlO0FBQ2hDO0FBQ0E7O0FBRUEsNkRBQTZEOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3UyxrQ0FBa0M7O0FBRWxDLG1DQUFtQzs7QUFFbkMsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUU2VTtBQUN4Vzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3YrQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxrQ0FBa0M7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtEQUFrRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBLGNBQWMsMExBQTBMO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0IsSUFBSTtBQUMzQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaktBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN2U0E7O0dBRUc7QUFFSCxJQUFNLGdCQUFnQixHQUFHO0lBQ3ZCLFlBQVksRUFBRSxzREFBc0Q7SUFDcEUsa0JBQWtCLEVBQ2hCLHlFQUF5RTtJQUMzRSxpQkFBaUIsRUFDZixvRUFBb0U7SUFDdEUsU0FBUyxFQUFFLDREQUE0RDtJQUN2RSxVQUFVLEVBQUUsaUVBQWlFO0lBQzdFLG9CQUFvQixFQUNsQiwyRUFBMkU7SUFDN0UsaUJBQWlCLEVBQ2Ysd0VBQXdFO0lBQzFFLE9BQU8sRUFBRSw4REFBOEQ7SUFDdkUsVUFBVSxFQUFFLDBEQUEwRDtJQUN0RSxrQkFBa0IsRUFDaEIseUVBQXlFO0lBQzNFLGlCQUFpQixFQUNmLHdFQUF3RTtJQUMxRSxXQUFXLEVBQ1Qsa0VBQWtFO0lBQ3BFLG1CQUFtQixFQUNqQiwwRUFBMEU7SUFDNUUsSUFBSSxFQUFFLDJEQUEyRDtJQUNqRSxXQUFXLEVBQ1Qsa0VBQWtFO0lBQ3BFLHFCQUFxQixFQUNuQiw0RUFBNEU7SUFDOUUsV0FBVyxFQUFFLDBEQUEwRDtJQUN2RSxhQUFhLEVBQ1gsZ0VBQWdFO0NBQzFELENBQUM7QUFFWCxpRUFBZSxnQkFBZ0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDaEM7O0dBRUc7QUFDSCxJQUFNLFNBQVMsR0FBRztJQUNoQixXQUFXLEVBQUUsR0FBRztJQUNoQixXQUFXLEVBQUUsSUFBSTtJQUNqQixRQUFRLEVBQUUsSUFBSTtJQUNkLG1CQUFtQixFQUFFLEdBQUcsRUFBRSw2REFBNkQ7Q0FDL0UsQ0FBQztBQUVYLGlFQUFlLFNBQVMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVlk7QUFDQTtBQUV5QztBQUNGO0FBQ2I7QUFDRTtBQUNvQjtBQUNUO0FBQ3BCO0FBQ3NCO0FBQ0Y7QUFDWjtBQUNnQjtBQUMzQjtBQUNjO0FBQ2lCO0FBQ047QUFDRjtBQUNiO0FBQy9ELDJEQUEyRDtBQUMzRCwrRUFBK0U7QUFDSDtBQUNqQjtBQUVtQjtBQUNOO0FBQ0M7QUFDRjtBQUNDO0FBQ1E7QUFDaEYsK0NBQStDO0FBQy9DLDZEQUE2RDtBQUN1QjtBQUlwRixJQUFNLGNBQWMsR0FBWTtJQUM5QiwwQkFBMEIsRUFBRSxDQUFDLDJFQUEwQixDQUFDO0lBQ3hELHlCQUF5QixFQUFFLENBQUMsMEVBQXlCLENBQUM7SUFDdEQseUJBQXlCLEVBQUUsQ0FBQywwRUFBeUIsQ0FBQztJQUN0RCxlQUFlLEVBQUUsQ0FBQyxnRUFBZSxDQUFDO0lBQ2xDLDBCQUEwQixFQUFFLENBQUMsMkVBQTBCLENBQUM7SUFDeEQseUJBQXlCLEVBQUUsQ0FBQywyRUFBeUIsQ0FBQztJQUN0RCxtQkFBbUIsRUFBRSxDQUFDLHFFQUFtQixDQUFDO0lBQzFDLDJCQUEyQixFQUFFLENBQUMsNkVBQTJCLENBQUM7SUFDMUQsNkJBQTZCLEVBQUUsQ0FBQywrRUFBNkIsQ0FBQztDQUMvRCxDQUFDO0FBRUYsSUFBTSxjQUFjLEdBQVk7SUFDOUIsMEJBQTBCLEVBQUUsQ0FBQyw0RUFBMEIsQ0FBQztJQUN4RCx5QkFBeUIsRUFBRSxDQUFDLDJFQUF5QixDQUFDO0lBQ3RELHlCQUF5QixFQUFFLENBQUMsMkVBQXlCLENBQUM7SUFDdEQsZUFBZSxFQUFFLENBQUMsb0VBQWUsQ0FBQztJQUNsQywwQkFBMEIsRUFBRSxDQUFDLDRFQUEwQixDQUFDO0lBQ3hELHVCQUF1QixFQUFFLENBQUMseUVBQXVCLENBQUM7SUFDbEQsdUJBQXVCLEVBQUUsQ0FBQyx5RUFBdUIsQ0FBQztJQUNsRCwyQkFBMkIsRUFBRSxDQUFDLDZFQUEyQixDQUFDO0lBQzFELDZCQUE2QixFQUFFLENBQUMsK0VBQTZCLENBQUM7Q0FDL0QsQ0FBQztBQUVGLElBQU0saUJBQWlCLEdBQVk7SUFDakMsWUFBWSxFQUFFLENBQUMsaUVBQVksQ0FBQztJQUM1QixpQkFBaUIsRUFBRSxDQUFDLHFFQUFpQixDQUFDO0lBQ3RDLGtCQUFrQixFQUFFLENBQUMsc0VBQWtCLENBQUM7SUFDeEMsbUJBQW1CLEVBQUUsQ0FBQyx3RUFBbUIsQ0FBQztJQUMxQyw0QkFBNEIsRUFBRSxDQUFDLGdGQUE0QixDQUFDO0NBQzdELENBQUM7QUFFRixJQUFNLGlCQUFpQixHQUFZO0lBQ2pDLGlCQUFpQixFQUFFLENBQUMsc0VBQWlCLENBQUM7SUFDdEMsZUFBZSxFQUFFLENBQUMsb0VBQWUsQ0FBQztJQUNsQyxxQkFBcUIsRUFBRSxDQUFDLDBFQUFxQixDQUFDO0lBQzlDLHNCQUFzQixFQUFFLENBQUMsMkVBQXNCLENBQUM7Q0FDakQsQ0FBQztBQUVGLFNBQVMsV0FBVyxDQUFDLEVBQWE7SUFDaEMsSUFBTSxHQUFHLEdBQW1CLEVBQUUsQ0FBQztJQUMvQixFQUFFLENBQUMsR0FBRyxDQUFDLFVBQUMsSUFBSTtRQUNWLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEdBQUcsSUFBSyxVQUFHLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSSxJQUFLLFVBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQWQsQ0FBYyxDQUFDLEVBQXJDLENBQXFDLENBQUMsQ0FBQztJQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVNLElBQU0sUUFBUSx5Q0FDbkIsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLEVBQzNELFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQyxjQUFjLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxFQUMzRCxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsRUFDMUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQzFDLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQ2hELGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQzdDLGNBQWMsR0FDZCxpQkFBaUIsR0FDakIsY0FBYyxHQUNkLGlCQUFpQixDQUNyQixDQUFDO0FBRUssSUFBTSxLQUFLLEdBQWtDO0lBQ2xELGdCQUFnQixFQUFFLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxjQUFjLENBQUM7SUFDMUQsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDckQsMkJBQTJCLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztJQUMzRCxnQkFBZ0IsRUFBRSxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsY0FBYyxDQUFDO0lBQzFELHdCQUF3QixFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQ3JELDJCQUEyQixFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUM7Q0FDNUQsQ0FBQztBQUVLLFNBQVMsWUFBWTtJQUMxQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQUVNLFNBQVMsY0FBYyxDQUFDLFFBQWdCO0lBQzdDLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFFRDs7O0dBR0c7QUFDSSxJQUFNLHFCQUFxQixHQUFHLFVBQUMsSUFBWTtJQUMvQyxvREFBcUIsQ0FBQyw4REFBcUIsQ0FBQyxDQUFDO0lBQzlDLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQyxJQUFLLFFBQUMsRUFBRSxFQUFILENBQUcsQ0FBQyxDQUFDO0lBQzFCLGdEQUFTLEVBQUUsQ0FBQztBQUNkLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSG9DO0FBQ0s7QUFDVTtBQUVSO0FBRzdDLElBQU0sYUFBYSxHQUNqQixxQkFBcUIsR0FBRyxrRUFBNkIsR0FBRyxZQUFZLENBQUM7QUFNdkUsaUVBQWU7SUFDYixlQUFRLENBQUMsZ0JBQWdCLEVBQUU7UUFDekIsSUFBSSxRQUFrQixDQUFDO1FBQ3ZCLElBQUksU0FBbUIsQ0FBQztRQUV4QixFQUFFLENBQUMsOEJBQThCLEVBQUU7O2dCQUNqQyxJQUFJLENBQUMsU0FBUyxDQUFDO29CQUNiLElBQUksRUFBRSxpQkFBaUI7b0JBQ3ZCLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7aUJBQ3ZCLENBQUMsQ0FBQzs7O2FBQ0osQ0FBQyxDQUFDO1FBRUgsUUFBUSxDQUFDLGlCQUFpQixFQUFFO1lBQzFCLFVBQVUsQ0FBQzs7O2dDQUNULHFCQUFNLG9CQUFvQixFQUFFOzs0QkFBNUIsU0FBNEIsQ0FBQzs0QkFDN0IscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFOzs0QkFBaEMsU0FBZ0MsQ0FBQzs7OztpQkFDbEMsQ0FBQyxDQUFDO1lBRUgsU0FBUyxDQUFDLFNBQWUsU0FBUzs7OztvQ0FDaEMscUJBQU0sc0JBQXNCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7O2dDQUFwRCxTQUFvRCxDQUFDOzs7OzthQUN0RCxDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYiwrSUFBK0ksQ0FBQztZQUNsSixFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsd0xBQWlMLGFBQWEsQ0FBRSxDQUFDOzRCQUc3SyxtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixTQUFTOzRCQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBR0csZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFDNUIsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBTyxPQUFPOztvQ0FDckQsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7b0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7OztpQ0FDeEIsQ0FBQyxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUdqQixxQkFBTSxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7OzRCQUF6QyxPQUFPLEdBQUcsU0FBK0I7NEJBRXpDLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsd0JBQXdCO2dDQUNqQyxRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0NBQ3pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLCtCQUErQjs0QkFDL0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxxQkFBcUIsR0FBRyxZQUFZLENBQUMsQ0FBQzs2QkFDbkQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IsdUpBQXVKLENBQUM7WUFDMUosRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLHdMQUFpTCxhQUFhLENBQUUsQ0FBQzs0QkFHN0ssbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUdlLHFCQUFNLHNCQUFzQixDQUFDLENBQUMsQ0FBQzs7NEJBQXpDLE9BQU8sR0FBRyxTQUErQjs0QkFFM0MsZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFFNUIsc0NBQXNDOzRCQUN0QyxRQUFRLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxVQUFPLE9BQU87O29DQUNyRCw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztvQ0FDbkUsZUFBZSxHQUFHLElBQUksQ0FBQzs7O2lDQUN4QixDQUFDLENBQUM7NEJBRUgsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRTNCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsd0JBQXdCO2dDQUNqQyxRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0NBQ3pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2Isa0pBQWtKLENBQUM7WUFDckosRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLHNMQUErSyxhQUFhLENBQUUsQ0FBQzs0QkFHM0ssbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUdlLHFCQUFNLGNBQWMsQ0FBQyxDQUFDLENBQUM7OzRCQUFqQyxPQUFPLEdBQUcsU0FBdUI7NEJBRWpDLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsd0JBQXdCO2dDQUNqQyxRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0NBQ3pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsdUJBQXVCOzRCQUN2QixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7OzRCQURsQyx1QkFBdUI7NEJBQ3ZCLFNBQWtDLENBQUM7NEJBRS9CLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBRTVCLHNDQUFzQzs0QkFDdEMsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBTyxPQUFPOztvQ0FDckQsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7b0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7OztpQ0FDeEIsQ0FBQyxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUVqQyxpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsNkJBQTZCOzRCQUM3QixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUFDLGdDQUF5QixZQUFZLENBQUUsQ0FBQyxDQUFDOzZCQUN0RDs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYixzS0FBc0ssQ0FBQztZQUN6SyxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsOExBQXVMLGFBQWEsQ0FBRSxDQUFDOzRCQUduTCxtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixTQUFTOzRCQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBRUcsZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFFNUIsc0JBQXNCOzRCQUN0QixRQUFRLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLFVBQUMsT0FBTztnQ0FDNUQsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7NEJBQ3pCLENBQUMsQ0FBQyxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUdqQixxQkFBTSxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7OzRCQUF6QyxPQUFPLEdBQUcsU0FBK0I7NEJBRXpDLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsd0JBQXdCO2dDQUNqQyxRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0NBQ3pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IseUhBQXlILENBQUM7WUFDNUgsRUFBRSxDQUFDLFNBQVMsRUFBRTtnQkFXWixTQUFTLDJCQUEyQjtvQkFDbEMsSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTt3QkFDN0IsSUFDRSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDOzRCQUN0QyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsRUFDekM7NEJBQ0EsNkNBQVcsQ0FBQyw0QkFBNEIsRUFBRSxZQUFZLENBQUMsQ0FBQzt5QkFDekQ7NkJBQU07NEJBQ0wsZUFBZSxHQUFHLElBQUksQ0FBQzt5QkFDeEI7cUJBQ0Y7Z0JBQ0gsQ0FBQzs7Ozs7NEJBckJLLFlBQVksR0FBRyxrTUFBMkwsYUFBYSxDQUFFLENBQUM7NEJBR3ZMLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFDRyxZQUFZLEdBQWEsRUFBRSxDQUFDOzRCQUM1QixlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQWM1QixzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsVUFBQyxPQUFPO2dDQUM1RCxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQzs0QkFDaEMsQ0FBQyxDQUFDLENBQUM7NEJBRUgsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRWpDLHNDQUFzQzs0QkFDdEMsU0FBUyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUUsVUFBQyxPQUFPO2dDQUMxRCxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQzs0QkFDaEMsQ0FBQyxDQUFDLENBQUM7NEJBRUgsc0JBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBR2xCLHFCQUFNLHNCQUFzQixDQUFDLENBQUMsQ0FBQzs7NEJBQXpDLE9BQU8sR0FBRyxTQUErQjs0QkFFekMsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyx3QkFBd0I7Z0NBQ2pDLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLGFBQWEsRUFBRSxPQUFPLENBQUMsRUFBRTtnQ0FDekIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsYUFBYSxFQUNiLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRixpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsNkJBQTZCOzRCQUM3QixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUNULGtEQUEyQyxZQUFZLENBQUUsQ0FDMUQsQ0FBQzs2QkFDSDs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYiw4SEFBOEgsQ0FBQztZQUNqSSxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsa01BQTJMLGFBQWEsQ0FBRSxDQUFDOzRCQUVoTyxzQ0FBc0M7NEJBQ3RDLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsVUFBQyxPQUFPO2dDQUM1RCw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7NEJBQ2xFLENBQUMsQ0FBQyxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUVqQyxtQ0FBbUM7NEJBQ25DLFNBQVMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxFQUFFLFVBQUMsT0FBTztnQ0FDMUQsNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDOzRCQUNsRSxDQUFDLENBQUMsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQzs0QkFFakIscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFOzs0QkFBekMsUUFBUSxHQUFHLFNBQThCOzRCQUMvQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQ0FDckIsNkNBQVcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDOzRCQUV4RCwyREFBMkQ7NEJBQzNELHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7NEJBRHRDLDJEQUEyRDs0QkFDM0QsU0FBc0MsQ0FBQzs0QkFFakMsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyx3QkFBd0I7Z0NBQ2pDLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs2QkFDOUIsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsYUFBYSxFQUNiLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRix3Q0FBd0M7NEJBQ3hDLHFCQUFNLDRDQUFJLEVBQUU7OzRCQURaLHdDQUF3Qzs0QkFDeEMsU0FBWSxDQUFDOzs7O2lCQUNkLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLHdJQUF3SSxDQUFDO1lBQzNJLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRywyT0FBb08sYUFBYSxDQUFFLENBQUM7NEJBR2hPLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRCxzQ0FBc0M7NEJBQ3RDLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsVUFBQyxPQUFPO2dDQUM1RCw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7NEJBQ2xFLENBQUMsQ0FBQyxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUdqQixxQkFBTSxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7OzRCQUF6QyxPQUFPLEdBQUcsU0FBK0I7aUNBRzNDLFNBQVEsS0FBSyxTQUFTLEdBQXRCLHdCQUFzQjs0QkFDeEIscUJBQU0sUUFBUSxDQUFDLFdBQVcsRUFBRTs7NEJBQTVCLFNBQTRCLENBQUM7NEJBQzdCLFFBQVEsR0FBRyxTQUFTLENBQUM7Ozs0QkFFckIsNkNBQVcsQ0FBQyxvQkFBb0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs7OzRCQUc1QyxtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLHdCQUF3QjtnQ0FDakMsUUFBUSxDQUFDLDBCQUEwQjs2QkFDcEMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsYUFBYSxFQUFFLE9BQU8sQ0FBQyxFQUFFO2dDQUN6QixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzs7O2lCQUN4QyxDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYix5S0FBeUssQ0FBQztZQUM1SyxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsaU9BQTBOLGFBQWEsQ0FBRSxDQUFDOzRCQUUvUCxzQ0FBc0M7NEJBQ3RDLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQ2hDLGlCQUFpQixFQUNqQixVQUFPLE9BQU87O29DQUNaLDZDQUFXLENBQUMsVUFBRyxZQUFZLGNBQUksT0FBTyxDQUFDLElBQUksc0JBQW1CLENBQUMsQ0FBQzs7O2lDQUNqRSxDQUNGLENBQUM7NEJBR2UscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFOzs0QkFBekMsUUFBUSxHQUFHLFNBQThCOzRCQUMvQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQ0FDckIsNkNBQVcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDOzRCQUV4RCxtREFBbUQ7NEJBQ25ELHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7NEJBRHRDLG1EQUFtRDs0QkFDbkQsU0FBc0MsQ0FBQzs0QkFDdkMscUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDOzs0QkFBdEMsU0FBc0MsQ0FBQzs0QkFFakMsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyx3QkFBd0I7Z0NBQ2pDLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs2QkFDOUIsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsYUFBYSxFQUNiLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRix1Q0FBdUM7NEJBQ3ZDLHFCQUFNLDRDQUFJLEVBQUU7OzRCQURaLHVDQUF1Qzs0QkFDdkMsU0FBWSxDQUFDOzs7O2lCQUNkLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLDRKQUE0SixDQUFDO1lBQy9KLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyxrT0FBMk4sYUFBYSxDQUFFLENBQUM7NEJBRWhRLGtDQUFrQzs0QkFDbEMsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsRUFBRSxVQUFDLE9BQU87Z0NBQzVELDZDQUFXLENBQUMsVUFBRyxZQUFZLGNBQUksT0FBTyxDQUFDLElBQUksc0JBQW1CLENBQUMsQ0FBQzs0QkFDbEUsQ0FBQyxDQUFDLENBQUM7NEJBRUgsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBR2pCLHFCQUFNLHNCQUFzQixDQUFDLENBQUMsQ0FBQzs7NEJBQXpDLE9BQU8sR0FBRyxTQUErQjs0QkFFL0Msd0JBQXdCOzRCQUN4QixxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7OzRCQURoQyx3QkFBd0I7NEJBQ3hCLFNBQWdDLENBQUM7NEJBRTNCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsd0JBQXdCO2dDQUNqQyxRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUU7NkJBQzFCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsdUNBQXVDOzRCQUN2QyxxQkFBTSw0Q0FBSSxFQUFFOzs0QkFEWix1Q0FBdUM7NEJBQ3ZDLFNBQVksQ0FBQzs7OztpQkFDZCxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxjQUFjLEVBQUU7WUFDdkIsVUFBVSxDQUFDOzs7Z0NBQ1QscUJBQU0sb0JBQW9CLEVBQUU7OzRCQUE1QixTQUE0QixDQUFDOzRCQUM3QixxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7OzRCQUFoQyxTQUFnQyxDQUFDOzs7O2lCQUNsQyxDQUFDLENBQUM7WUFFSCxTQUFTLENBQUMsU0FBZSxTQUFTOzs7O29DQUNoQyxxQkFBTSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQzs7Z0NBQXBELFNBQW9ELENBQUM7Ozs7O2FBQ3RELENBQUMsQ0FBQztZQUVILElBQU0sUUFBUSxHQUNaLGdIQUFnSCxDQUFDO1lBQ25ILEVBQUUsQ0FBQyxRQUFRLEVBQUU7Ozs7OzRCQUNMLFlBQVksR0FBRywrTkFBd04sYUFBYSxDQUFFLENBQUM7NEJBR3pPLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7OzRCQUEzRCxXQUFXLEdBQUcsU0FBNkM7NEJBR3hCLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFFBQVE7NEJBQ1IscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRyxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUU1QixzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxXQUFXLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFVBQU8sT0FBTzs7b0NBQzVELDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO29DQUNuRSxlQUFlLEdBQUcsSUFBSSxDQUFDOzs7aUNBQ3hCLENBQUMsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFM0IsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFFBQVE7Z0NBQ2hCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IsMkhBQTJILENBQUM7WUFDOUgsRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLHNMQUErSyxhQUFhLENBQUUsQ0FBQzs0QkFHaE0scUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFHeEIsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVLLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLDJDQUEyQzs0QkFDM0MscUJBQU0sZ0NBQWdDOzs0QkFEdEMsMkNBQTJDOzRCQUMzQyxTQUFzQyxDQUFDOzRCQUVuQyxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUU1Qix1Q0FBdUM7NEJBQ3ZDLHFCQUFNLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFPLE9BQU87O3dDQUN2RCw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQzt3Q0FDbkUsZUFBZSxHQUFHLElBQUksQ0FBQzs7O3FDQUN4QixDQUFDOzs0QkFKRix1Q0FBdUM7NEJBQ3ZDLFNBR0UsQ0FBQzs0QkFFSCw2QkFBNkI7NEJBQzdCLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQUMsZ0NBQXlCLFlBQVksQ0FBRSxDQUFDLENBQUM7NkJBQ3REOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLCtIQUErSCxDQUFDO1lBQ2xJLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyx3UEFBaVAsYUFBYSxDQUFFLENBQUM7NEJBR2xRLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7OzRCQUEzRCxXQUFXLEdBQUcsU0FBNkM7NEJBR3hCLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRyxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUU1QixzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxXQUFXLENBQUMsa0JBQWtCLENBQ3ZDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87Z0NBQ04sNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7NEJBQ3pCLENBQUMsQ0FDRixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUUzQixtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLHNCQUFzQjtnQ0FDL0IsUUFBUSxDQUFDLDBCQUEwQjtnQ0FDbkMsUUFBUSxDQUFDLHVCQUF1Qjs2QkFDakMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsYUFBYSxFQUNiLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRixpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsNkJBQTZCOzRCQUM3QixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUFDLGdDQUF5QixZQUFZLENBQUUsQ0FBQyxDQUFDOzZCQUN0RDs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYix3SEFBd0gsQ0FBQztZQUMzSCxFQUFFLENBQUMsU0FBUyxFQUFFO2dCQXVEWixTQUFTLDJCQUEyQjtvQkFDbEMsSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTt3QkFDN0IsSUFDRSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDOzRCQUN0QyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsRUFDekM7NEJBQ0EsNkNBQVcsQ0FBQyw0QkFBNEIsRUFBRSxZQUFZLENBQUMsQ0FBQzt5QkFDekQ7NkJBQU07NEJBQ0wsZUFBZSxHQUFHLElBQUksQ0FBQzt5QkFDeEI7cUJBQ0Y7Z0JBQ0gsQ0FBQzs7Ozs7NEJBakVLLFlBQVksR0FBRyx5UUFBa1EsYUFBYSxDQUFFLENBQUM7NEJBRW5TLFlBQVksR0FBYSxFQUFFLENBQUM7NEJBRVoscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFHeEIsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVELHNDQUFzQzs0QkFDdEMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsQ0FDdkMsaUJBQWlCLEVBQ2pCLFVBQUMsT0FBTztnQ0FDTixZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQzs0QkFDaEMsQ0FBQyxDQUNGLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRWpDLG1DQUFtQzs0QkFDbkMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsQ0FDeEMsY0FBYyxFQUNkLFVBQUMsT0FBTztnQ0FDTixZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQzs0QkFDaEMsQ0FBQyxDQUNGLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBRTVCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVFLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBYzVCLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2Qyw2QkFBNkI7NEJBQzdCLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQUMsZ0NBQXlCLFlBQVksQ0FBRSxDQUFDLENBQUM7NkJBQ3REOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLHNIQUFzSCxDQUFDO1lBQ3pILEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyxnUkFBeVEsYUFBYSxDQUFFLENBQUM7NEJBRzFSLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7OzRCQUEzRCxXQUFXLEdBQUcsU0FBNkM7NEJBR3hCLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRCxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxXQUFXLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFVBQUMsT0FBTztnQ0FDdEQsNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDOzRCQUNsRSxDQUFDLENBQUMsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFakMsOEJBQThCOzRCQUM5QixRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7NEJBRWpCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzs7O2lCQUN4QyxDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYiwwR0FBMEcsQ0FBQztZQUM3RyxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcscU9BQThOLGFBQWEsQ0FBRSxDQUFDOzRCQUcvTyxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQy9DLDBCQUEwQixDQUMzQjs7NEJBRkssV0FBVyxHQUFHLFNBRW5COzRCQUVELHNCQUFzQjs0QkFDdEIsUUFBUSxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsQ0FDdkMsaUJBQWlCLEVBQ2pCLFVBQUMsT0FBTztnQ0FDTiw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7NEJBQ2xFLENBQUMsQ0FDRixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUUzQixtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLHNCQUFzQjtnQ0FDL0IsUUFBUSxDQUFDLDBCQUEwQjs2QkFDcEMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsYUFBYSxFQUNiLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRix1Q0FBdUM7NEJBQ3ZDLHFCQUFNLDRDQUFJLEVBQUU7OzRCQURaLHVDQUF1Qzs0QkFDdkMsU0FBWSxDQUFDOzs7O2lCQUNkLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLDhLQUE4SyxDQUFDO1lBQ2pMLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRywrUkFBd1IsYUFBYSxDQUFFLENBQUM7NEJBRzNTLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7OzRCQUEzRCxXQUFXLEdBQUcsU0FBNkM7NEJBR3RCLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFHYSxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsMEJBQTBCLENBQUM7OzRCQUR2RSx5Q0FBeUM7NEJBQ3pDLFdBQVcsR0FBRyxTQUF5RCxDQUFDOzRCQUV4RSxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxXQUFXLENBQUMsa0JBQWtCLENBQ3ZDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87Z0NBQ04sNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDOzRCQUNsRSxDQUFDLENBQ0YsQ0FBQzs0QkFFRixzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFM0IsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLGFBQWEsRUFDYix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7Ozs7aUJBQ3hDLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLDJKQUEySixDQUFDO1lBQzlKLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyxtUUFBNFAsYUFBYSxDQUFFLENBQUM7NEJBRzdRLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7OzRCQUEzRCxXQUFXLEdBQUcsU0FBNkM7NEJBRTNELG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTOzZCQUNsQixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUdjLHFCQUFNLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBQzs7NEJBQWhFLE9BQU8sR0FBRyxTQUFzRDs0QkFDdEUsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsWUFBWSxDQUFDLENBQUM7NEJBRTNDLHFCQUFNLFdBQVcsQ0FBQyxpQkFBaUIsQ0FDeEQsY0FBYyxDQUNmOzs0QkFGSyxjQUFjLEdBQUcsU0FFdEI7NEJBQ0QsNENBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQ3RDLGdCQUFnQixFQUNoQixZQUFZLENBQ2IsQ0FBQzs7OztpQkFDSCxDQUFDLENBQUM7WUFFSCxJQUFNLFVBQVUsR0FDZCwyTEFBMkwsQ0FBQztZQUM5TCxFQUFFLENBQUMsVUFBVSxFQUFFOzs7Ozs0QkFDUCxZQUFZLEdBQUcsOE9BQXVPLGFBQWEsQ0FBRSxDQUFDOzRCQUd4UCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDOzs0QkFBM0QsV0FBVyxHQUFHLFNBQTZDOzRCQUd4QixtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixVQUFVOzRCQUNWLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBRUssbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFVBQVU7Z0NBQ2xCLHNCQUFzQixFQUFFLElBQUk7Z0NBQzVCLFlBQVksRUFBRSxDQUFDOzZCQUNoQixDQUFDOzRCQUVGLGdEQUFnRDs0QkFDaEQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGdEQUFnRDs0QkFDaEQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUd2QixxQkFBTSxXQUFXLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7OzRCQUFoRSxPQUFPLEdBQUcsU0FBc0Q7NEJBQ3RFLDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUNuRSw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs0QkFFakQscUJBQU0sV0FBVyxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTlELFFBQVEsR0FBRyxTQUFtRDs0QkFDcEUsNENBQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUNqRSw0Q0FBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs7OztpQkFDcEUsQ0FBQyxDQUFDO1lBRUgsSUFBTSxVQUFVLEdBQ2Qsd0tBQXdLLENBQUM7WUFDM0ssRUFBRSxDQUFDLFVBQVUsRUFBRTs7Ozs7NEJBQ1AsWUFBWSxHQUFHLCtPQUF3TyxhQUFhLENBQUUsQ0FBQzs0QkFHelAscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFHeEIsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsVUFBVTs0QkFDVixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVLLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxVQUFVO2dDQUNsQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixhQUFhLEVBQ2IsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2QixxQkFBTSxXQUFXLENBQUMsaUJBQWlCLEVBQUU7OzRCQUEvQyxPQUFPLEdBQUcsU0FBcUM7NEJBRXJELElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxzQkFBc0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs2QkFDbkQ7aUNBQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGlCQUFpQixFQUFFO2dDQUM3Qyw2Q0FBVyxDQUNULG9EQUFvRCxFQUNwRCxZQUFZLENBQ2IsQ0FBQzs2QkFDSDtpQ0FBTTtnQ0FDTCw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUM7NkJBQ2pFOzs7O2lCQUNGLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBTSxzQkFBc0IsR0FBRyxVQUM3QixhQUFxQjs7Ozs0QkFFTCxxQkFBTSxjQUFjLENBQUMsYUFBYSxDQUFDOzt3QkFBN0MsT0FBTyxHQUFHLFNBQW1DO3dCQUNuRCxxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7O3dCQUFsQyxTQUFrQyxDQUFDO3dCQUNuQyxzQkFBTyxPQUFPLEVBQUM7OzthQUNoQixDQUFDO1FBRUYsSUFBTSxjQUFjLEdBQUcsVUFBTyxPQUFlOzs7OzRCQUMxQixxQkFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7O3dCQUF6QyxRQUFRLEdBQUcsU0FBOEI7d0JBQy9DLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7NEJBQ3ZCLHNCQUFPLFFBQVEsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUM7eUJBQzlCOzZCQUFNOzRCQUNMLDZDQUFXLENBQUMsd0NBQXdDLENBQUMsQ0FBQzt5QkFDdkQ7Ozs7YUFDRixDQUFDO1FBRUYsU0FBUyxzQkFBc0IsQ0FBQyxjQUFjO1lBQzVDLCtDQUFhLENBQ1gsT0FBTyxjQUFjLEtBQUssUUFBUSxFQUNsQywwQkFBMEIsQ0FDM0IsQ0FBQztZQUNGLDRDQUFNLENBQUMsT0FBTyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQ3BELFVBQVUsRUFDVixpREFBaUQsQ0FDbEQsQ0FBQztRQUNKLENBQUM7UUFFRCxTQUFlLHNCQUFzQixDQUFDLE1BQWM7Ozs7O2dDQUV4QixxQkFBTSw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7OzRCQUFoRSxpQkFBaUIsR0FBRyxTQUE0Qzs0QkFFdEUsaUNBQWlDOzRCQUNqQyxxQkFBTSxjQUFjLENBQUMsY0FBYyxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQzs7NEJBRC9ELGlDQUFpQzs0QkFDakMsU0FBK0QsQ0FBQzs0QkFDaEUscUJBQU0sNENBQUksQ0FBQyxzRUFBNkIsQ0FBQzs7NEJBQXpDLFNBQXlDLENBQUM7Ozs7O1NBQzNDO1FBRUQsSUFBTSw4QkFBOEIsR0FBRyxVQUFPLE1BQWM7Ozs7NEJBQ2hDLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O3dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0Qzt3QkFFaEUsWUFBWSxHQUFzQjs0QkFDdEMsSUFBSSxFQUFFLGFBQWE7NEJBQ25CLE1BQU0sRUFBRSxNQUFNO3lCQUNmLENBQUM7d0JBQ0YsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO3dCQUMxQyxzQkFBTyxpQkFBaUIsRUFBQzs7O2FBQzFCLENBQUM7UUFFRixTQUFlLG9CQUFvQjs7Ozs7aUNBQzdCLFNBQVEsS0FBSyxTQUFTLEdBQXRCLHdCQUFzQjs0QkFDeEIscUJBQU0sUUFBUSxDQUFDLFdBQVcsRUFBRTs7NEJBQTVCLFNBQTRCLENBQUM7NEJBQzdCLFFBQVEsR0FBRyxTQUFTLENBQUM7OztpQ0FHbkIsVUFBUyxLQUFLLFNBQVMsR0FBdkIsd0JBQXVCOzRCQUN6QixxQkFBTSxTQUFTLENBQUMsV0FBVyxFQUFFOzs0QkFBN0IsU0FBNkIsQ0FBQzs0QkFDOUIsU0FBUyxHQUFHLFNBQVMsQ0FBQzs7Ozs7O1NBRXpCO1FBRUQsSUFBTSxjQUFjLEdBQUcsVUFDckIsV0FBbUIsRUFDbkIsTUFBYyxFQUNkLE9BQWlCO1lBRWpCLElBQUksaUJBQTJCLENBQUM7WUFDaEMsT0FBTyxJQUFJLE9BQU8sQ0FBVSxVQUFPLE9BQU87OztvQkFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO3dCQUNSLCtCQUF1QixXQUFXLCtCQUFtQixPQUFPLENBQUMsRUFBRSwyQkFBZSxNQUFNLE9BQUcsQ0FDMUYsQ0FBQztvQkFFSSxPQUFPLEdBQUcsVUFBQyxPQUEwQjt3QkFDekMsSUFBSSxNQUFNLEVBQUU7NEJBQ1YsSUFBSSxNQUFNLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtnQ0FDNUIsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsb0JBQWEsV0FBVyx3QkFBYyxNQUFNLENBQUUsQ0FDNUQsQ0FBQztnQ0FDRixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7Z0NBQ2pCLElBQUksaUJBQWlCO29DQUFFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDOzZCQUN4RDtpQ0FBTTtnQ0FDTCxPQUFPLENBQUMsSUFBSSxDQUNWLElBQUksQ0FBQyxHQUFHLEVBQUU7b0NBQ1Isc0JBQWMsV0FBVyw4REFBa0QsTUFBTSx1QkFBVyxPQUFPLENBQUMsTUFBTSxRQUFJLENBQ2pILENBQUM7NkJBQ0g7eUJBQ0Y7NkJBQU07NEJBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dDQUNSLHVDQUErQixXQUFXLDRCQUFnQixNQUFNLE9BQUcsQ0FDdEUsQ0FBQzs0QkFDRixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7NEJBQ2pCLElBQUksaUJBQWlCO2dDQUFFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO3lCQUN4RDtvQkFDSCxDQUFDLENBQUM7b0JBRUYsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO3dCQUN6QixpQkFBaUIsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO3FCQUNuRTt5QkFBTTt3QkFDTCxpQkFBaUIsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUUvRCxTQUFTLEdBQUcsVUFBTyxPQUEwQjs7Z0NBQ2pELElBQUksT0FBTyxFQUFFO29DQUNYLElBQUksTUFBTSxFQUFFO3dDQUNWLElBQUksTUFBTSxLQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLEtBQUksUUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksS0FBSSxXQUFXLEVBQUU7NENBQzdELE9BQU8sQ0FBQyxHQUFHLENBQ1QsSUFBSSxDQUFDLEdBQUcsRUFBRTtnREFDUixzQkFBYyxXQUFXLG1EQUF1QyxNQUFNLE9BQUcsQ0FDNUUsQ0FBQzs0Q0FDRixJQUFJLGlCQUFpQjtnREFBRSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs0Q0FDdkQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO3lDQUNsQixDQUFDLG9FQUFvRTs2Q0FDakU7NENBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dEQUNSLGtEQUEwQyxXQUFXLDRCQUFnQixNQUFNLG9DQUN6RSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSx5Q0FFMUIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0saUJBQ1YsTUFBTSxLQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNO29EQUN2QixDQUFDLENBQUMsV0FBVztvREFDYixDQUFDLENBQUMsZUFBZSxnQ0FFM0IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksaUJBQ0wsUUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksS0FBSSxXQUFXO29EQUMxQixDQUFDLENBQUMsV0FBVztvREFDYixDQUFDLENBQUMsZUFBZSxNQUNsQixDQUNOLENBQUM7eUNBQ0g7cUNBQ0Y7eUNBQU07d0NBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFOzRDQUNSLHNCQUFjLFdBQVcsc0RBQWtELENBQzlFLENBQUM7d0NBQ0YsSUFBSSxpQkFBaUI7NENBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7d0NBQ3ZELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztxQ0FDbEI7aUNBQ0Y7Ozs2QkFDRixDQUFDO3dCQUNGLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztxQkFDN0M7OztpQkFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7QUEvbkNGLENBK25DRSxFQUFDO0FBcUJMLFNBQVMsdUJBQXVCLENBQzlCLGVBQXlCLEVBQ3pCLE1BQXlCOztJQUV6QixPQUFPO1FBQ0wsSUFBSSxFQUFFLG9CQUFvQjtRQUMxQixRQUFRLEVBQUUsZUFBZTtRQUN6QixNQUFNLEVBQUU7WUFDTixjQUFjLEVBQUUsTUFBTSxDQUFDLGNBQWM7WUFDckMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3JCLHNCQUFzQixFQUFFLFlBQU0sQ0FBQyxzQkFBc0IsbUNBQUksS0FBSztZQUM5RCxZQUFZLEVBQUUsWUFBTSxDQUFDLFlBQVksbUNBQUksQ0FBQztZQUN0QyxhQUFhLEVBQUUsWUFBTSxDQUFDLGFBQWEsbUNBQUksSUFBSTtTQUM1QztLQUNGLENBQUM7QUFDSixDQUFDO0FBRUQsSUFBTSxRQUFRLEdBQUc7SUFDZix3QkFBd0IsRUFBRSwwQkFBMEI7SUFDcEQsc0JBQXNCLEVBQUUsd0JBQXdCO0lBQ2hELDBCQUEwQixFQUFFLDRCQUE0QjtJQUN4RCx1QkFBdUIsRUFBRSx5QkFBeUI7Q0FDbkQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFyQ3NDO0FBQ0Y7QUFDZTtBQUlyRCxJQUFNLGNBQWMsR0FDbEIscUJBQXFCLEdBQUcsZ0VBQTJCLEdBQUcsV0FBVyxDQUFDO0FBRXBFOztHQUVHO0FBQ0gsaUVBQWU7SUFDYixlQUFRLENBQUMsaUJBQWlCLEVBQUU7UUFDMUIsRUFBRSxDQUFDLGlGQUFpRixFQUFFOzs7OzRCQUNsRSxxQkFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDOzt3QkFBbkQsU0FBUyxHQUFHLFNBQXVDO3dCQUN6RCw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDakM7NEJBQ0UsSUFBSSxFQUFFLGdCQUFnQjs0QkFDdEIsV0FBVyxFQUFFLGtCQUFrQjt5QkFDaEMsRUFDRCxjQUFjLENBQ2YsQ0FBQzt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7d0JBQ3pELDRDQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUN4QyxNQUFNLEVBQ04sWUFBWSxFQUNaLGNBQWMsQ0FDZixDQUFDOzs7O2FBQ0gsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDZFQUE2RSxFQUFFOzs7Ozs7d0JBRTlFLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUM7O3dCQUExQyxTQUEwQyxDQUFDO3dCQUMzQyw2Q0FBVyxDQUFDLHFCQUFxQixFQUFFLGNBQWMsQ0FBQyxDQUFDOzs7O3dCQUVuRCw0Q0FBTSxDQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUN6QixTQUFTLEVBQ1QsOERBQXdCLEVBQ3hCLGNBQWMsQ0FDZixDQUFDOzs7OzthQUVMLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyx5SEFBeUgsRUFBRTs7Ozs0QkFDMUcscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTs0QkFDeEQsSUFBSSxFQUFFLGNBQWM7eUJBQ3JCLENBQUM7O3dCQUZJLFNBQVMsR0FBRyxTQUVoQjt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDakM7NEJBQ0UsSUFBSSxFQUFFLGdCQUFnQjs0QkFDdEIsV0FBVyxFQUFFLGtCQUFrQjt5QkFDaEMsRUFDRCxjQUFjLENBQ2YsQ0FBQzt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7d0JBQ3pELDRDQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUN4QyxNQUFNLEVBQ04sWUFBWSxFQUNaLGNBQWMsQ0FDZixDQUFDOzs7O2FBQ0gsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLGlHQUFpRyxFQUFFOzs7Ozs7d0JBRWxHLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLEVBQUU7Z0NBQ3RDLElBQUksRUFBRSxjQUFjOzZCQUNyQixDQUFDOzt3QkFGRixTQUVFLENBQUM7d0JBQ0gsNkNBQVcsQ0FBQyxxQkFBcUIsRUFBRSxjQUFjLENBQUMsQ0FBQzs7Ozt3QkFFbkQsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULDhEQUF3QixFQUN4QixjQUFjLENBQ2YsQ0FBQzs7Ozs7YUFFTCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsa0hBQWtILEVBQUU7Ozs7NEJBQ25HLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUM7O3dCQUF6RCxTQUFTLEdBQUcsU0FBNkM7d0JBQy9ELDRDQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNqQzs0QkFDRSxJQUFJLEVBQUUsc0JBQXNCOzRCQUM1QixXQUFXLEVBQUUsdUJBQXVCO3lCQUNyQyxFQUNELGNBQWMsQ0FDZixDQUFDO3dCQUNGLDRDQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQzt3QkFDekQsNENBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQ3hDLE1BQU0sRUFDTixZQUFZLEVBQ1osY0FBYyxDQUNmLENBQUM7d0JBQ0YsNENBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQ3hDLE1BQU0sRUFDTixZQUFZLEVBQ1osY0FBYyxDQUNmLENBQUM7Ozs7YUFDSCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsOEpBQThKLEVBQUU7Ozs7NEJBQy9JLHFCQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUU7NEJBQzlELElBQUksRUFBRSxjQUFjO3lCQUNyQixDQUFDOzt3QkFGSSxTQUFTLEdBQUcsU0FFaEI7d0JBQ0YsNENBQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQ2pDOzRCQUNFLElBQUksRUFBRSxzQkFBc0I7NEJBQzVCLFdBQVcsRUFBRSx1QkFBdUI7eUJBQ3JDLEVBQ0QsY0FBYyxDQUNmLENBQUM7d0JBQ0YsNENBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO3dCQUN6RCw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDeEMsTUFBTSxFQUNOLFlBQVksRUFDWixjQUFjLENBQ2YsQ0FBQzt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDeEMsTUFBTSxFQUNOLFlBQVksRUFDWixjQUFjLENBQ2YsQ0FBQzs7OzthQUNILENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyw4SUFBOEksRUFBRTs7Ozs0QkFDL0gscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsRUFBRTs0QkFDOUQsSUFBSSxFQUFFLGNBQWM7eUJBQ3JCLENBQUM7O3dCQUZJLFNBQVMsR0FBRyxTQUVoQjt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDakM7NEJBQ0UsSUFBSSxFQUFFLHNCQUFzQjs0QkFDNUIsV0FBVyxFQUFFLHVCQUF1Qjt5QkFDckMsRUFDRCxjQUFjLENBQ2YsQ0FBQzt3QkFDRiw0Q0FBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7d0JBQ3pELDRDQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUN4QyxNQUFNLEVBQ04sWUFBWSxFQUNaLGNBQWMsQ0FDZixDQUFDOzs7O2FBQ0gsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBaklGLENBaUlFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5SW1DO0FBQ0Y7QUFDZTtBQUlyRCxJQUFNLHdCQUF3QixHQUM1QixxQkFBcUIsR0FBRywwRUFBcUMsR0FBRyxXQUFXLENBQUM7QUFFOUU7O0dBRUc7QUFDSCxpRUFBZTtJQUNiLGVBQVEsQ0FBQywyQkFBMkIsRUFBRTtRQUNwQyxFQUFFLENBQUMsK0RBQStELEVBQUU7Ozs7Ozs7d0JBRWhELHFCQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztnQ0FDOUMsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLENBQUM7O3dCQUZJLE9BQU8sR0FBRyxTQUVkO3dCQUNGLDRDQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLHdCQUF3QixDQUFDLENBQUM7d0JBRXRELFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQUMsU0FBUyxJQUFLLGdCQUFTLENBQUMsTUFBTSxDQUFDLElBQUksRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO3dCQUN0RSw0Q0FBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FDckMsQ0FBQyxnQkFBZ0IsRUFBRSxzQkFBc0IsRUFBRSxnQkFBZ0IsQ0FBQyxFQUM1RCx3QkFBd0IsQ0FDekIsQ0FBQzt3QkFFSSxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDakMsVUFBQyxTQUFTLElBQUssZ0JBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUExQyxDQUEwQyxDQUMxRCxDQUFDO3dCQUNGLDRDQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO3dCQUN4RSw0Q0FBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FDdkMsWUFBWSxFQUNaLHdCQUF3QixDQUN6QixDQUFDO3dCQUVJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQ3ZDLFVBQUMsU0FBUyxJQUFLLGdCQUFTLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxzQkFBc0IsRUFBaEQsQ0FBZ0QsQ0FDaEUsQ0FBQzt3QkFDRiw0Q0FBTSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUM5QyxDQUFDLEVBQ0Qsd0JBQXdCLENBQ3pCLENBQUM7d0JBQ0ksY0FBYyxHQUFHLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBQyxHQUFHLElBQUssVUFBRyxDQUFDLElBQUksRUFBUixDQUFRLENBQUMsQ0FBQzt3QkFDeEUsNENBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQ3hDLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxFQUM1Qix3QkFBd0IsQ0FDekIsQ0FBQzt3QkFFSSxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FDakMsVUFBQyxTQUFTLElBQUssZ0JBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUExQyxDQUEwQyxDQUMxRCxDQUFDO3dCQUNGLDRDQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO3dCQUN4RSw0Q0FBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FDdkMsWUFBWSxFQUNaLHdCQUF3QixDQUN6QixDQUFDOzs7O3dCQUVGLDZDQUFXLENBQUMsd0JBQXdCLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUU5RCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsZ0ZBQWdGLEVBQUU7Ozs7O3dCQUM3RSxPQUFPLEdBQUc7NEJBQ2QsSUFBSSxFQUFFLHlCQUF5Qjt5QkFDaEMsQ0FBQzs7Ozt3QkFFQSxxQkFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDOzt3QkFBeEMsU0FBd0MsQ0FBQzt3QkFDekMsNkNBQVcsQ0FDVCx1Q0FBdUMsRUFDdkMsd0JBQXdCLENBQ3pCLENBQUM7Ozs7d0JBRUYsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULDhEQUF3QixFQUN4Qix3QkFBd0IsQ0FDekIsQ0FBQzs7Ozs7YUFFTCxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFuRUYsQ0FtRUUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEY0RDtBQUMzQjtBQUNlO0FBQ1Y7QUFFRTtBQUk3QyxJQUFNLFFBQVEsR0FBRyxTQUFTLENBQUM7QUFDM0IsSUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDO0FBQzNCLElBQU0sZUFBZSxHQUFHLGNBQWMsQ0FBQztBQUN2QyxJQUFNLGlCQUFpQixHQUFHLFlBQVksQ0FBQztBQUN2QyxJQUFNLG9CQUFvQixHQUFHLGNBQWMsQ0FBQztBQUM1QyxJQUFNLHNCQUFzQixHQUFHLFlBQVksQ0FBQztBQUU1QyxJQUFNLFFBQVEsR0FBRyxxQkFBcUIsR0FBRywwREFBcUIsR0FBRyxXQUFXLENBQUM7QUFFN0U7O0dBRUc7QUFDSCxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxXQUFXLEVBQUU7UUFDcEIsVUFBVSxDQUFDOzs7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFOzt3QkFBaEMsU0FBZ0MsQ0FBQzs7OzthQUNsQyxDQUFDLENBQUM7UUFFSCxJQUFNLFlBQVksR0FDaEIsMkVBQTJFLENBQUM7UUFDOUUsRUFBRSxDQUFDLFlBQVksRUFBRTs7Ozs0QkFDZixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLDBCQUEwQixDQUFDOzt3QkFBbEQsU0FBa0QsQ0FBQzt3QkFDN0MsTUFBTSxHQUFHLGNBQWMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO3dCQUN6RCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7d0JBQXpCLFNBQXlCLENBQUM7d0JBQzFCLHFCQUFNLE1BQU07O3dCQUFaLFNBQVksQ0FBQzt3QkFDYixxQkFBTSxlQUFlLENBQUMsWUFBWSxDQUFDOzt3QkFBbkMsU0FBbUMsQ0FBQzs7OzthQUNyQyxDQUFDLENBQUM7UUFFSCxJQUFNLFlBQVksR0FDaEIsdUZBQXVGLENBQUM7UUFDMUYsRUFBRSxDQUFDLFlBQVksRUFBRTs7Ozs0QkFDZixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLDBCQUEwQixDQUFDOzt3QkFBbEQsU0FBa0QsQ0FBQzt3QkFDN0MsTUFBTSxHQUFHLGNBQWMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO3dCQUN6RCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDOzt3QkFBbkMsU0FBbUMsQ0FBQzt3QkFDcEMscUJBQU0sTUFBTTs7d0JBQVosU0FBWSxDQUFDO3dCQUNiLHFCQUFNLGVBQWUsQ0FBQyxZQUFZLENBQUM7O3dCQUFuQyxTQUFtQyxDQUFDOzs7O2FBQ3JDLENBQUMsQ0FBQztRQUVILElBQU0sWUFBWSxHQUNoQixpR0FBaUcsQ0FBQztRQUNwRyxFQUFFLENBQUMsWUFBWSxFQUFFOzs7OzRCQUNmLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUM7O3dCQUFsRCxTQUFrRCxDQUFDO3dCQUM3QyxNQUFNLEdBQUcsY0FBYyxDQUFDLHlCQUF5QixDQUFDLENBQUM7d0JBQ3pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQzs7d0JBQWxELFNBQWtELENBQUM7d0JBQ25ELHFCQUFNLE1BQU07O3dCQUFaLFNBQVksQ0FBQzt3QkFDYixxQkFBTSxlQUFlLENBQUMsWUFBWSxDQUFDOzt3QkFBbkMsU0FBbUMsQ0FBQzs7OzthQUNyQyxDQUFDLENBQUM7UUFFSCxJQUFNLGtCQUFrQixHQUN0QiwyRkFBMkYsQ0FBQztRQUM5RixFQUFFLENBQUMsa0JBQWtCLEVBQUU7Ozs7Ozt3QkFFbkIscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQzs7d0JBQXRDLFNBQXNDLENBQUM7d0JBQ3ZDLDZDQUFXLENBQUMseUJBQXlCLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7d0JBRWpELDRDQUFNLENBQUMsSUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLDJEQUFxQixFQUFFLFFBQVEsQ0FBQyxDQUFDOzs7OzthQUUzRSxDQUFDLENBQUM7UUFDSCxJQUFNLGtCQUFrQixHQUN0Qix5R0FBeUcsQ0FBQztRQUM1RyxFQUFFLENBQUMsa0JBQWtCLEVBQUU7Ozs7Ozt3QkFFbkIscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQztnQ0FDZCxJQUFJLEVBQUUscUJBQXFCOzZCQUM1QixDQUFDOzt3QkFGRixTQUVFLENBQUM7d0JBQ0gsNkNBQVcsQ0FBQyx5QkFBeUIsRUFBRSxRQUFRLENBQUMsQ0FBQzs7Ozt3QkFFakQsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsMkRBQXFCLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7O2FBRTNFLENBQUMsQ0FBQztRQUVILElBQU0sY0FBYyxHQUNsQixtSEFBbUgsQ0FBQztRQUN0SCxFQUFFLENBQUMsY0FBYyxFQUFFOzs7Ozs7d0JBRWYscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQztnQ0FDZCxJQUFJLEVBQUUscUJBQXFCO2dDQUMzQixLQUFLLEVBQUUscUJBQXFCOzZCQUM3QixDQUFDOzt3QkFIRixTQUdFLENBQUM7d0JBQ0gsNkNBQVcsQ0FBQyx5QkFBeUIsRUFBRSxRQUFRLENBQUMsQ0FBQzs7Ozt3QkFFakQsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsMkRBQXFCLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7O2FBRTNFLENBQUMsQ0FBQztRQUVILElBQU0sK0JBQStCLEdBQ25DLHlIQUF5SCxDQUFDO1FBQzVILEVBQUUsQ0FBQywrQkFBK0IsRUFBRTs7Ozs0QkFDbEMscUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQywwQkFBMEIsQ0FBQzs7d0JBQWxELFNBQWtELENBQUM7d0JBQzdDLFFBQVEsR0FBRyxjQUFjLENBQUMsbUNBQW1DLENBQUMsQ0FBQzt3QkFDckUscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0NBQ3hCLElBQUksRUFBRSxTQUFTO2dDQUNmLElBQUksRUFBRSxtQkFBbUI7NkJBQzFCLENBQUM7O3dCQUhGLFNBR0UsQ0FBQzt3QkFDb0IscUJBQU0sUUFBUTs7d0JBQS9CLGFBQWEsR0FBRyxDQUFDLFNBQWMsQ0FBUTt3QkFDN0MsNENBQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUM5RCw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDeEUscUJBQU0sZUFBZSxDQUFDLCtCQUErQixDQUFDOzt3QkFBdEQsU0FBc0QsQ0FBQzs7OzthQUN4RCxDQUFDLENBQUM7UUFFSCxJQUFNLCtCQUErQixHQUNuQyxxSUFBcUksQ0FBQztRQUN4SSxFQUFFLENBQUMsK0JBQStCLEVBQUU7Ozs7NEJBQ2xDLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUM7O3dCQUFsRCxTQUFrRCxDQUFDO3dCQUM3QyxRQUFRLEdBQUcsY0FBYyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7d0JBQ3JFLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQ2xCLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsQ0FDL0M7O3dCQUhELFNBR0MsQ0FBQzt3QkFDcUIscUJBQU0sUUFBUTs7d0JBQS9CLGFBQWEsR0FBRyxDQUFDLFNBQWMsQ0FBUTt3QkFDN0MsNENBQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUM5RCw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDeEUscUJBQU0sZUFBZSxDQUFDLCtCQUErQixDQUFDOzt3QkFBdEQsU0FBc0QsQ0FBQzs7OzthQUN4RCxDQUFDLENBQUM7UUFFSCxJQUFNLCtCQUErQixHQUNuQywrSUFBK0ksQ0FBQztRQUNsSixFQUFFLENBQUMsK0JBQStCLEVBQUU7Ozs7NEJBQ2xDLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUM7O3dCQUFsRCxTQUFrRCxDQUFDO3dCQUM3QyxRQUFRLEdBQUcsY0FBYyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7d0JBQ3JFLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFDakMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxDQUMvQzs7d0JBSEQsU0FHQyxDQUFDO3dCQUNxQixxQkFBTSxRQUFROzt3QkFBL0IsYUFBYSxHQUFHLENBQUMsU0FBYyxDQUFRO3dCQUM3Qyw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQzlELDRDQUFNLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUN4RSxxQkFBTSxlQUFlLENBQUMsK0JBQStCLENBQUM7O3dCQUF0RCxTQUFzRCxDQUFDOzs7O2FBQ3hELENBQUMsQ0FBQztRQUVILElBQU0sdUJBQXVCLEdBQzNCLGdIQUFnSCxDQUFDO1FBQ25ILEVBQUUsQ0FBQyx1QkFBdUIsRUFBRTs7Ozs0QkFDMUIscUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQzs7d0JBQTFDLFNBQTBDLENBQUM7d0JBQ3JDLFFBQVEsR0FBRyxjQUFjLENBQUMsbUNBQW1DLENBQUMsQ0FBQzt3QkFDckUscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtnQ0FDdEMsSUFBSSxFQUFFLFNBQVM7Z0NBQ2YsSUFBSSxFQUFFLHNCQUFzQjs2QkFDN0IsQ0FBQzs7d0JBSEYsU0FHRSxDQUFDO3dCQUNvQixxQkFBTSxRQUFROzt3QkFBL0IsYUFBYSxHQUFHLENBQUMsU0FBYyxDQUFRO3dCQUM3QyxxQkFBTSxlQUFlLENBQUMsdUJBQXVCLENBQUM7O3dCQUE5QyxTQUE4QyxDQUFDO3dCQUMvQyw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQzlELDRDQUFNLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUN0QyxzQkFBc0IsRUFDdEIsUUFBUSxDQUNULENBQUM7Ozs7YUFDSCxDQUFDLENBQUM7UUFFSCxJQUFNLHVCQUF1QixHQUMzQiw0SEFBNEgsQ0FBQztRQUMvSCxFQUFFLENBQUMsdUJBQXVCLEVBQUU7Ozs7NEJBQzFCLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUM7O3dCQUExQyxTQUEwQyxDQUFDO3dCQUNyQyxRQUFRLEdBQUcsY0FBYyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7d0JBQ3JFLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsRUFDaEMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxzQkFBc0IsRUFBRSxDQUNsRDs7d0JBSEQsU0FHQyxDQUFDO3dCQUNxQixxQkFBTSxRQUFROzt3QkFBL0IsYUFBYSxHQUFHLENBQUMsU0FBYyxDQUFRO3dCQUM3QyxxQkFBTSxlQUFlLENBQUMsdUJBQXVCLENBQUM7O3dCQUE5QyxTQUE4QyxDQUFDO3dCQUMvQyw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQzlELDRDQUFNLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUN0QyxzQkFBc0IsRUFDdEIsUUFBUSxDQUNULENBQUM7Ozs7YUFDSCxDQUFDLENBQUM7UUFFSCxJQUFNLHVCQUF1QixHQUMzQixzSUFBc0ksQ0FBQztRQUN6SSxFQUFFLENBQUMsdUJBQXVCLEVBQUU7Ozs7NEJBQzFCLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUM7O3dCQUExQyxTQUEwQyxDQUFDO3dCQUNyQyxRQUFRLEdBQUcsY0FBYyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7d0JBQ3JFLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsS0FBSyxFQUFFLG9CQUFvQixFQUFFLEVBQzdELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsQ0FDbEQ7O3dCQUhELFNBR0MsQ0FBQzt3QkFDcUIscUJBQU0sUUFBUTs7d0JBQS9CLGFBQWEsR0FBRyxDQUFDLFNBQWMsQ0FBUTt3QkFDN0MscUJBQU0sZUFBZSxDQUFDLHVCQUF1QixDQUFDOzt3QkFBOUMsU0FBOEMsQ0FBQzt3QkFDL0MsNENBQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUM5RCw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FDdEMsc0JBQXNCLEVBQ3RCLFFBQVEsQ0FDVCxDQUFDOzs7O2FBQ0gsQ0FBQyxDQUFDO1FBRUgsSUFBTSwyQkFBMkIsR0FDL0IsMEZBQTBGLENBQUM7UUFDN0YsRUFBRSxDQUFDLDJCQUEyQixFQUFFOzs7OzRCQUM5QixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLDBCQUEwQixDQUFDOzt3QkFBbEQsU0FBa0QsQ0FBQzs7Ozt3QkFFakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsRUFDbEIsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSw4QkFBOEIsRUFBRSxDQUMxRDs7d0JBSEQsU0FHQyxDQUFDO3dCQUNGLDZDQUFXLENBQUMseUJBQXlCLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7d0JBRWpELDRDQUFNLENBQUMsSUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLDBEQUFvQixFQUFFLFFBQVEsQ0FBQyxDQUFDOzs0QkFFekUscUJBQU0sZUFBZSxDQUFDLDJCQUEyQixDQUFDOzt3QkFBbEQsU0FBa0QsQ0FBQzs7OzthQUNwRCxDQUFDLENBQUM7UUFFSCxJQUFNLG1CQUFtQixHQUN2QixpRkFBaUYsQ0FBQztRQUNwRixFQUFFLENBQUMsbUJBQW1CLEVBQUU7Ozs7NEJBQ3RCLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUM7O3dCQUExQyxTQUEwQyxDQUFDOzs7O3dCQUV6QyxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDbkQsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxDQUMvQzs7d0JBSEQsU0FHQyxDQUFDO3dCQUNGLDZDQUFXLENBQUMseUJBQXlCLEVBQUUsUUFBUSxDQUFDLENBQUM7Ozs7d0JBRWpELDRDQUFNLENBQUMsSUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLDBEQUFvQixFQUFFLFFBQVEsQ0FBQyxDQUFDOzs0QkFFekUscUJBQU0sZUFBZSxDQUFDLG1CQUFtQixDQUFDOzt3QkFBMUMsU0FBMEMsQ0FBQzs7OzthQUM1QyxDQUFDLENBQUM7UUFFSCxJQUFNLHlCQUF5QixHQUM3QixnSkFBZ0osQ0FBQztRQUNuSixFQUFFLENBQUMseUJBQXlCLEVBQUU7Ozs7NEJBQzVCLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUM7O3dCQUFsRCxTQUFrRCxDQUFDO3dCQUM3QyxRQUFRLEdBQUcsY0FBYyxDQUM3Qiw0Q0FBNEMsQ0FDN0MsQ0FBQzt3QkFDRixxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQ2pDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsQ0FDdkQ7O3dCQUhELFNBR0MsQ0FBQzt3QkFDcUIscUJBQU0sUUFBUTs7d0JBQS9CLGFBQWEsR0FBRyxDQUFDLFNBQWMsQ0FBUTt3QkFDN0MsNENBQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUM5RCw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FDdEMsMkJBQTJCLEVBQzNCLFFBQVEsQ0FDVCxDQUFDO3dCQUNGLHFCQUFNLGVBQWUsQ0FBQyx5QkFBeUIsQ0FBQzs7d0JBQWhELFNBQWdELENBQUM7Ozs7YUFDbEQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBOU5GLENBOE5FLEVBQUM7QUFFTCxtRUFBbUU7QUFDbkUsaUZBQWlGO0FBQ2pGLElBQU0sY0FBYyxHQUFHLFVBQUMsV0FBbUI7SUFDekMsSUFBSSxPQUFPLENBQUM7SUFDWixJQUFNLGVBQWUsR0FBRyxJQUFJLE9BQU8sQ0FBVSxVQUFPLE9BQU8sRUFBRSxNQUFNOzs7OztvQkFDM0QsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsVUFBQyxPQUFPO3dCQUM1RCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ2pCLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDdEIsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO29CQUN6QixDQUFDLENBQUMsQ0FBQztvQkFHRyxLQUErQyw2Q0FBSyxFQUFFLEVBQTNDLFVBQVUsZUFBVyxVQUFVLGNBQWE7b0JBQzdELE9BQU8sR0FBRyxVQUFVLENBQUM7b0JBQ3JCLHFCQUFNLFVBQVU7O29CQUFoQixTQUFnQixDQUFDO29CQUNqQixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQyxDQUFDOzs7O1NBQ3JELENBQUMsQ0FBQztJQUVILE9BQU8sZUFBZSxDQUFDO0FBQ3pCLENBQUMsQ0FBQztBQUVGLFNBQWUsZUFBZSxDQUFDLE1BQU07Ozs7O3dCQUNuQyxxQkFBTSxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7O29CQUFsQyxTQUFrQyxDQUFDO29CQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O29CQUFoRSxpQkFBaUIsR0FBRyxTQUE0QztvQkFDdEUscUJBQU0sY0FBYyxDQUFDLGNBQWMsRUFBRSxNQUFNLEVBQUUsaUJBQWlCLENBQUM7O29CQUEvRCxTQUErRCxDQUFDO29CQUNoRSxxQkFBTSw0Q0FBSSxDQUFDLHNFQUE2QixDQUFDOztvQkFBekMsU0FBeUMsQ0FBQzs7Ozs7Q0FDM0M7QUFFRCxJQUFNLG9CQUFvQixHQUFHLFVBQU8sV0FBVzs7OztvQkFDbkIscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7Z0JBQWhFLGlCQUFpQixHQUFHLFNBQTRDO2dCQUN0RSxpQkFBaUIsQ0FBQyxTQUFTLENBQUM7b0JBQzFCLElBQUksRUFBRSxhQUFhO29CQUNuQixNQUFNLEVBQUUsV0FBVztpQkFDQyxDQUFDLENBQUM7Ozs7S0FDekIsQ0FBQztBQUVGLElBQU0sY0FBYyxHQUFHLFVBQ3JCLFdBQW1CLEVBQ25CLE1BQWMsRUFDZCxPQUFpQjtJQUVqQixJQUFJLGlCQUEyQixDQUFDO0lBQ2hDLE9BQU8sSUFBSSxPQUFPLENBQVUsVUFBTyxPQUFPOzs7WUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNSLCtCQUF1QixXQUFXLCtCQUFtQixPQUFPLENBQUMsRUFBRSwyQkFBZSxNQUFNLE9BQUcsQ0FDMUYsQ0FBQztZQUVJLE9BQU8sR0FBRyxVQUFDLE9BQTBCO2dCQUN6QyxPQUFPLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7Z0JBQzlDLElBQUksTUFBTSxFQUFFO29CQUNWLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBSSxNQUFNLGlCQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUUsQ0FBQyxDQUFDO29CQUMvQyxJQUFJLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO3dCQUM1QixPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxvQkFBYSxXQUFXLHdCQUFjLE1BQU0sQ0FBRSxDQUM1RCxDQUFDO3dCQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDakIsSUFBSSxpQkFBaUI7NEJBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7cUJBQ3hEO3lCQUFNO3dCQUNMLE9BQU8sQ0FBQyxJQUFJLENBQ1YsSUFBSSxDQUFDLEdBQUcsRUFBRTs0QkFDUixzQkFBYyxXQUFXLDhEQUFrRCxNQUFNLHVCQUFXLE9BQU8sQ0FBQyxNQUFNLFFBQUksQ0FDakgsQ0FBQztxQkFDSDtpQkFDRjtxQkFBTTtvQkFDTCxPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUU7d0JBQ1IsdUNBQStCLFdBQVcsNEJBQWdCLE1BQU0sT0FBRyxDQUN0RSxDQUFDO29CQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDakIsSUFBSSxpQkFBaUI7d0JBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7aUJBQ3hEO1lBQ0gsQ0FBQyxDQUFDO1lBRUYsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO2dCQUN6QixpQkFBaUIsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ25FO2lCQUFNO2dCQUNMLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUNBQW1DLENBQUMsQ0FBQztnQkFDakQsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFFL0QsU0FBUyxHQUFHLFVBQU8sT0FBMEI7O3dCQUNqRCxJQUFJLE9BQU8sRUFBRTs0QkFDWCxJQUFJLE1BQU0sRUFBRTtnQ0FDVixJQUFJLE1BQU0sS0FBSSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxLQUFJLFFBQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLEtBQUksV0FBVyxFQUFFO29DQUM3RCxPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUU7d0NBQ1Isc0JBQWMsV0FBVyxtREFBdUMsTUFBTSxPQUFHLENBQzVFLENBQUM7b0NBQ0YsSUFBSSxpQkFBaUI7d0NBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7b0NBQ3ZELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztpQ0FDbEIsQ0FBQyxvRUFBb0U7cUNBQ2pFO29DQUNILE9BQU8sQ0FBQyxHQUFHLENBQ1QsSUFBSSxDQUFDLEdBQUcsRUFBRTt3Q0FDUixrREFBMEMsV0FBVyw0QkFBZ0IsTUFBTSxvQ0FDekUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sZ0RBRWQsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0saUJBQ3RCLE1BQU0sS0FBSSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGVBQWUsdUNBRXJELE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLG1CQUFRLFdBQVcsZUFDcEMsUUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksS0FBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsZUFBZSxNQUMzRCxDQUNOLENBQUM7aUNBQ0g7NkJBQ0Y7aUNBQU07Z0NBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO29DQUNSLHNCQUFjLFdBQVcsc0RBQWtELENBQzlFLENBQUM7Z0NBQ0YsSUFBSSxpQkFBaUI7b0NBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7Z0NBQ3ZELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzs2QkFDbEI7eUJBQ0Y7OztxQkFDRixDQUFDO2dCQUNGLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUM3Qzs7O1NBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyV2dCO0FBQ29CO0FBQ2U7QUFDVjtBQUVFO0FBRzdDLElBQU0sZUFBZSxHQUNuQixxQkFBcUIsR0FBRyxpRUFBNEIsR0FBRyxXQUFXLENBQUM7QUFFckU7O0dBRUc7QUFDSCxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxrQkFBa0IsRUFBRTtRQUMzQixNQUFNLENBQUM7Ozs0QkFDTCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLENBQUM7O3dCQUFqRCxTQUFpRCxDQUFDO3dCQUNsRCxxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDOzt3QkFBMUMsU0FBMEMsQ0FBQzs7OzthQUM1QyxDQUFDLENBQUM7UUFFSCxTQUFTLENBQUMsU0FBZSxTQUFTOzs7O2dDQUNoQyxxQkFBTSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQzs7NEJBQXBELFNBQW9ELENBQUM7Ozs7O1NBQ3RELENBQUMsQ0FBQztRQUVILElBQU0sS0FBSyxHQUNULG1IQUFtSCxDQUFDO1FBQ3RILEVBQUUsQ0FBQyxLQUFLLEVBQUU7Ozs7O3dCQUNGLE1BQU0sR0FBRyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQzt3QkFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUNMLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsc0JBQXNCLEVBQUU7Z0NBQ3RFLElBQUksRUFBRSxjQUFjOzZCQUNyQixDQUFDOzt3QkFGSSxnQkFBZ0IsR0FBRyxTQUV2Qjt3QkFFRix3QkFBd0IsQ0FBQyxZQUFZLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzt3QkFDekQscUJBQU0sTUFBTTs7d0JBQVosU0FBWSxDQUFDOzs7O2FBQ2QsQ0FBQyxDQUFDO1FBRUgsSUFBTSxLQUFLLEdBQ1QsMkhBQTJILENBQUM7UUFDOUgsRUFBRSxDQUFDLEtBQUssRUFBRTs7Ozs7d0JBQ0YsTUFBTSxHQUFHLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO3dCQUM3QixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUM3QyxnQkFBZ0IsRUFDaEI7Z0NBQ0UsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLEVBQ0QsWUFBWSxDQUNiOzt3QkFOSyxnQkFBZ0IsR0FBRyxTQU14Qjt3QkFDRCx3QkFBd0IsQ0FBQyxZQUFZLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzt3QkFDekQscUJBQU0sTUFBTTs7d0JBQVosU0FBWSxDQUFDOzs7O2FBQ2QsQ0FBQyxDQUFDO1FBRUgsSUFBTSxLQUFLLEdBQ1Qsa0lBQWtJLENBQUM7UUFDckksRUFBRSxDQUFDLEtBQUssRUFBRTs7Ozs7d0JBQ0YsTUFBTSxHQUFHLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO3dCQUM3QixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUM3QyxnQkFBZ0IsRUFDaEI7Z0NBQ0UsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLEVBQ0QsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLENBQ3ZCOzt3QkFOSyxnQkFBZ0IsR0FBRyxTQU14Qjt3QkFFRCx3QkFBd0IsQ0FBQyxZQUFZLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzt3QkFDekQscUJBQU0sTUFBTTs7d0JBQVosU0FBWSxDQUFDOzs7O2FBQ2QsQ0FBQyxDQUFDO1FBRUgsSUFBTSxLQUFLLEdBQ1QsNElBQTRJLENBQUM7UUFDL0ksRUFBRSxDQUFDLEtBQUssRUFBRTs7Ozs7d0JBQ0YsTUFBTSxHQUFHLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO3dCQUM3QixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUM3QyxnQkFBZ0IsRUFDaEI7Z0NBQ0UsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLEVBQ0QsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsQ0FDOUM7O3dCQU5LLGdCQUFnQixHQUFHLFNBTXhCO3dCQUNELHdCQUF3QixDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUN6RCxxQkFBTSxNQUFNOzt3QkFBWixTQUFZLENBQUM7Ozs7YUFDZCxDQUFDLENBQUM7UUFFSCxJQUFNLEtBQUssR0FDVCw4SUFBOEksQ0FBQztRQUNqSixFQUFFLENBQUMsS0FBSyxFQUFFOzs7Ozs7d0JBRU4scUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FDcEIsZ0JBQWdCLEVBQ2hCO2dDQUNFLElBQUksRUFBRSxjQUFjOzZCQUNyQixFQUNELFlBQVksQ0FDYjs7d0JBTkQsU0FNQyxDQUFDO3dCQUNGLDZDQUFXLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7Ozt3QkFFcEMsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsOERBQXdCLENBQUMsQ0FBQzt3QkFFakUseUNBQXlDO3dCQUN6QyxxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLHNCQUFzQixFQUFFO2dDQUM3QyxJQUFJLEVBQUUsY0FBYzs2QkFDckIsQ0FBQzs7d0JBSEYseUNBQXlDO3dCQUN6QyxTQUVFLENBQUM7Ozs7O2FBRU4sQ0FBQyxDQUFDO1FBQ0gsSUFBTSxLQUFLLEdBQ1QsK0pBQStKLENBQUM7UUFDbEssRUFBRSxDQUFDLEtBQUssRUFBRTs7Ozs7O3dCQUVOLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQ3BCLGdCQUFnQixFQUNoQjtnQ0FDRSxJQUFJLEVBQUUsY0FBYzs2QkFDckIsRUFDRCxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxDQUM5Qzs7d0JBTkQsU0FNQyxDQUFDO3dCQUNGLDZDQUFXLENBQUMsc0JBQXNCLEVBQUUsZUFBZSxDQUFDLENBQUM7Ozs7d0JBRXJELDRDQUFNLENBQUMsSUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQ3pCLFNBQVMsRUFDVCw4REFBd0IsRUFDeEIsZUFBZSxDQUNoQixDQUFDO3dCQUVGLHlDQUF5Qzt3QkFDekMscUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxzQkFBc0IsRUFBRTtnQ0FDN0MsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLENBQUM7O3dCQUhGLHlDQUF5Qzt3QkFDekMsU0FFRSxDQUFDOzs7OzthQUVOLENBQUMsQ0FBQztRQUVILElBQU0sS0FBSyxHQUNULHFKQUFxSixDQUFDO1FBQ3hKLEVBQUUsQ0FBQyxLQUFLLEVBQUU7Ozs7Ozt3QkFFTixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUNwQixnQkFBZ0IsRUFDaEI7Z0NBQ0UsSUFBSSxFQUFFLGNBQWM7NkJBQ3JCLEVBQ0QsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLENBQ3ZCOzt3QkFORCxTQU1DLENBQUM7d0JBQ0YsNkNBQVcsQ0FBQyxzQkFBc0IsRUFBRSxlQUFlLENBQUMsQ0FBQzs7Ozt3QkFFckQsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULDhEQUF3QixFQUN4QixlQUFlLENBQ2hCLENBQUM7d0JBRUYseUNBQXlDO3dCQUN6QyxxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLHNCQUFzQixFQUFFO2dDQUM3QyxJQUFJLEVBQUUsY0FBYzs2QkFDckIsQ0FBQzs7d0JBSEYseUNBQXlDO3dCQUN6QyxTQUVFLENBQUM7Ozs7O2FBRU4sQ0FBQyxDQUFDO1FBRUgsSUFBTSxLQUFLLEdBQ1QsOElBQThJLENBQUM7UUFDakosRUFBRSxDQUFDLEtBQUssRUFBRTs7Ozs7O3dCQUVOLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQ3BCLGdCQUFnQixFQUNoQjtnQ0FDRSxJQUFJLEVBQUUsY0FBYzs2QkFDckIsRUFDRCxZQUFZLENBQ2I7O3dCQU5ELFNBTUMsQ0FBQzt3QkFDRiw2Q0FBVyxDQUFDLHNCQUFzQixFQUFFLGVBQWUsQ0FBQyxDQUFDOzs7O3dCQUVyRCw0Q0FBTSxDQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUN6QixTQUFTLEVBQ1QsOERBQXdCLEVBQ3hCLGVBQWUsQ0FDaEIsQ0FBQzt3QkFFRix5Q0FBeUM7d0JBQ3pDLHFCQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsc0JBQXNCLEVBQUU7Z0NBQzdDLElBQUksRUFBRSxjQUFjOzZCQUNyQixDQUFDOzt3QkFIRix5Q0FBeUM7d0JBQ3pDLFNBRUUsQ0FBQzs7Ozs7YUFFTixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUF2S0YsQ0F1S0UsRUFBQztBQUVMLElBQU0sd0JBQXdCLEdBQUcsVUFDL0IsT0FBZSxFQUNmLGdCQUFrQztJQUVsQyxJQUFJLE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUMvQyw0Q0FBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0tBQ2pFO1NBQU0sSUFBSSxPQUFPLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxRQUFRLEVBQUU7UUFDdEQsNENBQU0sQ0FBRSxnQkFBZ0IsQ0FBQyxNQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQ3pELE9BQU8sRUFDUCxlQUFlLENBQ2hCLENBQUM7S0FDSDs7UUFBTSw2Q0FBVyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBRUYsSUFBTSxvQkFBb0IsR0FBRyxVQUFPLFdBQVc7Ozs7b0JBQ25CLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O2dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0QztnQkFDdEUsaUJBQWlCLENBQUMsU0FBUyxDQUFDO29CQUMxQixJQUFJLEVBQUUsYUFBYTtvQkFDbkIsTUFBTSxFQUFFLFdBQVc7aUJBQ0MsQ0FBQyxDQUFDOzs7O0tBQ3pCLENBQUM7QUFFRixtRUFBbUU7QUFDbkUsaUZBQWlGO0FBQ2pGLElBQU0sY0FBYyxHQUFHLFVBQUMsV0FBbUI7SUFDekMsSUFBSSxPQUFPLENBQUM7SUFDWixJQUFNLGVBQWUsR0FBRyxJQUFJLE9BQU8sQ0FBVSxVQUFPLE9BQU8sRUFBRSxNQUFNOzs7OztvQkFDM0QsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsVUFBQyxPQUFPO3dCQUM1RCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ2pCLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDdEIsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO29CQUN6QixDQUFDLENBQUMsQ0FBQztvQkFHRyxLQUFpRCw2Q0FBSyxFQUFFLEVBQTdDLFlBQVksZUFBVyxVQUFVLGNBQWE7b0JBQy9ELE9BQU8sR0FBRyxVQUFVLENBQUM7b0JBQ3JCLHFCQUFNLFlBQVk7O29CQUFsQixTQUFrQixDQUFDO29CQUNuQixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQyxDQUFDOzs7O1NBQ3JELENBQUMsQ0FBQztJQUVILE9BQU8sZUFBZSxDQUFDO0FBQ3pCLENBQUMsQ0FBQztBQUVGLFNBQWUsc0JBQXNCLENBQUMsTUFBTTs7Ozs7d0JBQzFDLHFCQUFNLG9CQUFvQixDQUFDLE1BQU0sQ0FBQzs7b0JBQWxDLFNBQWtDLENBQUM7b0JBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7b0JBQWhFLGlCQUFpQixHQUFHLFNBQTRDO29CQUN0RSxxQkFBTSxjQUFjLENBQUMsY0FBYyxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQzs7b0JBQS9ELFNBQStELENBQUM7b0JBQ2hFLHFCQUFNLDRDQUFJLENBQUMsc0VBQTZCLENBQUM7O29CQUF6QyxTQUF5QyxDQUFDOzs7OztDQUMzQztBQUVELElBQU0sY0FBYyxHQUFHLFVBQ3JCLFdBQW1CLEVBQ25CLE1BQWMsRUFDZCxPQUFpQjtJQUVqQixJQUFJLGlCQUEyQixDQUFDO0lBQ2hDLE9BQU8sSUFBSSxPQUFPLENBQVUsVUFBTyxPQUFPOzs7WUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNSLCtCQUF1QixXQUFXLCtCQUFtQixPQUFPLENBQUMsRUFBRSwyQkFBZSxNQUFNLE9BQUcsQ0FDMUYsQ0FBQztZQUVJLE9BQU8sR0FBRyxVQUFDLE9BQTBCO2dCQUN6QyxJQUFJLE1BQU0sRUFBRTtvQkFDVixJQUFJLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO3dCQUM1QixPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxvQkFBYSxXQUFXLHdCQUFjLE1BQU0sQ0FBRSxDQUM1RCxDQUFDO3dCQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDakIsSUFBSSxpQkFBaUI7NEJBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7cUJBQ3hEO3lCQUFNO3dCQUNMLE9BQU8sQ0FBQyxJQUFJLENBQ1YsSUFBSSxDQUFDLEdBQUcsRUFBRTs0QkFDUixzQkFBYyxXQUFXLDhEQUFrRCxNQUFNLHVCQUFXLE9BQU8sQ0FBQyxNQUFNLFFBQUksQ0FDakgsQ0FBQztxQkFDSDtpQkFDRjtxQkFBTTtvQkFDTCxPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUU7d0JBQ1IsdUNBQStCLFdBQVcsNEJBQWdCLE1BQU0sT0FBRyxDQUN0RSxDQUFDO29CQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDakIsSUFBSSxpQkFBaUI7d0JBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7aUJBQ3hEO1lBQ0gsQ0FBQyxDQUFDO1lBRUYsSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO2dCQUN6QixpQkFBaUIsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ25FO2lCQUFNO2dCQUNMLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBRS9ELFNBQVMsR0FBRyxVQUFPLE9BQTBCOzt3QkFDakQsSUFBSSxPQUFPLEVBQUU7NEJBQ1gsSUFBSSxNQUFNLEVBQUU7Z0NBQ1YsSUFBSSxNQUFNLEtBQUksT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0sS0FBSSxRQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSxLQUFJLFdBQVcsRUFBRTtvQ0FDN0QsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO3dDQUNSLHNCQUFjLFdBQVcsbURBQXVDLE1BQU0sT0FBRyxDQUM1RSxDQUFDO29DQUNGLElBQUksaUJBQWlCO3dDQUFFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO29DQUN2RCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7aUNBQ2xCLENBQUMsb0VBQW9FO3FDQUNqRTtvQ0FDSCxPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUU7d0NBQ1Isa0RBQTBDLFdBQVcsNEJBQWdCLE1BQU0sb0NBQ3pFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLHFDQUUxQixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxpQkFDVixNQUFNLEtBQUksT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0sRUFBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxlQUFlLDRCQUVqRSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSxpQkFDTCxRQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSxLQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxlQUFlLE1BQzNELENBQ04sQ0FBQztpQ0FDSDs2QkFDRjtpQ0FBTTtnQ0FDTCxPQUFPLENBQUMsR0FBRyxDQUNULElBQUksQ0FBQyxHQUFHLEVBQUU7b0NBQ1Isc0JBQWMsV0FBVyxzREFBa0QsQ0FDOUUsQ0FBQztnQ0FDRixJQUFJLGlCQUFpQjtvQ0FBRSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQ0FDdkQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzZCQUNsQjt5QkFDRjs7O3FCQUNGLENBQUM7Z0JBQ0YsT0FBTyxDQUFDLGlCQUFpQixFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQzdDOzs7U0FDRixDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9Ub0M7QUFDZTtBQUlyRCxJQUFNLGFBQWEsR0FDakIscUJBQXFCLEdBQUcsd0VBQW1DLEdBQUcsV0FBVyxDQUFDO0FBRTVFLGlFQUFlO0lBQ2IsZUFBUSxDQUFDLHlCQUF5QixFQUFFO1FBQ2xDLElBQUksUUFBa0IsQ0FBQztRQUV2QixTQUFTLENBQUM7WUFDUixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQzFCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDdkIsUUFBUSxHQUFHLFNBQVMsQ0FBQzthQUN0QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtCQUErQixFQUFFOzs7O2dCQUM1QixXQUFXLEdBQUcsY0FBYyxDQUFDO2dCQUNuQyxJQUFJO29CQUNGLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLFVBQUMsSUFBUzt3QkFDeEQsT0FBTyxDQUFDLEdBQUcsQ0FDVCxtQ0FBNEIsV0FBVyxvQ0FBMEIsSUFBSSxDQUFFLENBQ3hFLENBQUM7b0JBQ0osQ0FBQyxDQUFDLENBQUM7aUJBQ0o7Z0JBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ1gsNkNBQVcsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxRQUFFLENBQUMsT0FBTyxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUNqRDs7O2FBQ0YsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9DQUFvQyxFQUFFOzs7Z0JBQ3ZDLElBQUk7b0JBQ0YsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsY0FBTyxDQUFDLENBQUMsQ0FBQztvQkFDbkQsK0NBQWEsQ0FBQyxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUFDO29CQUN2RSw0Q0FBTSxDQUFDLE9BQU8sUUFBUSxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FDN0QsVUFBVSxDQUNYLENBQUM7aUJBQ0g7Z0JBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ1gsNkNBQVcsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxRQUFFLENBQUMsT0FBTyxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUNqRDs7O2FBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBbENGLENBa0NFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDaUM7QUFDZTtBQUtyRCxpRUFBZTtJQUNiLGVBQVEsQ0FBQyx3QkFBd0IsRUFBRTtRQUNqQyxJQUFJLFFBQWtCLENBQUM7UUFFdkIsU0FBUyxDQUFDO1lBQ1IsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO2dCQUMxQixRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3ZCLFFBQVEsR0FBRyxTQUFTLENBQUM7YUFDdEI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywrQkFBK0IsRUFBRTs7OztnQkFDNUIsVUFBVSxHQUFHLDBCQUEwQixDQUFDO2dCQUM5QyxJQUFJO29CQUNGLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLFVBQUMsSUFBUzt3QkFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FDVCxxQ0FBOEIsVUFBVSxvQ0FBMEIsSUFBSSxDQUFFLENBQ3pFLENBQUM7b0JBQ0osQ0FBQyxDQUFDLENBQUM7b0JBQ0gsNENBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDeEU7Z0JBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ1gsNkNBQVcsQ0FDVCxxQkFBcUI7d0JBQ25CLHVFQUFrQzt3QkFDbEMsV0FBVzt3QkFDWCxDQUFDLFFBQUUsQ0FBQyxPQUFPLG1DQUFJLEVBQUUsQ0FBQyxDQUNyQixDQUFDO2lCQUNIOzs7YUFDRixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUE1QkYsQ0E0QkUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENpQztBQUNlO0FBSXJELElBQU0scUJBQXFCLEdBQ3pCLHFCQUFxQixHQUFHLHVFQUFrQyxHQUFHLFdBQVcsQ0FBQztBQUUzRSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyx3QkFBd0IsRUFBRTtRQUNqQyxFQUFFLENBQUMsK0JBQStCLEVBQUU7Ozs7Ozs7d0JBRWhCLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRTs7d0JBQXhDLE9BQU8sR0FBRyxTQUE4Qjs7Ozt3QkFFOUMsNkNBQVcsQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7O2FBRTNELENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywyRUFBMkUsRUFBRTs7Ozs7Ozt3QkFFNUQscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFOzt3QkFBeEMsT0FBTyxHQUFHLFNBQThCO3dCQUM5Qyw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozt3QkFFN0IsNkNBQVcsQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7O2FBRTNELENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQWpCRixDQWlCRSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQmlDO0FBQ2U7QUFJckQsSUFBTSxXQUFXLEdBQ2YscUJBQXFCLEdBQUcsNkRBQXdCLEdBQUcsV0FBVyxDQUFDO0FBRWpFLGlFQUFlO0lBQ2IsZUFBUSxDQUFDLGNBQWMsRUFBRTtRQUN2QixFQUFFLENBQUMsa0RBQWtELEVBQUU7Ozs7Z0JBQ3JELElBQUk7b0JBQ0ksSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDNUIsNENBQU0sQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQzFELDRDQUFNLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUN4RDtnQkFBQyxPQUFPLEVBQUUsRUFBRTtvQkFDWCw2Q0FBVyxDQUFDLFdBQVcsR0FBRyxDQUFDLFFBQUUsQ0FBQyxPQUFPLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQy9DOzs7YUFDRixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFWRixDQVVFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CaUM7QUFDZTtBQUlyRCxJQUFNLHNCQUFzQixHQUMxQixxQkFBcUIsR0FBRyx3RUFBbUMsR0FBRyxXQUFXLENBQUM7QUFFNUUsaUVBQWU7SUFDYixlQUFRLENBQUMseUJBQXlCLEVBQUU7UUFDbEMsRUFBRSxDQUFDLG1DQUFtQyxFQUFFOzs7Ozs7O3dCQUVwQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLENBQUM7O3dCQUExRCxPQUFPLEdBQUcsU0FBZ0Q7d0JBQ2hFLDRDQUFNLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQy9ELDRDQUFNLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ2pFLDRDQUFNLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7d0JBQ3RFLDRDQUFNLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQ3RELG1CQUFtQixDQUNwQixDQUFDO3dCQUNGLDRDQUFNLENBQUMsT0FBTyxFQUFFLHNCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQ3RELG9CQUFvQixDQUNyQixDQUFDOzs7O3dCQUVGLDZDQUFXLENBQUMsc0JBQXNCLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUU1RCxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFqQkYsQ0FpQkUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJpQztBQUNlO0FBS3JELElBQU0sb0JBQW9CLEdBQ3hCLHFCQUFxQixHQUFHLHVFQUFrQyxHQUFHLFdBQVcsQ0FBQztBQUUzRSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyx3QkFBd0IsRUFBRTtRQUNqQyxFQUFFLENBQUMsb0NBQW9DLEVBQUU7Ozs7NEJBQ3RCLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRTs7d0JBQXpDLFFBQVEsR0FBRyxTQUE4Qjt3QkFDL0MsNENBQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLG9CQUFvQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ25FLDRDQUFNLENBQUMsT0FBTyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsb0JBQW9CLENBQUMsQ0FBQzt3QkFDckUsNENBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDN0MsNENBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7OzthQUM1QyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFSRixDQVFFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJpQztBQU10QyxTQUFTLFdBQVc7SUFLbEIsSUFBSSxjQUFjLENBQUM7SUFDbkIsSUFBSSxhQUFhLENBQUM7SUFFbEIsSUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQU8sVUFBQyxPQUFPLEVBQUUsTUFBTTtRQUNoRCxjQUFjLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLGFBQWEsR0FBRyxNQUFNLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLEVBQUUsT0FBTyxXQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ3JFLENBQUM7QUFFRCxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxrQkFBa0IsRUFBRTtRQUMzQixTQUFTLENBQUM7Ozs0QkFDUixxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7O3dCQUFoQyxTQUFnQyxDQUFDOzs7O2FBQ2xDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywyQ0FBMkMsRUFBRTs7Ozs7O3dCQUN4QyxPQUFPLEdBQUcsV0FBVyxFQUFFLENBQUM7d0JBQ2IscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFOzt3QkFBekMsUUFBUSxHQUFHLFNBQThCOzZCQUUzQyxTQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBbkIsd0JBQW1COzs7O3dCQUVuQixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7O3dCQUF0QyxTQUFzQyxDQUFDO3dCQUVoQixxQkFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7O3dCQUEvQyxjQUFjLEdBQUcsU0FBOEI7d0JBRXJELDRDQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO3dCQUVoQyxVQUFVLEdBQUcsVUFBQyxDQUFDOzRCQUNuQixPQUFPLElBQUksQ0FBQzt3QkFDZCxDQUFDLENBQUM7d0JBRUYsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsRUFBRSxVQUFDLEdBQUc7NEJBQ3pDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxhQUFhLEVBQUU7Z0NBQzdCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzs2QkFDbkI7aUNBQU07Z0NBQ0wsT0FBTyxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOzZCQUN0Qzt3QkFDSCxDQUFDLENBQUMsQ0FBQzt3QkFFSCxjQUFjLENBQUMsU0FBUyxDQUFDOzRCQUN2QixJQUFJLEVBQUUsYUFBYTs0QkFDbkIsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTt5QkFDdEIsQ0FBQyxDQUFDO3dCQUVILHFCQUFNLE9BQU8sQ0FBQyxPQUFPOzt3QkFBckIsU0FBcUIsQ0FBQzs7Ozt3QkFFdEIsNkNBQVcsQ0FBQywrQkFBK0IsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7d0JBR3BFLDZDQUFXLENBQUMsOEJBQThCLENBQUMsQ0FBQzs7Ozs7YUFFL0MsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBMUNGLENBMENFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFeUI7QUFDdUI7QUFLckQsaUVBQWU7SUFDYixlQUFRLENBQUMsMEJBQTBCLEVBQUU7O1FBQ25DLElBQUk7WUFDRixFQUFFLENBQUMsK0JBQStCLEVBQUU7OztnQ0FDbEMscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFOzs0QkFBaEMsU0FBZ0MsQ0FBQzs7OztpQkFDbEMsQ0FBQyxDQUFDO1NBQ0o7UUFBQyxPQUFPLEVBQUUsRUFBRTtZQUNYLDZDQUFXLENBQ1QscUJBQXFCO2dCQUNuQix5RUFBb0M7Z0JBQ3BDLFdBQVc7Z0JBQ1gsQ0FBQyxRQUFFLENBQUMsT0FBTyxtQ0FBSSxFQUFFLENBQUMsQ0FDckIsQ0FBQztTQUNIO0lBQ0gsQ0FBQyxDQUFDO0FBYkYsQ0FhRSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJtQztBQUNGO0FBQ2U7QUFJckQsSUFBTSxJQUFJLEdBQ1IscUJBQXFCO0lBQ3JCLDJFQUFzQztJQUN0QyxhQUFhLENBQUM7QUFFaEIsaUVBQWU7SUFDYixlQUFRLENBQUMsNEJBQTRCLEVBQUU7O1lBQ3JDLEVBQUUsQ0FBQywrRUFBK0UsRUFBRTs7Ozs7NEJBQzVFLE9BQU8sR0FBRztnQ0FDZCxJQUFJLEVBQUUseUJBQXlCOzZCQUNoQyxDQUFDOzs7OzRCQUdBLHFCQUFNLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUM7OzRCQUF6QyxTQUF5QyxDQUFDOzRCQUMxQyw2Q0FBVyxDQUFDLHVDQUF1QyxFQUFFLElBQUksQ0FBQyxDQUFDOzs7OzRCQUUzRCw0Q0FBTSxDQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSw4REFBd0IsRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7aUJBRTFFLENBQUMsQ0FBQzs7O1NBQ0osQ0FBQztBQWJGLENBYUUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QmlDO0FBQ0s7QUFDVTtBQUVSO0FBRzdDLElBQU0sYUFBYSxHQUNqQixxQkFBcUIsR0FBRyxrRUFBNkIsR0FBRyxZQUFZLENBQUM7QUFNdkUsaUVBQWU7SUFDYixlQUFRLENBQUMsZ0JBQWdCLEVBQUU7UUFDekIsSUFBSSxRQUFrQixDQUFDO1FBQ3ZCLElBQUksU0FBbUIsQ0FBQztRQUN4QixJQUFJLGlCQUEyQixDQUFDO1FBRWhDLEVBQUUsQ0FBQyw4QkFBOEIsRUFBRTs7OzRCQUNqQyxxQkFBTSxJQUFJLENBQUMsU0FBUyxDQUFDOzRCQUNuQixJQUFJLEVBQUUsaUJBQWlCOzRCQUN2QixFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO3lCQUN2QixDQUFDOzt3QkFIRixTQUdFLENBQUM7Ozs7YUFDSixDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsaUJBQWlCLEVBQUU7WUFDMUIsVUFBVSxDQUFDOzs7Z0NBQ1QscUJBQU0sb0JBQW9CLEVBQUU7OzRCQUE1QixTQUE0QixDQUFDOzRCQUM3QixxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7OzRCQUFoQyxTQUFnQyxDQUFDOzs7O2lCQUNsQyxDQUFDLENBQUM7WUFFSCxTQUFTLENBQUMsU0FBZSxTQUFTOzs7O29DQUNoQyxxQkFBTSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQzs7Z0NBQXBELFNBQW9ELENBQUM7Ozs7O2FBQ3RELENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLCtJQUErSSxDQUFDO1lBQ2xKLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyx3TEFBaUwsYUFBYSxDQUFFLENBQUM7NEJBRzdLLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFDRyxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUdqQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFVBQU8sT0FBTzs7d0NBQzNELDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO3dDQUNuRSxlQUFlLEdBQUcsSUFBSSxDQUFDOzs7cUNBQ3hCLENBQUM7OzRCQUpGLHNCQUFzQjs0QkFDdEIsUUFBUSxHQUFHLFNBR1QsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFakMscUJBQXFCOzRCQUNyQixxQkFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDOzs0QkFEcEIscUJBQXFCOzRCQUNyQixTQUFvQixDQUFDOzRCQUVmLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsa0JBQWtCO2dDQUMzQixRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2QywrQkFBK0I7NEJBQy9CLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQUMscUJBQXFCLEdBQUcsWUFBWSxDQUFDLENBQUM7NkJBQ25EOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLHVKQUF1SixDQUFDO1lBQzFKLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyx3TEFBaUwsYUFBYSxDQUFFLENBQUM7NEJBRzdLLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRCxxQkFBcUI7NEJBQ3JCLHFCQUFNLFdBQVcsQ0FBQyxDQUFDLENBQUM7OzRCQURwQixxQkFBcUI7NEJBQ3JCLFNBQW9CLENBQUM7NEJBRWpCLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBR2pCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBTyxPQUFPOzt3Q0FDM0QsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7d0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7OztxQ0FDeEIsQ0FBQzs7NEJBSkYsc0NBQXNDOzRCQUN0QyxRQUFRLEdBQUcsU0FHVCxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUUzQixtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLGtCQUFrQjtnQ0FDM0IsUUFBUSxDQUFDLDBCQUEwQjs2QkFDcEMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEVBQzFCLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRixpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsNkJBQTZCOzRCQUM3QixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUFDLGdDQUF5QixZQUFZLENBQUUsQ0FBQyxDQUFDOzZCQUN0RDs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYixrSkFBa0osQ0FBQztZQUNySixFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsc0xBQStLLGFBQWEsQ0FBRSxDQUFDOzRCQUczSyxtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixTQUFTOzRCQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBRUssbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxrQkFBa0I7Z0NBQzNCLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYscUJBQXFCOzRCQUNyQixxQkFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDOzs0QkFEcEIscUJBQXFCOzRCQUNyQixTQUFvQixDQUFDOzRCQUVqQixlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUdqQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFVBQU8sT0FBTzs7d0NBQzNELDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO3dDQUNuRSxlQUFlLEdBQUcsSUFBSSxDQUFDOzs7cUNBQ3hCLENBQUM7OzRCQUpGLHNDQUFzQzs0QkFDdEMsUUFBUSxHQUFHLFNBR1QsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFakMsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2Isd0tBQXdLLENBQUM7WUFDM0ssRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLDhMQUF1TCxhQUFhLENBQUUsQ0FBQzs0QkFHbkwsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVHLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBR2pCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FDdEMsaUJBQWlCLEVBQ2pCLFVBQUMsT0FBTztvQ0FDTiw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztvQ0FDbkUsZUFBZSxHQUFHLElBQUksQ0FBQztnQ0FDekIsQ0FBQyxDQUNGOzs0QkFQRCxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxTQU1WLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRWpDLHFCQUFxQjs0QkFDckIsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUVULG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsa0JBQWtCO2dDQUMzQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2Qyw2QkFBNkI7NEJBQzdCLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQUMsZ0NBQXlCLFlBQVksQ0FBRSxDQUFDLENBQUM7NkJBQ3REOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLGdMQUFnTCxDQUFDO1lBQ25MLEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyw4TEFBdUwsYUFBYSxDQUFFLENBQUM7NEJBR25MLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFFRCxxQkFBcUI7NEJBQ3JCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFFWCxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUdqQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQ3RDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87b0NBQ04sNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7b0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7Z0NBQ3pCLENBQUMsQ0FDRjs7NEJBUEQsc0JBQXNCOzRCQUN0QixRQUFRLEdBQUcsU0FNVixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUUzQixtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLGtCQUFrQjtnQ0FDM0IsUUFBUSxDQUFDLDBCQUEwQjtnQ0FDbkMsUUFBUSxDQUFDLHVCQUF1Qjs2QkFDakMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEVBQzFCLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRixpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsK0JBQStCOzRCQUMvQixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUFDLHFCQUFxQixHQUFHLFlBQVksQ0FBQyxDQUFDOzZCQUNuRDs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYixzTEFBc0wsQ0FBQztZQUN6TCxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsOExBQXVMLGFBQWEsQ0FBRSxDQUFDOzRCQUduTCxtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixTQUFTOzRCQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBRUssbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxrQkFBa0I7Z0NBQzNCLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRW5DLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBR2pCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FDdEMsaUJBQWlCLEVBQ2pCLFVBQUMsT0FBTztvQ0FDTiw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztvQ0FDbkUsZUFBZSxHQUFHLElBQUksQ0FBQztnQ0FDekIsQ0FBQyxDQUNGOzs0QkFQRCxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxTQU1WLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRWpDLHFCQUFxQjs0QkFDckIsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUVmLCtCQUErQjs0QkFDL0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxxQkFBcUIsR0FBRyxZQUFZLENBQUMsQ0FBQzs2QkFDbkQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IsK0xBQStMLENBQUM7WUFDbE0sRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLDhMQUF1TCxhQUFhLENBQUUsQ0FBQzs0QkFHbkwsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVLLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsa0JBQWtCO2dDQUMzQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTO2dDQUNqQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2QyxxQkFBcUI7NEJBQ3JCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFFWCxlQUFlLEdBQUcsS0FBSyxDQUFDOzRCQUdqQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQ3RDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87b0NBQ04sNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7b0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7Z0NBQ3pCLENBQUMsQ0FDRjs7NEJBUEQsc0JBQXNCOzRCQUN0QixRQUFRLEdBQUcsU0FNVixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUVqQyw2QkFBNkI7NEJBQzdCLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQUMsZ0NBQXlCLFlBQVksQ0FBRSxDQUFDLENBQUM7NkJBQ3REOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLHlIQUF5SCxDQUFDO1lBQzVILEVBQUUsQ0FBQyxTQUFTLEVBQUU7Z0JBYVosU0FBUywyQkFBMkI7b0JBQ2xDLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7d0JBQzdCLElBQ0UsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQzs0QkFDdEMsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEVBQ3pDOzRCQUNBLDZDQUFXLENBQUMsNEJBQTRCLEVBQUUsWUFBWSxDQUFDLENBQUM7eUJBQ3pEOzZCQUFNOzRCQUNMLGVBQWUsR0FBRyxJQUFJLENBQUM7eUJBQ3hCO3FCQUNGO2dCQUNILENBQUM7Ozs7OzRCQXZCSyxZQUFZLEdBQUcsa01BQTJMLGFBQWEsQ0FBRSxDQUFDOzRCQUd2TCxtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixTQUFTOzRCQUNULHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBQ0csWUFBWSxHQUFhLEVBQUUsQ0FBQzs0QkFFNUIsZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFnQmpCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FDdEMsaUJBQWlCLEVBQ2pCLFVBQUMsT0FBTztvQ0FDTixZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQztnQ0FDaEMsQ0FBQyxDQUNGOzs0QkFQRCxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxTQU1WLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBR3JCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLEVBQUUsVUFBQyxPQUFPO29DQUNoRSxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQ0FDaEMsMkJBQTJCLEVBQUUsQ0FBQztnQ0FDaEMsQ0FBQyxDQUFDOzs0QkFKRixzQ0FBc0M7NEJBQ3RDLFNBQVMsR0FBRyxTQUdWLENBQUM7NEJBRUgsc0JBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBRWxDLHFCQUFxQjs0QkFDckIscUJBQU0sV0FBVyxDQUFDLENBQUMsQ0FBQzs7NEJBRHBCLHFCQUFxQjs0QkFDckIsU0FBb0IsQ0FBQzs0QkFFZixtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLGtCQUFrQjtnQ0FDM0IsUUFBUSxDQUFDLDBCQUEwQjtnQ0FDbkMsUUFBUSxDQUFDLHVCQUF1Qjs2QkFDakMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsU0FBUztnQ0FDakIsc0JBQXNCLEVBQUUsSUFBSTs2QkFDN0IsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEVBQzFCLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFFRixpQ0FBaUM7NEJBQ2pDLHFCQUFNLGdDQUFnQzs7NEJBRHRDLGlDQUFpQzs0QkFDakMsU0FBc0MsQ0FBQzs0QkFFdkMsK0JBQStCOzRCQUMvQixJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQiw2Q0FBVyxDQUFDLFVBQUcsWUFBWSwyQ0FBd0MsQ0FBQyxDQUFDOzZCQUN0RTs7OztpQkFDRixDQUFDLENBQUM7WUFFSCxJQUFNLFNBQVMsR0FDYiw4SEFBOEgsQ0FBQztZQUNqSSxFQUFFLENBQUMsU0FBUyxFQUFFOzs7Ozs0QkFDTixZQUFZLEdBQUcsa01BQTJMLGFBQWEsQ0FBRSxDQUFDOzRCQUlyTixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQ3RDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87b0NBQ04sWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29DQUN0Qiw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7Z0NBQ2xFLENBQUMsQ0FDRjs7NEJBUEQsc0NBQXNDOzRCQUN0QyxRQUFRLEdBQUcsU0FNVixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUdyQixxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxFQUFFLFVBQUMsT0FBTztvQ0FDaEUsNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDO2dDQUNsRSxDQUFDLENBQUM7OzRCQUhGLG1DQUFtQzs0QkFDbkMsU0FBUyxHQUFHLFNBRVYsQ0FBQzs0QkFFSCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQzs0QkFFbEMsNkJBQTZCOzRCQUM3QixxQkFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDOzs0QkFEcEIsNkJBQTZCOzRCQUM3QixTQUFvQixDQUFDOzRCQUVmLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsa0JBQWtCO2dDQUMzQixRQUFRLENBQUMsMEJBQTBCO2dDQUNuQyxRQUFRLENBQUMsdUJBQXVCOzZCQUNqQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxTQUFTOzZCQUNsQixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUdJLEtBQWlELDZDQUFLLEVBQUUsRUFBN0MsWUFBWSxlQUFXLFVBQVUsY0FBYTs0QkFDL0QsT0FBTyxHQUFHLFVBQVUsQ0FBQzs7OztpQkFDdEIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFNLFVBQVUsR0FDZCw2SUFBNkksQ0FBQztRQUNoSixFQUFFLENBQUMsVUFBVSxFQUFFOzs7Ozt3QkFDUCxZQUFZLEdBQUcsMk9BQW9PLGFBQWEsQ0FBRSxDQUFDO3dCQUdoTyxtQkFBYzs4QkFDckQsbUJBQW1COzRCQUNuQixVQUFVO3dCQUNWLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O3dCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7d0JBR1UscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLFVBQUMsT0FBTztnQ0FDbEUsNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDOzRCQUNsRSxDQUFDLENBQUM7O3dCQUhGLHNDQUFzQzt3QkFDdEMsUUFBUSxHQUFHLFNBRVQsQ0FBQzt3QkFFSCxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFFakMscUJBQXFCO3dCQUNyQixxQkFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDOzt3QkFEcEIscUJBQXFCO3dCQUNyQixTQUFvQixDQUFDOzZCQUdqQixTQUFRLEtBQUssU0FBUyxHQUF0Qix3QkFBc0I7d0JBQ3hCLHFCQUFNLFFBQVEsQ0FBQyxXQUFXLEVBQUU7O3dCQUE1QixTQUE0QixDQUFDO3dCQUM3QixRQUFRLEdBQUcsU0FBUyxDQUFDOzs7d0JBRXJCLDZDQUFXLENBQUMsb0JBQW9CLEVBQUUsWUFBWSxDQUFDLENBQUM7Ozt3QkFHNUMsbUJBQW1CLEdBQUc7NEJBQzFCLFFBQVEsQ0FBQyxrQkFBa0I7NEJBQzNCLFFBQVEsQ0FBQywwQkFBMEI7eUJBQ3BDLENBQUM7d0JBRUksaUJBQWlCLEdBQXNCOzRCQUMzQyxjQUFjLEVBQUUsS0FBSzs0QkFDckIsTUFBTSxFQUFFLFVBQVU7NEJBQ2xCLHNCQUFzQixFQUFFLElBQUk7eUJBQzdCLENBQUM7d0JBRUYsaURBQWlEO3dCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7d0JBSkQsaURBQWlEO3dCQUNqRCxTQUdDLENBQUM7d0JBRUYsaUNBQWlDO3dCQUNqQyxxQkFBTSxnQ0FBZ0M7O3dCQUR0QyxpQ0FBaUM7d0JBQ2pDLFNBQXNDLENBQUM7Ozs7YUFDeEMsQ0FBQyxDQUFDO1FBRUgsSUFBTSxVQUFVLEdBQ2QseUtBQXlLLENBQUM7UUFDNUssRUFBRSxDQUFDLFVBQVUsRUFBRTs7Ozs7d0JBQ1AsWUFBWSxHQUFHLGlPQUEwTixhQUFhLENBQUUsQ0FBQzt3QkFJcFAscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUN0QyxpQkFBaUIsRUFDakIsVUFBTyxPQUFPOztvQ0FDWiw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7OztpQ0FDakUsQ0FDRjs7d0JBTkQsc0NBQXNDO3dCQUN0QyxRQUFRLEdBQUcsU0FLVixDQUFDO3dCQUVGLG9EQUFvRDt3QkFDcEQscUJBQU0sV0FBVyxDQUFDLENBQUMsQ0FBQzs7d0JBRHBCLG9EQUFvRDt3QkFDcEQsU0FBb0IsQ0FBQzt3QkFDckIscUJBQU0sV0FBVyxDQUFDLENBQUMsQ0FBQzs7d0JBQXBCLFNBQW9CLENBQUM7d0JBRWYsbUJBQW1CLEdBQUc7NEJBQzFCLFFBQVEsQ0FBQyxrQkFBa0I7NEJBQzNCLFFBQVEsQ0FBQywwQkFBMEI7eUJBQ3BDLENBQUM7d0JBRUksaUJBQWlCLEdBQXNCOzRCQUMzQyxjQUFjLEVBQUUsS0FBSzs0QkFDckIsTUFBTSxFQUFFLFVBQVU7eUJBQ25CLENBQUM7d0JBRUYsaURBQWlEO3dCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7d0JBSkQsaURBQWlEO3dCQUNqRCxTQUdDLENBQUM7d0JBR0ksS0FBaUQsNkNBQUssRUFBRSxFQUE3QyxZQUFZLGVBQVcsVUFBVSxjQUFhO3dCQUMvRCxPQUFPLEdBQUcsVUFBVSxDQUFDO3dCQUNyQixxQkFBTSxZQUFZOzt3QkFBbEIsU0FBa0IsQ0FBQzs7OzthQUNwQixDQUFDLENBQUM7UUFFSCxJQUFNLFVBQVUsR0FDZCw0SkFBNEosQ0FBQztRQUMvSixFQUFFLENBQUMsVUFBVSxFQUFFOzs7Ozt3QkFDUCxZQUFZLEdBQUcsa09BQTJOLGFBQWEsQ0FBRSxDQUFDO3dCQUdyUCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQWlCLEVBQUUsVUFBQyxPQUFPO2dDQUNsRSw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7NEJBQ2xFLENBQUMsQ0FBQzs7d0JBSEYsa0NBQWtDO3dCQUNsQyxRQUFRLEdBQUcsU0FFVCxDQUFDO3dCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUVqQyxxQkFBcUI7d0JBQ3JCLHFCQUFNLFdBQVcsQ0FBQyxDQUFDLENBQUM7O3dCQURwQixxQkFBcUI7d0JBQ3JCLFNBQW9CLENBQUM7d0JBRXJCLHdCQUF3Qjt3QkFDeEIscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFOzt3QkFEaEMsd0JBQXdCO3dCQUN4QixTQUFnQyxDQUFDO3dCQUUzQixtQkFBbUIsR0FBRzs0QkFDMUIsUUFBUSxDQUFDLGtCQUFrQjs0QkFDM0IsUUFBUSxDQUFDLDBCQUEwQjt5QkFDcEMsQ0FBQzt3QkFFSSxpQkFBaUIsR0FBc0I7NEJBQzNDLGNBQWMsRUFBRSxLQUFLOzRCQUNyQixNQUFNLEVBQUUsVUFBVTs0QkFDbEIsc0JBQXNCLEVBQUUsSUFBSTt5QkFDN0IsQ0FBQzt3QkFFRixpREFBaUQ7d0JBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEVBQzFCLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzt3QkFKRCxpREFBaUQ7d0JBQ2pELFNBR0MsQ0FBQzt3QkFHSSxLQUFpRCw2Q0FBSyxFQUFFLEVBQTdDLFlBQVksZUFBVyxVQUFVLGNBQWE7d0JBQy9ELE9BQU8sR0FBRyxVQUFVLENBQUM7d0JBQ3JCLHFCQUFNLFlBQVk7O3dCQUFsQixTQUFrQixDQUFDOzs7O2FBQ3BCLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxjQUFjLEVBQUU7WUFDdkIsVUFBVSxDQUFDOzs7Z0NBQ1QscUJBQU0sb0JBQW9CLEVBQUU7OzRCQUE1QixTQUE0QixDQUFDOzRCQUM3QixxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7OzRCQUFoQyxTQUFnQyxDQUFDOzs7O2lCQUNsQyxDQUFDLENBQUM7WUFFSCxTQUFTLENBQUMsU0FBZSxTQUFTOzs7O29DQUNoQyxxQkFBTSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQzs7Z0NBQXBELFNBQW9ELENBQUM7Ozs7O2FBQ3RELENBQUMsQ0FBQztZQUVILElBQU0sUUFBUSxHQUNaLGdIQUFnSCxDQUFDO1lBQ25ILEVBQUUsQ0FBQyxRQUFRLEVBQUU7Ozs7OzRCQUNMLFlBQVksR0FBRywrTkFBd04sYUFBYSxDQUFFLENBQUM7NEJBR3BOLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFFBQVE7NEJBQ1IscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFHbUIscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFDN0QsZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFHakIscUJBQU0sV0FBVyxDQUFDLGtCQUFrQixDQUM3QyxJQUFJLEVBQ0osVUFBTyxPQUFPOzt3Q0FDWiw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQzt3Q0FDbkUsZUFBZSxHQUFHLElBQUksQ0FBQzs7O3FDQUN4QixDQUNGOzs0QkFQRCxzQkFBc0I7NEJBQ3RCLFFBQVEsR0FBRyxTQU1WLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBRTNCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxRQUFRO2dDQUNoQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUV2Qyw2QkFBNkI7NEJBQzdCLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLDZDQUFXLENBQ1Qsa0RBQTJDLFlBQVksQ0FBRSxDQUMxRCxDQUFDOzZCQUNIOzs7O2lCQUNGLENBQUMsQ0FBQztZQUVILElBQU0sU0FBUyxHQUNiLDJIQUEySCxDQUFDO1lBQzlILEVBQUUsQ0FBQyxTQUFTLEVBQUU7Ozs7OzRCQUNOLFlBQVksR0FBRyxzTEFBK0ssYUFBYSxDQUFFLENBQUM7NEJBRzNLLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFNBQVM7NEJBQ1QscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFHbUIscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFFM0QsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUUsZUFBZSxHQUFHLEtBQUssQ0FBQzs0QkFFNUIsdUNBQXVDOzRCQUN2QyxxQkFBTSxXQUFXLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBTyxPQUFPOzt3Q0FDdkQsNENBQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7d0NBQ25FLGVBQWUsR0FBRyxJQUFJLENBQUM7OztxQ0FDeEIsQ0FBQzs7NEJBSkYsdUNBQXVDOzRCQUN2QyxTQUdFLENBQUM7NEJBRUgsMkNBQTJDOzRCQUMzQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QywyQ0FBMkM7NEJBQzNDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IsK0hBQStILENBQUM7WUFDbEksRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLHdQQUFpUCxhQUFhLENBQUUsQ0FBQzs0QkFHN08sbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUVHLGVBQWUsR0FBRyxLQUFLLENBQUM7NEJBR1IscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFHdEQscUJBQU0sV0FBVyxDQUFDLGtCQUFrQixDQUM3QyxpQkFBaUIsRUFDakIsVUFBQyxPQUFPO29DQUNOLDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO29DQUNuRSxlQUFlLEdBQUcsSUFBSSxDQUFDO2dDQUN6QixDQUFDLENBQ0Y7OzRCQVBELHNCQUFzQjs0QkFDdEIsUUFBUSxHQUFHLFNBTVYsQ0FBQzs0QkFFRixzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFM0IsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7NEJBRXZDLDZCQUE2Qjs0QkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtnQ0FDcEIsNkNBQVcsQ0FBQyxnQ0FBeUIsWUFBWSxDQUFFLENBQUMsQ0FBQzs2QkFDdEQ7Ozs7aUJBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2IsMEdBQTBHLENBQUM7WUFDN0csRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLHFPQUE4TixhQUFhLENBQUUsQ0FBQzs0QkFHL08scUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUMvQywwQkFBMEIsQ0FDM0I7OzRCQUZLLFdBQVcsR0FBRyxTQUVuQjs0QkFHVSxxQkFBTSxXQUFXLENBQUMsa0JBQWtCLENBQzdDLGlCQUFpQixFQUNqQixVQUFDLE9BQU87b0NBQ04sNkNBQVcsQ0FBQyxVQUFHLFlBQVksY0FBSSxPQUFPLENBQUMsSUFBSSxzQkFBbUIsQ0FBQyxDQUFDO2dDQUNsRSxDQUFDLENBQ0Y7OzRCQU5ELHNCQUFzQjs0QkFDdEIsUUFBUSxHQUFHLFNBS1YsQ0FBQzs0QkFFRixzQkFBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFFM0IsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7NkJBQ3BDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7NkJBQ2xCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBR0ksS0FBaUQsNkNBQUssRUFBRSxFQUE3QyxZQUFZLGVBQVcsVUFBVSxjQUFhOzRCQUMvRCxPQUFPLEdBQUcsVUFBVSxDQUFDOzRCQUNyQixxQkFBTSxZQUFZOzs0QkFBbEIsU0FBa0IsQ0FBQzs7OztpQkFDcEIsQ0FBQyxDQUFDO1lBRUgsSUFBTSxTQUFTLEdBQ2Isc0hBQXNILENBQUM7WUFDekgsRUFBRSxDQUFDLFNBQVMsRUFBRTs7Ozs7NEJBQ04sWUFBWSxHQUFHLGdSQUF5USxhQUFhLENBQUUsQ0FBQzs0QkFHMVIscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFHeEIsbUJBQWM7a0NBQ3JELG1CQUFtQjtnQ0FDbkIsU0FBUzs0QkFDVCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFIeEMsZ0NBQWdDLEdBQUcsNEJBR3ZDLFNBQTRDLEdBQzdDOzRCQUdVLHFCQUFNLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBQyxPQUFPO29DQUM1RCw2Q0FBVyxDQUFDLFVBQUcsWUFBWSxjQUFJLE9BQU8sQ0FBQyxJQUFJLHNCQUFtQixDQUFDLENBQUM7Z0NBQ2xFLENBQUMsQ0FBQzs7NEJBSEYsc0JBQXNCOzRCQUN0QixRQUFRLEdBQUcsU0FFVCxDQUFDOzRCQUVILHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUVqQyw4QkFBOEI7NEJBQzlCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs0QkFFakIsbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBRUksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFNBQVM7Z0NBQ2pCLHNCQUFzQixFQUFFLElBQUk7NkJBQzdCLENBQUM7NEJBRUYsaURBQWlEOzRCQUNqRCxxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUNiLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxFQUMxQix1QkFBdUIsQ0FBQyxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUNoRTs7NEJBSkQsaURBQWlEOzRCQUNqRCxTQUdDLENBQUM7NEJBRUYsaUNBQWlDOzRCQUNqQyxxQkFBTSxnQ0FBZ0M7OzRCQUR0QyxpQ0FBaUM7NEJBQ2pDLFNBQXNDLENBQUM7Ozs7aUJBQ3hDLENBQUMsQ0FBQztZQUVILElBQU0sVUFBVSxHQUNkLDhLQUE4SyxDQUFDO1lBQ2pMLEVBQUUsQ0FBQyxVQUFVLEVBQUU7Ozs7OzRCQUNQLFlBQVksR0FBRywrUkFBd1IsYUFBYSxDQUFFLENBQUM7NEJBR3BSLG1CQUFjO2tDQUNyRCxtQkFBbUI7Z0NBQ25CLFVBQVU7NEJBQ1YscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7NEJBSHhDLGdDQUFnQyxHQUFHLDRCQUd2QyxTQUE0QyxHQUM3Qzs0QkFHaUIscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTNELFdBQVcsR0FBRyxTQUE2Qzs0QkFFcEQscUJBQU0sV0FBVyxDQUFDLGtCQUFrQixDQUM3QyxpQkFBaUIsRUFDakIsVUFBQyxPQUFPO29DQUNOLDZDQUFXLENBQUMsVUFBRyxZQUFZLGNBQUksT0FBTyxDQUFDLElBQUksc0JBQW1CLENBQUMsQ0FBQztnQ0FDbEUsQ0FBQyxDQUNGOzs0QkFMRCxRQUFRLEdBQUcsU0FLVixDQUFDOzRCQUVGLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUdkLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FDOUMsMEJBQTBCLENBQzNCOzs0QkFGRyxZQUFZLEdBQUcsU0FFbEI7NEJBR1cscUJBQU0sWUFBWSxDQUFDLGtCQUFrQixDQUMvQyxpQkFBaUIsRUFDakIsVUFBQyxPQUFPO29DQUNOLDZDQUFXLENBQUMsVUFBRyxZQUFZLGNBQUksT0FBTyxDQUFDLElBQUksc0JBQW1CLENBQUMsQ0FBQztnQ0FDbEUsQ0FBQyxDQUNGOzs0QkFORCxzQkFBc0I7NEJBQ3RCLFNBQVMsR0FBRyxTQUtYLENBQUM7NEJBRUYsc0JBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7NEJBRTVCLG1CQUFtQixHQUFHO2dDQUMxQixRQUFRLENBQUMsc0JBQXNCO2dDQUMvQixRQUFRLENBQUMsMEJBQTBCOzZCQUNwQyxDQUFDOzRCQUVJLGlCQUFpQixHQUFzQjtnQ0FDM0MsY0FBYyxFQUFFLEtBQUs7Z0NBQ3JCLE1BQU0sRUFBRSxVQUFVO2dDQUNsQixzQkFBc0IsRUFBRSxJQUFJOzZCQUM3QixDQUFDOzRCQUVGLGlEQUFpRDs0QkFDakQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsRUFDMUIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGlEQUFpRDs0QkFDakQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzs7O2lCQUN4QyxDQUFDLENBQUM7WUFFSCxJQUFNLFVBQVUsR0FDZCwySkFBMkosQ0FBQztZQUM5SixFQUFFLENBQUMsVUFBVSxFQUFFOzs7Ozs0QkFDUCxZQUFZLEdBQUcsbVFBQTRQLGFBQWEsQ0FBRSxDQUFDOzRCQUc3USxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDOzs0QkFBM0QsV0FBVyxHQUFHLFNBQTZDOzRCQUUzRCxtQkFBbUIsR0FBRztnQ0FDMUIsUUFBUSxDQUFDLHNCQUFzQjtnQ0FDL0IsUUFBUSxDQUFDLDBCQUEwQjtnQ0FDbkMsUUFBUSxDQUFDLHVCQUF1Qjs2QkFDakMsQ0FBQzs0QkFFSSxpQkFBaUIsR0FBc0I7Z0NBQzNDLGNBQWMsRUFBRSxLQUFLO2dDQUNyQixNQUFNLEVBQUUsVUFBVTs2QkFDbkIsQ0FBQzs0QkFFRixpREFBaUQ7NEJBQ2pELHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQ2IsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLEVBQ3hCLHVCQUF1QixDQUFDLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQ2hFOzs0QkFKRCxpREFBaUQ7NEJBQ2pELFNBR0MsQ0FBQzs0QkFHYyxxQkFBTSxXQUFXLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7OzRCQUFoRSxPQUFPLEdBQUcsU0FBc0Q7NEJBQ3RFLDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUUzQyxxQkFBTSxXQUFXLENBQUMsaUJBQWlCLENBQ3hELGNBQWMsQ0FDZjs7NEJBRkssY0FBYyxHQUFHLFNBRXRCOzRCQUNELDRDQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUN0QyxnQkFBZ0IsRUFDaEIsWUFBWSxDQUNiLENBQUM7NEJBRW9CLHFCQUFNLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRTs7NEJBQXJELGFBQWEsR0FBRyxTQUFxQzs0QkFDM0QsNENBQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDOzs7O2lCQUN2RSxDQUFDLENBQUM7WUFFSCxJQUFNLFVBQVUsR0FDZCwyTEFBMkwsQ0FBQztZQUM5TCxFQUFFLENBQUMsVUFBVSxFQUFFOzs7Ozs0QkFDUCxZQUFZLEdBQUcsOE9BQXVPLGFBQWEsQ0FBRSxDQUFDOzRCQUd4UCxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDOzs0QkFBM0QsV0FBVyxHQUFHLFNBQTZDOzRCQUd4QixtQkFBYztrQ0FDckQsbUJBQW1CO2dDQUNuQixVQUFVOzRCQUNWLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7OzRCQUh4QyxnQ0FBZ0MsR0FBRyw0QkFHdkMsU0FBNEMsR0FDN0M7NEJBRUssbUJBQW1CLEdBQUc7Z0NBQzFCLFFBQVEsQ0FBQyxzQkFBc0I7Z0NBQy9CLFFBQVEsQ0FBQywwQkFBMEI7Z0NBQ25DLFFBQVEsQ0FBQyx1QkFBdUI7NkJBQ2pDLENBQUM7NEJBQ0ksaUJBQWlCLEdBQXNCO2dDQUMzQyxjQUFjLEVBQUUsS0FBSztnQ0FDckIsTUFBTSxFQUFFLFVBQVU7Z0NBQ2xCLHNCQUFzQixFQUFFLElBQUk7Z0NBQzVCLFlBQVksRUFBRSxDQUFDOzZCQUNoQixDQUFDOzRCQUVGLGdEQUFnRDs0QkFDaEQscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDYixFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsRUFDeEIsdUJBQXVCLENBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLENBQUMsQ0FDaEU7OzRCQUpELGdEQUFnRDs0QkFDaEQsU0FHQyxDQUFDOzRCQUVGLGlDQUFpQzs0QkFDakMscUJBQU0sZ0NBQWdDOzs0QkFEdEMsaUNBQWlDOzRCQUNqQyxTQUFzQyxDQUFDOzRCQUd2QixxQkFBTSxXQUFXLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7OzRCQUFoRSxPQUFPLEdBQUcsU0FBc0Q7NEJBQ3RFLDRDQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUNuRSw0Q0FBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs0QkFFakQscUJBQU0sV0FBVyxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQzs7NEJBQTlELFFBQVEsR0FBRyxTQUFtRDs0QkFDcEUsNENBQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUNqRSw0Q0FBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLENBQUMsQ0FBQzs0QkFFN0MscUJBQU0sV0FBVyxDQUFDLGlCQUFpQixFQUFFOzs0QkFBckQsYUFBYSxHQUFHLFNBQXFDOzRCQUMzRCw0Q0FBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUM7NEJBQ3RFLDRDQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDOzs7O2lCQUN6RSxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQU0sV0FBVyxHQUFHLFVBQU8sT0FBZTs7Ozs0QkFDdkIscUJBQU0sSUFBSSxDQUFDLGVBQWUsRUFBRTs7d0JBQXZDLFFBQVEsR0FBRyxTQUE0Qjs2QkFDekMsU0FBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQW5CLHdCQUFtQjt3QkFDckIscUJBQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7d0JBQXBELFNBQW9ELENBQUM7Ozt3QkFFckQsNkNBQVcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDOzs7OzthQUV6RCxDQUFDO1FBRUYsU0FBUyxzQkFBc0IsQ0FBQyxjQUFjO1lBQzVDLCtDQUFhLENBQ1gsT0FBTyxjQUFjLEtBQUssUUFBUSxFQUNsQywwQkFBMEIsQ0FDM0IsQ0FBQztZQUNGLDRDQUFNLENBQUMsT0FBTyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQ3BELFVBQVUsRUFDVixpREFBaUQsQ0FDbEQsQ0FBQztRQUNKLENBQUM7UUFFRCxTQUFlLHNCQUFzQixDQUFDLE1BQWM7Ozs7O2dDQUV4QixxQkFBTSw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7OzRCQUFoRSxpQkFBaUIsR0FBRyxTQUE0Qzs0QkFFdEUsaUNBQWlDOzRCQUNqQyxxQkFBTSxjQUFjLENBQUMsY0FBYyxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQzs7NEJBRC9ELGlDQUFpQzs0QkFDakMsU0FBK0QsQ0FBQzs0QkFDaEUscUJBQU0sNENBQUksQ0FBQyxzRUFBNkIsQ0FBQzs7NEJBQXpDLFNBQXlDLENBQUM7Ozs7O1NBQzNDO1FBRUQsSUFBTSw4QkFBOEIsR0FBRyxVQUFPLE1BQWM7Ozs7NEJBQ2hDLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O3dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0Qzt3QkFFaEUsWUFBWSxHQUFzQjs0QkFDdEMsSUFBSSxFQUFFLGFBQWE7NEJBQ25CLE1BQU0sRUFBRSxNQUFNO3lCQUNmLENBQUM7d0JBQ0YscUJBQU0saUJBQWlCLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQzs7d0JBQS9DLFNBQStDLENBQUM7d0JBQ2hELHNCQUFPLGlCQUFpQixFQUFDOzs7YUFDMUIsQ0FBQztRQUVGLFNBQWUsb0JBQW9COzs7OztpQ0FDN0IsU0FBUSxLQUFLLFNBQVMsR0FBdEIsd0JBQXNCOzRCQUN4QixxQkFBTSxRQUFRLENBQUMsV0FBVyxFQUFFOzs0QkFBNUIsU0FBNEIsQ0FBQzs0QkFDN0IsUUFBUSxHQUFHLFNBQVMsQ0FBQzs7O2lDQUduQixVQUFTLEtBQUssU0FBUyxHQUF2Qix3QkFBdUI7NEJBQ3pCLHFCQUFNLFNBQVMsQ0FBQyxXQUFXLEVBQUU7OzRCQUE3QixTQUE2QixDQUFDOzRCQUM5QixTQUFTLEdBQUcsU0FBUyxDQUFDOzs7aUNBR3BCLGtCQUFpQixJQUFJLFNBQVMsR0FBOUIsd0JBQThCOzRCQUNoQyxxQkFBTSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUU7OzRCQUFyQyxTQUFxQyxDQUFDOzRCQUN0QyxpQkFBaUIsR0FBRyxTQUFTLENBQUM7Ozs7OztTQUVqQztRQUVELElBQU0sY0FBYyxHQUFHLFVBQ3JCLFdBQW1CLEVBQ25CLE1BQWMsRUFDZCxPQUFpQjtZQUVqQixJQUFJLGlCQUEyQixDQUFDO1lBQ2hDLE9BQU8sSUFBSSxPQUFPLENBQVUsVUFBTyxPQUFPOzs7Ozs0QkFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dDQUNSLCtCQUF1QixXQUFXLCtCQUFtQixPQUFPLENBQUMsRUFBRSwyQkFBZSxNQUFNLE9BQUcsQ0FDMUYsQ0FBQzs0QkFFSSxPQUFPLEdBQUcsVUFBQyxPQUEwQjtnQ0FDekMsSUFBSSxNQUFNLEVBQUU7b0NBQ1YsSUFBSSxNQUFNLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTt3Q0FDNUIsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsb0JBQWEsV0FBVyx3QkFBYyxNQUFNLENBQUUsQ0FDNUQsQ0FBQzt3Q0FDRixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7d0NBQ2pCLElBQUksaUJBQWlCOzRDQUFFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO3FDQUN4RDt5Q0FBTTt3Q0FDTCxPQUFPLENBQUMsSUFBSSxDQUNWLElBQUksQ0FBQyxHQUFHLEVBQUU7NENBQ1Isc0JBQWMsV0FBVyw4REFBa0QsTUFBTSx1QkFBVyxPQUFPLENBQUMsTUFBTSxRQUFJLENBQ2pILENBQUM7cUNBQ0g7aUNBQ0Y7cUNBQU07b0NBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO3dDQUNSLHVDQUErQixXQUFXLDRCQUFnQixNQUFNLE9BQUcsQ0FDdEUsQ0FBQztvQ0FDRixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7b0NBQ2pCLElBQUksaUJBQWlCO3dDQUFFLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO2lDQUN4RDs0QkFDSCxDQUFDLENBQUM7aUNBRUUsUUFBTyxLQUFLLFNBQVMsR0FBckIsd0JBQXFCOzRCQUNILHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FDL0MsV0FBVyxFQUNYLE9BQU8sQ0FDUjs7NEJBSEQsaUJBQWlCLEdBQUcsU0FHbkIsQ0FBQzs7Z0NBRWtCLHFCQUFNLE9BQU8sQ0FBQyxrQkFBa0IsQ0FDbEQsV0FBVyxFQUNYLE9BQU8sQ0FDUjs7NEJBSEQsaUJBQWlCLEdBQUcsU0FHbkIsQ0FBQzs0QkFFSSxTQUFTLEdBQUcsVUFBTyxPQUEwQjs7b0NBQ2pELElBQUksT0FBTyxFQUFFO3dDQUNYLElBQUksTUFBTSxFQUFFOzRDQUNWLElBQUksTUFBTSxLQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNLEtBQUksUUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksS0FBSSxXQUFXLEVBQUU7Z0RBQzdELE9BQU8sQ0FBQyxHQUFHLENBQ1QsSUFBSSxDQUFDLEdBQUcsRUFBRTtvREFDUixzQkFBYyxXQUFXLG1EQUF1QyxNQUFNLE9BQUcsQ0FDNUUsQ0FBQztnREFDRixJQUFJLGlCQUFpQjtvREFBRSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnREFDdkQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzZDQUNsQixDQUFDLG9FQUFvRTtpREFDakU7Z0RBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO29EQUNSLGtEQUEwQyxXQUFXLDRCQUFnQixNQUFNLG9DQUN6RSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSx5Q0FFMUIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0saUJBQ1YsTUFBTSxLQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxNQUFNO3dEQUN2QixDQUFDLENBQUMsV0FBVzt3REFDYixDQUFDLENBQUMsZUFBZSxnQ0FFM0IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksaUJBQ0wsUUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLElBQUksS0FBSSxXQUFXO3dEQUMxQixDQUFDLENBQUMsV0FBVzt3REFDYixDQUFDLENBQUMsZUFBZSxNQUNsQixDQUNOLENBQUM7NkNBQ0g7eUNBQ0Y7NkNBQU07NENBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCxJQUFJLENBQUMsR0FBRyxFQUFFO2dEQUNSLHNCQUFjLFdBQVcsc0RBQWtELENBQzlFLENBQUM7NENBQ0YsSUFBSSxpQkFBaUI7Z0RBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7NENBQ3ZELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzt5Q0FDbEI7cUNBQ0Y7OztpQ0FDRixDQUFDOzRCQUNGLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7aUJBRS9DLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztBQTFyQ0YsQ0EwckNFLEVBQUM7QUFtQkwsU0FBUyx1QkFBdUIsQ0FDOUIsZUFBeUIsRUFDekIsTUFBeUI7O0lBRXpCLE9BQU87UUFDTCxJQUFJLEVBQUUsb0JBQW9CO1FBQzFCLFFBQVEsRUFBRSxlQUFlO1FBQ3pCLE1BQU0sRUFBRTtZQUNOLGNBQWMsRUFBRSxNQUFNLENBQUMsY0FBYztZQUNyQyxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU07WUFDckIsc0JBQXNCLEVBQUUsWUFBTSxDQUFDLHNCQUFzQixtQ0FBSSxLQUFLO1lBQzlELFlBQVksRUFBRSxZQUFNLENBQUMsWUFBWSxtQ0FBSSxDQUFDO1NBQ3ZDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCxJQUFNLFFBQVEsR0FBRztJQUNmLGtCQUFrQixFQUFFLG9CQUFvQjtJQUN4QyxzQkFBc0IsRUFBRSx3QkFBd0I7SUFDaEQsMEJBQTBCLEVBQUUsNEJBQTRCO0lBQ3hELHVCQUF1QixFQUFFLHlCQUF5QjtDQUNuRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsdkNvQztBQUNlO0FBR1Y7QUFDZTtBQUcxRCxJQUFNLGlCQUFpQixHQUNyQixxQkFBcUIsR0FBRyxtRUFBOEIsR0FBRyxXQUFXLENBQUM7QUFFdkUsaUVBQWU7SUFDYixlQUFRLENBQUMsb0JBQW9CLEVBQUU7UUFDN0IsU0FBUyxDQUFDOzs7NEJBQ1IscUJBQU0sb0JBQW9CLEVBQUU7O3dCQUE1QixTQUE0QixDQUFDO3dCQUM3QixxQkFBTSxxQkFBcUIsRUFBRTs7d0JBQTdCLFNBQTZCLENBQUM7Ozs7YUFDL0IsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9DQUFvQyxFQUFFOzs7Ozs7O3dCQUdmLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQUM7Z0NBQ3BDLEtBQUssRUFBRSxlQUFlOzZCQUN2QixDQUFDOzt3QkFGSSxrQkFBZ0IsU0FFcEI7d0JBR21CLHFCQUFNLElBQUksQ0FBQyxJQUFJLENBQUM7Z0NBQ25DLEtBQUssRUFBRSxlQUFlOzZCQUN2QixDQUFDOzt3QkFGRSxjQUFjLEdBQUcsU0FFbkI7d0JBRUYsc0VBQXNFO3dCQUN0RSw0Q0FBTSxDQUNKLGVBQWEsQ0FBQyxVQUFVLEVBQ3hCLDhHQUF1RyxpQkFBaUIsQ0FBRSxDQUMzSCxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFHMUIscUJBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FBQzs7d0JBQWhFLFNBQVMsR0FBRyxTQUFvRDt3QkFFcEUsSUFDRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsZUFBYSxDQUFDOzRCQUNsQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEVBQ25DOzRCQUNBLDZDQUFXLENBQ1QsaUpBQTBJLGlCQUFpQixDQUFFLENBQzlKLENBQUM7eUJBQ0g7d0JBR0ssWUFBVSxtREFBVyxFQUFFLENBQUM7d0JBRTlCLGlEQUFpRDt3QkFDakQscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUMzQixpQkFBaUIsRUFDakIsVUFBQyxPQUF3QjtnQ0FDdkIsWUFBWSxDQUFDLFNBQU8sQ0FBQyxDQUFDO2dDQUN0Qiw0Q0FBTSxDQUNKLE9BQU8sQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUM5Qiw4RkFBOEYsQ0FDL0YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxlQUFhLENBQUMsQ0FBQztnQ0FDOUIsU0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDOzRCQUNwQixDQUFDLENBQ0Y7O3dCQVhELGlEQUFpRDt3QkFDakQsU0FVQyxDQUFDO3dCQUVJLGtCQUFrQixHQUFHOzRCQUN6QixJQUFJLEVBQUUsb0JBQW9COzRCQUMxQixPQUFPLEVBQUUsa0JBQWtCLENBQUMsMkJBQTJCO3lCQUN4RCxDQUFDO3dCQUdpQixxQkFBTSxJQUFJLENBQUMsV0FBVyxDQUN2QyxnQkFBZ0IsRUFDaEIsa0JBQWtCLEVBQ2xCLGVBQWEsQ0FDZDs7d0JBSkssVUFBVSxHQUFHLFNBSWxCO3dCQUVELDRDQUFNLENBQ0osVUFBVSxDQUFDLE1BQU0sRUFDakIsb0VBQW9FLENBQ3JFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsZUFBYSxDQUFDLENBQUM7d0JBR25CLHFCQUFNLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0NBQ2hDLFNBQU8sQ0FBQyxNQUFNLENBQUMsbURBQW1ELENBQUMsQ0FBQzs0QkFDdEUsQ0FBQyxFQUFFLDJEQUFrQixDQUFDOzt3QkFIdEIscUNBQXFDO3dCQUNyQyxTQUFPLEdBQUcsU0FFWSxDQUFDO3dCQUV2Qix3QkFBd0I7d0JBQ3hCLHFCQUFNLFNBQU8sQ0FBQyxPQUFPOzt3QkFEckIsd0JBQXdCO3dCQUN4QixTQUFxQixDQUFDOzs7O3dCQUV0Qiw2Q0FBVyxDQUFDLGlCQUFpQixHQUFHLENBQUMsVUFBRSxDQUFDLE9BQU8sbUNBQUksSUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7YUFFdkQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBaEZGLENBZ0ZFLEVBQUM7QUFFTCxTQUFlLHFCQUFxQjs7Ozs7WUFFNUIsZUFBZSxHQUFHLElBQUksT0FBTyxDQUFVLFVBQU8sT0FBTyxFQUFFLE1BQU07Ozs7O2dDQUN2QyxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFBaEUsaUJBQWlCLEdBQUcsU0FBNEM7NEJBQ3JELHFCQUFNLGlCQUFpQixDQUFDLGtCQUFrQixDQUN6RCxjQUFjLEVBQ2QsVUFBTyxPQUFPOzs7b0RBQ1oscUJBQU0sNENBQUksQ0FBQyxzRUFBNkIsQ0FBQzs7Z0RBQXpDLFNBQXlDLENBQUM7Z0RBQzFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztnREFDakIsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDOzs7O3FDQUN4QixDQUNGOzs0QkFQSyxRQUFRLEdBQUcsU0FPaEI7NEJBR0ssS0FBaUQsNkNBQUssRUFBRSxFQUE3QyxZQUFZLGVBQVcsVUFBVSxjQUFhOzRCQUMvRCxPQUFPLEdBQUcsVUFBVSxDQUFDOzRCQUNyQixxQkFBTSxZQUFZOzs0QkFBbEIsU0FBa0IsQ0FBQzs0QkFDbkIsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUMsQ0FBQzs7OztpQkFDbkUsQ0FBQyxDQUFDO1lBRUgsc0JBQU8sZUFBZSxFQUFDOzs7Q0FDeEI7QUFFRCxJQUFNLG9CQUFvQixHQUFHOzs7O29CQUNELHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O2dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0QztnQkFDdEUscUJBQU0saUJBQWlCLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxDQUFDOztnQkFBMUQsU0FBMEQsQ0FBQzs7OztLQUM1RCxDQUFDO0FBV0YsSUFBWSxrQkFHWDtBQUhELFdBQVksa0JBQWtCO0lBQzVCLCtFQUF5RDtJQUN6RCxpRkFBMkQ7QUFDN0QsQ0FBQyxFQUhXLGtCQUFrQixLQUFsQixrQkFBa0IsUUFHN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdElxQztBQUNlO0FBR2Q7QUFHdkMsSUFBTSxlQUFlLEdBQ25CLHFCQUFxQixHQUFHLGlFQUE0QixHQUFHLGFBQWEsQ0FBQztBQUV2RSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxxQkFBcUIsRUFBRTtRQUM5QixLQUFLLENBQUM7Ozs0QkFDSixxQkFBTSxvQkFBb0IsRUFBRTs7d0JBQTVCLFNBQTRCLENBQUM7d0JBQzdCLHFCQUFNLHFCQUFxQixFQUFFOzt3QkFBN0IsU0FBNkIsQ0FBQzs7OzthQUMvQixDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsb0JBQW9CLEVBQUU7Ozs7Ozs7d0JBRXJCLHFCQUFNLElBQUksQ0FBQyxjQUFjLENBQUM7Z0NBQ3hCLEtBQUssRUFBRSxlQUFlOzZCQUN2QixDQUFDOzt3QkFGRixTQUVFLENBQUM7Ozs7d0JBRUgsNkNBQVcsQ0FBQyxlQUFlLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUVyRCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsd0NBQXdDLEVBQUU7Ozs7Ozs7d0JBR3hCLHFCQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLENBQUM7O3dCQUFoRSxRQUFRLEdBQUcsU0FBcUQ7d0JBRXRFLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7O3dCQUU5Qiw2Q0FBVyxDQUFDLGVBQWUsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7O2FBRXJELENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQywwREFBMEQsRUFBRTs7Ozs7Ozt3QkFHcEMscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FBQzs7d0JBQTVELGNBQWMsR0FBRyxTQUEyQzt3QkFDbEUsNENBQU0sQ0FDSixjQUFjLEVBQ2Qsd0dBQWlHLGVBQWUsQ0FBRSxDQUNuSCxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUM1Qiw0Q0FBTSxDQUNKLGNBQWMsRUFDZCw2R0FBc0csZUFBZSxDQUFFLENBQ3hILENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBRWpDLElBQUksT0FBTyxjQUFjLENBQUMsVUFBVSxLQUFLLFFBQVEsRUFBRTs0QkFDakQsNkNBQVcsQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO3lCQUM5RDt3QkFHc0IscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FBQzs7d0JBQTVELGNBQWMsR0FBRyxTQUEyQzt3QkFDbEUsNENBQU0sQ0FDSixjQUFjLEVBQ2Qsd0dBQWlHLGVBQWUsQ0FBRSxDQUNuSCxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUM1Qiw0Q0FBTSxDQUNKLGNBQWMsRUFDZCw2R0FBc0csZUFBZSxDQUFFLENBQ3hILENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBRWpDLDRDQUFNLENBQ0osT0FBTyxjQUFjLENBQUMsVUFBVSxFQUNoQyw4RUFBdUUsT0FBTyxjQUFjLENBQUMsVUFBVSxDQUFFLENBQzFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBRXhCLGtFQUFrRTt3QkFDbEUsNENBQU0sQ0FDSixjQUFjLENBQUMsVUFBVSxFQUN6Qiw4R0FBdUcsZUFBZSxDQUFFLENBQ3pILENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUV4QixxQkFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQzs7d0JBQXJELFNBQVMsR0FBRyxTQUF5Qzt3QkFFM0QsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBRS9CLDRFQUE0RTt3QkFDNUUsNENBQU0sQ0FDSixTQUFTLENBQUMsVUFBVSxFQUNwQiw0TUFBNE0sQ0FDN00sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBRXZCLHFCQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDOzt3QkFBckQsU0FBUyxHQUFHLFNBQXlDO3dCQUUzRCw0Q0FBTSxDQUNKLFNBQVMsRUFDVCw2R0FBc0csZUFBZSxDQUFFLENBQ3hILENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7d0JBQ2pDLDRDQUFNLENBQ0osU0FBUyxDQUFDLFVBQVUsRUFDcEIsaUxBQWlMLENBQ2xMLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7O3dCQUV6Qyw2Q0FBVyxDQUFDLGVBQWUsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7O2FBRXJELENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQTFGRixDQTBGRSxFQUFDO0FBRUwsU0FBZSxxQkFBcUI7Ozs7O1lBRTVCLGVBQWUsR0FBRyxJQUFJLE9BQU8sQ0FBVSxVQUFPLE9BQU8sRUFBRSxNQUFNOzs7O2dDQUN2QyxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDOzs0QkFBaEUsaUJBQWlCLEdBQUcsU0FBNEM7NEJBQ3JELHFCQUFNLGlCQUFpQixDQUFDLGtCQUFrQixDQUN6RCxjQUFjLEVBQ2QsVUFBQyxPQUFPO29DQUNOLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQ0FDakIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29DQUN0QixRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7Z0NBQ3pCLENBQUMsQ0FDRjs7NEJBUEssUUFBUSxHQUFHLFNBT2hCOzRCQUdLLEtBQWlELDZDQUFLLEVBQUUsRUFBN0MsWUFBWSxlQUFXLFVBQVUsY0FBYTs0QkFDL0QsT0FBTyxHQUFHLFVBQVUsQ0FBQzs0QkFDckIscUJBQU0sWUFBWTs7NEJBQWxCLFNBQWtCLENBQUM7NEJBQ25CLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDLENBQUM7Ozs7aUJBQ25FLENBQUMsQ0FBQztZQUVILHNCQUFPLGVBQWUsRUFBQzs7O0NBQ3hCO0FBRU0sU0FBUyxtQkFBbUIsQ0FBQyxRQUFxQjtJQUN2RCw0Q0FBTSxDQUNKLFFBQVEsRUFDUixzREFBK0MsZUFBZSxDQUFFLENBQ2pFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0IsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQ3JDLDZDQUFXLENBQ1QsK0VBQXdFLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBRSxDQUMvRixDQUFDO0tBQ0g7SUFDRCw0Q0FBTSxDQUNKLFFBQVEsRUFDUix5REFBa0QsZUFBZSxDQUFFLENBQ3BFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUIsNENBQU0sQ0FDSixPQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQ3ZCLGtGQUEyRSxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUUsQ0FDckcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV4Qiw0Q0FBTSxDQUNKLFFBQVEsRUFDUix1REFBZ0QsZUFBZSxDQUFFLENBQ2xFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDNUIsNENBQU0sQ0FDSixPQUFPLFFBQVEsQ0FBQyxLQUFLLEVBQ3JCLGdGQUF5RSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUUsQ0FDakcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV4Qiw0Q0FBTSxDQUNKLFFBQVEsRUFDUix5REFBa0QsZUFBZSxDQUFFLENBQ3BFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUIsNENBQU0sQ0FDSixPQUFPLFFBQVEsQ0FBQyxPQUFPLEVBQ3ZCLGtGQUEyRSxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUUsQ0FDckcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV4Qiw0Q0FBTSxDQUNKLFFBQVEsRUFDUiw2REFBc0QsZUFBZSxDQUFFLENBQ3hFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDbEMsNENBQU0sQ0FDSixPQUFPLFFBQVEsQ0FBQyxXQUFXLEVBQzNCLHNGQUErRSxPQUFPLFFBQVEsQ0FBQyxXQUFXLENBQUUsQ0FDN0csQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV4Qiw0Q0FBTSxDQUNKLFFBQVEsRUFDUix1REFBZ0QsZUFBZSxDQUFFLENBQ2xFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ2xDLDZDQUFXLENBQ1QsZ0ZBQXlFLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBRSxDQUN2RyxDQUFDO0tBQ0g7SUFFRCxvREFBb0Q7SUFDcEQsSUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXZELElBQUksQ0FBQyxhQUFhO1FBQ2hCLDZDQUFXLENBQUMsc0RBQXNELENBQUMsQ0FBQztJQUV0RSw0Q0FBTSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNsRSw0Q0FBTSxDQUNKLE9BQU8sUUFBUSxDQUFDLFdBQVcsRUFDM0Isc0ZBQStFLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBRSxDQUM3RyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRXZCLDBEQUEwRDtJQUMxRCxJQUFNLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFOUQsSUFBSSxDQUFDLGNBQWM7UUFDakIsNkNBQVcsQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFFRCxJQUFNLG9CQUFvQixHQUFHOzs7O29CQUNELHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O2dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0QztnQkFDdEUscUJBQU0saUJBQWlCLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxDQUFDOztnQkFBMUQsU0FBMEQsQ0FBQzs7OztLQUM1RCxDQUFDO0FBRUYsSUFBTSxnQkFBZ0IsR0FBRyxVQUFDLEtBQUs7SUFDN0IsT0FBTyxDQUNMLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUNoQixLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxVQUFDLEtBQUs7WUFDNUIsT0FBTyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Tm9DO0FBQ2U7QUFHVjtBQUNTO0FBRU47QUFDYztBQUs5QjtBQUc5QixJQUFNLFdBQVcsR0FDZixxQkFBcUIsR0FBRyxnRUFBMkIsR0FBRyxXQUFXLENBQUM7QUFDcEUsSUFBTSxlQUFlLEdBQ25CLHFCQUFxQixHQUFHLGlFQUE0QixHQUFHLFdBQVcsQ0FBQztBQUVyRSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxjQUFjLEVBQUU7UUFDdkIsS0FBSyxDQUFDOzs7NEJBQ0oscUJBQU0sb0JBQW9CLEVBQUU7O3dCQUE1QixTQUE0QixDQUFDO3dCQUM3QixxQkFBTSxxQkFBcUIsRUFBRTs7d0JBQTdCLFNBQTZCLENBQUM7Ozs7YUFDL0IsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG9CQUFvQixFQUFFOzs7Ozs7O3dCQUVyQixxQkFBTSxJQUFJLENBQUMsT0FBTyxFQUFFOzt3QkFBcEIsU0FBb0IsQ0FBQzs7Ozt3QkFFckIsNkNBQVcsQ0FDVCxxQkFBcUI7NEJBQ25CLDZEQUF3Qjs0QkFDeEIsV0FBVzs0QkFDWCxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUNyQixDQUFDOzs7OzthQUVMLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyw4REFBOEQsRUFBRTs7Ozs7Ozt3QkFFMUMscUJBQU0sSUFBSSxDQUFDLE9BQU8sRUFBRTs7d0JBQW5DLFlBQVksR0FBRyxTQUFvQjt3QkFDekMsNENBQU0sQ0FDSixZQUFZLEVBQ1osa0VBQTJELFdBQVcsQ0FBRSxDQUN6RSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO3dCQUNsQyw0Q0FBTSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUNuRSxDQUFDLENBQ0YsQ0FBQzt3QkFDRiw0Q0FBTSxDQUNKLFlBQVksRUFDWiwrREFBd0QsV0FBVyxDQUFFLENBQ3RFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBQy9CLDRDQUFNLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQzt3QkFDbEQsNENBQU0sQ0FDSixZQUFZLENBQUMsZ0JBQWdCLEVBQzdCLDhGQUF1RixXQUFXLENBQUUsQ0FDckcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO3dCQUM3Qyw0Q0FBTSxDQUNKLFlBQVksQ0FBQyxnQkFBZ0IsRUFDN0IsaUdBQTBGLFdBQVcsQ0FBRSxDQUN4RyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixDQUFDLENBQUM7d0JBQ2hELDRDQUFNLENBQ0osT0FBTyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsc0JBQXNCLEVBQzNELDBGQUEwRixDQUMzRixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO3dCQUN6Qiw0Q0FBTSxDQUNKLE9BQU8sWUFBWSxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixFQUM5RCw2RkFBNkYsQ0FDOUYsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozt3QkFFekIsNkNBQVcsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUVqRCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsOERBQThELEVBQUU7Ozs7O3dCQUNqRSxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO3dCQUVBLHFCQUFNLDREQUFrQixDQUFDLGFBQWEsQ0FBQzs7d0JBQTNELGlCQUFpQixHQUFHLFNBQXVDO3dCQUczRCxrQkFBa0IsR0FBOEI7NEJBQ3BELElBQUksRUFBRSxvQkFBb0I7NEJBQzFCLE9BQU8sRUFBRSw4RkFBNkM7eUJBQ3ZELENBQUM7d0JBR0ksT0FBTyxHQUFHLG1EQUFXLEVBQUUsQ0FBQzt3QkFFOUIsaUJBQWlCLENBQUMsa0JBQWtCLENBQ2xDLGlCQUFpQixFQUNqQixVQUFPLE9BQXdCOztnQ0FDN0IsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7Z0NBQ3BDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQ0FDbEIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7NkJBQ3ZCLENBQ0YsQ0FBQzt3QkFFb0IscUJBQU0sSUFBSSxDQUFDLElBQUksQ0FDbkMsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLEVBQzFCLGtCQUFrQixDQUNuQjs7d0JBSEssYUFBYSxHQUFHLFNBR3JCO3dCQUdTLHFCQUFNLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0NBQ2hDLE9BQU8sQ0FBQyxNQUFNLENBQUMsbURBQW1ELENBQUMsQ0FBQzs0QkFDdEUsQ0FBQyxFQUFFLDJEQUFrQixDQUFDOzt3QkFIdEIscUNBQXFDO3dCQUNyQyxPQUFPLEdBQUcsU0FFWSxDQUFDO3dCQUV2QixzQ0FBc0M7d0JBQ3RDLHFCQUFNLE9BQU8sQ0FBQyxPQUFPOzt3QkFEckIsc0NBQXNDO3dCQUN0QyxTQUFxQixDQUFDO3dCQUV0Qix3QkFBd0I7d0JBQ3hCLDRDQUFNLENBQ0osYUFBYSxFQUNiLG1EQUE0QyxXQUFXLENBQUUsQ0FDMUQsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDNUIsNENBQU0sQ0FDSixhQUFhLEVBQ2Isd0RBQWlELFdBQVcsQ0FBRSxDQUMvRCxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO3dCQUVqQyxpQ0FBaUM7d0JBQ2pDLDRDQUFNLENBQ0osWUFBWSxFQUNaLGtFQUEyRCxXQUFXLENBQUUsQ0FDekUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQzt3QkFDbEMsNENBQU0sQ0FDSixZQUFZLENBQUMsV0FBVyxFQUN4Qiw0REFBcUQsV0FBVyxDQUFFLENBQ25FLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQzVCLDRDQUFNLENBQ0osWUFBWSxDQUFDLFdBQVcsRUFDeEIsaUVBQTBELFdBQVcsQ0FBRSxDQUN4RSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO3dCQUNqQyw0Q0FBTSxDQUNKLFlBQVksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUM5QixzSEFBc0gsQ0FDdkgsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ25DLDRDQUFNLENBQ0osWUFBWSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQ25DLGdJQUFnSSxDQUNqSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFHVCxxQkFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQzs7d0JBQW5ELFFBQVEsR0FBRyxTQUF3Qzt3QkFDekQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7d0JBQ3RDLHlFQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Ozs7YUFDcEMsQ0FBQyxDQUFDO1FBRUgsU0FBZSxxQkFBcUI7Ozs7O29CQUU1QixlQUFlLEdBQUcsSUFBSSxPQUFPLENBQVUsVUFBTyxPQUFPLEVBQUUsTUFBTTs7Ozt3Q0FDdkMscUJBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQzs7b0NBQWhFLGlCQUFpQixHQUFHLFNBQTRDO29DQUNyRCxxQkFBTSxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FDekQsY0FBYyxFQUNkLFVBQUMsT0FBTzs0Q0FDTixPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7NENBQ2pCLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzs0Q0FDdEIsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO3dDQUN6QixDQUFDLENBQ0Y7O29DQVBLLFFBQVEsR0FBRyxTQU9oQjtvQ0FHSyxLQUFpRCw2Q0FBSyxFQUFFLEVBQTdDLFlBQVksZUFBVyxVQUFVLGNBQWE7b0NBQy9ELE9BQU8sR0FBRyxVQUFVLENBQUM7b0NBQ3JCLHFCQUFNLFlBQVk7O29DQUFsQixTQUFrQixDQUFDO29DQUNuQixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQyxDQUFDOzs7O3lCQUNuRSxDQUFDLENBQUM7b0JBRUgsc0JBQU8sZUFBZSxFQUFDOzs7U0FDeEI7UUFFRCxJQUFNLG9CQUFvQixHQUFHOzs7OzRCQUNELHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUM7O3dCQUFoRSxpQkFBaUIsR0FBRyxTQUE0Qzt3QkFDdEUscUJBQU0saUJBQWlCLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxDQUFDOzt3QkFBMUQsU0FBMEQsQ0FBQzs7OzthQUM1RCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBOUpGLENBOEpFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25MaUM7QUFDZTtBQUlyRCxJQUFNLGFBQWEsR0FDakIscUJBQXFCLEdBQUcsd0VBQW1DLEdBQUcsV0FBVyxDQUFDO0FBRTVFLGlFQUFlO0lBQ2IsZUFBUSxDQUFDLHlCQUF5QixFQUFFO1FBQ2xDLElBQUksUUFBa0IsQ0FBQztRQUV2QixTQUFTLENBQUM7WUFDUixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQzFCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUN4QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG1DQUFtQyxFQUFFOzs7Ozs7d0JBQ2hDLFdBQVcsR0FBRyxjQUFjLENBQUM7Ozs7d0JBRXRCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsVUFBQyxJQUFTO2dDQUM5RCxPQUFPLENBQUMsR0FBRyxDQUNULG1DQUE0QixXQUFXLG9DQUEwQixJQUFJLENBQUUsQ0FDeEUsQ0FBQzs0QkFDSixDQUFDLENBQUM7O3dCQUpGLFFBQVEsR0FBRyxTQUlULENBQUM7Ozs7d0JBRUgsNkNBQVcsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUVuRCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsd0NBQXdDLEVBQUU7Ozs7Ozs7d0JBRTlCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsY0FBTyxDQUFDLENBQUM7O3dCQUF4RCxRQUFRLEdBQUcsU0FBNkMsQ0FBQzt3QkFDekQsK0NBQWEsQ0FBQyxRQUFRLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUFDO3dCQUN2RSw0Q0FBTSxDQUFDLE9BQU8sUUFBUSxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FDN0QsVUFBVSxDQUNYLENBQUM7Ozs7d0JBRUYsNkNBQVcsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUVuRCxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFqQ0YsQ0FpQ0UsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNpQztBQUNlO0FBS3JELGlFQUFlO0lBQ2IsZUFBUSxDQUFDLHdCQUF3QixFQUFFO1FBQ2pDLElBQUksUUFBa0IsQ0FBQztRQUV2QixTQUFTLENBQUM7WUFDUixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQzFCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDdkIsUUFBUSxHQUFHLFNBQVMsQ0FBQzthQUN0QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLG1DQUFtQyxFQUFFOzs7Ozs7d0JBQ2hDLFVBQVUsR0FBRywwQkFBMEIsQ0FBQzs7Ozt3QkFFakMscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxVQUFDLElBQVM7Z0NBQzVELE9BQU8sQ0FBQyxHQUFHLENBQ1QscUNBQThCLFVBQVUsb0NBQTBCLElBQUksQ0FBRSxDQUN6RSxDQUFDOzRCQUNKLENBQUMsQ0FBQzs7d0JBSkYsUUFBUSxHQUFHLFNBSVQsQ0FBQzt3QkFDSCw0Q0FBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7O3dCQUV2RSw2Q0FBVyxDQUNULHFCQUFxQjs0QkFDbkIsdUVBQWtDOzRCQUNsQyxXQUFXOzRCQUNYLENBQUMsVUFBRSxDQUFDLE9BQU8sbUNBQUksSUFBRSxDQUFDLENBQ3JCLENBQUM7Ozs7O2FBRUwsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBNUJGLENBNEJFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDaUM7QUFDZTtBQUlyRCxJQUFNLHFCQUFxQixHQUN6QixxQkFBcUIsR0FBRyx1RUFBa0MsR0FBRyxXQUFXLENBQUM7QUFFM0UsaUVBQWU7SUFDYixlQUFRLENBQUMsd0JBQXdCLEVBQUU7UUFDakMsRUFBRSxDQUFDLG1DQUFtQyxFQUFFOzs7Ozs7O3dCQUVwQixxQkFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7O3dCQUF4QyxPQUFPLEdBQUcsU0FBOEI7Ozs7d0JBRTlDLDZDQUFXLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUUzRCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsK0VBQStFLEVBQUU7Ozs7Ozs7d0JBRWhFLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRTs7d0JBQXhDLE9BQU8sR0FBRyxTQUE4Qjt3QkFDOUMsNENBQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7d0JBRTdCLDZDQUFXLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxVQUFFLENBQUMsT0FBTyxtQ0FBSSxJQUFFLENBQUMsQ0FBQyxDQUFDOzs7OzthQUUzRCxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7QUFqQkYsQ0FpQkUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJpQztBQUNlO0FBSXJELElBQU0sc0JBQXNCLEdBQzFCLHFCQUFxQixHQUFHLHdFQUFtQyxHQUFHLFdBQVcsQ0FBQztBQUU1RSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyx5QkFBeUIsRUFBRTtRQUNsQyxFQUFFLENBQUMsdUNBQXVDLEVBQUU7Ozs7Ozs7d0JBRXhCLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQzs7d0JBQTFELE9BQU8sR0FBRyxTQUFnRDt3QkFDaEUsNENBQU0sQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDL0QsNENBQU0sQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDakUsNENBQU0sQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQzt3QkFDdEUsNENBQU0sQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDdEQsbUJBQW1CLENBQ3BCLENBQUM7d0JBQ0YsNENBQU0sQ0FBQyxPQUFPLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FDdEQsb0JBQW9CLENBQ3JCLENBQUM7Ozs7d0JBRUYsNkNBQVcsQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7O2FBRTVELENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQWpCRixDQWlCRSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQnlCO0FBQ3VCO0FBSXJELElBQU0sb0JBQW9CLEdBQ3hCLHFCQUFxQixHQUFHLHVFQUFrQyxHQUFHLFdBQVcsQ0FBQztBQUUzRSxpRUFBZTtJQUNiLGVBQVEsQ0FBQyxzQkFBc0IsRUFBRTtRQUMvQixFQUFFLENBQUMsbUNBQW1DLEVBQUU7Ozs7Ozs7d0JBRXBDLHFCQUFNLElBQUksQ0FBQyxlQUFlLEVBQUU7O3dCQUE1QixTQUE0QixDQUFDOzs7O3dCQUU3Qiw2Q0FBVyxDQUFDLG9CQUFvQixHQUFHLENBQUMsVUFBRSxDQUFDLE9BQU8sbUNBQUksSUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7YUFFMUQsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBUkYsQ0FRRSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCaUM7QUFNdEMsU0FBUyxXQUFXO0lBS2xCLElBQUksY0FBYyxDQUFDO0lBQ25CLElBQUksYUFBYSxDQUFDO0lBRWxCLElBQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFPLFVBQUMsT0FBTyxFQUFFLE1BQU07UUFDaEQsY0FBYyxHQUFHLE9BQU8sQ0FBQztRQUN6QixhQUFhLEdBQUcsTUFBTSxDQUFDO0lBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxFQUFFLE9BQU8sV0FBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsQ0FBQztBQUNyRSxDQUFDO0FBRUQsaUVBQWU7SUFDYixlQUFRLENBQUMsa0JBQWtCLEVBQUU7UUFDM0IsU0FBUyxDQUFDOzs7NEJBQ1IscUJBQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFOzt3QkFBaEMsU0FBZ0MsQ0FBQzs7OzthQUNsQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsK0NBQStDLEVBQUU7Ozs7Ozt3QkFDNUMsT0FBTyxHQUFHLFdBQVcsRUFBRSxDQUFDO3dCQUViLHFCQUFNLElBQUksQ0FBQyxlQUFlLEVBQUU7O3dCQUF2QyxRQUFRLEdBQUcsU0FBNEI7NkJBRXpDLFNBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFuQix3QkFBbUI7Ozs7d0JBRW5CLHFCQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs7d0JBQTFDLFNBQTBDLENBQUM7d0JBRXBCLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRTs7d0JBQS9DLGNBQWMsR0FBRyxTQUE4Qjt3QkFFckQsNENBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7d0JBRWhDLFVBQVUsR0FBRyxVQUFDLENBQUM7NEJBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUM1QixPQUFPLElBQUksQ0FBQzt3QkFDZCxDQUFDLENBQUM7d0JBRUYsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsRUFBRSxVQUFDLEdBQUc7NEJBQ3pDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxhQUFhLEVBQUU7Z0NBQzdCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7Z0NBQ3hCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzs2QkFDbkI7aUNBQU07Z0NBQ0wsT0FBTyxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOzZCQUN0Qzt3QkFDSCxDQUFDLENBQUMsQ0FBQzt3QkFFSCxjQUFjLENBQUMsU0FBUyxDQUFDOzRCQUN2QixJQUFJLEVBQUUsYUFBYTs0QkFDbkIsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTt5QkFDdEIsQ0FBQyxDQUFDO3dCQUVILHFCQUFNLE9BQU8sQ0FBQyxPQUFPOzt3QkFBckIsU0FBcUIsQ0FBQzt3QkFDdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Ozt3QkFFcEIsNkNBQVcsQ0FBQywrQkFBK0IsR0FBRyxDQUFDLFVBQUUsQ0FBQyxPQUFPLG1DQUFJLElBQUUsQ0FBQyxDQUFDLENBQUM7Ozs7d0JBR3BFLDZDQUFXLENBQUMsOEJBQThCLENBQUMsQ0FBQzs7Ozs7YUFFL0MsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBOUNGLENBOENFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JFaUM7QUFDZTtBQUtyRCxpRUFBZTtJQUNiLGVBQVEsQ0FBQywwQkFBMEIsRUFBRTs7UUFDbkMsSUFBSTtZQUNGLEVBQUUsQ0FBQyxtQ0FBbUMsRUFBRTs7O2dDQUN0QyxxQkFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUU7OzRCQUFoQyxTQUFnQyxDQUFDOzs7O2lCQUNsQyxDQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ1gsNkNBQVcsQ0FDVCxxQkFBcUI7Z0JBQ25CLHlFQUFvQztnQkFDcEMsV0FBVztnQkFDWCxDQUFDLFFBQUUsQ0FBQyxPQUFPLG1DQUFJLEVBQUUsQ0FBQyxDQUNyQixDQUFDO1NBQ0g7SUFDSCxDQUFDLENBQUM7QUFiRixDQWFFLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQm1DO0FBQ0Y7QUFDZTtBQUlyRCxJQUFNLElBQUksR0FDUixxQkFBcUI7SUFDckIsMkVBQXNDO0lBQ3RDLGFBQWEsQ0FBQztBQUVoQixpRUFBZTtJQUNiLGVBQVEsQ0FBQyw0QkFBNEIsRUFBRTs7WUFDckMsRUFBRSxDQUFDLG1DQUFtQyxFQUFFOzs7Ozs0QkFDaEMsT0FBTyxHQUFHO2dDQUNkLElBQUksRUFBRSx5QkFBeUI7Z0NBQy9CLElBQUksRUFBRSxNQUFNO2dDQUNaLEVBQUUsRUFBRTtvQ0FDRixNQUFNLEVBQUUsUUFBUTtvQ0FDaEIsSUFBSSxFQUFFLGNBQWM7b0NBQ3BCLEtBQUssRUFBRSxXQUFXO29DQUNsQixJQUFJLEVBQUUsY0FBYztpQ0FDckI7NkJBQ0YsQ0FBQzs7Ozs0QkFHQSxxQkFBTSxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDOzs0QkFBekMsU0FBeUMsQ0FBQzs0QkFDMUMsNkNBQVcsQ0FBQyx1Q0FBdUMsRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs0QkFFM0QsNENBQU0sQ0FBQyxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsOERBQXdCLEVBQUUsSUFBSSxDQUFDLENBQUM7Ozs7O2lCQUUxRSxDQUFDLENBQUM7OztTQUNKLENBQUM7QUFwQkYsQ0FvQkUsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDK0I7QUFFN0IsU0FBUyxLQUFLLENBQUMsU0FBc0M7SUFBdEMsd0NBQW9CLDJEQUFrQjtJQUMxRCxJQUFJLE9BQU8sQ0FBQztJQUNaLElBQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFPLFVBQUMsT0FBTztRQUN4QyxPQUFPLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUMxQixPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNoQixDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBRSxPQUFPLFdBQUUsT0FBTyxXQUFFLENBQUM7QUFDOUIsQ0FBQztBQUVNLFNBQWUsSUFBSSxDQUFDLFNBQWtCOzs7O1lBQ3JDLEtBQXVCLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBckMsT0FBTyxlQUFFLE9BQU8sY0FBc0I7WUFDOUMsc0JBQU8sT0FBTyxFQUFDOzs7Q0FDaEI7QUFFTSxTQUFTLFdBQVc7SUFLekIsSUFBSSxjQUFjLENBQUM7SUFDbkIsSUFBSSxhQUFhLENBQUM7SUFDbEIsSUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQU8sVUFBQyxPQUFPLEVBQUUsTUFBTTtRQUNoRCxjQUFjLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLGFBQWEsR0FBRyxNQUFNLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEVBQUUsT0FBTyxXQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ3JFLENBQUM7Ozs7Ozs7Ozs7O0FDN0JEO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQytCO0FBQ2hDLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQscUJBQU0sRUFBRTs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNsWUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBTTtBQUNmLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxxQkFBTTtBQUNsQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBOztBQUVhOztBQUViLHdCQUF3QixtQkFBTyxDQUFDLDJEQUFjO0FBQzlDLDBCQUEwQixtQkFBTyxDQUFDLDZFQUF1QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBbUI7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWdCOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOzs7QUFHekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7O0FDN1VEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsT0FBTyxvQkFBb0IsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBLFFBQVEsU0FBUyxPQUFPO0FBQ3hCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLElBQUksT0FBTztBQUNYLGlCQUFpQixPQUFPO0FBQ3hCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtR0FBMEM7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O0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxR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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNyWWE7O0FBRWI7QUFDQTtBQUNBLFlBQVksR0FBRywrRkFBZ0M7QUFDL0MsV0FBVyxHQUFHLDRGQUE4QjtBQUM1QyxXQUFXLEdBQUcsNEZBQThCO0FBQzVDLFdBQVcsR0FBRyw0RkFBOEI7QUFDNUMsWUFBWSxHQUFHLCtGQUFnQztBQUMvQyxZQUFZLEdBQUcsK0ZBQWdDO0FBQy9DLFlBQVksR0FBRywrRkFBZ0M7QUFDL0MsV0FBVyxHQUFHLDRGQUE4QjtBQUM1QyxZQUFZLEdBQUcsK0ZBQWdDO0FBQy9DLFlBQVksR0FBRywrRkFBZ0M7QUFDL0MsYUFBYSxHQUFHLGtHQUFrQztBQUNsRCxnQkFBZ0IsR0FBRywyR0FBd0M7QUFDM0QsZ0JBQWdCLEdBQUcsMkdBQXdDO0FBQzNELGVBQWUsR0FBRyx3R0FBc0M7QUFDeEQsa0JBQWtCLEdBQUcsdUhBQWlEOzs7Ozs7Ozs7Ozs7O0FDbEJ6RDtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsZ0JBQWdCLHVGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsRUFBRSxPQUFPO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzNGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsU0FBUyxtQkFBTyxDQUFDLGlCQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxtQkFBTTtBQUN6QiwrQkFBK0Isb0dBQTJDO0FBQzFFLGNBQWMsbUJBQU8sQ0FBQyxvREFBVTtBQUNoQyxnQkFBZ0IsdUZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBLFFBQVE7QUFDUjtBQUNBLGFBQWEsa0JBQWtCLDZCQUE2QixPQUFPLFlBQVksWUFBWTtBQUMzRjtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0EsTUFBTTtBQUNOLE1BQU0sT0FBTztBQUNiO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2pLYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsZUFBZSxvRkFBNEI7QUFDM0MsZ0JBQWdCLHVGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0dBQTZDOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFLE9BQU87QUFDVDtBQUNBLElBQUksT0FBTztBQUNYLE1BQU0sT0FBTyxNQUFNLE9BQU87QUFDMUIsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ25IYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsZUFBZSxvRkFBNEI7QUFDM0MsZ0JBQWdCLHVGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxJQUFJLE9BQU87QUFDWCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzdFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsWUFBWSxtQkFBTyxDQUFDLG9EQUFVO0FBQzlCLGdCQUFnQix1RkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLElBQUksT0FBTztBQUNYLElBQUksT0FBTztBQUNYLElBQUksT0FBTztBQUNYLEdBQUc7QUFDSDs7QUFFQTs7Ozs7Ozs7Ozs7OztBQy9HYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsZUFBZSxvRkFBNEI7QUFDM0MsZ0JBQWdCLHVGQUE4QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBLElBQUksT0FBTyx3QkFBd0I7QUFDbkMsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbkRhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywyREFBUTtBQUMzQixnQkFBZ0IsdUZBQThCO0FBQzlDLGVBQWUsb0ZBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDblJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywyREFBUTtBQUMzQixnQkFBZ0IsdUZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0ZBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLE9BQU87QUFDWCxJQUFJLE9BQU87QUFDWCxJQUFJLE9BQU87QUFDWCxJQUFJLE9BQU87QUFDWCxJQUFJLE9BQU87QUFDWDtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN2R2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLDJEQUFRO0FBQzNCLGdCQUFnQix1RkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9GQUE0QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbEdhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywwQ0FBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsZ0JBQWdCLHVGQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9GQUE0QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU87QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDcFNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQywyREFBUTtBQUMzQixZQUFZLG1CQUFPLENBQUMsb0RBQVU7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLGlCQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxtQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0RBQVc7QUFDaEM7QUFDQSxnQkFBZ0IsdUZBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdHQUE2QztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQU07O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0IsT0FBTyxpQkFBaUIsT0FBTztBQUNuRCxJQUFJLE9BQU87QUFDWCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhEQUE4RDtBQUM5RCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3hOYTs7QUFFYixtQkFBbUIsb0ZBQThCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyx1REFBVztBQUNqQyxZQUFZLG1CQUFPLENBQUMsc0VBQU87QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsdUNBQUk7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLG1EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQVU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBTTtBQUNqQixpQkFBaUIscUJBQU07QUFDdkIsbUJBQW1CLHFCQUFNO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxXQUFXLGVBQWU7QUFDMUIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRyxtRUFBbUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDM2RhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9GQUE4QjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsdURBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLG1EQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxzRUFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMseURBQVk7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLG1EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFEQUFVOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxtQ0FBbUMsb0JBQW9CLEtBQUssaUJBQWlCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixVQUFVO0FBQ1YsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLHFCQUFxQixxQkFBTSxpQkFBaUIsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQU07O0FBRWhDO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsbUJBQW1CLEVBQUUsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CLE9BQU8sMkJBQTJCO0FBQzlFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQSx3QkFBd0Isb0JBQW9CLE1BQU0sWUFBWTtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNB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O0FDSmlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2Uvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9hc3NlcnRpb24tZXJyb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1zdGRvdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2Fzc2VydGlvbi5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9jb25maWcuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvY29tcGFyZUJ5SW5zcGVjdC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldE9wZXJhdG9yLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbnNwZWN0LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzTmFOLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9wcm94aWZ5LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9jb252ZXJ0L2RtcC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvY29udmVydC94bWwuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYmFzZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi9jaGFyYWN0ZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvY3NzLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9kaWZmL2pzb24uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvbGluZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi9zZW50ZW5jZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi93b3JkLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvcGF0Y2gvYXBwbHkuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZGlmZi9saWIvcGF0Y2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2RpZmYvbGliL3BhdGNoL3BhcnNlLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi91dGlsL2FycmF5LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9kaWZmL2xpYi91dGlsL3BhcmFtcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2ZkYzNfMV8yL2Rpc3QvZmRjMy5lc20uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2ZkYzNfMl8wL2Rpc3QvZmRjMy5lc20uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvaGUvaGUuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2xvZy1zeW1ib2xzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2xvdXBlL2xvdXBlLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvIHN5bmMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi9zcmMvYXBpRG9jdW1lbnRzLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3Rlc3RTdWl0ZS50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYWR2YW5jZWQvZmRjMy5icm9hZGNhc3QudHMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi9zcmMvdGVzdC92MS4yL2FkdmFuY2VkL2ZkYzMuZmluZEludGVudC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYWR2YW5jZWQvZmRjMy5maW5kSW50ZW50c0J5Q29udGV4dC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYWR2YW5jZWQvZmRjMy5vcGVuLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjEuMi9hZHZhbmNlZC9mZGMzLnJhaXNlSW50ZW50LnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjEuMi9iYXNpYy9mZGMzLmFkZENvbnRleHRMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5hZGRJbnRlbnRMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5nZXRDdXJyZW50Q2hhbm5lbC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5nZXRJbmZvLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjEuMi9iYXNpYy9mZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5nZXRTeXN0ZW1DaGFubmVscy50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5qb2luQ2hhbm5lbC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YxLjIvYmFzaWMvZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjEuMi9iYXNpYy9mZGMzLnJhaXNlSW50ZW50Rm9yQ29udGV4dC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYWR2YW5jZWQvZmRjMy5icm9hZGNhc3QudHMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi9zcmMvdGVzdC92Mi4wL2FkdmFuY2VkL2ZkYzMuZmluZEluc3RhbmNlcy50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYWR2YW5jZWQvZmRjMy5nZXRBcHBNZXRhZGF0YS50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYWR2YW5jZWQvZmRjMy5nZXRJbmZvLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjIuMC9iYXNpYy9mZGMzLmFkZENvbnRleHRMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYmFzaWMvZmRjMy5hZGRJbnRlbnRMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYmFzaWMvZmRjMy5nZXRDdXJyZW50Q2hhbm5lbC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYmFzaWMvZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwudHMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi9zcmMvdGVzdC92Mi4wL2Jhc2ljL2ZkYzMuZ2V0VXNlckNoYW5uZWxzLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjIuMC9iYXNpYy9mZGMzLmpvaW5Vc2VyQ2hhbm5lbC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy90ZXN0L3YyLjAvYmFzaWMvZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsLnRzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL3Rlc3QvdjIuMC9iYXNpYy9mZGMzLnJhaXNlSW50ZW50Rm9yQ29udGV4dC50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uL3NyYy91dGlscy50cyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvdHlwZS1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS9pZ25vcmVkfEM6XFxVc2Vyc1xcamR1bmxlYXZ5XFxzb3VyY2VcXHJlcG9zXFxGREMzLWNvbmZvcm1hbmNlLWZyYW1ld29ya1xcbm9kZV9tb2R1bGVzXFxsb3VwZXx1dGlsIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL2lnbm9yZWR8QzpcXFVzZXJzXFxqZHVubGVhdnlcXHNvdXJjZVxccmVwb3NcXEZEQzMtY29uZm9ybWFuY2UtZnJhbWV3b3JrXFxub2RlX21vZHVsZXNcXG1vY2hhXFxsaWJcXHJlcG9ydGVyc3xmcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS9pZ25vcmVkfEM6XFxVc2Vyc1xcamR1bmxlYXZ5XFxzb3VyY2VcXHJlcG9zXFxGREMzLWNvbmZvcm1hbmNlLWZyYW1ld29ya1xcbm9kZV9tb2R1bGVzXFxtb2NoYVxcbGliXFxyZXBvcnRlcnN8cGF0aCIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS9pZ25vcmVkfEM6XFxVc2Vyc1xcamR1bmxlYXZ5XFxzb3VyY2VcXHJlcG9zXFxGREMzLWNvbmZvcm1hbmNlLWZyYW1ld29ya1xcbm9kZV9tb2R1bGVzXFxtb2NoYVxcbGliXFxyZXBvcnRlcnN8c3VwcG9ydHMtY29sb3IiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvaWdub3JlZHxDOlxcVXNlcnNcXGpkdW5sZWF2eVxcc291cmNlXFxyZXBvc1xcRkRDMy1jb25mb3JtYW5jZS1mcmFtZXdvcmtcXG5vZGVfbW9kdWxlc1xcbW9jaGFcXGxpYnwuL25vZGVqcy9lc20tdXRpbHMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvaWdub3JlZHxDOlxcVXNlcnNcXGpkdW5sZWF2eVxcc291cmNlXFxyZXBvc1xcRkRDMy1jb25mb3JtYW5jZS1mcmFtZXdvcmtcXG5vZGVfbW9kdWxlc1xcbW9jaGFcXGxpYnwuL25vZGVqcy9maWxlLXVubG9hZGVyIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL2lnbm9yZWR8QzpcXFVzZXJzXFxqZHVubGVhdnlcXHNvdXJjZVxccmVwb3NcXEZEQzMtY29uZm9ybWFuY2UtZnJhbWV3b3JrXFxub2RlX21vZHVsZXNcXG1vY2hhXFxsaWJ8Li9ub2RlanMvcGFyYWxsZWwtYnVmZmVyZWQtcnVubmVyIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL2lnbm9yZWR8QzpcXFVzZXJzXFxqZHVubGVhdnlcXHNvdXJjZVxccmVwb3NcXEZEQzMtY29uZm9ybWFuY2UtZnJhbWV3b3JrXFxub2RlX21vZHVsZXNcXG1vY2hhXFxsaWJ8cGF0aCIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS9pZ25vcmVkfEM6XFxVc2Vyc1xcamR1bmxlYXZ5XFxzb3VyY2VcXHJlcG9zXFxGREMzLWNvbmZvcm1hbmNlLWZyYW1ld29ya1xcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYlxcaW50ZXJuYWxcXHN0cmVhbXN8dXRpbCIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS9pZ25vcmVkfEM6XFxVc2Vyc1xcamR1bmxlYXZ5XFxzb3VyY2VcXHJlcG9zXFxGREMzLWNvbmZvcm1hbmNlLWZyYW1ld29ya1xcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYnx1dGlsIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvYnJvd3Nlci1lbnRyeS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2Jyb3dzZXIvaGlnaGxpZ2h0LXRhZ3MuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9icm93c2VyL3BhcnNlLXF1ZXJ5LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvYnJvd3Nlci9wcm9ncmVzcy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ob29rLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy9iZGQuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9pbnRlcmZhY2VzL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvZXhwb3J0cy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL2ludGVyZmFjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9pbnRlcmZhY2VzL3F1bml0LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvaW50ZXJmYWNlcy90ZGQuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9tb2NoYS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3BlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvYmFzZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9kb2MuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvZG90LmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2h0bWwuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvanNvbi1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvanNvbi5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy9sYW5kaW5nLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL2xpc3QuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbWFya2Rvd24uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvbWluLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvcmVwb3J0ZXJzL255YW4uanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvcHJvZ3Jlc3MuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMvc3BlYy5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3JlcG9ydGVycy90YXAuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9yZXBvcnRlcnMveHVuaXQuanMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYi9ydW5uYWJsZS5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3J1bm5lci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N0YXRzLWNvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3N1aXRlLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9tb2NoYS9saWIvdGVzdC5qcyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS8uLi9ub2RlX21vZHVsZXMvbW9jaGEvbGliL3V0aWxzLmpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4uL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5janMiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2UvLi4vbm9kZV9tb2R1bGVzL2NoYWkvaW5kZXgubWpzIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZmRjM0NvbXBsaWFuY2Uvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9mZGMzQ29tcGxpYW5jZS93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL2ZkYzNDb21wbGlhbmNlLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZkYzNDb21wbGlhbmNlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZkYzNDb21wbGlhbmNlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgKCkgPT4ge1xucmV0dXJuICIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBBc3NlcnRpb25FcnJvcjtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsInZhciBXcml0YWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLldyaXRhYmxlXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyU3Rkb3V0XG5cblxuaW5oZXJpdHMoQnJvd3NlclN0ZG91dCwgV3JpdGFibGVTdHJlYW0pXG5cbmZ1bmN0aW9uIEJyb3dzZXJTdGRvdXQob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnJvd3NlclN0ZG91dCkpIHJldHVybiBuZXcgQnJvd3NlclN0ZG91dChvcHRzKVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIFdyaXRhYmxlU3RyZWFtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5sYWJlbCA9IChvcHRzLmxhYmVsICE9PSB1bmRlZmluZWQpID8gb3B0cy5sYWJlbCA6ICdzdGRvdXQnXG59XG5cbkJyb3dzZXJTdGRvdXQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rcywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBvdXRwdXQgPSBjaHVua3MudG9TdHJpbmcgPyBjaHVua3MudG9TdHJpbmcoKSA6IGNodW5rc1xuICBpZiAodGhpcy5sYWJlbCA9PT0gZmFsc2UpIHtcbiAgICBjb25zb2xlLmxvZyhvdXRwdXQpXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2codGhpcy5sYWJlbCsnOicsIG91dHB1dClcbiAgfVxuICBwcm9jZXNzLm5leHRUaWNrKGNiKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB1c2VkID0gW107XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzQuMy4zJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbihleHBvcnRzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuXG4vKiFcbiAqIFV0aWxpdHkgRnVuY3Rpb25zXG4gKi9cblxuZXhwb3J0cy51dGlsID0gdXRpbDtcblxuLyohXG4gKiBDb25maWd1cmF0aW9uXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY2hhaS9jb25maWcnKTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuXG4vKiFcbiAqIFByaW1hcnkgYEFzc2VydGlvbmAgcHJvdG90eXBlXG4gKi9cblxudmFyIGFzc2VydGlvbiA9IHJlcXVpcmUoJy4vY2hhaS9hc3NlcnRpb24nKTtcbmV4cG9ydHMudXNlKGFzc2VydGlvbik7XG5cbi8qIVxuICogQ29yZSBBc3NlcnRpb25zXG4gKi9cblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NoYWkvY29yZS9hc3NlcnRpb25zJyk7XG5leHBvcnRzLnVzZShjb3JlKTtcblxuLyohXG4gKiBFeHBlY3QgaW50ZXJmYWNlXG4gKi9cblxudmFyIGV4cGVjdCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvZXhwZWN0Jyk7XG5leHBvcnRzLnVzZShleHBlY3QpO1xuXG4vKiFcbiAqIFNob3VsZCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgc2hvdWxkID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9zaG91bGQnKTtcbmV4cG9ydHMudXNlKHNob3VsZCk7XG5cbi8qIVxuICogQXNzZXJ0IGludGVyZmFjZVxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2Fzc2VydCcpO1xuZXhwb3J0cy51c2UoYXNzZXJ0KTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2NoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb25FcnJvciA9IF9jaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICBfY2hhaS5Bc3NlcnRpb24gPSBBc3NlcnRpb247XG5cbiAgLyohXG4gICAqIEFzc2VydGlvbiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBDcmVhdGVzIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIGBBc3NlcnRpb25gIG9iamVjdHMgY29udGFpbiBtZXRhZGF0YSBpbiB0aGUgZm9ybSBvZiBmbGFncy4gVGhyZWUgZmxhZ3MgY2FuXG4gICAqIGJlIGFzc2lnbmVkIGR1cmluZyBpbnN0YW50aWF0aW9uIGJ5IHBhc3NpbmcgYXJndW1lbnRzIHRvIHRoaXMgY29uc3RydWN0b3I6XG4gICAqXG4gICAqIC0gYG9iamVjdGA6IFRoaXMgZmxhZyBjb250YWlucyB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb24uIEZvciBleGFtcGxlLCBpblxuICAgKiAgIHRoZSBhc3NlcnRpb24gYGV4cGVjdChudW1LaXR0ZW5zKS50by5lcXVhbCg3KTtgLCB0aGUgYG9iamVjdGAgZmxhZyB3aWxsXG4gICAqICAgY29udGFpbiBgbnVtS2l0dGVuc2Agc28gdGhhdCB0aGUgYGVxdWFsYCBhc3NlcnRpb24gY2FuIHJlZmVyZW5jZSBpdCB3aGVuXG4gICAqICAgbmVlZGVkLlxuICAgKlxuICAgKiAtIGBtZXNzYWdlYDogVGhpcyBmbGFnIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIGJlXG4gICAqICAgcHJlcGVuZGVkIHRvIHRoZSBlcnJvciBtZXNzYWdlIHRoYXQncyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2VydGlvbiB3aGVuIGl0XG4gICAqICAgZmFpbHMuXG4gICAqXG4gICAqIC0gYHNzZmlgOiBUaGlzIGZsYWcgc3RhbmRzIGZvciBcInN0YXJ0IHN0YWNrIGZ1bmN0aW9uIGluZGljYXRvclwiLiBJdFxuICAgKiAgIGNvbnRhaW5zIGEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgc2VydmVzIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3JcbiAgICogICByZW1vdmluZyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgdGhlIGVycm9yIHRoYXQncyBjcmVhdGVkIGJ5IHRoZVxuICAgKiAgIGFzc2VydGlvbiB3aGVuIGl0IGZhaWxzLiBUaGUgZ29hbCBpcyB0byBwcm92aWRlIGEgY2xlYW5lciBzdGFjayB0cmFjZSB0b1xuICAgKiAgIGVuZCB1c2VycyBieSByZW1vdmluZyBDaGFpJ3MgaW50ZXJuYWwgZnVuY3Rpb25zLiBOb3RlIHRoYXQgaXQgb25seSB3b3Jrc1xuICAgKiAgIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCwgYW5kIG9ubHkgd2hlblxuICAgKiAgIGBDaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2tgIGhhc24ndCBiZWVuIHNldCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAtIGBsb2NrU3NmaWA6IFRoaXMgZmxhZyBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHNzZmlgIGZsYWdcbiAgICogICBzaG91bGQgcmV0YWluIGl0cyBjdXJyZW50IHZhbHVlLCBldmVuIGFzIGFzc2VydGlvbnMgYXJlIGNoYWluZWQgb2ZmIG9mXG4gICAqICAgdGhpcyBvYmplY3QuIFRoaXMgaXMgdXN1YWxseSBzZXQgdG8gYHRydWVgIHdoZW4gY3JlYXRpbmcgYSBuZXcgYXNzZXJ0aW9uXG4gICAqICAgZnJvbSB3aXRoaW4gYW5vdGhlciBhc3NlcnRpb24uIEl0J3MgYWxzbyB0ZW1wb3JhcmlseSBzZXQgdG8gYHRydWVgIGJlZm9yZVxuICAgKiAgIGFuIG92ZXJ3cml0dGVuIGFzc2VydGlvbiBnZXRzIGNhbGxlZCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmogdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAob3B0aW9uYWwpIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNzZmkgKG9wdGlvbmFsKSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3Zpbmcgc3RhY2sgZnJhbWVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9ja1NzZmkgKG9wdGlvbmFsKSB3aGV0aGVyIG9yIG5vdCB0aGUgc3NmaSBmbGFnIGlzIGxvY2tlZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3NmaSwgbG9ja1NzZmkpIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3NmaSB8fCBBc3NlcnRpb24pO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgbG9ja1NzZmkpO1xuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIG9iaik7XG4gICAgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICByZXR1cm4gdXRpbC5wcm94aWZ5KHRoaXMpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ2luY2x1ZGVTdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuaW5jbHVkZVN0YWNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5pbmNsdWRlU3RhY2sgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdzaG93RGlmZicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLnNob3dEaWZmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuc2hvd0RpZmYgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5hZGRDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UsIGV4cGVjdGVkLCBhY3R1YWwsIHNob3dEaWZmKVxuICAgKlxuICAgKiBFeGVjdXRlcyBhbiBleHByZXNzaW9uIGFuZCBjaGVjayBleHBlY3RhdGlvbnMuIFRocm93cyBBc3NlcnRpb25FcnJvciBmb3IgcmVwb3J0aW5nIGlmIHRlc3QgZG9lc24ndCBwYXNzLlxuICAgKlxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQHBhcmFtIHtQaGlsb3NvcGhpY2FsfSBleHByZXNzaW9uIHRvIGJlIHRlc3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWVzc2FnZSB0byBkaXNwbGF5IGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5lZ2F0ZWRNZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dEaWZmIChvcHRpb25hbCkgd2hlbiBzZXQgdG8gYHRydWVgLCBhc3NlcnQgd2lsbCBkaXNwbGF5IGEgZGlmZiBpbiBhZGRpdGlvbiB0byB0aGUgbWVzc2FnZSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChleHByLCBtc2csIG5lZ2F0ZU1zZywgZXhwZWN0ZWQsIF9hY3R1YWwsIHNob3dEaWZmKSB7XG4gICAgdmFyIG9rID0gdXRpbC50ZXN0KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGZhbHNlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSB0cnVlO1xuICAgIGlmICh1bmRlZmluZWQgPT09IGV4cGVjdGVkICYmIHVuZGVmaW5lZCA9PT0gX2FjdHVhbCkgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgbXNnID0gdXRpbC5nZXRNZXNzYWdlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBhc3NlcnRpb25FcnJvck9iamVjdFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH07XG5cbiAgICAgIHZhciBvcGVyYXRvciA9IHV0aWwuZ2V0T3BlcmF0b3IodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICBhc3NlcnRpb25FcnJvck9iamVjdFByb3BlcnRpZXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICBtc2csXG4gICAgICAgIGFzc2VydGlvbkVycm9yT2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBpbmNsdWRlU3RhY2s6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnNob3dEaWZmXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZSBgc2hvd0RpZmZgIGZsYWcgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB0aHJvd25cbiAgICogQXNzZXJ0aW9uRXJyb3JzLiBgZmFsc2VgIHdpbGwgYWx3YXlzIGJlIGBmYWxzZWA7IGB0cnVlYFxuICAgKiB3aWxsIGJlIHRydWUgd2hlbiB0aGUgYXNzZXJ0aW9uIGhhcyByZXF1ZXN0ZWQgYSBkaWZmXG4gICAqIGJlIHNob3duLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHNob3dEaWZmOiB0cnVlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnRydW5jYXRlVGhyZXNob2xkXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBzZXRzIGxlbmd0aCB0aHJlc2hvbGQgZm9yIGFjdHVhbCBhbmRcbiAgICogZXhwZWN0ZWQgdmFsdWVzIGluIGFzc2VydGlvbiBlcnJvcnMuIElmIHRoaXMgdGhyZXNob2xkIGlzIGV4Y2VlZGVkLCBmb3JcbiAgICogZXhhbXBsZSBmb3IgbGFyZ2UgZGF0YSBzdHJ1Y3R1cmVzLCB0aGUgdmFsdWUgaXMgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmdcbiAgICogbGlrZSBgWyBBcnJheSgzKSBdYCBvciBgeyBPYmplY3QgKHByb3AxLCBwcm9wMikgfWAuXG4gICAqXG4gICAqIFNldCBpdCB0byB6ZXJvIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdHJ1bmNhdGluZyBhbHRvZ2V0aGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlcmZ1bCB3aGVuIGRvaW5nIGFzc2VydGlvbnMgb24gYXJyYXlzOiBoYXZpbmcgdGhpc1xuICAgKiBzZXQgdG8gYSByZWFzb25hYmxlIGxhcmdlIHZhbHVlIG1ha2VzIHRoZSBmYWlsdXJlIG1lc3NhZ2VzIHJlYWRpbHlcbiAgICogaW5zcGVjdGFibGUuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDA7ICAvLyBkaXNhYmxlIHRydW5jYXRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHRydW5jYXRlVGhyZXNob2xkOiA0MCxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy51c2VQcm94eVxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgZGVmaW5lcyBpZiBjaGFpIHdpbGwgdXNlIGEgUHJveHkgdG8gdGhyb3dcbiAgICogYW4gZXJyb3Igd2hlbiBhIG5vbi1leGlzdGVudCBwcm9wZXJ0eSBpcyByZWFkLCB3aGljaCBwcm90ZWN0cyB1c2Vyc1xuICAgKiBmcm9tIHR5cG9zIHdoZW4gdXNpbmcgcHJvcGVydHktYmFzZWQgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudXNlUHJveHkgPSBmYWxzZTsgIC8vIGRpc2FibGUgdXNlIG9mIFByb3h5XG4gICAqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBhdXRvbWF0aWNhbGx5IGRpc2FibGVkIHJlZ2FyZGxlc3Mgb2YgdGhpcyBjb25maWcgdmFsdWVcbiAgICogaW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwcm94aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHVzZVByb3h5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBkZWZpbmVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICogaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGUgYXNzZXJ0aW9uLlxuICAgKiBUaGlzIGlzIG9ubHkgYXBwbGllZCBpZiB0aGUgZW52aXJvbm1lbnQgQ2hhaSBpcyBydW5uaW5nIGluIHN1cHBvcnRzIHByb3hpZXMgYW5kXG4gICAqIGlmIHRoZSBgdXNlUHJveHlgIGNvbmZpZ3VyYXRpb24gc2V0dGluZyBpcyBlbmFibGVkLlxuICAgKiBCeSBkZWZhdWx0LCBgdGhlbmAgYW5kIGBpbnNwZWN0YCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGVcbiAgICogYXNzZXJ0aW9uIG9iamVjdCBiZWNhdXNlIHRoZSBgLmluc3BlY3RgIHByb3BlcnR5IGlzIHJlYWQgYnkgYHV0aWwuaW5zcGVjdGAgKGZvciBleGFtcGxlLCB3aGVuXG4gICAqIHVzaW5nIGBjb25zb2xlLmxvZ2Agb24gdGhlIGFzc2VydGlvbiBvYmplY3QpIGFuZCBgLnRoZW5gIGlzIG5lY2Vzc2FyeSBmb3IgcHJvbWlzZSB0eXBlLWNoZWNraW5nLlxuICAgKlxuICAgKiAgICAgLy8gQnkgZGVmYXVsdCB0aGVzZSBrZXlzIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZSBhc3NlcnRpb24gb2JqZWN0XG4gICAqICAgICBjaGFpLmNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5cyA9IFsndGhlbicsICdpbnNwZWN0J107XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHByb3h5RXhjbHVkZWRLZXlzOiBbJ3RoZW4nLCAnY2F0Y2gnLCAnaW5zcGVjdCcsICd0b0pTT04nXVxufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgQXNzZXJ0aW9uRXJyb3IgPSBjaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5XG4gICAqIG9mIHlvdXIgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gd2hpY2hcbiAgICogLSBhbmRcbiAgICogLSBoYXNcbiAgICogLSBoYXZlXG4gICAqIC0gd2l0aFxuICAgKiAtIGF0XG4gICAqIC0gb2ZcbiAgICogLSBzYW1lXG4gICAqIC0gYnV0XG4gICAqIC0gZG9lc1xuICAgKiAtIHN0aWxsXG4gICAqIC0gYWxzb1xuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbicsICdpcydcbiAgLCAnYW5kJywgJ2hhcycsICdoYXZlJywgJ3dpdGgnXG4gICwgJ3RoYXQnLCAnd2hpY2gnLCAnYXQnLCAnb2YnXG4gICwgJ3NhbWUnLCAnYnV0JywgJ2RvZXMnLCAnc3RpbGwnLCBcImFsc29cIiBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYWxsIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHt9KS50by5ub3QudGhyb3coKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5iZS5hbignYXJyYXknKS50aGF0LmRvZXMubm90LmluY2x1ZGUoMyk7XG4gICAqXG4gICAqIEp1c3QgYmVjYXVzZSB5b3UgY2FuIG5lZ2F0ZSBhbnkgYXNzZXJ0aW9uIHdpdGggYC5ub3RgIGRvZXNuJ3QgbWVhbiB5b3VcbiAgICogc2hvdWxkLiBXaXRoIGdyZWF0IHBvd2VyIGNvbWVzIGdyZWF0IHJlc3BvbnNpYmlsaXR5LiBJdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIG9uZSBleHBlY3RlZCBvdXRwdXQgd2FzIHByb2R1Y2VkLCByYXRoZXIgdGhhbiBhc3NlcnRpbmdcbiAgICogdGhhdCBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgb3V0cHV0cyB3YXNuJ3QgcHJvZHVjZWQuIFNlZSBpbmRpdmlkdWFsXG4gICAqIGFzc2VydGlvbnMgZm9yIHNwZWNpZmljIGd1aWRhbmNlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5lcXVhbCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAuZXF1YWxgLCBgLmluY2x1ZGVgLCBgLm1lbWJlcnNgLCBgLmtleXNgLCBhbmQgYC5wcm9wZXJ0eWBcbiAgICogYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZCBvZiBzdHJpY3RcbiAgICogKGA9PT1gKSBlcXVhbGl0eS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcFxuICAgKiBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5kZWVwLmVxdWFsKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmRlZXAuaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaW5jbHVkZSh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmRlZXAuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBtZW1iZXIgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uaGF2ZS5kZWVwLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaGF2ZS5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuZGVlcC5rZXlzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8ubm90LmhhdmUua2V5cyhbe2E6IDF9XSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIHByb3BlcnR5IGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRcbiAgICpcbiAgICogRW5hYmxlcyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGluIGFsbCBgLnByb3BlcnR5YCBhbmQgYC5pbmNsdWRlYFxuICAgKiBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScpO1xuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5uZXN0ZWQuaW5jbHVkZSh7J2EuYlsxXSc6ICd5J30pO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnXFxcXC5hLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqXG4gICAqIGAubmVzdGVkYCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBgLm93bmAuXG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25lc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZXN0ZWQnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5wcm9wZXJ0eWAgYW5kIGAuaW5jbHVkZWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW5cbiAgICogdG8gaWdub3JlIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBgLm93bmAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggYC5uZXN0ZWRgLlxuICAgKlxuICAgKiBAbmFtZSBvd25cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3duJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9yZGVyZWRcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLm1lbWJlcnNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdFxuICAgKiBtZW1iZXJzIGJlIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzEsIDJdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5oYXZlLm9yZGVyZWQubWVtYmVycyhbMiwgMV0pO1xuICAgKlxuICAgKiBXaGVuIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZVxuICAgKiBzdGFydCBvZiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKFsxLCAyXSlcbiAgICogICAgICAgLmJ1dC5ub3QuaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoWzIsIDNdKTtcbiAgICpcbiAgICogQG5hbWUgb3JkZXJlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29yZGVyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3JkZXJlZCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbnlcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mXG4gICAqIGAuYWxsYCwgd2hpY2ggcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbnlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbnknLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbGxcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBgLmFueWAsIHdoaWNoXG4gICAqIG9ubHkgcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBgLmFsbGAgaXMgdXNlZCBieSBkZWZhdWx0IHdoZW4gbmVpdGhlciBgLmFsbGAgbm9yIGAuYW55YCBhcmVcbiAgICogYWRkZWQgZWFybGllciBpbiB0aGUgY2hhaW4uIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbGxgIGFueXdheVxuICAgKiBiZWNhdXNlIGl0IGltcHJvdmVzIHJlYWRhYmlsaXR5LlxuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIHR5cGUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHN0cmluZyBgdHlwZWAuIFR5cGVzXG4gICAqIGFyZSBjYXNlIGluc2Vuc2l0aXZlLiBTZWUgdGhlIGB0eXBlLWRldGVjdGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZVxuICAgKiB0eXBlIGRldGVjdGlvbiBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvdHlwZS1kZXRlY3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRXJyb3IpLnRvLmJlLmFuKCdlcnJvcicpO1xuICAgKiAgICAgZXhwZWN0KFByb21pc2UucmVzb2x2ZSgpKS50by5iZS5hKCdwcm9taXNlJyk7XG4gICAqICAgICBleHBlY3QobmV3IEZsb2F0MzJBcnJheSkudG8uYmUuYSgnZmxvYXQzMmFycmF5Jyk7XG4gICAqICAgICBleHBlY3QoU3ltYm9sKCkpLnRvLmJlLmEoJ3N5bWJvbCcpO1xuICAgKlxuICAgKiBgLmFgIHN1cHBvcnRzIG9iamVjdHMgdGhhdCBoYXZlIGEgY3VzdG9tIHR5cGUgc2V0IHZpYSBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtcbiAgICogICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdteUN1c3RvbVR5cGUnXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5iZS5hKCdteUN1c3RvbVR5cGUnKS5idXQubm90LmFuKCdvYmplY3QnKTtcbiAgICpcbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIHVzZSBgLmFgIHRvIGNoZWNrIGEgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgbWFraW5nIG1vcmVcbiAgICogYXNzZXJ0aW9ucyBvbiB0aGUgc2FtZSB0YXJnZXQuIFRoYXQgd2F5LCB5b3UgYXZvaWQgdW5leHBlY3RlZCBiZWhhdmlvciBmcm9tXG4gICAqIGFueSBhc3NlcnRpb24gdGhhdCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5iZS5hbignYXJyYXknKS50aGF0LmluY2x1ZGVzKDIpO1xuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5hbignYXJyYXknKS50aGF0LmlzLmVtcHR5O1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZXhwZWN0ZWQgdHlwZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXRcbiAgICogaXNuJ3Qgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB0eXBlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5hbignYXJyYXknKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvXG4gICAqIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmEoJ3N0cmluZycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqXG4gICAqIGAuYWAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mXG4gICAqIHlvdXIgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLmhhdmUuYS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5hbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5hYC5cbiAgICpcbiAgICogQG5hbWUgYVxuICAgKiBAYWxpYXMgYW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgc3RyaW5nLCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gc3RyaW5nIGB2YWxgXG4gICAqIGlzIGEgc3Vic3RyaW5nIG9mIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmluY2x1ZGUoJ2ZvbycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBhXG4gICAqIG1lbWJlciBvZiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIG9iamVjdFxuICAgKiBgdmFsYCdzIHByb3BlcnRpZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZSh7YTogMSwgYjogMn0pO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBTZXQgb3IgV2Vha1NldCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGB2YWxgIGlzIGFcbiAgICogbWVtYmVyIG9mIHRoZSB0YXJnZXQuIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtIGlzIHVzZWQuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMl0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBNYXAsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBvbmUgb2ZcbiAgICogdGhlIHZhbHVlcyBvZiB0aGUgdGFyZ2V0LiBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBCZWNhdXNlIGAuaW5jbHVkZWAgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5pbmNsdWRlYC4gU2VlIHRoZSBgLmFgXG4gICAqIGRvYyBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaW5jbHVkZXMoMik7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBhcnJheSBtZW1iZXJzIGFuZFxuICAgKiBvYmplY3QgcHJvcGVydGllcy4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHlcbiAgICogaW5zdGVhZCAoV2Vha1NldCB0YXJnZXRzIGFyZSBub3Qgc3VwcG9ydGVkKS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3RcbiAgICogcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5kZWVwLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmluY2x1ZGUoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5kZWVwLmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBvZiB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmUgc2VhcmNoZWQgd2hlbiB3b3JraW5nIHdpdGhcbiAgICogb2JqZWN0cy4gVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluaGVyaXRlZCBhbmQvb3Igbm9uLWVudW1lcmFibGUuXG4gICAqIEFkZCBgLm93bmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZXhjbHVkZSB0aGUgdGFyZ2V0J3MgaW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgZnJvbSB0aGUgc2VhcmNoLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYSB0YXJnZXQgb2JqZWN0IGlzIGFsd2F5cyBvbmx5IHNlYXJjaGVkIGZvciBgdmFsYCdzIG93blxuICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAub3duYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiAyfX0pLnRvLmRlZXAub3duLmluY2x1ZGUoe2E6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBBZGQgYC5uZXN0ZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGVuYWJsZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIHdoZW5cbiAgICogcmVmZXJlbmNpbmcgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzFdJzogJ3knfSk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogMn19KS50by5uZXN0ZWQuaW5jbHVkZSh7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IDJ9KTtcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5uZXN0ZWRgIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFt7YzogM31dfX0pLnRvLmRlZXAubmVzdGVkLmluY2x1ZGUoeydhLmJbMF0nOiB7YzogM319KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaW5jbHVkZSgndGFjbycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUoNCk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLmluY2x1ZGVgIHdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3QuXG4gICAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgb2JqZWN0IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgYHZhbGAncyBrZXkvdmFsdWUgcGFpcnMgYnV0IG1heSBvciBtYXlcbiAgICogbm90IGhhdmUgc29tZSBvZiB0aGVtLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3NcbiAgICogZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IG9iamVjdCBpc24ndCBldmVuIGV4cGVjdGVkIHRvIGhhdmUgYHZhbGAncyBrZXlzLCBpdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YzogM30pLnRvLm5vdC5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YzogM30pLnRvLm5vdC5pbmNsdWRlKHthOiAxLCBiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYHZhbGAncyBrZXlzLCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgZWFjaCBvZiB0aGUgcHJvcGVydGllcyBoYXMgaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBlYWNoIHByb3BlcnR5IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMywgYjogNH0pLnRvLmluY2x1ZGUoe2E6IDMsIGI6IDR9KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMywgYjogNH0pLnRvLm5vdC5pbmNsdWRlKHthOiAxLCBiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmluY2x1ZGVgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUoNCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY2x1ZGUoNCk7XG4gICAqXG4gICAqIGAuaW5jbHVkZWAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluLCBjYXVzaW5nIGFsbCBgLm1lbWJlcnNgIGFuZFxuICAgKiBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhlIHRhcmdldCB0byBiZSBhXG4gICAqIHN1cGVyc2V0IG9mIHRoZSBleHBlY3RlZCBzZXQsIHJhdGhlciB0aGFuIGFuIGlkZW50aWNhbCBzZXQuIE5vdGUgdGhhdFxuICAgKiBgLm1lbWJlcnNgIGlnbm9yZXMgZHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IHdoZW4gYC5pbmNsdWRlYCBpcyBhZGRlZC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QncyBrZXlzIGFyZSBhIHN1cGVyc2V0IG9mIFsnYScsICdiJ10gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLmluY2x1ZGUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8ubm90LmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGEgc3VwZXJzZXQgb2YgWzEsIDJdIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICpcbiAgICogICAgIC8vIER1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCBhcmUgaWdub3JlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyLCAyLCAyXSk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBhZGRpbmcgYC5hbnlgIGVhcmxpZXIgaW4gdGhlIGNoYWluIGNhdXNlcyB0aGUgYC5rZXlzYCBhc3NlcnRpb25cbiAgICogdG8gaWdub3JlIGAuaW5jbHVkZWAuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5pbmNsdWRlc2AsIGAuY29udGFpbmAsIGFuZCBgLmNvbnRhaW5zYCBjYW4gYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBhbGlhcyBpbmNsdWRlc1xuICAgKiBAYWxpYXMgY29udGFpbnNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKGEsIGIpIHtcbiAgICByZXR1cm4gKF8uaXNOYU4oYSkgJiYgXy5pc05hTihiKSkgfHwgYSA9PT0gYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIGRlc2NyaXB0b3IgPSBpc0RlZXAgPyAnZGVlcCAnIDogJyc7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICB2YXIgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIHN3aXRjaCAob2JqVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYWtzZXQnOlxuICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICd1bmFibGUgdG8gdXNlIC5kZWVwLmluY2x1ZGUgd2l0aCBXZWFrU2V0JyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaGFzKHZhbCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgICB2YXIgaXNFcWwgPSBpc0RlZXAgPyBfLmVxbCA6IFNhbWVWYWx1ZVplcm87XG4gICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBpc0VxbChpdGVtLCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBfLmVxbChpdGVtLCB2YWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmhhcyh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IG9iai5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoaXRlbSwgdmFsKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRoaXMgYmxvY2sgaXMgZm9yIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICAgICAgLy8gYF8uZXhwZWN0VHlwZXNgIGlzbid0IHVzZWQgaGVyZSBiZWNhdXNlIGAuaW5jbHVkZWAgc2hvdWxkIHdvcmsgd2l0aFxuICAgICAgICAvLyBvYmplY3RzIHdpdGggYSBjdXN0b20gYEBAdG9TdHJpbmdUYWdgLlxuICAgICAgICBpZiAodmFsICE9PSBPYmplY3QodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGdpdmVuIGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyAoJ1xuICAgICAgICAgICAgKyBvYmpUeXBlICsgJyBhbmQgJ1xuICAgICAgICAgICAgKyBfLnR5cGUodmFsKS50b0xvd2VyQ2FzZSgpICsgJyknXG4gICAgICAgICAgICArICcgaXMgaW52YWxpZCBmb3IgdGhpcyBhc3NlcnRpb24uICdcbiAgICAgICAgICAgICsgJ1lvdSBjYW4gdXNlIGFuIGFycmF5LCBhIG1hcCwgYW4gb2JqZWN0LCBhIHNldCwgYSBzdHJpbmcsICdcbiAgICAgICAgICAgICsgJ29yIGEgd2Vha3NldCBpbnN0ZWFkIG9mIGEgJ1xuICAgICAgICAgICAgKyBfLnR5cGUodmFsKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICAgICAgLCBmaXJzdEVyciA9IG51bGxcbiAgICAgICAgICAsIG51bUVycnMgPSAwO1xuXG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJvcEFzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24ob2JqKTtcbiAgICAgICAgICBfLnRyYW5zZmVyRmxhZ3ModGhpcywgcHJvcEFzc2VydGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgZmxhZyhwcm9wQXNzZXJ0aW9uLCAnbG9ja1NzZmknLCB0cnVlKTtcblxuICAgICAgICAgIGlmICghbmVnYXRlIHx8IHByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcHJvcEFzc2VydGlvbi5wcm9wZXJ0eShwcm9wLCB2YWxbcHJvcF0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9wQXNzZXJ0aW9uLnByb3BlcnR5KHByb3AsIHZhbFtwcm9wXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIV8uY2hlY2tFcnJvci5jb21wYXRpYmxlQ29uc3RydWN0b3IoZXJyLCBBc3NlcnRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RXJyID09PSBudWxsKSBmaXJzdEVyciA9IGVycjtcbiAgICAgICAgICAgIG51bUVycnMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFdoZW4gdmFsaWRhdGluZyAubm90LmluY2x1ZGUgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBvbmx5IHdhbnRcbiAgICAgICAgLy8gdG8gdGhyb3cgYW4gYXNzZXJ0aW9uIGVycm9yIGlmIGFsbCBvZiB0aGUgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgdGhyb3cgdGhlIGZpcnN0IHByb3BlcnR5IGFzc2VydGlvbiBlcnJvciB0aGF0IHdlXG4gICAgICAgIC8vIGVuY291bnRlcmVkLlxuICAgICAgICBpZiAobmVnYXRlICYmIHByb3BzLmxlbmd0aCA+IDEgJiYgbnVtRXJycyA9PT0gcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgZmlyc3RFcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFzc2VydCBpbmNsdXNpb24gaW4gY29sbGVjdGlvbiBvciBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbmNsdWRlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVzY3JpcHRvciArICdpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlc2NyaXB0b3IgKyAnaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbnMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY2x1ZGVzJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgdHJ1dGh5IHZhbHVlIChjb25zaWRlcmVkIGB0cnVlYCBpbiBib29sZWFuIGNvbnRleHQpLlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIG9yXG4gICAqIGRlZXBseSBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm9rYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgwKS50by5lcXVhbCgwKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRydWVgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUudHJ1ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZmFsc2VgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8ubm90LmJlLmZhbHNlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuZmFsc2U7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5udWxsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5udWxsOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC51bmRlZmluZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudW5kZWZpbmVkOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5OYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXhhY3RseSBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5OYU5gLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uZXF1YWwoJ2ZvbycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuTmFOOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQG5hbWUgTmFOXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnTmFOJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmlzTmFOKGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIE5hTidcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgTmFOJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5vdCBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGVpdGhlciBgbnVsbGAgb3JcbiAgICogYHVuZGVmaW5lZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvXG4gICAqIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMCkudG8uZXF1YWwoMCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMCkudG8uZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmV4aXN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwsICdub29vIHdoeSBmYWlsPz8nKS50by5leGlzdDtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZXhpc3RzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmV4aXN0YC5cbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQGFsaWFzIGV4aXN0c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFeGlzdCAoKSB7XG4gICAgdmFyIHZhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXhpc3QnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBleGlzdCdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGFzc2VydEV4aXN0KTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdHMnLCBhc3NlcnRFeGlzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIGFycmF5LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzXG4gICAqIGBsZW5ndGhgIHByb3BlcnR5IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYDBgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG1hcCBvciBzZXQsIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYHNpemVgXG4gICAqIHByb3BlcnR5IGlzIHN0cmljdGx5IGVxdWFsIHRvIGAwYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KCkpLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoKSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0XG4gICAqIGRvZXNuJ3QgaGF2ZSBhbnkgb3duIGVudW1lcmFibGUgcHJvcGVydGllcy4gUHJvcGVydGllcyB3aXRoIFN5bWJvbC1iYXNlZFxuICAgKiBrZXlzIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBjb3VudC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEJlY2F1c2UgYC5lbXB0eWAgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5lbXB0eWAuIFNlZSB0aGUgYC5hYFxuICAgKiBkb2MgZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaXMuZW1wdHk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZW1wdHlgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBjb250YWlucyBpdHMgZXhwZWN0ZWQgbnVtYmVyIG9mIHZhbHVlcyxcbiAgICogcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQncyBub3QgZW1wdHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyLCAzXSkpLnRvLmhhdmUucHJvcGVydHkoJ3NpemUnLCAzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyLCAzXSkpLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoT2JqZWN0LmtleXMoe2E6IDF9KSkudG8uaGF2ZS5sZW5ndGhPZigxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEBuYW1lIGVtcHR5XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBpdGVtc0NvdW50O1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gICAgc3dpdGNoIChfLnR5cGUodmFsKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpdGVtc0NvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgaXRlbXNDb3VudCA9IHZhbC5zaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlYWttYXAnOlxuICAgICAgY2FzZSAnd2Vha3NldCc6XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIGEgd2VhayBjb2xsZWN0aW9uJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICB2YXIgbXNnID0gZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBhIGZ1bmN0aW9uICcgKyBfLmdldE5hbWUodmFsKTtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZy50cmltKCksIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsICE9PSBPYmplY3QodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgbm9uLXN0cmluZyBwcmltaXRpdmUgJyArIF8uaW5zcGVjdCh2YWwpLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbXNDb3VudCA9IE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAwID09PSBpdGVtc0NvdW50XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGVtcHR5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgZW1wdHknXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYXJndW1lbnRzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICB0ZXN0KCk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYXJndW1lbnRzYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB3aGljaCB0eXBlIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGl04oCZcyBub3QgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmFyZ3VtZW50czsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hcmd1bWVudHM7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLkFyZ3VtZW50c2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5hcmd1bWVudHNgLlxuICAgKlxuICAgKiBAbmFtZSBhcmd1bWVudHNcbiAgICogQGFsaWFzIEFyZ3VtZW50c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBjaGVja0FyZ3VtZW50cyAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHR5cGUgPSBfLnR5cGUob2JqKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ0FyZ3VtZW50cycgPT09IHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXJndW1lbnRzIGJ1dCBnb3QgJyArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFyZ3VtZW50cydcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnQXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKHZhbFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gdGhlIGdpdmVuIGB2YWxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5lcXVhbCgnZm9vJyk7XG4gICAqXG4gICAqIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZGVlcC5lcXVhbCh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxdWFsKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYFsxLCAyXWBcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmRlZXAuZXF1YWwoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5lcXVhbChbMSwgMl0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVxdWFsYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxdWFsYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5lcXVhbCgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5lcXVhbHNgIGFuZCBgZXFgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZXF1YWxgLlxuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICB2YXIgcHJldkxvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgICB0aGlzLmVxbCh2YWwpO1xuICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBwcmV2TG9ja1NzZmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IG9ialxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHRoaXMuX29ialxuICAgICAgICAsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWwnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFscycsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXEnLCBhc3NlcnRFcXVhbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXFsKG9ialssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYG9iamAuIFNlZSB0aGVcbiAgICogYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBpcyBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFsIHRvIHthOiAxfVxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSkuYnV0Lm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWwgdG8gWzEsIDJdXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5lcWwoWzEsIDJdKS5idXQubm90LmVxdWFsKFsxLCAyXSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXFsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyXG4gICAqIHRoYW4gbm90IGRlZXBseSBlcXVhbCB0byBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHthOiAxfSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXFsKHtiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmVxbGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uZXFsKHtiOiAyfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmVxbCh7YjogMn0pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5lcWxzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmVxbGAuXG4gICAqXG4gICAqIFRoZSBgLmRlZXAuZXF1YWxgIGFzc2VydGlvbiBpcyBhbG1vc3QgaWRlbnRpY2FsIHRvIGAuZXFsYCBidXQgd2l0aCBvbmVcbiAgICogZGlmZmVyZW5jZTogYC5kZWVwLmVxdWFsYCBjYXVzZXMgZGVlcCBlcXVhbGl0eSBjb21wYXJpc29ucyB0byBhbHNvIGJlIHVzZWRcbiAgICogZm9yIGFueSBvdGhlciBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogQG5hbWUgZXFsXG4gICAqIEBhbGlhcyBlcWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXFsKG9iaiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIF8uZXFsKG9iaiwgZmxhZyh0aGlzLCAnb2JqZWN0JykpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCBvYmpcbiAgICAgICwgdGhpcy5fb2JqXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFsJywgYXNzZXJ0RXFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXFscycsIGFzc2VydEVxbCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYWJvdmUoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hYm92ZSgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYWJvdmVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5hYm92ZSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWJvdmVgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hYm92ZSgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFib3ZlKDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmd0YCBhbmQgYC5ncmVhdGVyVGhhbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5hYm92ZWAuXG4gICAqXG4gICAqIEBuYW1lIGFib3ZlXG4gICAqIEBhbGlhcyBndFxuICAgKiBAYWxpYXMgZ3JlYXRlclRoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGFib3ZlIG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50ID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvXG4gICAqIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5sZWFzdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmxlYXN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuYXQubGVhc3QoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmxlYXN0YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubGVhc3QoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hdC5sZWFzdCgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5ndGVgIGFuZCBgLmdyZWF0ZXJUaGFuT3JFcXVhbGAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5sZWFzdGAuXG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuT3JFcXVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVhc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbGVhc3QgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBpdGVtc0NvdW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbk9yRXF1YWwnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3coblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBsZXNzIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5iZWxvdygyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYmVsb3coNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmJlbG93YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5ub3QuYmUuYmVsb3coMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmJlbG93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYmVsb3coMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5iZWxvdygxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5sdGAgYW5kIGAubGVzc1RoYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAuYmVsb3dgLlxuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRCZWxvdyAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBiZWxvdyBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBiZWxvdyBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGl0ZW1zQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hdC5tb3N0KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1vc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5iZS5hdC5tb3N0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5tb3N0YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubW9zdCgxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmF0Lm1vc3QoMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAubHRlYCBhbmQgYC5sZXNzVGhhbk9yRXF1YWxgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAubW9zdGAuXG4gICAqXG4gICAqIEBuYW1lIG1vc3RcbiAgICogQGFsaWFzIGx0ZVxuICAgKiBAYWxpYXMgbGVzc1RoYW5PckVxdWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIG1vc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbW9zdCBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhdCBtb3N0ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtb3N0JywgYXNzZXJ0TW9zdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0ZScsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbk9yRXF1YWwnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIG51bWJlciBvciBkYXRlIGBzdGFydGAsIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBmaW5pc2hgIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigxLCAzKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDIsIDMpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMSwgMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgc3RhcnRgLCBhbmQgbGVzc1xuICAgKiB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYGZpbmlzaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLCA0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAud2l0aGluYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC53aXRoaW5gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0KS50by5iZS53aXRoaW4oMSwgMywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDQsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS53aXRoaW4oMSwgMyk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXIgYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIHN0YXJ0VHlwZSA9IF8udHlwZShzdGFydCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmaW5pc2hUeXBlID0gXy50eXBlKGZpbmlzaCkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlXG4gICAgICAsIHJhbmdlID0gKHN0YXJ0VHlwZSA9PT0gJ2RhdGUnICYmIGZpbmlzaFR5cGUgPT09ICdkYXRlJylcbiAgICAgICAgICA/IHN0YXJ0LnRvSVNPU3RyaW5nKCkgKyAnLi4nICsgZmluaXNoLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICA6IHN0YXJ0ICsgJy4uJyArIGZpbmlzaDtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiAoc3RhcnRUeXBlICE9PSAnZGF0ZScgfHwgZmluaXNoVHlwZSAhPT0gJ2RhdGUnKSkpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnRzIHRvIHdpdGhpbiBtdXN0IGJlIGRhdGVzJztcbiAgICB9IGVsc2UgaWYgKChzdGFydFR5cGUgIT09ICdudW1iZXInIHx8IGZpbmlzaFR5cGUgIT09ICdudW1iZXInKSAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50cyB0byB3aXRoaW4gbXVzdCBiZSBudW1iZXJzJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA+PSBzdGFydCAmJiBpdGVtc0NvdW50IDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvclssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHsgfVxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBDYXQoKSkudG8uYmUuYW4uaW5zdGFuY2VvZihDYXQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIGAuaW5zdGFuY2VvZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmFuLmluc3RhbmNlb2YoQXJyYXksICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSk7XG4gICAqXG4gICAqIER1ZSB0byBsaW1pdGF0aW9ucyBpbiBFUzUsIGAuaW5zdGFuY2VvZmAgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZFxuICAgKiB3aGVuIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIGJ1aWx0LWluIG9iamVjdCBzdWNoIGFzXG4gICAqIGBBcnJheWAsIGBFcnJvcmAsIGFuZCBgTWFwYC4gU2VlIHlvdXIgdHJhbnNwaWxlcidzIGRvY3MgZm9yIGRldGFpbHM6XG4gICAqXG4gICAqIC0gKFtCYWJlbF0oaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvdXNhZ2UvY2F2ZWF0cy8jY2xhc3NlcykpXG4gICAqIC0gKFtUeXBlU2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29yaykpXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmluc3RhbmNlT2ZgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5zdGFuY2VvZmAuXG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlb2ZcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciB0YXJnZXQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHZhciBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIHZhciBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0luc3RhbmNlT2YgPSB0YXJnZXQgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICdUaGUgaW5zdGFuY2VvZiBhc3NlcnRpb24gbmVlZHMgYSBjb25zdHJ1Y3RvciBidXQgJ1xuICAgICAgICAgICAgKyBfLnR5cGUoY29uc3RydWN0b3IpICsgJyB3YXMgZ2l2ZW4uJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgbmFtZSA9ICdhbiB1bm5hbWVkIGNvbnN0cnVjdG9yJztcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNJbnN0YW5jZU9mXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICk7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VvZicsIGFzc2VydEluc3RhbmNlT2YpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZU9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkobmFtZVssIHZhbFssIG1zZ11dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScpO1xuICAgKlxuICAgKiBXaGVuIGB2YWxgIGlzIHByb3ZpZGVkLCBgLnByb3BlcnR5YCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgcHJvcGVydHkncyB2YWx1ZVxuICAgKiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZSB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yXG4gICAqIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBwcm9wZXJ0eSBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIFRoZSB0YXJnZXQncyBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIHNlYXJjaC4gQnkgZGVmYXVsdCwgYm90aCBvd24gYW5kIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZC5cbiAgICogQWRkIGAub3duYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBleGNsdWRlIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGZyb20gdGhlXG4gICAqIHNlYXJjaC5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnLCAxKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm93bmAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQWRkIGAubmVzdGVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBlbmFibGUgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiB3aGVuXG4gICAqIHJlZmVyZW5jaW5nIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdhLmJbMV0nLCAneScpO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAubmVzdGVkYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbe2M6IDN9XX19KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzBdJywge2M6IDN9KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLnByb3BlcnR5YCB3aGVuIHByb3ZpZGluZyBgdmFsYC4gVGhlXG4gICAqIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCwgb3IgdGhhdCBpdFxuICAgKiBkb2VzIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgIGJ1dCBpdHMgdmFsdWUgaXNuJ3QgZXF1YWwgdG9cbiAgICogdGhlIGdpdmVuIGB2YWxgLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3NcbiAgICogZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLFxuICAgKiBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHByb3BlcnR5IGhhcyBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlclxuICAgKiB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLnByb3BlcnR5YCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluXG4gICAqIHRvIGJlIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnKS50aGF0LmlzLmEoJ251bWJlcicpO1xuICAgKlxuICAgKiBgLnByb3BlcnR5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyBgdmFsYCwgb25seSB1c2UgdGhlXG4gICAqIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDIpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYicsIHVuZGVmaW5lZCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiBUaGUgYWJvdmUgYXNzZXJ0aW9uIGlzbid0IHRoZSBzYW1lIHRoaW5nIGFzIG5vdCBwcm92aWRpbmcgYHZhbGAuIEluc3RlYWQsXG4gICAqIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5IHRoYXQncyBlcXVhbCB0b1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFzc2VydGlvbnMgYC5vd25Qcm9wZXJ0eWAgYW5kIGAuaGF2ZU93blByb3BlcnR5YCBjYW4gYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm93bi5wcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbCAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0UHJvcGVydHkgKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgaXNOZXN0ZWQgPSBmbGFnKHRoaXMsICduZXN0ZWQnKVxuICAgICAgLCBpc093biA9IGZsYWcodGhpcywgJ293bicpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBuYW1lVHlwZSA9IHR5cGVvZiBuYW1lO1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuXG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICBpZiAobmFtZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ3RoZSBhcmd1bWVudCB0byBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgbmVzdGVkIHN5bnRheCcsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWVUeXBlICE9PSAnc3RyaW5nJyAmJiBuYW1lVHlwZSAhPT0gJ251bWJlcicgJiYgbmFtZVR5cGUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ3RoZSBhcmd1bWVudCB0byBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIHN5bWJvbCcsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNOZXN0ZWQgJiYgaXNPd24pIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgZmxhZ01zZyArICdUaGUgXCJuZXN0ZWRcIiBhbmQgXCJvd25cIiBmbGFncyBjYW5ub3QgYmUgY29tYmluZWQuJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgZmxhZ01zZyArICdUYXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIHBhdGhJbmZvID0gaXNOZXN0ZWQgPyBfLmdldFBhdGhJbmZvKG9iaiwgbmFtZSkgOiBudWxsXG4gICAgICAsIHZhbHVlID0gaXNOZXN0ZWQgPyBwYXRoSW5mby52YWx1ZSA6IG9ialtuYW1lXTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gJyc7XG4gICAgaWYgKGlzRGVlcCkgZGVzY3JpcHRvciArPSAnZGVlcCAnO1xuICAgIGlmIChpc093bikgZGVzY3JpcHRvciArPSAnb3duICc7XG4gICAgaWYgKGlzTmVzdGVkKSBkZXNjcmlwdG9yICs9ICduZXN0ZWQgJztcbiAgICBkZXNjcmlwdG9yICs9ICdwcm9wZXJ0eSAnO1xuXG4gICAgdmFyIGhhc1Byb3BlcnR5O1xuICAgIGlmIChpc093bikgaGFzUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKTtcbiAgICBlbHNlIGlmIChpc05lc3RlZCkgaGFzUHJvcGVydHkgPSBwYXRoSW5mby5leGlzdHM7XG4gICAgZWxzZSBoYXNQcm9wZXJ0eSA9IF8uaGFzUHJvcGVydHkob2JqLCBuYW1lKTtcblxuICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIG5lZ2F0ZWQgYXNzZXJ0aW9uIGZvciBib3RoIG5hbWUgYW5kIHZhbCwgbWVyZWx5IGhhdmluZ1xuICAgIC8vIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpc24ndCBlbm91Z2ggdG8gY2F1c2UgdGhlIGFzc2VydGlvbiB0b1xuICAgIC8vIGZhaWwuIEl0IG11c3QgYm90aCBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoYXQgcHJvcGVydHkgbXVzdCBlcXVhbCB0aGUgZ2l2ZW4gdmFsLiBUaGVyZWZvcmUsIHNraXAgdGhpcyBhc3NlcnRpb24gaW5cbiAgICAvLyBmYXZvciBvZiB0aGUgbmV4dC5cbiAgICBpZiAoIW5lZ2F0ZSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eSAmJiAoaXNEZWVwID8gXy5lcWwodmFsLCB2YWx1ZSkgOiB2YWwgPT09IHZhbHVlKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdwcm9wZXJ0eScsIGFzc2VydFByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBhc3NlcnRPd25Qcm9wZXJ0eSAobmFtZSwgdmFsdWUsIG1zZykge1xuICAgIGZsYWcodGhpcywgJ293bicsIHRydWUpO1xuICAgIGFzc2VydFByb3BlcnR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaGF2ZU93blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5RGVzY3JpcHRvcihuYW1lWywgZGVzY3JpcHRvclssIG1zZ11dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgaXRzIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuIGtleVxuICAgKiBgbmFtZWAuIEVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkIGluIHRoZVxuICAgKiBzZWFyY2guXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKlxuICAgKiBXaGVuIGBkZXNjcmlwdG9yYCBpcyBwcm92aWRlZCwgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFsc28gYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSBwcm9wZXJ0eSdzIGRlc2NyaXB0b3IgaXMgZGVlcGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBgZGVzY3JpcHRvcmAuIFNlZVxuICAgKiB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYicpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIHdoZW4gcHJvdmlkaW5nXG4gICAqIGEgYGRlc2NyaXB0b3JgLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieVxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGhcbiAgICogdGhlIGdpdmVuIGtleSBgbmFtZWAsIG9yIHRoYXQgaXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBrZXkgYG5hbWVgIGJ1dCBpdOKAmXMgbm90IGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYGRlc2NyaXB0b3JgLiBJdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlblxuICAgKiBrZXkgYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHByb3BlcnR5IGhhcyBpdHMgZXhwZWN0ZWRcbiAgICogZGVzY3JpcHRvciwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55XG4gICAqIHVuZXhwZWN0ZWQgZGVzY3JpcHRvcnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAzLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvd1xuICAgKiBpbiB0aGUgY2hhaW4gdG8gYmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZyb20gdGhlIG9yaWdpbmFsXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScpXG4gICAqICAgICAgIC50aGF0Lmhhcy5wcm9wZXJ0eSgnZW51bWVyYWJsZScsIHRydWUpO1xuICAgKlxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhXG4gICAqIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzb1xuICAgKiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmdcbiAgICogYGRlc2NyaXB0b3JgLCBvbmx5IHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAyLFxuICAgKiAgICAgfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDIsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSlcbiAgICogICAgICAgLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJywgdW5kZWZpbmVkLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqIFRoZSBhYm92ZSBhc3NlcnRpb24gaXNuJ3QgdGhlIHNhbWUgdGhpbmcgYXMgbm90IHByb3ZpZGluZyBgZGVzY3JpcHRvcmAuXG4gICAqIEluc3RlYWQsIGl0J3MgYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgaGFzIGEgYGJgIHByb3BlcnR5XG4gICAqIGRlc2NyaXB0b3IgdGhhdCdzIGRlZXBseSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvcmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgLlxuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIChuYW1lLCBkZXNjcmlwdG9yLCBtc2cpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBkZXNjcmlwdG9yO1xuICAgICAgZGVzY3JpcHRvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgYWN0dWFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iaiksIG5hbWUpO1xuICAgIGlmIChhY3R1YWxEZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIF8uZXFsKGRlc2NyaXB0b3IsIGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpICsgJywgZ290ICcgKyBfLmluc3BlY3QoYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG5vdCBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpXG4gICAgICAgICwgZGVzY3JpcHRvclxuICAgICAgICAsIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWxEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIG9yIGBzaXplYCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dKSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5sZW5ndGhPZmAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLCByYXRoZXIgdGhhbiBub3QgZXF1YWwgdG8gb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5oYXZlLmxlbmd0aE9mKDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5sZW5ndGhPZigyKTtcbiAgICpcbiAgICogYC5sZW5ndGhPZmAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluLCBjYXVzaW5nIGFsbCBgLmFib3ZlYCxcbiAgICogYC5iZWxvd2AsIGAubGVhc3RgLCBgLm1vc3RgLCBhbmQgYC53aXRoaW5gIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlXG4gICAqIGNoYWluIHRvIHVzZSB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgYXMgdGhlIHRhcmdldC4gSG93ZXZlciwgaXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgbGVuZ3RoLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdHMgYGxlbmd0aGAgcHJvcGVydHkgZmFsbHNcbiAgICogd2l0aGluIHNvbWUgcmFuZ2Ugb2YgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCgzKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIER1ZSB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIHRoZSBhbGlhcyBgLmxlbmd0aGAgY2FuJ3QgYmUgY2hhaW5lZCBkaXJlY3RseVxuICAgKiBvZmYgb2YgYW4gdW5pbnZva2VkIG1ldGhvZCBzdWNoIGFzIGAuYWAuIFRoZXJlZm9yZSwgYC5sZW5ndGhgIGNhbid0IGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5sZW5ndGhPZmAgaW4gZXZlcnkgc2l0dWF0aW9uLiBJdCdzIHJlY29tbWVuZGVkIHRvXG4gICAqIGFsd2F5cyB1c2UgYC5sZW5ndGhPZmAgaW5zdGVhZCBvZiBgLmxlbmd0aGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmEubGVuZ3RoKDMpOyAvLyBpbmNvbXBhdGlibGU7IHRocm93cyBlcnJvclxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5hLmxlbmd0aE9mKDMpOyAgLy8gcGFzc2VzIGFzIGV4cGVjdGVkXG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBhbGlhcyBsZW5ndGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aENoYWluICgpIHtcbiAgICBmbGFnKHRoaXMsICdkb0xlbmd0aCcsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgLCBpdGVtc0NvdW50O1xuXG4gICAgc3dpdGNoIChvYmpUeXBlKSB7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGl0ZW1zQ291bnQgPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGl0ZW1zQ291bnRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aE9mJywgYXNzZXJ0TGVuZ3RoLCBhc3NlcnRMZW5ndGhDaGFpbik7XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2gocmVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYHJlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tYXRjaGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5tYXRjaCgvdGFjby8pO1xuICAgKlxuICAgKiBgLm1hdGNoYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC90YWNvLywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInLCAnbm9vbyB3aHkgZmFpbD8/JykudG8ubWF0Y2goL3RhY28vKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAubWF0Y2hlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5tYXRjaGAuXG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBhbGlhcyBtYXRjaGVzXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1hdGNoKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGFzc2VydE1hdGNoKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGFzc2VydE1hdGNoKTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgc3RyaW5nIGNvbnRhaW5zIHRoZSBnaXZlbiBzdWJzdHJpbmcgYHN0cmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zdHJpbmdgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaGF2ZS5zdHJpbmcoJ3RhY28nKTtcbiAgICpcbiAgICogYC5zdHJpbmdgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ3RhY28nLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicsICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnN0cmluZygndGFjbycpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxWywga2V5MlssIC4uLl1dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBvYmplY3QsIGFycmF5LCBtYXAsIG9yIHNldCBoYXMgdGhlIGdpdmVuIGtleXMuIE9ubHlcbiAgICogdGhlIHRhcmdldCdzIG93biBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCBvciBhcnJheSwga2V5cyBjYW4gYmUgcHJvdmlkZWQgYXMgb25lIG9yIG1vcmVcbiAgICogc3RyaW5nIGFyZ3VtZW50cywgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIG9yIGEgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4gSW5cbiAgICogdGhlIGxhdHRlciBjYXNlLCBvbmx5IHRoZSBrZXlzIGluIHRoZSBnaXZlbiBvYmplY3QgbWF0dGVyOyB0aGUgdmFsdWVzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cygwLCAxKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoWydhJywgJ2InXSk7XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cyhbMCwgMV0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cyh7YTogNCwgYjogNX0pOyAvLyBpZ25vcmUgNCBhbmQgNVxuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoezA6IDQsIDE6IDV9KTsgLy8gaWdub3JlIDQgYW5kIDVcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbWFwIG9yIHNldCwgZWFjaCBrZXkgbXVzdCBiZSBwcm92aWRlZCBhcyBhIHNlcGFyYXRlXG4gICAqIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsnYScsICdiJ10pKS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmtleXNgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAua2V5c2AuIFNlZSB0aGUgYC5hYCBkb2NcbiAgICogZm9yIGluZm8gb24gdGVzdGluZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5iZS5hbignb2JqZWN0JykudGhhdC5oYXMuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUga2V5cyBvZiBtYXBzIGFuZFxuICAgKiBzZXRzLiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWVcbiAgICogdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuYWxsLmRlZXAua2V5cyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLm5vdC5oYXZlLmFsbC5rZXlzKFt7YTogMX1dKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHRhcmdldCBtdXN0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFuZCBubyBtb3JlLiBBZGRcbiAgICogYC5hbnlgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdFxuICAgKiBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIEFsc28sIGFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlXG4gICAqIGAua2V5c2AuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbnlgIHdoZW4gbmVnYXRpbmcgYC5rZXlzYCwgYW5kIHRvIHVzZVxuICAgKiBgLmFsbGAgd2hlbiBhc3NlcnRpbmcgYC5rZXlzYCB3aXRob3V0IG5lZ2F0aW9uLlxuICAgKlxuICAgKiBXaGVuIG5lZ2F0aW5nIGAua2V5c2AsIGAuYW55YCBpcyBwcmVmZXJyZWQgYmVjYXVzZSBgLm5vdC5hbnkua2V5c2AgYXNzZXJ0c1xuICAgKiBleGFjdGx5IHdoYXQncyBleHBlY3RlZCBvZiB0aGUgb3V0cHV0LCB3aGVyZWFzIGAubm90LmFsbC5rZXlzYCBjcmVhdGVzXG4gICAqIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBkb2Vzbid0IGhhdmUgYW55IG9mIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgZG9lc24ndCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW5cbiAgICogICAgIC8vIGtleXMgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqIFdoZW4gYXNzZXJ0aW5nIGAua2V5c2Agd2l0aG91dCBuZWdhdGlvbiwgYC5hbGxgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAqIGAuYWxsLmtleXNgIGFzc2VydHMgZXhhY3RseSB3aGF0J3MgZXhwZWN0ZWQgb2YgdGhlIG91dHB1dCwgd2hlcmVhc1xuICAgKiBgLmFueS5rZXlzYCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYWxsIHRoZSBnaXZlbiBrZXlzXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlblxuICAgKiAgICAgLy8ga2V5cyBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBtb3JlIG9mIHRoZW1cbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYC5hbGxgIGlzIHVzZWQgYnkgZGVmYXVsdCB3aGVuIG5laXRoZXIgYC5hbGxgIG5vciBgLmFueWAgYXBwZWFyXG4gICAqIGVhcmxpZXIgaW4gdGhlIGNoYWluLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYWxsYCBhbnl3YXkgYmVjYXVzZVxuICAgKiBpdCBpbXByb3ZlcyByZWFkYWJpbGl0eS5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUua2V5cygnYScsICdiJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5pbmNsdWRlYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCdzIGtleXMgYmUgYVxuICAgKiBzdXBlcnNldCBvZiB0aGUgZXhwZWN0ZWQga2V5cywgcmF0aGVyIHRoYW4gaWRlbnRpY2FsIHNldHMuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0J3Mga2V5cyBhcmUgYSBzdXBlcnNldCBvZiBbJ2EnLCAnYiddIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogSG93ZXZlciwgaWYgYC5hbnlgIGFuZCBgLmluY2x1ZGVgIGFyZSBjb21iaW5lZCwgb25seSB0aGUgYC5hbnlgIHRha2VzXG4gICAqIGVmZmVjdC4gVGhlIGAuaW5jbHVkZWAgaXMgaWdub3JlZCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLmtleSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5rZXlgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAua2V5c2AuXG4gICAqXG4gICAqIEBuYW1lIGtleXNcbiAgICogQGFsaWFzIGtleVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ3xBcnJheXxPYmplY3R9IGtleXNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iailcbiAgICAgICwga2V5c1R5cGUgPSBfLnR5cGUoa2V5cylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgc3RyXG4gICAgICAsIGRlZXBTdHIgPSAnJ1xuICAgICAgLCBhY3R1YWxcbiAgICAgICwgb2sgPSB0cnVlXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJyk7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgdmFyIG1peGVkQXJnc01zZyA9IGZsYWdNc2cgKyAnd2hlbiB0ZXN0aW5nIGtleXMgYWdhaW5zdCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgeW91IG11c3QgZ2l2ZSBhIHNpbmdsZSBBcnJheXxPYmplY3R8U3RyaW5nIGFyZ3VtZW50IG9yIG11bHRpcGxlIFN0cmluZyBhcmd1bWVudHMnO1xuXG4gICAgaWYgKG9ialR5cGUgPT09ICdNYXAnIHx8IG9ialR5cGUgPT09ICdTZXQnKSB7XG4gICAgICBkZWVwU3RyID0gaXNEZWVwID8gJ2RlZXBseSAnIDogJyc7XG4gICAgICBhY3R1YWwgPSBbXTtcblxuICAgICAgLy8gTWFwIGFuZCBTZXQgJy5rZXlzJyBhcmVuJ3Qgc3VwcG9ydGVkIGluIElFIDExLiBUaGVyZWZvcmUsIHVzZSAuZm9yRWFjaC5cbiAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkgeyBhY3R1YWwucHVzaChrZXkpIH0pO1xuXG4gICAgICBpZiAoa2V5c1R5cGUgIT09ICdBcnJheScpIHtcbiAgICAgICAga2V5cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IF8uZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqKTtcblxuICAgICAgc3dpdGNoIChrZXlzVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWl4ZWRBcmdzTXNnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtaXhlZEFyZ3NNc2csIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBzdHJpbmdpZnkgbm9uLVN5bWJvbHMgYmVjYXVzZSBTeW1ib2xzIHdvdWxkIGJlY29tZSBcIlN5bWJvbCgpXCJcbiAgICAgIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJyA/IHZhbCA6IFN0cmluZyh2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGZsYWdNc2cgKyAna2V5cyByZXF1aXJlZCcsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoXG4gICAgICAsIGFueSA9IGZsYWcodGhpcywgJ2FueScpXG4gICAgICAsIGFsbCA9IGZsYWcodGhpcywgJ2FsbCcpXG4gICAgICAsIGV4cGVjdGVkID0ga2V5cztcblxuICAgIGlmICghYW55ICYmICFhbGwpIHtcbiAgICAgIGFsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFueVxuICAgIGlmIChhbnkpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuc29tZShmdW5jdGlvbihleHBlY3RlZEtleSkge1xuICAgICAgICByZXR1cm4gYWN0dWFsLnNvbWUoZnVuY3Rpb24oYWN0dWFsS2V5KSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGV4cGVjdGVkS2V5LCBhY3R1YWxLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWRLZXkgPT09IGFjdHVhbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGFzIGFsbFxuICAgIGlmIChhbGwpIHtcbiAgICAgIG9rID0gZXhwZWN0ZWQuZXZlcnkoZnVuY3Rpb24oZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5zb21lKGZ1bmN0aW9uKGFjdHVhbEtleSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChleHBlY3RlZEtleSwgYWN0dWFsS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkS2V5ID09PSBhY3R1YWxLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gXy5pbnNwZWN0KGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgICAgfVxuICAgICAgaWYgKGFueSkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBvciAnICsgbGFzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gXy5pbnNwZWN0KGtleXNbMF0pO1xuICAgIH1cblxuICAgIC8vIEZvcm1cbiAgICBzdHIgPSAobGVuID4gMSA/ICdrZXlzICcgOiAna2V5ICcpICsgc3RyO1xuXG4gICAgLy8gSGF2ZSAvIGluY2x1ZGVcbiAgICBzdHIgPSAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSA/ICdjb250YWluICcgOiAnaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVlcFN0ciArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlZXBTdHIgKyBzdHJcbiAgICAgICwgZXhwZWN0ZWQuc2xpY2UoMCkuc29ydChfLmNvbXBhcmVCeUluc3BlY3QpXG4gICAgICAsIGFjdHVhbC5zb3J0KF8uY29tcGFyZUJ5SW5zcGVjdClcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXlzJywgYXNzZXJ0S2V5cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleScsIGFzc2VydEtleXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93KFtlcnJvckxpa2VdLCBbZXJyTXNnTWF0Y2hlcl0sIFttc2ddKVxuICAgKlxuICAgKiBXaGVuIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAudGhyb3dgIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmRcbiAgICogYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93bi5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KCk7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhbiBlcnJvciBjb25zdHJ1Y3RvciwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQncyBhblxuICAgKiBpbnN0YW5jZSBvZiB0aGF0IGVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGFuIGVycm9yIGluc3RhbmNlLCBgLnRocm93YCBpbnZva2VzXG4gICAqIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCdzIHN0cmljdGx5XG4gICAqIChgPT09YCkgZXF1YWwgdG8gdGhhdCBlcnJvciBpbnN0YW5jZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSBzdHJpbmcsIGAudGhyb3dgIGludm9rZXMgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGEgbWVzc2FnZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoYXQgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coJ3NhbG1vbicpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYSByZWd1bGFyIGV4cHJlc3Npb24sIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB3aXRoIGFcbiAgICogbWVzc2FnZSB0aGF0IG1hdGNoZXMgdGhhdCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygvc2FsbW9uLyk7XG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFuZCB0aGUgZmlyc3QgaXMgYW4gZXJyb3IgaW5zdGFuY2Ugb3JcbiAgICogY29uc3RydWN0b3IsIGFuZCB0aGUgc2Vjb25kIGlzIGEgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCBmdWxmaWxscyBib3RoXG4gICAqIGNvbmRpdGlvbnMgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsIC9zYWxtb24vKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyLCAnc2FsbW9uJyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVyciwgL3NhbG1vbi8pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRocm93YC5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdygpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC50aHJvd2Agd2hlbiBwcm92aWRpbmcgYW55IGFyZ3VtZW50cy5cbiAgICogVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBlaXRoZXIgZG9lc24ndCB0aHJvdyBhbiBlcnJvciwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3IgYnV0IG9mIGFcbiAgICogZGlmZmVyZW50IHR5cGUgdGhhbiB0aGUgZ2l2ZW4gdHlwZSwgb3IgdGhhdCBpdCB0aHJvd3MgYW4gZXJyb3Igb2YgdGhlIGdpdmVuXG4gICAqIHR5cGUgYnV0IHdpdGggYSBtZXNzYWdlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoZSBnaXZlbiBzdHJpbmcuIEl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3IsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogdGhhdCB0aGUgZXJyb3IgaXMgb2YgaXRzIGV4cGVjdGVkIHR5cGUsIGFuZCBoYXMgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgYW5cbiAgICogZXhwZWN0ZWQgc3RyaW5nLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnlcbiAgICogdW5leHBlY3RlZCB0eXBlcywgYW5kIGRvZXNuJ3QgaGF2ZSBhIG1lc3NhZ2UgdGhhdCBpbmNsdWRlcyBzb21lIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3NhbG1vbicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by5ub3QudGhyb3coUmVmZXJlbmNlRXJyb3IsICd4Jyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLnRocm93YCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvXG4gICAqIGJlIHRoZSBlcnJvciBvYmplY3QgdGhhdCdzIHRocm93bi5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIGVyci5jb2RlID0gNDI7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yKS53aXRoLnByb3BlcnR5KCdjb2RlJywgNDIpO1xuICAgKlxuICAgKiBgLnRocm93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXMgdXNlXG4gICAqIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLnRocm93KFR5cGVFcnJvciwgJ3gnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuLCAnbm9vbyB3aHkgZmFpbD8/JykudG8udGhyb3coKTtcbiAgICpcbiAgICogRHVlIHRvIGxpbWl0YXRpb25zIGluIEVTNSwgYC50aHJvd2AgbWF5IG5vdCBhbHdheXMgd29yayBhcyBleHBlY3RlZCB3aGVuXG4gICAqIHVzaW5nIGEgdHJhbnNwaWxlciBzdWNoIGFzIEJhYmVsIG9yIFR5cGVTY3JpcHQuIEluIHBhcnRpY3VsYXIsIGl0IG1heVxuICAgKiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aGVuIHN1YmNsYXNzaW5nIHRoZSBidWlsdC1pbiBgRXJyb3JgIG9iamVjdCBhbmRcbiAgICogdGhlbiBwYXNzaW5nIHRoZSBzdWJjbGFzc2VkIGNvbnN0cnVjdG9yIHRvIGAudGhyb3dgLiBTZWUgeW91ciB0cmFuc3BpbGVyJ3NcbiAgICogZG9jcyBmb3IgZGV0YWlsczpcbiAgICpcbiAgICogLSAoW0JhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9jYXZlYXRzLyNjbGFzc2VzKSlcbiAgICogLSAoW1R5cGVTY3JpcHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrKSlcbiAgICpcbiAgICogQmV3YXJlIG9mIHNvbWUgY29tbW9uIG1pc3Rha2VzIHdoZW4gdXNpbmcgdGhlIGB0aHJvd2AgYXNzZXJ0aW9uLiBPbmUgY29tbW9uXG4gICAqIG1pc3Rha2UgaXMgdG8gYWNjaWRlbnRhbGx5IGludm9rZSB0aGUgZnVuY3Rpb24geW91cnNlbGYgaW5zdGVhZCBvZiBsZXR0aW5nXG4gICAqIHRoZSBgdGhyb3dgIGFzc2VydGlvbiBpbnZva2UgdGhlIGZ1bmN0aW9uIGZvciB5b3UuIEZvciBleGFtcGxlLCB3aGVuXG4gICAqIHRlc3RpbmcgaWYgYSBmdW5jdGlvbiBuYW1lZCBgZm5gIHRocm93cywgcHJvdmlkZSBgZm5gIGluc3RlYWQgb2YgYGZuKClgIGFzXG4gICAqIHRoZSB0YXJnZXQgZm9yIHRoZSBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KCk7ICAgICAvLyBHb29kISBUZXN0cyBgZm5gIGFzIGRlc2lyZWRcbiAgICogICAgIGV4cGVjdChmbigpKS50by50aHJvdygpOyAgIC8vIEJhZCEgVGVzdHMgcmVzdWx0IG9mIGBmbigpYCwgbm90IGBmbmBcbiAgICpcbiAgICogSWYgeW91IG5lZWQgdG8gYXNzZXJ0IHRoYXQgeW91ciBmdW5jdGlvbiBgZm5gIHRocm93cyB3aGVuIHBhc3NlZCBjZXJ0YWluXG4gICAqIGFyZ3VtZW50cywgdGhlbiB3cmFwIGEgY2FsbCB0byBgZm5gIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgZm4oNDIpOyB9KS50by50aHJvdygpOyAgLy8gRnVuY3Rpb24gZXhwcmVzc2lvblxuICAgKiAgICAgZXhwZWN0KCgpID0+IGZuKDQyKSkudG8udGhyb3coKTsgICAgICAgICAgICAgLy8gRVM2IGFycm93IGZ1bmN0aW9uXG4gICAqXG4gICAqIEFub3RoZXIgY29tbW9uIG1pc3Rha2UgaXMgdG8gcHJvdmlkZSBhbiBvYmplY3QgbWV0aG9kIChvciBhbnkgc3RhbmQtYWxvbmVcbiAgICogZnVuY3Rpb24gdGhhdCByZWxpZXMgb24gYHRoaXNgKSBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb24uIERvaW5nIHNvIGlzXG4gICAqIHByb2JsZW1hdGljIGJlY2F1c2UgdGhlIGB0aGlzYCBjb250ZXh0IHdpbGwgYmUgbG9zdCB3aGVuIHRoZSBmdW5jdGlvbiBpc1xuICAgKiBpbnZva2VkIGJ5IGAudGhyb3dgOyB0aGVyZSdzIG5vIHdheSBmb3IgaXQgdG8ga25vdyB3aGF0IGB0aGlzYCBpcyBzdXBwb3NlZFxuICAgKiB0byBiZS4gVGhlcmUgYXJlIHR3byB3YXlzIGFyb3VuZCB0aGlzIHByb2JsZW0uIE9uZSBzb2x1dGlvbiBpcyB0byB3cmFwIHRoZVxuICAgKiBtZXRob2Qgb3IgZnVuY3Rpb24gY2FsbCBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbi4gQW5vdGhlciBzb2x1dGlvbiBpcyB0b1xuICAgKiB1c2UgYGJpbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHsgY2F0Lm1lb3coKTsgfSkudG8udGhyb3coKTsgIC8vIEZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICogICAgIGV4cGVjdCgoKSA9PiBjYXQubWVvdygpKS50by50aHJvdygpOyAgICAgICAgICAgICAvLyBFUzYgYXJyb3cgZnVuY3Rpb25cbiAgICogICAgIGV4cGVjdChjYXQubWVvdy5iaW5kKGNhdCkpLnRvLnRocm93KCk7ICAgICAgICAgICAvLyBCaW5kXG4gICAqXG4gICAqIEZpbmFsbHksIGl0J3Mgd29ydGggbWVudGlvbmluZyB0aGF0IGl0J3MgYSBiZXN0IHByYWN0aWNlIGluIEphdmFTY3JpcHQgdG9cbiAgICogb25seSB0aHJvdyBgRXJyb3JgIGFuZCBkZXJpdmF0aXZlcyBvZiBgRXJyb3JgIHN1Y2ggYXMgYFJlZmVyZW5jZUVycm9yYCxcbiAgICogYFR5cGVFcnJvcmAsIGFuZCB1c2VyLWRlZmluZWQgb2JqZWN0cyB0aGF0IGV4dGVuZCBgRXJyb3JgLiBObyBvdGhlciB0eXBlIG9mXG4gICAqIHZhbHVlIHdpbGwgZ2VuZXJhdGUgYSBzdGFjayB0cmFjZSB3aGVuIGluaXRpYWxpemVkLiBXaXRoIHRoYXQgc2FpZCwgdGhlXG4gICAqIGB0aHJvd2AgYXNzZXJ0aW9uIGRvZXMgdGVjaG5pY2FsbHkgc3VwcG9ydCBhbnkgdHlwZSBvZiB2YWx1ZSBiZWluZyB0aHJvd24sXG4gICAqIG5vdCBqdXN0IGBFcnJvcmAgYW5kIGl0cyBkZXJpdmF0aXZlcy5cbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC50aHJvd3NgIGFuZCBgLlRocm93YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLnRocm93YC5cbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNc2dNYXRjaGVyIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQHJldHVybnMgZXJyb3IgZm9yIGNoYWluaW5nIChudWxsIGlmIG5vIGVycm9yKVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRUaHJvd3MgKGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKSB8fCBmYWxzZTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIGVycm9yTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjYXVnaHRFcnI7XG4gICAgdHJ5IHtcbiAgICAgIG9iaigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2F1Z2h0RXJyID0gZXJyO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdGhlIG5lZ2F0ZSBmbGFnIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSB2YWxpZCBhcmd1bWVudCBpdCBtZWFucyB3ZSBkbyBleHBlY3QgYW4gZXJyb3JcbiAgICAvLyBidXQgd2Ugd2FudCBpdCB0byBtYXRjaCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICAgIHZhciBldmVyeUFyZ0lzVW5kZWZpbmVkID0gZXJyb3JMaWtlID09PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UndmUgZ290IHRoZSBuZWdhdGUgZmxhZyBlbmFibGVkIGFuZCBib3RoIGFyZ3MsIHdlIHNob3VsZCBvbmx5IGZhaWwgaWYgYm90aCBhcmVuJ3QgY29tcGF0aWJsZVxuICAgIC8vIFNlZSBJc3N1ZSAjNTUxIGFuZCBQUiAjNjgzQEdpdEh1YlxuICAgIHZhciBldmVyeUFyZ0lzRGVmaW5lZCA9IEJvb2xlYW4oZXJyb3JMaWtlICYmIGVyck1zZ01hdGNoZXIpO1xuICAgIHZhciBlcnJvckxpa2VGYWlsID0gZmFsc2U7XG4gICAgdmFyIGVyck1zZ01hdGNoZXJGYWlsID0gZmFsc2U7XG5cbiAgICAvLyBDaGVja2luZyBpZiBlcnJvciB3YXMgdGhyb3duXG4gICAgaWYgKGV2ZXJ5QXJnSXNVbmRlZmluZWQgfHwgIWV2ZXJ5QXJnSXNVbmRlZmluZWQgJiYgIW5lZ2F0ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0aGlzIHRvIGRpc3BsYXkgcmVzdWx0cyBjb3JyZWN0bHkgYWNjb3JkaW5nIHRvIHRoZWlyIHR5cGVzXG4gICAgICB2YXIgZXJyb3JMaWtlU3RyaW5nID0gJ2FuIGVycm9yJztcbiAgICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBlcnJvckxpa2VTdHJpbmcgPSAnI3tleHB9JztcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3JMaWtlKSB7XG4gICAgICAgIGVycm9yTGlrZVN0cmluZyA9IF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgY2F1Z2h0RXJyXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGVycm9yTGlrZVN0cmluZ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyBhbiBlcnJvciBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICwgZXJyb3JMaWtlICYmIGVycm9yTGlrZS50b1N0cmluZygpXG4gICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgIGNhdWdodEVyci50b1N0cmluZygpIDogKHR5cGVvZiBjYXVnaHRFcnIgPT09ICdzdHJpbmcnID8gY2F1Z2h0RXJyIDogY2F1Z2h0RXJyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JMaWtlICYmIGNhdWdodEVycikge1xuICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgaW5zdGFuY2VzIG9ubHkgaWYgYGVycm9yTGlrZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYEVycm9yYFxuICAgICAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBpc0NvbXBhdGlibGVJbnN0YW5jZSA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlSW5zdGFuY2UoY2F1Z2h0RXJyLCBlcnJvckxpa2UpO1xuXG4gICAgICAgIGlmIChpc0NvbXBhdGlibGVJbnN0YW5jZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgICAgLy8gVGhlc2UgY2hlY2tzIHdlcmUgY3JlYXRlZCB0byBlbnN1cmUgd2Ugd29uJ3QgZmFpbCB0b28gc29vbiB3aGVuIHdlJ3ZlIGdvdCBib3RoIGFyZ3MgYW5kIGEgbmVnYXRlXG4gICAgICAgICAgLy8gU2VlIElzc3VlICM1NTEgYW5kIFBSICM2ODNAR2l0SHViXG4gICAgICAgICAgaWYgKGV2ZXJ5QXJnSXNEZWZpbmVkICYmIG5lZ2F0ZSkge1xuICAgICAgICAgICAgZXJyb3JMaWtlRmFpbCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyICYmICFuZWdhdGUgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgICAgICAgLCBlcnJvckxpa2UudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAsIGNhdWdodEVyci50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wYXRpYmxlQ29uc3RydWN0b3IgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUNvbnN0cnVjdG9yKGNhdWdodEVyciwgZXJyb3JMaWtlKTtcbiAgICAgIGlmIChpc0NvbXBhdGlibGVDb25zdHJ1Y3RvciA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlrZUZhaWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID8gY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiBjYXVnaHRFcnIgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2F1Z2h0RXJyICYmIGVyck1zZ01hdGNoZXIgIT09IHVuZGVmaW5lZCAmJiBlcnJNc2dNYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIGNvbXBhdGlibGUgbWVzc2FnZXNcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9ICdpbmNsdWRpbmcnO1xuICAgICAgaWYgKGVyck1zZ01hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcGxhY2Vob2xkZXIgPSAnbWF0Y2hpbmcnXG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbXBhdGlibGVNZXNzYWdlID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVNZXNzYWdlKGNhdWdodEVyciwgZXJyTXNnTWF0Y2hlcik7XG4gICAgICBpZiAoaXNDb21wYXRpYmxlTWVzc2FnZSA9PT0gbmVnYXRlKSB7XG4gICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVyck1zZ01hdGNoZXJGYWlsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciAnICsgcGxhY2Vob2xkZXIgKyAnICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90ICcgKyBwbGFjZWhvbGRlciArICcgI3tleHB9J1xuICAgICAgICAgICAgLCAgZXJyTXNnTWF0Y2hlclxuICAgICAgICAgICAgLCAgXy5jaGVja0Vycm9yLmdldE1lc3NhZ2UoY2F1Z2h0RXJyKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGFzc2VydGlvbnMgZmFpbGVkIGFuZCBib3RoIHNob3VsZCd2ZSBtYXRjaGVkIHdlIHRocm93IGFuIGVycm9yXG4gICAgaWYgKGVycm9yTGlrZUZhaWwgJiYgZXJyTXNnTWF0Y2hlckZhaWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBuZWdhdGVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAsIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yTGlrZS50b1N0cmluZygpIDogZXJyb3JMaWtlICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSlcbiAgICAgICAgLCAoY2F1Z2h0RXJyIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVnaHRFcnIudG9TdHJpbmcoKSA6IGNhdWdodEVyciAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGNhdWdodEVycik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZFssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGAucmVzcG9uZFRvYCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHRhcmdldCBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBgbWV0aG9kYC4gVGhlIG1ldGhvZCBjYW4gYmUgb3duIG9yXG4gICAqIGluaGVyaXRlZCwgYW5kIGl0IGNhbiBiZSBlbnVtZXJhYmxlIG9yIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgYC5yZXNwb25kVG9gIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3NcbiAgICogYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAuIEFnYWluLCB0aGVcbiAgICogbWV0aG9kIGNhbiBiZSBvd24gb3IgaW5oZXJpdGVkLCBhbmQgaXQgY2FuIGJlIGVudW1lcmFibGUgb3Igbm9uLWVudW1lcmFibGUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEFkZCBgLml0c2VsZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZm9yY2UgYC5yZXNwb25kVG9gIHRvIHRyZWF0IHRoZVxuICAgKiB0YXJnZXQgYXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBldmVuIGlmIGl0J3MgYSBmdW5jdGlvbi4gVGh1cywgaXQgYXNzZXJ0c1xuICAgKiB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYSBtZXRob2Qgd2l0aCB0aGVcbiAgICogZ2l2ZW4gbmFtZSBgbWV0aG9kYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFdoZW4gbm90IGFkZGluZyBgLml0c2VsZmAsIGl0J3MgaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZVxuICAgKiB1c2luZyBgLnJlc3BvbmRUb2AuIFNlZSB0aGUgYC5hYCBkb2MgZm9yIGluZm8gb24gY2hlY2tpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLmJlLmFuKCdvYmplY3QnKS50aGF0LnJlc3BvbmRzVG8oJ21lb3cnKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5yZXNwb25kVG9gLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRG9nICgpIHt9XG4gICAqICAgICBEb2cucHJvdG90eXBlLmJhcmsgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgRG9nKCkpLnRvLm5vdC5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogYC5yZXNwb25kVG9gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSkudG8ucmVzcG9uZFRvKCdtZW93JywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHt9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLnJlc3BvbmRzVG9gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAucmVzcG9uZFRvYC5cbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBhbGlhcyByZXNwb25kc1RvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmRUbyAobWV0aG9kLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgaXRzZWxmID0gZmxhZyh0aGlzLCAnaXRzZWxmJylcbiAgICAgICwgY29udGV4dCA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb2JqICYmICFpdHNlbGYpXG4gICAgICAgID8gb2JqLnByb3RvdHlwZVttZXRob2RdXG4gICAgICAgIDogb2JqW21ldGhvZF07XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbnRleHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRUbycsIHJlc3BvbmRUbyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRzVG8nLCByZXNwb25kVG8pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBGb3JjZXMgYWxsIGAucmVzcG9uZFRvYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBiZWhhdmUgYXMgaWZcbiAgICogdGhlIHRhcmdldCBpcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGV2ZW4gaWYgaXQncyBhIGZ1bmN0aW9uLiBUaHVzLCBpdFxuICAgKiBjYXVzZXMgYC5yZXNwb25kVG9gIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuXG4gICAqIG5hbWUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYVxuICAgKiBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqICAgICBDYXQuaGlzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KENhdCkuaXRzZWxmLnRvLnJlc3BvbmRUbygnaGlzcycpLmJ1dC5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtYXRjaGVyWywgbXNnXSlcbiAgICpcbiAgICogSW52b2tlcyB0aGUgZ2l2ZW4gYG1hdGNoZXJgIGZ1bmN0aW9uIHdpdGggdGhlIHRhcmdldCBiZWluZyBwYXNzZWQgYXMgdGhlXG4gICAqIGZpcnN0IGFyZ3VtZW50LCBhbmQgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSByZXR1cm5lZCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDA7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zYXRpc2Z5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3Quc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogYC5zYXRpc2Z5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLnNhdGlzZmllc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5zYXRpc2Z5YC5cbiAgICpcbiAgICogQG5hbWUgc2F0aXNmeVxuICAgKiBAYWxpYXMgc2F0aXNmaWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNhdGlzZnkgKG1hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgcmVzdWx0ID0gbWF0Y2hlcihvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZXN1bHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gc2F0aXNmeSAnICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBzYXRpc2Z5JyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IGZhbHNlIDogdHJ1ZVxuICAgICAgLCByZXN1bHRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIHNhdGlzZnkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2ZpZXMnLCBzYXRpc2Z5KTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGV4cGVjdGVkLCBkZWx0YVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIHRoYXQncyB3aXRoaW4gYSBnaXZlbiArLy0gYGRlbHRhYCByYW5nZVxuICAgKiBvZiB0aGUgZ2l2ZW4gbnVtYmVyIGBleHBlY3RlZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5lcXVhbCgxLjUpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDEsIDAuNSk7XG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDIsIDAuNSk7XG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDEsIDEpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmNsb3NlVG9gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uZXF1YWwoMS41KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLm5vdC5iZS5jbG9zZVRvKDMsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5jbG9zZVRvYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMS41KS50by5iZS5jbG9zZVRvKDMsIDEsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLjUsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5jbG9zZVRvKDMsIDEpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5hcHByb3hpbWF0ZWx5YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmNsb3NlVG9gLlxuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBhbGlhcyBhcHByb3hpbWF0ZWx5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ251bWJlcicpO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdudW1iZXInIHx8IHR5cGVvZiBkZWx0YSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcbiAgICAgIHZhciBkZWx0YU1lc3NhZ2UgPSBkZWx0YSA9PT0gdW5kZWZpbmVkID8gXCIsIGFuZCBhIGRlbHRhIGlzIHJlcXVpcmVkXCIgOiBcIlwiO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGFyZ3VtZW50cyB0byBjbG9zZVRvIG9yIGFwcHJveGltYXRlbHkgbXVzdCBiZSBudW1iZXJzJyArIGRlbHRhTWVzc2FnZSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Nsb3NlVG8nLCBjbG9zZVRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXBwcm94aW1hdGVseScsIGNsb3NlVG8pO1xuXG4gIC8vIE5vdGU6IER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgaWYgdGVzdGluZyBmb3IgaW5jbHVzaW9uIGluc3RlYWQgb2Ygc2FtZW5lc3MuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0T2Yoc3Vic2V0LCBzdXBlcnNldCwgY21wLCBjb250YWlucywgb3JkZXJlZCkge1xuICAgIGlmICghY29udGFpbnMpIHtcbiAgICAgIGlmIChzdWJzZXQubGVuZ3RoICE9PSBzdXBlcnNldC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHN1cGVyc2V0ID0gc3VwZXJzZXQuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0sIGlkeCkge1xuICAgICAgaWYgKG9yZGVyZWQpIHJldHVybiBjbXAgPyBjbXAoZWxlbSwgc3VwZXJzZXRbaWR4XSkgOiBlbGVtID09PSBzdXBlcnNldFtpZHhdO1xuXG4gICAgICBpZiAoIWNtcCkge1xuICAgICAgICB2YXIgbWF0Y2hJZHggPSBzdXBlcnNldC5pbmRleE9mKGVsZW0pO1xuICAgICAgICBpZiAobWF0Y2hJZHggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1hdGNoIGZyb20gc3VwZXJzZXQgc28gbm90IGNvdW50ZWQgdHdpY2UgaWYgZHVwbGljYXRlIGluIHN1YnNldC5cbiAgICAgICAgaWYgKCFjb250YWlucykgc3VwZXJzZXQuc3BsaWNlKG1hdGNoSWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yLCBtYXRjaElkeCkge1xuICAgICAgICBpZiAoIWNtcChlbGVtLCBlbGVtMikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2ggZnJvbSBzdXBlcnNldCBzbyBub3QgY291bnRlZCB0d2ljZSBpZiBkdXBsaWNhdGUgaW4gc3Vic2V0LlxuICAgICAgICBpZiAoIWNvbnRhaW5zKSBzdXBlcnNldC5zcGxpY2UobWF0Y2hJZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXRbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBhcnJheSBoYXMgdGhlIHNhbWUgbWVtYmVycyBhcyB0aGUgZ2l2ZW4gYXJyYXlcbiAgICogYHNldGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDNdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgMl0pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgMl0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBtZW1iZXJzIGFyZSBjb21wYXJlZCB1c2luZyBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eS4gQWRkIGAuZGVlcGBcbiAgICogZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZSBgZGVlcC1lcWxgXG4gICAqIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgbWVtYmVyIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmhhdmUuZGVlcC5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmhhdmUubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG9yZGVyIGRvZXNuJ3QgbWF0dGVyLiBBZGQgYC5vcmRlcmVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0b1xuICAgKiByZXF1aXJlIHRoYXQgbWVtYmVycyBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm9yZGVyZWQubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAzXSlcbiAgICogICAgICAgLmJ1dC5ub3Qub3JkZXJlZC5tZW1iZXJzKFsyLCAxLCAzXSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGJvdGggYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgc2l6ZS4gQWRkIGAuaW5jbHVkZWAgZWFybGllciBpblxuICAgKiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQncyBtZW1iZXJzIGJlIGEgc3VwZXJzZXQgb2YgdGhlXG4gICAqIGV4cGVjdGVkIG1lbWJlcnMuIE5vdGUgdGhhdCBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGluIHRoZSBzdWJzZXQgd2hlblxuICAgKiBgLmluY2x1ZGVgIGlzIGFkZGVkLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGEgc3VwZXJzZXQgb2YgWzEsIDJdIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICpcbiAgICogICAgIC8vIER1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCBhcmUgaWdub3JlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyLCAyLCAyXSk7XG4gICAqXG4gICAqIGAuZGVlcGAsIGAub3JkZXJlZGAsIGFuZCBgLmluY2x1ZGVgIGNhbiBhbGwgYmUgY29tYmluZWQuIEhvd2V2ZXIsIGlmXG4gICAqIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZSBzdGFydCBvZlxuICAgKiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbe2E6IDF9LCB7YjogMn0sIHtjOiAzfV0pXG4gICAqICAgICAgIC50by5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKFt7YTogMX0sIHtiOiAyfV0pXG4gICAqICAgICAgIC5idXQubm90LmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoW3tiOiAyfSwge2M6IDN9XSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubWVtYmVyc2AuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGFycmF5IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgdGhlIHNhbWUgbWVtYmVycyBhc1xuICAgKiB0aGUgZ2l2ZW4gYXJyYXkgYHNldGAgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtLiBJdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvblxuICAgKiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5pbmNsdWRlKDMpLmFuZC5ub3QuaW5jbHVkZSg0KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzMsIDRdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubWVtYmVyc2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNvbnRhaW5zID0gZmxhZyh0aGlzLCAnY29udGFpbnMnKTtcbiAgICB2YXIgb3JkZXJlZCA9IGZsYWcodGhpcywgJ29yZGVyZWQnKTtcblxuICAgIHZhciBzdWJqZWN0LCBmYWlsTXNnLCBmYWlsTmVnYXRlTXNnO1xuXG4gICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICBzdWJqZWN0ID0gb3JkZXJlZCA/ICdhbiBvcmRlcmVkIHN1cGVyc2V0JyA6ICdhIHN1cGVyc2V0JztcbiAgICAgIGZhaWxNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgc3ViamVjdCArICcgb2YgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgJyArIHN1YmplY3QgKyAnIG9mICN7ZXhwfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YmplY3QgPSBvcmRlcmVkID8gJ29yZGVyZWQgbWVtYmVycycgOiAnbWVtYmVycyc7XG4gICAgICBmYWlsTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICB9XG5cbiAgICB2YXIgY21wID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gXy5lcWwgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wLCBjb250YWlucywgb3JkZXJlZClcbiAgICAgICwgZmFpbE1zZ1xuICAgICAgLCBmYWlsTmVnYXRlTXNnXG4gICAgICAsIHN1YnNldFxuICAgICAgLCBvYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGxpc3RbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG1lbWJlciBvZiB0aGUgZ2l2ZW4gYXJyYXkgYGxpc3RgLiBIb3dldmVyLFxuICAgKiBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub25lT2YoWzEsIDIsIDNdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIENvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgdXNpbmcgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub25lT2ZgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5vbmVPZihbMiwgMywgNF0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogSXQgY2FuIGFsc28gYmUgY2hhaW5lZCB3aXRoIGAuY29udGFpbmAgb3IgYC5pbmNsdWRlYCwgd2hpY2ggd2lsbCB3b3JrIHdpdGhcbiAgICogYm90aCBhcnJheXMgYW5kIHN0cmluZ3M6XG4gICAqXG4gICAqICAgICBleHBlY3QoJ1RvZGF5IGlzIHN1bm55JykudG8uY29udGFpbi5vbmVPZihbJ3N1bm55JywgJ2Nsb3VkeSddKVxuICAgKiAgICAgZXhwZWN0KCdUb2RheSBpcyByYWlueScpLnRvLm5vdC5jb250YWluLm9uZU9mKFsnc3VubnknLCAnY2xvdWR5J10pXG4gICAqICAgICBleHBlY3QoWzEsMiwzXSkudG8uY29udGFpbi5vbmVPZihbMyw0LDVdKVxuICAgKiAgICAgZXhwZWN0KFsxLDIsM10pLnRvLm5vdC5jb250YWluLm9uZU9mKFs0LDUsNl0pXG4gICAqXG4gICAqIGAub25lT2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vbmVPZihbMiwgMywgNF0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub25lT2YoWzIsIDMsIDRdKTtcbiAgICpcbiAgICogQG5hbWUgb25lT2ZcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gb25lT2YgKGxpc3QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBleHBlY3RlZCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBjb250YWlucyA9IGZsYWcodGhpcywgJ2NvbnRhaW5zJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpO1xuICAgIG5ldyBBc3NlcnRpb24obGlzdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsaXN0LnNvbWUoZnVuY3Rpb24ocG9zc2liaWxpdHkpIHsgcmV0dXJuIGV4cGVjdGVkLmluZGV4T2YocG9zc2liaWxpdHkpID4gLTEgfSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluIG9uZSBvZiAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gb25lIG9mICN7ZXhwfSdcbiAgICAgICAgLCBsaXN0XG4gICAgICAgICwgZXhwZWN0ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGlzdC5zb21lKGZ1bmN0aW9uKHBvc3NpYmlsaXR5KSB7IHJldHVybiBfLmVxbChleHBlY3RlZCwgcG9zc2liaWxpdHkpIH0pXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgb25lIG9mICN7ZXhwfSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGRlZXBseSBlcXVhbCBvbmUgb2YgI3tleHB9J1xuICAgICAgICAgICwgbGlzdFxuICAgICAgICAgICwgZXhwZWN0ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxpc3QuaW5kZXhPZihleHBlY3RlZCkgPiAtMVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgb25lIG9mICN7ZXhwfSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgICAgICwgbGlzdFxuICAgICAgICAgICwgZXhwZWN0ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvbmVPZicsIG9uZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuY2hhbmdlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgZGlmZmVyZW50IHZhbHVlIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZSB0aGUgdGFyZ2V0XG4gICAqIGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyd2FyZC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IGBzdWJqZWN0YCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBkb3RzICs9ICcuJzsgfVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChnZXREb3RzKCkpLnRvLmVxdWFsKCcnKTtcbiAgICogICAgIGFkZERvdCgpO1xuICAgKiAgICAgZXhwZWN0KGdldERvdHMoKSkudG8uZXF1YWwoJy4nKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8uY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmNoYW5nZWAgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0IGBzdWJqZWN0YCdzIGBwcm9wYCBwcm9wZXJ0eSBpcyBkaWZmZXJlbnQgYmVmb3JlIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYWZ0ZXJ3YXJkLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgbXlPYmouZG90cyArPSAnLic7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5oYXZlLnByb3BlcnR5KCdkb3RzJywgJycpO1xuICAgKiAgICAgYWRkRG90KCk7XG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmhhdmUucHJvcGVydHkoJ2RvdHMnLCAnLicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5jaGFuZ2UobXlPYmosICdkb3RzJyk7XG4gICAqXG4gICAqIFN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlcy5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5jaGFuZ2VgLlxuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UobXlPYmosICdkb3RzJyk7XG4gICAqXG4gICAqIGAuY2hhbmdlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IG15T2JqLmRvdHMgKz0gJy4nOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8ubm90LmNoYW5nZShteU9iaiwgJ2RvdHMnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBkb3RzICs9ICcuJzsgfVxuICAgKiAgICAgICAsIGdldERvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb3RzOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZERvdCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLm5vdC5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqIGAuY2hhbmdlYCBhbHNvIGNhdXNlcyBhbGwgYC5ieWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG9cbiAgICogYXNzZXJ0IGhvdyBtdWNoIGEgbnVtZXJpYyBzdWJqZWN0IHdhcyBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkIGJ5LiBIb3dldmVyLFxuICAgKiBpdCdzIGRhbmdlcm91cyB0byB1c2UgYC5jaGFuZ2UuYnlgLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXNcbiAgICogdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgaW5jcmVhc2VzIGJ5XG4gICAqIHRoZSBnaXZlbiBkZWx0YSwgb3IgdGhhdCBpdCBkZWNyZWFzZXMgYnkgdGhlIGdpdmVuIGRlbHRhLiBJdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvblxuICAgKiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuY2hhbmdlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5jaGFuZ2VgLlxuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VcbiAgICogQGFsaWFzIGNoYW5nZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRDaGFuZ2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgZm4oKTtcblxuICAgIHZhciBmaW5hbCA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gc3ViamVjdCgpIDogc3ViamVjdFtwcm9wXTtcbiAgICB2YXIgbXNnT2JqID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBpbml0aWFsIDogJy4nICsgcHJvcDtcblxuICAgIC8vIFRoaXMgZ2V0cyBmbGFnZ2VkIGJlY2F1c2Ugb2YgdGhlIC5ieShkZWx0YSkgYXNzZXJ0aW9uXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnY2hhbmdlJyk7XG4gICAgZmxhZyh0aGlzLCAncmVhbERlbHRhJywgZmluYWwgIT09IGluaXRpYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbml0aWFsICE9PSBmaW5hbFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gY2hhbmdlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGNoYW5nZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2hhbmdlJywgYXNzZXJ0Q2hhbmdlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2NoYW5nZXMnLCBhc3NlcnRDaGFuZ2VzKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZShzdWJqZWN0WywgcHJvcFssIG1zZ11dKVxuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYC5pbmNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBmdW5jdGlvblxuICAgKiBgc3ViamVjdGAgcmV0dXJucyBhIGdyZWF0ZXIgbnVtYmVyIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlaGFuZC4gYC5pbmNyZWFzZWAgYWxzb1xuICAgKiBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIGFzc2VydCBob3cgbXVjaFxuICAgKiBncmVhdGVyIG9mIGEgbnVtYmVyIGlzIHJldHVybmVkLiBJdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBpbmNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIGl0IGluY3JlYXNlZFxuICAgKiBieSBhbnkgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IHZhbCArPSAyOyB9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UoZ2V0VmFsKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKGdldFZhbCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmluY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGdyZWF0ZXIgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byBiZWZvcmVoYW5kLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluY3JlYXNlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBkZWNyZWFzZXMsIG9yIHRoYXQgaXQgc3RheXMgdGhlIHNhbWUuXG4gICAqIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW5cbiAgICogd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIGRlY3JlYXNlLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgaXRcbiAgICogZGVjcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8ubm90LmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIHN0YXkgdGhlIHNhbWUsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ3ZhbCcpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5pbmNyZWFzZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3AsICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNyZWFzZShnZXRWYWwpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5pbmNyZWFzZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5jcmVhc2VgLlxuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZVxuICAgKiBAYWxpYXMgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5jcmVhc2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlclxuICAgIG5ldyBBc3NlcnRpb24oaW5pdGlhbCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnaW5jcmVhc2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBmaW5hbCAtIGluaXRpYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmaW5hbCAtIGluaXRpYWwgPiAwXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBpbmNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBpbmNyZWFzZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5jcmVhc2UnLCBhc3NlcnRJbmNyZWFzZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbmNyZWFzZXMnLCBhc3NlcnRJbmNyZWFzZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgbGVzc2VyIG51bWJlciB3aGVuIGl0J3MgaW52b2tlZCBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZWhhbmQuIGAuZGVjcmVhc2VgIGFsc29cbiAgICogY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBhc3NlcnQgaG93IG11Y2hcbiAgICogbGVzc2VyIG9mIGEgbnVtYmVyIGlzIHJldHVybmVkLiBJdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHJldHVyblxuICAgKiB2YWx1ZSBkZWNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIGl0IGRlY3JlYXNlZFxuICAgKiBieSBhbnkgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgdmFsIC09IDI7IH1cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCkuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKGdldFZhbCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLmRlY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGxlc3NlciBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGJlZm9yZWhhbmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZGVjcmVhc2VgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGluY3JlYXNlcywgb3IgdGhhdCBpdCBzdGF5cyB0aGUgc2FtZS5cbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlblxuICAgKiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gaW5jcmVhc2UsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCBpdFxuICAgKiBpbmNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5ub3QuZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gc3RheSB0aGUgc2FtZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAndmFsJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmRlY3JlYXNlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmRlY3JlYXNlKGdldFZhbCk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmRlY3JlYXNlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5kZWNyZWFzZWAuXG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlXG4gICAqIEBhbGlhcyBkZWNyZWFzZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnREZWNyZWFzZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyXG4gICAgbmV3IEFzc2VydGlvbihpbml0aWFsLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdkZWNyZWFzZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGluaXRpYWwgLSBmaW5hbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGZpbmFsIC0gaW5pdGlhbCA8IDBcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGRlY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGRlY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdkZWNyZWFzZScsIGFzc2VydERlY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2RlY3JlYXNlcycsIGFzc2VydERlY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuYnkoZGVsdGFbLCBtc2ddKVxuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhbiBgLmluY3JlYXNlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXRcbiAgICogdGhlIHN1YmplY3Qgb2YgdGhlIGAuaW5jcmVhc2VgIGFzc2VydGlvbiBpbmNyZWFzZWQgYnkgdGhlIGdpdmVuIGBkZWx0YWAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhIGAuZGVjcmVhc2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdCB0aGVcbiAgICogc3ViamVjdCBvZiB0aGUgYC5kZWNyZWFzZWAgYXNzZXJ0aW9uIGRlY3JlYXNlZCBieSB0aGUgZ2l2ZW4gYGRlbHRhYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiBXaGVuIGZvbGxvd2luZyBhIGAuY2hhbmdlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHN1YmplY3Qgb2YgdGhlIGAuY2hhbmdlYCBhc3NlcnRpb24gZWl0aGVyIGluY3JlYXNlZCBvciBkZWNyZWFzZWQgYnkgdGhlXG4gICAqIGdpdmVuIGBkZWx0YWAuIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIHVzZSBgLmNoYW5nZS5ieWAuIFRoZSBwcm9ibGVtIGlzXG4gICAqIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlXG4gICAqIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0c1xuICAgKiB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5ieWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgc3ViamVjdCBjaGFuZ2VkIGJ5IGl0cyBleHBlY3RlZCBkZWx0YSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgaXQgZGlkbid0IGNoYW5nZSBieSBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgZGVsdGFzLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnV0Lm5vdC5ieSgzKTtcbiAgICpcbiAgICogYC5ieWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvXG4gICAqIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgzLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoYWRkVHdvLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgzKTtcbiAgICpcbiAgICogQG5hbWUgYnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnREZWx0YShkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgbXNnT2JqID0gZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonKTtcbiAgICB2YXIgaW5pdGlhbCA9IGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJyk7XG4gICAgdmFyIGZpbmFsID0gZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJyk7XG4gICAgdmFyIGJlaGF2aW9yID0gZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicpO1xuICAgIHZhciByZWFsRGVsdGEgPSBmbGFnKHRoaXMsICdyZWFsRGVsdGEnKTtcblxuICAgIHZhciBleHByZXNzaW9uO1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ2NoYW5nZScpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBNYXRoLmFicyhmaW5hbCAtIGluaXRpYWwpID09PSBNYXRoLmFicyhkZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHJlc3Npb24gPSByZWFsRGVsdGEgPT09IE1hdGguYWJzKGRlbHRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGV4cHJlc3Npb25cbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvICcgKyBiZWhhdmlvciArICcgYnkgJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgJyArIGJlaGF2aW9yICsgJyBieSAnICsgZGVsdGFcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYnknLCBhc3NlcnREZWx0YSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXh0ZW5zaWJsZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBleHRlbnNpYmxlLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhblxuICAgKiBiZSBhZGRlZCB0byBpdC4gUHJpbWl0aXZlcyBhcmUgbmV2ZXIgZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXh0ZW5zaWJsZWAuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSlcbiAgICogICAgICAgLCBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSlcbiAgICogICAgICAgLCBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub25FeHRlbnNpYmxlT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmV4dGVuc2libGU7XG4gICAqXG4gICAqIEBuYW1lIGV4dGVuc2libGVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleHRlbnNpYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgbm9uLWV4dGVuc2libGUgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIGZhbHNlLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0V4dGVuc2libGVcbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc0V4dGVuc2libGUgPSBvYmogPT09IE9iamVjdChvYmopICYmIE9iamVjdC5pc0V4dGVuc2libGUob2JqKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNFeHRlbnNpYmxlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGV4dGVuc2libGUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBleHRlbnNpYmxlJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNlYWxlZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzZWFsZWQsIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgICogYWRkZWQgdG8gaXQsIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4ndCBiZSByZWNvbmZpZ3VyZWQgb3IgZGVsZXRlZC5cbiAgICogSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0aGF0IGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbiBzdGlsbCBiZSByZWFzc2lnbmVkXG4gICAqIHRvIGRpZmZlcmVudCB2YWx1ZXMuIFByaW1pdGl2ZXMgYXJlIGFsd2F5cyBzZWFsZWQuXG4gICAqXG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8uYmUuc2VhbGVkO1xuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8uYmUuc2VhbGVkO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLnNlYWxlZDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5zZWFsZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLnNlYWxlZDtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEBuYW1lIHNlYWxlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3NlYWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIHNlYWxlZCBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzU2VhbGVkXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNTZWFsZWQgPSBvYmogPT09IE9iamVjdChvYmopID8gT2JqZWN0LmlzU2VhbGVkKG9iaikgOiB0cnVlO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc1NlYWxlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBzZWFsZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBzZWFsZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZnJvemVuXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGZyb3plbiwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW4ndCBiZVxuICAgKiBhZGRlZCB0byBpdCwgYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbid0IGJlIHJlYXNzaWduZWQgdG8gZGlmZmVyZW50XG4gICAqIHZhbHVlcywgcmVjb25maWd1cmVkLCBvciBkZWxldGVkLiBQcmltaXRpdmVzIGFyZSBhbHdheXMgZnJvemVuLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGZyb3plbk9iamVjdCkudG8uYmUuZnJvemVuO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmZyb3plbjtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5mcm96ZW5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLmZyb3plbjtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5mcm96ZW47XG4gICAqXG4gICAqIEBuYW1lIGZyb3plblxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zyb3plbicsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIGZyb3plbiBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRnJvemVuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNGcm96ZW4gPSBvYmogPT09IE9iamVjdChvYmopID8gT2JqZWN0LmlzRnJvemVuKG9iaikgOiB0cnVlO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0Zyb3plblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmcm96ZW4nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBmcm96ZW4nXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZmluaXRlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyLCBhbmQgaXNuJ3QgYE5hTmAgb3IgcG9zaXRpdmUvbmVnYXRpdmVcbiAgICogYEluZmluaXR5YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5maW5pdGU7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZmluaXRlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpc24ndCBhIG51bWJlciwgb3IgdGhhdCBpdCdzIGBOYU5gLCBvclxuICAgKiB0aGF0IGl0J3MgcG9zaXRpdmUgYEluZmluaXR5YCwgb3IgdGhhdCBpdCdzIG5lZ2F0aXZlIGBJbmZpbml0eWAuIEl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogdGhhdCBpdCdzIHRoZSBleHBlY3RlZCB0eXBlLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBpc24ndCBvbmUgb2ZcbiAgICogbWFueSB1bmV4cGVjdGVkIHR5cGVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBgTmFOYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5XG4gICAqIHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoTmFOKS50by5iZS5OYU47IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoTmFOKS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIHBvc2l0aXZlIGluZmluaXR5LCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdChJbmZpbml0eSkudG8uZXF1YWwoSW5maW5pdHkpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KEluZmluaXR5KS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIG5lZ2F0aXZlIGluZmluaXR5LCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgtSW5maW5pdHkpLnRvLmVxdWFsKC1JbmZpbml0eSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoLUluZmluaXR5KS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmZpbml0ZTtcbiAgICpcbiAgICogQG5hbWUgZmluaXRlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmluaXRlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmIGlzRmluaXRlKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYSBmaW5pdGUgbnVtYmVyJ1xuICAgICk7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIENoYWkgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UpXG4gICAqXG4gICAqIFdyaXRlIHlvdXIgb3duIHRlc3QgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqICAgICBhc3NlcnQoJ2ZvbycgIT09ICdiYXInLCAnZm9vIGlzIG5vdCBiYXInKTtcbiAgICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KFtdKSwgJ2VtcHR5IGFycmF5cyBhcmUgYXJyYXlzJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cHJlc3Npb24gdG8gdGVzdCBmb3IgdHJ1dGhpbmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IG9uIGVycm9yXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgYXNzZXJ0ID0gY2hhaS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwcmVzcywgZXJybXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG51bGwsIG51bGwsIGNoYWkuYXNzZXJ0LCB0cnVlKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5mYWlsKCk7XG4gICAqICAgICBhc3NlcnQuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyLCB1bmRlZmluZWQsIFwiPlwiKTtcbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vIENvbXBseSB3aXRoIE5vZGUncyBmYWlsKFttZXNzYWdlXSkgaW50ZXJmYWNlXG5cbiAgICAgICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdhc3NlcnQuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBhc3NlcnQuZmFpbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc09rKCdldmVyeXRoaW5nJywgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5pc09rKGZhbHNlLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPa1xuICAgKiBAYWxpYXMgb2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPaywgdHJ1ZSkuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPa1xuICAgKiBAYWxpYXMgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RPaywgdHJ1ZSkuaXMubm90Lm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmVxdWFsLCB0cnVlKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgICAsIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwsIHRydWUpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LnN0cmljdEVxdWFsLCB0cnVlKS50by5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgaW5lcXVhbGl0eSAoYCE9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKDMsICczJywgJ25vIGNvZXJjaW9uIGZvciBzdHJpY3QgZXF1YWxpdHknKTtcbiAgICpcbiAgICogQG5hbWUgbm90U3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLCB0cnVlKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhbGlhcyBkZWVwU3RyaWN0RXF1YWxcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5kZWVwRXF1YWwsIHRydWUpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RGVlcEVxdWFsLCB0cnVlKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQWJvdmUodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBYm92ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAoPikgYHZhbHVlVG9CZUFib3ZlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Fib3ZlKDUsIDIsICc1IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAyJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQWJvdmVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUFib3ZlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Fib3ZlID0gZnVuY3Rpb24gKHZhbCwgYWJ2LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBYm92ZSwgdHJ1ZSkudG8uYmUuYWJvdmUoYWJ2KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdExlYXN0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRMZWFzdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAoPj0pIGB2YWx1ZVRvQmVBdExlYXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoNSwgMiwgJzUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyJyk7XG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDMsIDMsICczIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TGVhc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TGVhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRMZWFzdCA9IGZ1bmN0aW9uICh2YWwsIGF0bHN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBdExlYXN0LCB0cnVlKS50by5iZS5sZWFzdChhdGxzdCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQmVsb3codmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVCZWxvdywgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGxlc3MgdGhhbiAoPCkgYHZhbHVlVG9CZUJlbG93YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0JlbG93KDMsIDYsICczIGlzIHN0cmljdGx5IGxlc3MgdGhhbiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQmVsb3dcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUJlbG93XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0JlbG93ID0gZnVuY3Rpb24gKHZhbCwgYmx3LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNCZWxvdywgdHJ1ZSkudG8uYmUuYmVsb3coYmx3KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBdE1vc3QodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBdE1vc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gKDw9KSBgdmFsdWVUb0JlQXRNb3N0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCgzLCA2LCAnMyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDQsIDQsICc0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRNb3N0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdE1vc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRNb3N0ID0gZnVuY3Rpb24gKHZhbCwgYXRtc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0F0TW9zdCwgdHJ1ZSkudG8uYmUubW9zdChhdG1zdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gdHJ1ZTtcbiAgICogICAgIGFzc2VydC5pc1RydWUodGVhU2VydmVkLCAndGhlIHRlYSBoYXMgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNUcnVlLCB0cnVlKS5pc1sndHJ1ZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90VHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RUcnVlKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90VHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90VHJ1ZSwgdHJ1ZSkudG8ubm90LmVxdWFsKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqICAgICBhc3NlcnQuaXNGYWxzZSh0ZWFTZXJ2ZWQsICdubyB0ZWEgeWV0PyBobW0uLi4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0ZhbHNlLCB0cnVlKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RGYWxzZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RmFsc2UsIHRydWUpLnRvLm5vdC5lcXVhbChmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc051bGwsIHRydWUpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TnVsbCwgdHJ1ZSkudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB2YWx1ZSBpcyBOYU4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOYU4oTmFOLCAnTmFOIGlzIE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOYU4sIHRydWUpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE5hTig0LCAnNCBpcyBub3QgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBhc3NlcnQuaXNOb3ROYU4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROYU4sIHRydWUpLm5vdC50by5iZS5OYU47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmV4aXN0cyhmb28sICdmb28gaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgJyk7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXhpc3RzID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmV4aXN0cywgdHJ1ZSkudG8uZXhpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXhpc3RzXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVpdGhlciBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmFyKTtcbiAgICogICAgIGFzc2VydC5ub3RFeGlzdHMoYmF6LCAnYmF6IGlzIGVpdGhlciBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFeGlzdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEV4aXN0cyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RFeGlzdHMsIHRydWUpLnRvLm5vdC5leGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzVW5kZWZpbmVkLCB0cnVlKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNEZWZpbmVkLCB0cnVlKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Z1bmN0aW9uLCB0cnVlKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEZ1bmN0aW9uLCB0cnVlKS50by5ub3QuYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0JyAoYXMgcmV2ZWFsZWQgYnkgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICogX1RoZSBhc3NlcnRpb24gZG9lcyBub3QgbWF0Y2ggc3ViY2xhc3NlZCBvYmplY3RzLl9cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNPYmplY3QsIHRydWUpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90T2JqZWN0LCB0cnVlKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXJyYXksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90QXJyYXksIHRydWUpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNTdHJpbmcsIHRydWUpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RTdHJpbmcsIHRydWUpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTnVtYmVyLCB0cnVlKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE51bWJlciwgdHJ1ZSkudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0Zpbml0ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIuIFVubGlrZSBgLmlzTnVtYmVyYCwgdGhpcyB3aWxsIGZhaWwgZm9yIGBOYU5gIGFuZCBgSW5maW5pdHlgLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzRmluaXRlKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNGaW5pdGUoTmFOKTsgLy8gdGhyb3dzXG4gICAqXG4gICAqIEBuYW1lIGlzRmluaXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGaW5pdGUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGaW5pdGUsIHRydWUpLnRvLmJlLmZpbml0ZTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Jvb2xlYW4sIHRydWUpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90Qm9vbGVhbiwgdHJ1ZSkudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LnR5cGVPZiwgdHJ1ZSkudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RUeXBlT2YsIHRydWUpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lmluc3RhbmNlT2YsIHRydWUpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90SW5zdGFuY2VPZiwgdHJ1ZSlcbiAgICAgIC50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGVcbiAgICogaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXksIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLCBvciBhIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsxLDIsM10sIDIsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdmb28nLCAnc3RyaW5nIGNvbnRhaW5zIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9LCB7IGZvbzogJ2JhcicgfSwgJ29iamVjdCBjb250YWlucyBwcm9wZXJ0eScpO1xuICAgKlxuICAgKiBTdHJpY3QgZXF1YWxpdHkgKD09PSkgaXMgdXNlZC4gV2hlbiBhc3NlcnRpbmcgdGhlIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluXG4gICAqIGFuIGFycmF5LCB0aGUgYXJyYXkgaXMgc2VhcmNoZWQgZm9yIGFuIGVsZW1lbnQgdGhhdCdzIHN0cmljdGx5IGVxdWFsIHRvIHRoZVxuICAgKiBnaXZlbiB2YWx1ZS4gV2hlbiBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QsIHRoZSBvYmplY3RcbiAgICogaXMgc2VhcmNoZWQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBrZXlzLCBjaGVja2luZyB0aGF0IGVhY2ggb25lIGlzIHByZXNlbnRcbiAgICogYW5kIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS4gRm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoW29iajEsIG9iajJdLCBvYmoxKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajF9KTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajEsIGJhcjogb2JqMn0pO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5pbmNsdWRlLCB0cnVlKS5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydFxuICAgKiB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5LCBhIHN1YnN0cmluZyBpbiBhIHN0cmluZywgb3IgYSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbMSwyLDNdLCA0LCBcImFycmF5IGRvZXNuJ3QgY29udGFpbiB2YWx1ZVwiKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgXCJzdHJpbmcgZG9lc24ndCBjb250YWluIHN1YnN0cmluZ1wiKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSwgeyBmb286ICdiYXonIH0sICdvYmplY3QgZG9lc24ndCBjb250YWluIHByb3BlcnR5Jyk7XG4gICAqXG4gICAqIFN0cmljdCBlcXVhbGl0eSAoPT09KSBpcyB1c2VkLiBXaGVuIGFzc2VydGluZyB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuXG4gICAqIGFycmF5LCB0aGUgYXJyYXkgaXMgc2VhcmNoZWQgdG8gY29uZmlybSB0aGUgYWJzZW5jZSBvZiBhbiBlbGVtZW50IHRoYXQnc1xuICAgKiBzdHJpY3RseSBlcXVhbCB0byB0aGUgZ2l2ZW4gdmFsdWUuIFdoZW4gYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW5cbiAgICogYW4gb2JqZWN0LCB0aGUgb2JqZWN0IGlzIHNlYXJjaGVkIHRvIGNvbmZpcm0gdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuXG4gICAqIHByb3BlcnR5IGtleXMgaXMgZWl0aGVyIG5vdCBwcmVzZW50IG9yIG5vdCBzdHJpY3RseSBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogcHJvcGVydHkgdmFsdWUuIEZvciBpbnN0YW5jZTpcbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDF9KTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMSwgYmFyOiB7YjogMn19KTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZSwgdHJ1ZSkubm90LmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlXG4gICAqIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluIGFuIGFycmF5IG9yIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKiBEZWVwIGVxdWFsaXR5IGlzIHVzZWQuXG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogMX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfSwgYmFyOiB7YjogMn19KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwSW5jbHVkZSwgdHJ1ZSkuZGVlcC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnRcbiAgICogdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSBvciBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICogRGVlcCBlcXVhbGl0eSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDl9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogOX19KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX0sIGJhcjoge2I6IDl9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90RGVlcEluY2x1ZGUsIHRydWUpLm5vdC5kZWVwLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkSW5jbHVkZSh7Jy5hJzogeydiJzogJ3gnfX0sIHsnXFxcXC5hLltiXSc6ICd4J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5uZXN0ZWRJbmNsdWRlLCB0cnVlKS5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBkb2VzIG5vdCBpbmNsdWRlICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3QuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWRcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J2InOiAneCd9fSwgeydcXFxcLmEuYic6ICd5J30pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUoeydhJzogeydbYl0nOiAneCd9fSwgeydhLlxcXFxbYlxcXFxdJzogJ3knfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBOZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUoe2E6IHtiOiBbe3g6IDF9XX19LCB7J2EuYlswXSc6IHt4OiAxfX0pO1xuICAgKiAgICAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J1tiXSc6IHt4OiAxfX19LCB7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IHt4OiAxfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwTmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGRvZXMgbm90IGluY2x1ZGUgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlKHthOiB7YjogW3t4OiAxfV19fSwgeydhLmJbMF0nOiB7eTogMX19KVxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J1tiXSc6IHt4OiAxfX19LCB7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IHt5OiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwTmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5kZWVwLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25JbmNsdWRlKHsgYTogMSB9LCB7IGE6IDEgfSk7XG4gICAqXG4gICAqIEBuYW1lIG93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm93bkluY2x1ZGUsIHRydWUpLm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90T3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93bkluY2x1ZGUoeyBhOiAxIH0sIHsgYjogMiB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90T3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90T3duSW5jbHVkZSwgdHJ1ZSkubm90Lm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMgYW5kIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgIGFzc2VydC5kZWVwT3duSW5jbHVkZSh7YToge2I6IDJ9fSwge2E6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwT3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBPd25JbmNsdWRlLCB0cnVlKVxuICAgICAgLmRlZXAub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAubm90RGVlcE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFuZCBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgICBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUoe2E6IHtiOiAyfX0sIHthOiB7YzogM319KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QuZGVlcC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubWF0Y2gsIHRydWUpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90TWF0Y2gsIHRydWUpLnRvLm5vdC5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5wcm9wZXJ0eSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LnByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgYmFkJyk7XG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAnY29mZmVlJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90UHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgYmxhY2s6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ29vbG9uZycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICdjb2ZmZWUnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLiBJbmhlcml0ZWRcbiAgICogcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm93blByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLmhhdmUub3duLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSh7fSwgJ3RvU3RyaW5nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RPd25Qcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCh7IGNvZmZlZTogJ2lzIGdvb2QnfSwgJ2NvZmZlZScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQub3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YFxuICAgKiB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsKHsgdGVhOiAnaXMgYmV0dGVyJ30sICd0ZWEnLCAnaXMgd29yc2UnKTtcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90T3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIGFuZCBhIHZhbHVlXG4gICAqIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay4gSW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmRlZXAub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwT3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgXG4gICAqIHdpdGggYSB2YWx1ZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBibGFjazogJ21hdGNoYScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnb29sb25nJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ2NvZmZlZScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7fSwgJ3RvU3RyaW5nJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yXG4gICAqIG5lc3RlZCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkIHJlZmVyZW5jZS4gVGhlXG4gICAqIHByb3BlcnR5IGNhbm5vdCBleGlzdCBvbiB0aGUgb2JqZWN0IG5vciBhbnl3aGVyZSBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgbmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3ROZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwTmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWRcbiAgICogcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVtJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwTmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoXG4gICAqIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgb29sb25nOiAneXVtJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ncmVlbicsIHsgbWF0Y2hhOiAneXVjaycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuYmxhY2snLCB7IG1hdGNoYTogJ3l1bScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihvYmplY3QsIGxlbmd0aCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgYGxlbmd0aGAgb3IgYHNpemVgIHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNiwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihuZXcgU2V0KFsxLDIsM10pLCAzLCAnc2V0IGhhcyBzaXplIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihuZXcgTWFwKFtbJ2EnLDFdLFsnYicsMl0sWydjJywzXV0pLCAzLCAnbWFwIGhhcyBzaXplIG9mIDMnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubGVuZ3RoT2YsIHRydWUpLnRvLmhhdmUubGVuZ3RoT2YobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5oYXNBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdpRG9udEV4aXN0JywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGlEb250RXhpc3Q6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSksIFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pO1xuICAgKlxuICAgKiBAbmFtZSBoYXNBbnlLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlLZXlzLCB0cnVlKS50by5oYXZlLmFueS5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQWxsS2V5cywgdHJ1ZSkudG8uaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkIGJ1dCBtYXkgaGF2ZSBtb3JlIGtleXMgbm90IGxpc3RlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JhcicsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXI6IDk5LCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfSwgJ2tleSddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9XSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGNvbnRhaW5zQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY29udGFpbnNBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbnlLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgbm9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ29uZScsICd0d28nLCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7b25lOiAxLCB0d286IDIsIGV4YW1wbGU6ICdmb28nfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueUtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYW55LmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFsbEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnb25lJywgJ3R3bycsICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtvbmU6IDEsIHR3bzogMiwgZXhhbXBsZTogJ2Zvbyd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FueURlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0aHJlZTogJ3RocmVlJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQW55RGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmhhc0FsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIGFuZCBvbmx5IGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ31dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGNvbnRhaW5zIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgY29udGFpbnNBbGxEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQW55RGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBub25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7dHdlbnR5OiAndHdlbnR5J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueURlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7b25lOiAnb25lJ31dKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHt0d2VudHk6ICd0d2VudHknfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYWxsLmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAudGhyb3dzKGZuLCBbZXJyb3JMaWtlL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBjb25zdHJ1Y3RvciwgYXNzZXJ0cyB0aGF0IGBmbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuXG4gICAqIGluc3RhbmNlIG9mIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGluc3RhbmNlLCBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biBpcyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBhcyBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVyck1zZ01hdGNoZXJgIGlzIHByb3ZpZGVkLCBpdCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIHdpbGwgaGF2ZSBhXG4gICAqIG1lc3NhZ2UgbWF0Y2hpbmcgYGVyck1zZ01hdGNoZXJgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgJ0Vycm9yIHRocm93biBtdXN0IGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIC9FcnJvciB0aHJvd24gbXVzdCBoYXZlIGEgbXNnIHRoYXQgbWF0Y2hlcyB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAnRXJyb3IgdGhyb3duIG11c3QgYmUgYSBSZWZlcmVuY2VFcnJvciBhbmQgaGF2ZSB0aGlzIG1zZycpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSwgJ0Vycm9yIHRocm93biBtdXN0IGJlIHRoZSBzYW1lIGVycm9ySW5zdGFuY2UgYW5kIGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAvRXJyb3IgdGhyb3duIG11c3QgYmUgYSBSZWZlcmVuY2VFcnJvciBhbmQgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSwgL0Vycm9yIHRocm93biBtdXN0IGJlIHRoZSBzYW1lIGVycm9ySW5zdGFuY2UgYW5kIG1hdGNoIHRoaXMvKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dzXG4gICAqIEBhbGlhcyB0aHJvd1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfEVycm9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBlcnJNc2dNYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIChmbiwgZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBlcnJvckxpa2UgfHwgZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQudGhyb3dzLCB0cnVlKVxuICAgICAgLnRvLnRocm93KGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlcik7XG4gICAgcmV0dXJuIGZsYWcoYXNzZXJ0RXJyLCAnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdFRocm93KGZuLCBbZXJyb3JMaWtlL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBjb25zdHJ1Y3RvciwgYXNzZXJ0cyB0aGF0IGBmbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuXG4gICAqIGluc3RhbmNlIG9mIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGluc3RhbmNlLCBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biBpcyBfbm90XyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBhcyBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVyck1zZ01hdGNoZXJgIGlzIHByb3ZpZGVkLCBpdCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIHdpbGwgX25vdF8gaGF2ZSBhXG4gICAqIG1lc3NhZ2UgbWF0Y2hpbmcgYGVyck1zZ01hdGNoZXJgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgJ0FueSBFcnJvciB0aHJvd24gbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIC9BbnkgRXJyb3IgdGhyb3duIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsICdFcnJvciBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSwgJ0Vycm9yIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvciwgL0Vycm9yIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UsIC9FcnJvciBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGVyck1zZ01hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycm9yTGlrZSB8fCBlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RUaHJvdywgdHJ1ZSlcbiAgICAgIC50by5ub3QudGhyb3coZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIHZhciBvaztcbiAgICBzd2l0Y2gob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgb2sgPSB2YWwgPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgICBvayA9IHZhbCA9PT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+JzpcbiAgICAgICAgb2sgPSB2YWwgPiB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgb2sgPSB2YWwgPj0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgb2sgPSB2YWwgPCB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgb2sgPSB2YWwgPD0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIG9rID0gdmFsICE9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgb2sgPSB2YWwgIT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbXNnID0gbXNnID8gbXNnICsgJzogJyA6IG1zZztcbiAgICAgICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgbXNnICsgJ0ludmFsaWQgb3BlcmF0b3IgXCInICsgb3BlcmF0b3IgKyAnXCInLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBhc3NlcnQub3BlcmF0b3JcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG9rLCBtc2csIGFzc2VydC5vcGVyYXRvciwgdHJ1ZSk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBub3QgYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5jbG9zZVRvKDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNsb3NlVG8gPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuY2xvc2VUbywgdHJ1ZSkudG8uYmUuY2xvc2VUbyhleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5hcHByb3hpbWF0ZWx5KGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmFwcHJveGltYXRlbHkoMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBhcHByb3hpbWF0ZWx5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuYXBwcm94aW1hdGVseSA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5hcHByb3hpbWF0ZWx5LCB0cnVlKVxuICAgICAgLnRvLmJlLmFwcHJveGltYXRlbHkoZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci5cbiAgICogVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyA1LCAxLCAzIF0sICdub3Qgc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbeyBiOiAyIH0sIHsgYTogMSB9LCB7IGM6IDMgfV0sICdzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLmRlZXAubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVEZWVwTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLlxuICAgKiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFt7IGI6IDIgfSwgeyBhOiAxIH0sIHsgZjogNSB9XSwgJ25vdCBzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAxLCAyLCAzIF0sICdzYW1lIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWVcbiAgICogb3JkZXIuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ25vdCBzYW1lIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICogVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sICdzYW1lIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZVxuICAgKiBvcmRlci4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgejogNSB9IF0sICdub3Qgc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9LCB7IGM6IDMgfSBdLCAnbm90IHNhbWUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAyIF0sICdpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDUsIDEgXSwgJ25vdCBpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYSBkZWVwXG4gICAqIGVxdWFsaXR5IGNoZWNrLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYjogMiB9IF0sICdpbmNsdWRlIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBkZWVwIGVxdWFsaXR5IGNoZWNrLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBmOiA1IH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLmRlZXAubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMSwgMiBdLCAnaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSBdLCAnbm90IGluY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDMgXSwgJ25vdCBpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5XG4gICAqIGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgYjogMiB9IF0sICdpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5XG4gICAqIGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgZjogNSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYzogMyB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5vbmVPZihpbkxpc3QsIGxpc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IG5vbi1vYmplY3QsIG5vbi1hcnJheSB2YWx1ZSBgaW5MaXN0YCBhcHBlYXJzIGluIHRoZSBmbGF0IGFycmF5IGBsaXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vbmVPZigxLCBbIDIsIDEgXSwgJ05vdCBmb3VuZCBpbiBsaXN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7Kn0gaW5MaXN0XG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9uZU9mID0gZnVuY3Rpb24gKGluTGlzdCwgbGlzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihpbkxpc3QsIG1zZywgYXNzZXJ0Lm9uZU9mLCB0cnVlKS50by5iZS5vbmVPZihsaXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMjIgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXMsIHRydWUpLnRvLmNoYW5nZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmNoYW5nZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBhbiBhbW91bnQgKGRlbHRhKS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDIgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzQnkoZm4sIG9iaiwgJ3ZhbCcsIDIpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlc0J5LCB0cnVlKVxuICAgICAgLnRvLmNoYW5nZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5kb2VzTm90Q2hhbmdlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnZm9vJyk7IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdENoYW5nZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RDaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90Q2hhbmdlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdENoYW5nZSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBvciBvZiBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAxMCB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeShmbiwgb2JqLCAndmFsJywgNSk7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNCdXROb3RCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uY2hhbmdlKG9iaiwgcHJvcCkuYnV0Lm5vdC5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gaW5jcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDEzIH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzLCB0cnVlKVxuICAgICAgLnRvLmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gaW5jcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDEwIH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzQnkoZm4sIG9iaiwgJ3ZhbCcsIDEwKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RJbmNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA4IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEluY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEluY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEluY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdEluY3JlYXNlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGluY3JlYXNlIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDEwKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzQnV0Tm90QnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApLmJ1dC5ub3QuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzLCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgLT0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlc0J5KGZuLCBvYmosICd2YWwnLCA1KTtcbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3REZWNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTUgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90RGVjcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90RGVjcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90RGVjcmVhc2UsIHRydWUpXG4gICAgICAudG8ubm90LmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90RGVjcmVhc2VCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnkoZm4sIG9iaiwgJ3ZhbCcsIDEpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90RGVjcmVhc2VCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90RGVjcmVhc2VCeSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuZGVjcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDEpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNCdXROb3RCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5LCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCkuYnV0Lm5vdC5ieShkZWx0YSk7XG4gIH1cblxuICAvKiFcbiAgICogIyMjIC5pZkVycm9yKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyBpZiB2YWx1ZSBpcyBub3QgYSBmYWxzZSB2YWx1ZSwgYW5kIHRocm93cyBpZiBpdCBpcyBhIHRydWUgdmFsdWUuXG4gICAqIFRoaXMgaXMgYWRkZWQgdG8gYWxsb3cgZm9yIGNoYWkgdG8gYmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBOb2RlJ3NcbiAgICogYXNzZXJ0IGNsYXNzLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignSSBhbSBhIGN1c3RvbSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyKTsgLy8gUmV0aHJvd3MgZXJyIVxuICAgKlxuICAgKiBAbmFtZSBpZkVycm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhyb3codmFsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGV4dGVuc2libGUgKGNhbiBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0V4dGVuc2libGUoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc0V4dGVuc2libGVcbiAgICogQGFsaWFzIGV4dGVuc2libGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNFeHRlbnNpYmxlLCB0cnVlKS50by5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RXh0ZW5zaWJsZShvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBleHRlbnNpYmxlLlxuICAgKlxuICAgKiAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUobm9uRXh0ZW5zaWJsZU9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgbm90RXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdEV4dGVuc2libGUsIHRydWUpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHNlYWxlZCAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZW1vdmVkKS5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzU2VhbGVkKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNTZWFsZWRcbiAgICogQGFsaWFzIHNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzU2VhbGVkLCB0cnVlKS50by5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gc2VhbGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90U2VhbGVkKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTZWFsZWRcbiAgICogQGFsaWFzIG5vdFNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90U2VhbGVkLCB0cnVlKS50by5ub3QuYmUuc2VhbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRnJvemVuKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZyb3plbiAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBtb2RpZmllZCkuXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqICAgICBhc3NlcnQuZnJvemVuKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnJvemVuXG4gICAqIEBhbGlhcyBmcm96ZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Zyb3plbiA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc0Zyb3plbiwgdHJ1ZSkudG8uYmUuZnJvemVuO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnJvemVuKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGZyb3plbi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEZyb3plbih7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnJvemVuXG4gICAqIEBhbGlhcyBub3RGcm96ZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZyb3plbiA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdEZyb3plbiwgdHJ1ZSkudG8ubm90LmJlLmZyb3plbjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0VtcHR5KHRhcmdldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgZG9lcyBub3QgY29udGFpbiBhbnkgdmFsdWVzLlxuICAgKiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3MgdGhlIGBsZW5ndGhgIHByb3BlcnR5LlxuICAgKiBGb3IgYE1hcGAgYW5kIGBTZXRgIGluc3RhbmNlcywgaXQgY2hlY2tzIHRoZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAqIEZvciBub24tZnVuY3Rpb24gb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2Ygb3duXG4gICAqIGVudW1lcmFibGUgc3RyaW5nIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNFbXB0eShbXSk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eSgnJyk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eShuZXcgTWFwKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNFbXB0eVxuICAgKiBAYWxpYXMgZW1wdHlcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfE1hcHxTZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0VtcHR5ID0gZnVuY3Rpb24odmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNFbXB0eSwgdHJ1ZSkudG8uYmUuZW1wdHk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFbXB0eSh0YXJnZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIHZhbHVlcy5cbiAgICogRm9yIGFycmF5cyBhbmQgc3RyaW5ncywgaXQgY2hlY2tzIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICogRm9yIGBNYXBgIGFuZCBgU2V0YCBpbnN0YW5jZXMsIGl0IGNoZWNrcyB0aGUgYHNpemVgIHByb3BlcnR5LlxuICAgKiBGb3Igbm9uLWZ1bmN0aW9uIG9iamVjdHMsIGl0IGdldHMgdGhlIGNvdW50IG9mIG93blxuICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoWzEsIDJdKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KCczNCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkobmV3IFNldChbNSwgNl0pKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KHsga2V5OiA3IH0pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEVtcHR5XG4gICAqIEBhbGlhcyBub3RFbXB0eVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8TWFwfFNldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RW1wdHkgPSBmdW5jdGlvbih2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEVtcHR5LCB0cnVlKS50by5ub3QuYmUuZW1wdHk7XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnaXNPaycsICdvaycpXG4gICgnaXNOb3RPaycsICdub3RPaycpXG4gICgndGhyb3dzJywgJ3Rocm93JylcbiAgKCd0aHJvd3MnLCAnVGhyb3cnKVxuICAoJ2lzRXh0ZW5zaWJsZScsICdleHRlbnNpYmxlJylcbiAgKCdpc05vdEV4dGVuc2libGUnLCAnbm90RXh0ZW5zaWJsZScpXG4gICgnaXNTZWFsZWQnLCAnc2VhbGVkJylcbiAgKCdpc05vdFNlYWxlZCcsICdub3RTZWFsZWQnKVxuICAoJ2lzRnJvemVuJywgJ2Zyb3plbicpXG4gICgnaXNOb3RGcm96ZW4nLCAnbm90RnJvemVuJylcbiAgKCdpc0VtcHR5JywgJ2VtcHR5JylcbiAgKCdpc05vdEVtcHR5JywgJ25vdEVtcHR5Jyk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICpcbiAgICogICAgIGV4cGVjdC5mYWlsKCk7XG4gICAqICAgICBleHBlY3QuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyLCB1bmRlZmluZWQsIFwiPlwiKTtcbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNoYWkuZXhwZWN0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdleHBlY3QuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBjaGFpLmV4cGVjdC5mYWlsKTtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nXG4gICAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIE51bWJlclxuICAgICAgICAgIHx8IHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuXG4gICAgICAgICAgfHwgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzIGluc3RhbmNlb2YgU3ltYm9sXG4gICAgICAgICAgfHwgdHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzIGluc3RhbmNlb2YgQmlnSW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMudmFsdWVPZigpLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICAgKlxuICAgICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZmFpbCgpO1xuICAgICAqICAgICBzaG91bGQuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgICAqICAgICBzaG91bGQuZmFpbCgxLCAyKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAgICogICAgIHNob3VsZC5mYWlsKDEsIDIsIHVuZGVmaW5lZCwgXCI+XCIpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbmFtZSBmYWlsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgICAqIEBuYW1lc3BhY2UgQkREXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgICAgICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ3Nob3VsZC5mYWlsKCknO1xuICAgICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICB9LCBzaG91bGQuZmFpbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgICAqXG4gICAgICogQG5hbWUgZXF1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLnRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3Ivc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgICAqXG4gICAgICogQG5hbWUgdGhyb3dcbiAgICAgKiBAYWxpYXMgVGhyb3dcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8uVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZXhpc3RcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqICAgICB2YXIgZm9vID0gJ2hpJztcbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZXhpc3QoZm9vLCAnZm9vIGV4aXN0cycpO1xuICAgICAqXG4gICAgICogQG5hbWUgZXhpc3RcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmV4aXN0O1xuICAgIH1cblxuICAgIC8vIG5lZ2F0aW9uXG4gICAgc2hvdWxkLm5vdCA9IHt9XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLm5vdC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgaW5lcXVhbGl0eSAoYCE9YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC5lcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QuZXF1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5ub3QuZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAudGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIF9ub3RfIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QudGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC50aHJvd1xuICAgICAqIEBhbGlhcyBub3QuVGhyb3dcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5ub3QuZXhpc3RcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqICAgICB2YXIgYmFyID0gbnVsbDtcbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LmV4aXN0KGJhciwgJ2JhciBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LmV4aXN0XG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmV4aXN0O1xuICAgIH1cblxuICAgIHNob3VsZFsndGhyb3cnXSA9IHNob3VsZFsnVGhyb3cnXTtcbiAgICBzaG91bGQubm90Wyd0aHJvdyddID0gc2hvdWxkLm5vdFsnVGhyb3cnXTtcblxuICAgIHJldHVybiBzaG91bGQ7XG4gIH07XG5cbiAgY2hhaS5zaG91bGQgPSBsb2FkU2hvdWxkO1xuICBjaGFpLlNob3VsZCA9IGxvYWRTaG91bGQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIGlzIHN1cHBvcnRlZFxudmFyIGNhblNldFByb3RvdHlwZSA9IHR5cGVvZiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbic7XG5cbi8vIFdpdGhvdXQgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgc3VwcG9ydCwgdGhpcyBtb2R1bGUgd2lsbCBuZWVkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGEgZnVuY3Rpb24uXG4vLyBIb3dldmVyLCBzb21lIG9mIGZ1bmN0aW9ucycgb3duIHByb3BzIGFyZSBub3QgY29uZmlndXJhYmxlIGFuZCBzaG91bGQgYmUgc2tpcHBlZC5cbnZhciB0ZXN0Rm4gPSBmdW5jdGlvbigpIHt9O1xudmFyIGV4Y2x1ZGVOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3RGbikuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0ZXN0Rm4sIG5hbWUpO1xuXG4gIC8vIE5vdGU6IFBoYW50b21KUyAxLnggaW5jbHVkZXMgYGNhbGxlZWAgYXMgb25lIG9mIGB0ZXN0Rm5gJ3Mgb3duIHByb3BlcnRpZXMsXG4gIC8vIGJ1dCB0aGVuIHJldHVybnMgYHVuZGVmaW5lZGAgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBjYWxsZWVgLiBBcyBhXG4gIC8vIHdvcmthcm91bmQsIHdlIHBlcmZvcm0gYW4gb3RoZXJ3aXNlIHVubmVjZXNzYXJ5IHR5cGUtY2hlY2sgZm9yIGBwcm9wRGVzY2AsXG4gIC8vIGFuZCB0aGVuIGZpbHRlciBpdCBvdXQgaWYgaXQncyBub3QgYW4gb2JqZWN0IGFzIGl0IHNob3VsZCBiZS5cbiAgaWYgKHR5cGVvZiBwcm9wRGVzYyAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuICFwcm9wRGVzYy5jb25maWd1cmFibGU7XG59KTtcblxuLy8gQ2FjaGUgYEZ1bmN0aW9uYCBwcm9wZXJ0aWVzXG52YXIgY2FsbCAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCxcbiAgICBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLyoqXG4gKiAjIyMgLmFkZENoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIGFuIG9iamVjdCwgc3VjaCB0aGF0IHRoZSBtZXRob2QgY2FuIGFsc28gYmUgY2hhaW5lZC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiB0aGVuIGJlIHVzZWQgYXMgYm90aCBhIG1ldGhvZCBhc3NlcnRpb24sIGV4ZWN1dGluZyBib3RoIGBtZXRob2RgIGFuZFxuICogYGNoYWluaW5nQmVoYXZpb3JgLCBvciBhcyBhIGxhbmd1YWdlIGNoYWluLCB3aGljaCBvbmx5IGV4ZWN1dGVzIGBjaGFpbmluZ0JlaGF2aW9yYC5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28uZXF1YWwoJ2ZvbycpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBgbmFtZWAsIHdoZW4gY2FsbGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIGlmICh0eXBlb2YgY2hhaW5pbmdCZWhhdmlvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gIH1cblxuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICwgY2hhaW5pbmdCZWhhdmlvcjogY2hhaW5pbmdCZWhhdmlvclxuICB9O1xuXG4gIC8vIHNhdmUgdGhlIG1ldGhvZHMgc28gd2UgY2FuIG92ZXJ3cml0ZSB0aGVtIGxhdGVyLCBpZiB3ZSBuZWVkIHRvLlxuICBpZiAoIWN0eC5fX21ldGhvZHMpIHtcbiAgICBjdHguX19tZXRob2RzID0ge307XG4gIH1cbiAgY3R4Ll9fbWV0aG9kc1tuYW1lXSA9IGNoYWluYWJsZUJlaGF2aW9yO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIGNoYWluYWJsZU1ldGhvZEdldHRlcigpIHtcbiAgICAgICAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBjaGFpbmFibGVNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBjaGFpbmFibGVNZXRob2RXcmFwcGVyYCBjYXVzZXMgdGhpc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gdGhpcyBhc3NlcnRpb24gaXMgYmVpbmdcbiAgICAgICAgICAvLyBpbnZva2VkIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3NmaWBcbiAgICAgICAgICAvLyBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgb3ZlcndyaXRpbmcgYSBjaGFpbmFibGUgbWV0aG9kIG1lcmVseSByZXBsYWNlcyB0aGUgc2F2ZWRcbiAgICAgICAgICAvLyBtZXRob2RzIGluIGBjdHguX19tZXRob2RzYCBpbnN0ZWFkIG9mIGNvbXBsZXRlbHkgcmVwbGFjaW5nIHRoZVxuICAgICAgICAgIC8vIG92ZXJ3cml0dGVuIGFzc2VydGlvbi4gVGhlcmVmb3JlLCBhbiBvdmVyd3JpdGluZyBhc3NlcnRpb24gd29uJ3RcbiAgICAgICAgICAvLyBzZXQgdGhlIGBzc2ZpYCBvciBgbG9ja1NzZmlgIGZsYWdzLlxuICAgICAgICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXN1bHQgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExlbmd0aEd1YXJkKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIG5hbWUsIHRydWUpO1xuXG4gICAgICAgIC8vIFVzZSBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAgIC8vIEluaGVyaXQgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb2JqZWN0IGJ5IHJlcGxhY2luZyB0aGUgYEZ1bmN0aW9uYCBwcm90b3R5cGVcbiAgICAgICAgICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVOYW1lcy5pbmRleE9mKGFzc2VydGVyTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhaW5hYmxlTWV0aG9kV3JhcHBlciwgYXNzZXJ0ZXJOYW1lLCBwZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gcHJveGlmeShjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCJ2YXIgZm5MZW5ndGhEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgJ2xlbmd0aCcpO1xuXG4vKiFcbiAqIENoYWkgLSBhZGRMZW5ndGhHdWFyZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmFkZExlbmd0aEd1YXJkKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSlcbiAqXG4gKiBEZWZpbmUgYGxlbmd0aGAgYXMgYSBnZXR0ZXIgb24gdGhlIGdpdmVuIHVuaW52b2tlZCBtZXRob2QgYXNzZXJ0aW9uLiBUaGVcbiAqIGdldHRlciBhY3RzIGFzIGEgZ3VhcmQgYWdhaW5zdCBjaGFpbmluZyBgbGVuZ3RoYCBkaXJlY3RseSBvZmYgb2YgYW4gdW5pbnZva2VkXG4gKiBtZXRob2QgYXNzZXJ0aW9uLCB3aGljaCBpcyBhIHByb2JsZW0gYmVjYXVzZSBpdCByZWZlcmVuY2VzIGBmdW5jdGlvbmAnc1xuICogYnVpbHQtaW4gYGxlbmd0aGAgcHJvcGVydHkgaW5zdGVhZCBvZiBDaGFpJ3MgYGxlbmd0aGAgYXNzZXJ0aW9uLiBXaGVuIHRoZVxuICogZ2V0dGVyIGNhdGNoZXMgdGhlIHVzZXIgbWFraW5nIHRoaXMgbWlzdGFrZSwgaXQgdGhyb3dzIGFuIGVycm9yIHdpdGggYVxuICogaGVscGZ1bCBtZXNzYWdlLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyBpbiB3aGljaCB0aGlzIG1pc3Rha2UgY2FuIGJlIG1hZGUuIFRoZSBmaXJzdCB3YXkgaXMgYnlcbiAqIGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZCBjaGFpbmFibGVcbiAqIG1ldGhvZC4gSW4gdGhpcyBjYXNlLCBDaGFpIHN1Z2dlc3RzIHRoYXQgdGhlIHVzZXIgdXNlIGBsZW5ndGhPZmAgaW5zdGVhZC4gVGhlXG4gKiBzZWNvbmQgd2F5IGlzIGJ5IGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZFxuICogbm9uLWNoYWluYWJsZSBtZXRob2QuIE5vbi1jaGFpbmFibGUgbWV0aG9kcyBtdXN0IGJlIGludm9rZWQgcHJpb3IgdG9cbiAqIGNoYWluaW5nLiBJbiB0aGlzIGNhc2UsIENoYWkgc3VnZ2VzdHMgdGhhdCB0aGUgdXNlciBjb25zdWx0IHRoZSBkb2NzIGZvciB0aGVcbiAqIGdpdmVuIGFzc2VydGlvbi5cbiAqXG4gKiBJZiB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIHVuY29uZmlndXJhYmxlLCB0aGVuIHJldHVybiBgZm5gXG4gKiB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgaW4gRVM2LCB0aGUgZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBjb25maWd1cmFibGUsIHNvIG9uY2VcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgaXMgZHJvcHBlZCwgQ2hhaSdzIGBsZW5ndGhgIHByb3BlcnR5IGNhblxuICogcmVwbGFjZSB0aGUgYnVpbHQtaW4gZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSwgYW5kIHRoaXMgbGVuZ3RoIGd1YXJkIHdpbGxcbiAqIG5vIGxvbmdlciBiZSBuZWNlc3NhcnkuIEluIHRoZSBtZWFuIHRpbWUsIG1haW50YWluaW5nIGNvbnNpc3RlbmN5IGFjcm9zcyBhbGxcbiAqIGVudmlyb25tZW50cyBpcyB0aGUgcHJpb3JpdHkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhc3NlcnRpb25OYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hhaW5hYmxlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRMZW5ndGhHdWFyZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkTGVuZ3RoR3VhcmQgKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSkge1xuICBpZiAoIWZuTGVuZ3RoRGVzYy5jb25maWd1cmFibGUpIHJldHVybiBmbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdsZW5ndGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNDaGFpbmFibGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIGFzc2VydGlvbk5hbWUgKyAnLmxlbmd0aC4gRHVlJyArXG4gICAgICAgICAgJyB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIFwibGVuZ3RoXCIgY2Fubm90IGRpcmVjdGx5IGZvbGxvdyBcIicgK1xuICAgICAgICAgIGFzc2VydGlvbk5hbWUgKyAnXCIuIFVzZSBcIicgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGhPZlwiIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGguIFNlZScgK1xuICAgICAgICAnIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgKyBhc3NlcnRpb25OYW1lICsgJ1wiLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZuO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5hZGRNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZE1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgbWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgbWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXMgZnVuY3Rpb24gdG8gYmUgdGhlXG4gICAgLy8gc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZlxuICAgIC8vIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWYgdGhlXG4gICAgLy8gYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkIGZyb21cbiAgICAvLyBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzXG4gICAgLy8gYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZVxuICAgIC8vIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgbWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG5cbiAgYWRkTGVuZ3RoR3VhcmQobWV0aG9kV3JhcHBlciwgbmFtZSwgZmFsc2UpO1xuICBjdHhbbmFtZV0gPSBwcm94aWZ5KG1ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAuYWRkUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZFByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIGdldHRlciA9IGdldHRlciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge30gOiBnZXR0ZXI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gcHJvcGVydHlHZXR0ZXIoKSB7XG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBwcm9wZXJ0eUdldHRlcmAgY2F1c2VzIHRoaXMgZnVuY3Rpb24gdG9cbiAgICAgICAgLy8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0IGFuZCBwcm94eSBwcm90ZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWRcbiAgICAgICAgLy8gZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWdcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgcHJveHkgcHJvdGVjdGlvbiBpcyBlbmFibGVkLCB0aGVuIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIHNldCBieSB0aGUgcHJveHkgZ2V0dGVyLlxuICAgICAgICBpZiAoIWlzUHJveHlFbmFibGVkKCkgJiYgIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgcHJvcGVydHlHZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBjb21wYXJlQnlJbnNwZWN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKipcbiAqICMjIyAuY29tcGFyZUJ5SW5zcGVjdChtaXhlZCwgbWl4ZWQpXG4gKlxuICogVG8gYmUgdXNlZCBhcyBhIGNvbXBhcmVGdW5jdGlvbiB3aXRoIEFycmF5LnByb3RvdHlwZS5zb3J0LiBDb21wYXJlcyBlbGVtZW50c1xuICogdXNpbmcgaW5zcGVjdCBpbnN0ZWFkIG9mIGRlZmF1bHQgYmVoYXZpb3Igb2YgdXNpbmcgdG9TdHJpbmcgc28gdGhhdCBTeW1ib2xzXG4gKiBhbmQgb2JqZWN0cyB3aXRoIGlycmVndWxhci9taXNzaW5nIHRvU3RyaW5nIGNhbiBzdGlsbCBiZSBzb3J0ZWQgd2l0aG91dCBhXG4gKiBUeXBlRXJyb3IuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gZmlyc3QgZWxlbWVudCB0byBjb21wYXJlXG4gKiBAcGFyYW0ge01peGVkfSBzZWNvbmQgZWxlbWVudCB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSBpZiAnYScgc2hvdWxkIGNvbWUgYmVmb3JlICdiJzsgb3RoZXJ3aXNlIDFcbiAqIEBuYW1lIGNvbXBhcmVCeUluc3BlY3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wYXJlQnlJbnNwZWN0KGEsIGIpIHtcbiAgcmV0dXJuIGluc3BlY3QoYSkgPCBpbnNwZWN0KGIpID8gLTEgOiAxO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZXhwZWN0VHlwZXMob2JqLCB0eXBlcylcbiAqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIG9iamVjdCBiZWluZyB0ZXN0ZWQgYWdhaW5zdCBpcyBvZiBhIHZhbGlkIHR5cGUuXG4gKlxuICogICAgIHV0aWxzLmV4cGVjdFR5cGVzKHRoaXMsIFsnYXJyYXknLCAnb2JqZWN0JywgJ3N0cmluZyddKTtcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmogY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlIEEgbGlzdCBvZiBhbGxvd2VkIHR5cGVzIGZvciB0aGlzIGFzc2VydGlvblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZXhwZWN0VHlwZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpIHtcbiAgdmFyIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcbiAgdmFyIHNzZmkgPSBmbGFnKG9iaiwgJ3NzZmknKTtcblxuICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgb2JqID0gZmxhZyhvYmosICdvYmplY3QnKTtcbiAgdHlwZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTsgfSk7XG4gIHR5cGVzLnNvcnQoKTtcblxuICAvLyBUcmFuc2Zvcm1zIFsnbG9yZW0nLCAnaXBzdW0nXSBpbnRvICdhIGxvcmVtLCBvciBhbiBpcHN1bSdcbiAgdmFyIHN0ciA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCwgaW5kZXgpIHtcbiAgICB2YXIgYXJ0ID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHQuY2hhckF0KDApKSA/ICdhbicgOiAnYSc7XG4gICAgdmFyIG9yID0gdHlwZXMubGVuZ3RoID4gMSAmJiBpbmRleCA9PT0gdHlwZXMubGVuZ3RoIC0gMSA/ICdvciAnIDogJyc7XG4gICAgcmV0dXJuIG9yICsgYXJ0ICsgJyAnICsgdDtcbiAgfSkuam9pbignLCAnKTtcblxuICB2YXIgb2JqVHlwZSA9IHR5cGUob2JqKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICghdHlwZXMuc29tZShmdW5jdGlvbiAoZXhwZWN0ZWQpIHsgcmV0dXJuIG9ialR5cGUgPT09IGV4cGVjdGVkOyB9KSkge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgIGZsYWdNc2cgKyAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlICcgKyBzdHIgKyAnLCBidXQgJyArIG9ialR5cGUgKyAnIGdpdmVuJyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHNzZmlcbiAgICApO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmZsYWcob2JqZWN0LCBrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGFnKG9iaiwga2V5LCB2YWx1ZSkge1xuICB2YXIgZmxhZ3MgPSBvYmouX19mbGFncyB8fCAob2JqLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBmbGFnc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsYWdzW2tleV07XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRBY3R1YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRBY3R1YWwob2JqZWN0LCBbYWN0dWFsXSlcbiAqXG4gKiBSZXR1cm5zIHRoZSBgYWN0dWFsYCB2YWx1ZSBmb3IgYW4gQXNzZXJ0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0QWN0dWFsXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3R1YWwob2JqLCBhcmdzKSB7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogb2JqLl9vYmo7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1lc3NhZ2Uob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIGlmKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikgbXNnID0gbXNnKCk7XG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyNcXHt0aGlzXFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkodmFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2FjdFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGFjdHVhbCk7IH0pXG4gICAgLnJlcGxhY2UoLyNcXHtleHBcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheShleHBlY3RlZCk7IH0pO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwidmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG5mdW5jdGlvbiBpc09iamVjdFR5cGUob2JqKSB7XG4gIHZhciBvYmplY3RUeXBlID0gdHlwZShvYmopO1xuICB2YXIgb2JqZWN0VHlwZXMgPSBbJ0FycmF5JywgJ09iamVjdCcsICdmdW5jdGlvbiddO1xuXG4gIHJldHVybiBvYmplY3RUeXBlcy5pbmRleE9mKG9iamVjdFR5cGUpICE9PSAtMTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldE9wZXJhdG9yKG1lc3NhZ2UpXG4gKlxuICogRXh0cmFjdCB0aGUgb3BlcmF0b3IgZnJvbSBlcnJvciBtZXNzYWdlLlxuICogT3BlcmF0b3IgZGVmaW5lZCBpcyBiYXNlZCBvbiBiZWxvdyBsaW5rXG4gKiBodHRwczovL25vZGVqcy5vcmcvYXBpL2Fzc2VydC5odG1sI2Fzc2VydF9hc3NlcnQuXG4gKlxuICogUmV0dXJucyB0aGUgYG9wZXJhdG9yYCBvciBgdW5kZWZpbmVkYCB2YWx1ZSBmb3IgYW4gQXNzZXJ0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0T3BlcmF0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPcGVyYXRvcihvYmosIGFyZ3MpIHtcbiAgdmFyIG9wZXJhdG9yID0gZmxhZyhvYmosICdvcGVyYXRvcicpO1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKTtcbiAgdmFyIGV4cGVjdGVkID0gYXJnc1szXTtcbiAgdmFyIG1zZyA9IG5lZ2F0ZSA/IGFyZ3NbMl0gOiBhcmdzWzFdO1xuXG4gIGlmIChvcGVyYXRvcikge1xuICAgIHJldHVybiBvcGVyYXRvcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nKSBtc2cgPSBtc2coKTtcblxuICBtc2cgPSBtc2cgfHwgJyc7XG4gIGlmICghbXNnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgvXFxzaGF2ZVxccy8udGVzdChtc2cpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBpc09iamVjdCA9IGlzT2JqZWN0VHlwZShleHBlY3RlZCk7XG4gIGlmICgvXFxzbm90XFxzLy50ZXN0KG1zZykpIHtcbiAgICByZXR1cm4gaXNPYmplY3QgPyAnbm90RGVlcFN0cmljdEVxdWFsJyA6ICdub3RTdHJpY3RFcXVhbCc7XG4gIH1cblxuICByZXR1cm4gaXNPYmplY3QgPyAnZGVlcFN0cmljdEVxdWFsJyA6ICdzdHJpY3RFcXVhbCc7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBkaXJlY3RseS1vd25lZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBhbiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgT2JqZWN0LmtleXMgb25seVxuICogcmV0dXJucyBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLCBub3QgZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmNvbmNhdChnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGRpcmVjdGx5LW93bmVkIGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scyBvZiBhblxuICogb2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAqIHJldHVybnMgYm90aCBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikge1xuICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHJldHVybiBbXTtcblxuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pLmVudW1lcmFibGU7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCwgZW51bWVyYWJsZSBvciBub3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIERlcGVuZGVuY2llcyB0aGF0IGFyZSB1c2VkIGZvciBtdWx0aXBsZSBleHBvcnRzIGFyZSByZXF1aXJlZCBoZXJlIG9ubHkgb25jZVxuICovXG5cbnZhciBwYXRodmFsID0gcmVxdWlyZSgncGF0aHZhbCcpO1xuXG4vKiFcbiAqIHRlc3QgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xuXG4vKiFcbiAqIHR5cGUgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogZXhwZWN0VHlwZXMgdXRpbGl0eVxuICovXG5leHBvcnRzLmV4cGVjdFR5cGVzID0gcmVxdWlyZSgnLi9leHBlY3RUeXBlcycpO1xuXG4vKiFcbiAqIG1lc3NhZ2UgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vZ2V0TWVzc2FnZScpO1xuXG4vKiFcbiAqIGFjdHVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpO1xuXG4vKiFcbiAqIEluc3BlY3QgdXRpbFxuICovXG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKiFcbiAqIE9iamVjdCBEaXNwbGF5IHV0aWxcbiAqL1xuXG5leHBvcnRzLm9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyohXG4gKiBGbGFnIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyohXG4gKiBGbGFnIHRyYW5zZmVycmluZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogRGVlcCBlcXVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5lcWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpO1xuXG4vKiFcbiAqIERlZXAgcGF0aCBpbmZvXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoSW5mbyA9IHBhdGh2YWwuZ2V0UGF0aEluZm87XG5cbi8qIVxuICogQ2hlY2sgaWYgYSBwcm9wZXJ0eSBleGlzdHNcbiAqL1xuXG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gcGF0aHZhbC5oYXNQcm9wZXJ0eTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmMtbmFtZScpO1xuXG4vKiFcbiAqIGFkZCBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMuYWRkUHJvcGVydHkgPSByZXF1aXJlKCcuL2FkZFByb3BlcnR5Jyk7XG5cbi8qIVxuICogYWRkIE1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRNZXRob2QnKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBNZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlTWV0aG9kJyk7XG5cbi8qIVxuICogQWRkIGEgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBPdmVyd3JpdGUgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBDb21wYXJlIGJ5IGluc3BlY3QgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlQnlJbnNwZWN0ID0gcmVxdWlyZSgnLi9jb21wYXJlQnlJbnNwZWN0Jyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMnKTtcblxuLyohXG4gKiBDaGVja3MgZXJyb3IgYWdhaW5zdCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICovXG5cbmV4cG9ydHMuY2hlY2tFcnJvciA9IHJlcXVpcmUoJ2NoZWNrLWVycm9yJyk7XG5cbi8qIVxuICogUHJveGlmeSB1dGlsXG4gKi9cblxuZXhwb3J0cy5wcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG5cbi8qIVxuICogYWRkTGVuZ3RoR3VhcmQgdXRpbFxuICovXG5cbmV4cG9ydHMuYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG5cbi8qIVxuICogaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKi9cblxuZXhwb3J0cy5pc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBpc05hTiBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmlzTmFOID0gcmVxdWlyZSgnLi9pc05hTicpO1xuXG4vKiFcbiAqIGdldE9wZXJhdG9yIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuZ2V0T3BlcmF0b3IgPSByZXF1aXJlKCcuL2dldE9wZXJhdG9yJyk7IiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCdnZXQtZnVuYy1uYW1lJyk7XG52YXIgbG91cGUgPSByZXF1aXJlKCdsb3VwZScpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogIyMjIC5pbnNwZWN0KG9iaiwgW3Nob3dIaWRkZW5dLCBbZGVwdGhdLCBbY29sb3JzXSlcbiAqXG4gKiBFY2hvZXMgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyaWVzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dIaWRkZW4gRmxhZyB0aGF0IHNob3dzIGhpZGRlbiAobm90IGVudW1lcmFibGUpXG4gKiAgICBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggaW4gd2hpY2ggdG8gZGVzY2VuZCBpbiBvYmplY3QuIERlZmF1bHQgaXMgMi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzIEZsYWcgdG8gdHVybiBvbiBBTlNJIGVzY2FwZSBjb2RlcyB0byBjb2xvciB0aGVcbiAqICAgIG91dHB1dC4gRGVmYXVsdCBpcyBmYWxzZSAobm8gY29sb3JpbmcpLlxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaW5zcGVjdFxuICovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjb2xvcnM6IGNvbG9ycyxcbiAgICBkZXB0aDogKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpLFxuICAgIHNob3dIaWRkZW46IHNob3dIaWRkZW4sXG4gICAgdHJ1bmNhdGU6IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA/IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA6IEluZmluaXR5LFxuICB9O1xuICByZXR1cm4gbG91cGUuaW5zcGVjdChvYmosIG9wdGlvbnMpO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gaXNOYU4gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNSBTYWt0aGlwcml5YW4gVmFpcmFtYW5pIDx0aGVjaGFyZ2luZ3ZvbGNhbm9AZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzTmFOKHZhbHVlKVxuICpcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgTmFOIG9yIG5vdC5cbiAqXG4gKiAgICAgdXRpbHMuaXNOYU4oTmFOKTsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7VmFsdWV9IFRoZSB2YWx1ZSB3aGljaCBoYXMgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBOYU5cbiAqIEBuYW1lIGlzTmFOXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAvLyBSZWZlciBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNuYW4tbnVtYmVyXG4gIC8vIHNlY3Rpb24ncyBOT1RFLlxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vLyBJZiBFQ01BU2NyaXB0IDYncyBOdW1iZXIuaXNOYU4gaXMgcHJlc2VudCwgcHJlZmVyIHRoYXQuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBpc05hTjtcbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyohXG4gKiBDaGFpIC0gaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzUHJveHlFbmFibGVkKClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgQ2hhaSdzIHByb3h5IHByb3RlY3Rpb24gZmVhdHVyZSBpcyBlbmFibGVkLiBJZlxuICogcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW4gcmV0dXJuXG4gKiBmYWxzZS4gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZS5cbiAqXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBpc1Byb3h5RW5hYmxlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcm94eUVuYWJsZWQoKSB7XG4gIHJldHVybiBjb25maWcudXNlUHJveHkgJiZcbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuICogIyMjIC5vYmpEaXNwbGF5KG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9iakRpc3BsYXkob2JqKSB7XG4gIHZhciBzdHIgPSBpbnNwZWN0KG9iailcbiAgICAsIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBpZiAoY29uZmlnLnRydW5jYXRlVGhyZXNob2xkICYmIHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkKSB7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIHJldHVybiAhb2JqLm5hbWUgfHwgb2JqLm5hbWUgPT09ICcnXG4gICAgICAgID8gJ1tGdW5jdGlvbl0nXG4gICAgICAgIDogJ1tGdW5jdGlvbjogJyArIG9iai5uYW1lICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdbIEFycmF5KCcgKyBvYmoubGVuZ3RoICsgJykgXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICwga3N0ciA9IGtleXMubGVuZ3RoID4gMlxuICAgICAgICAgID8ga2V5cy5zcGxpY2UoMCwgMikuam9pbignLCAnKSArICcsIC4uLidcbiAgICAgICAgICA6IGtleXMuam9pbignLCAnKTtcbiAgICAgIHJldHVybiAneyBPYmplY3QgKCcgKyBrc3RyICsgJykgfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoT2YnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RHZXR0ZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gb3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBmdW5jdGlvblxuICogdG8gYmUgdXNlZCBmb3IgbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2VxdWFsJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai52YWx1ZSkudG8uZXF1YWwoc3RyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmVxdWFsKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIF9tZXRob2QgPSBjdHhbbmFtZV1cbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgaWYgKF9tZXRob2QgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9tZXRob2QpXG4gICAgX3N1cGVyID0gX21ldGhvZDtcblxuICB2YXIgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzXG4gICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbVxuICAgIC8vIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmIHRoZVxuICAgIC8vIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhc1xuICAgIC8vIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZCBjYXNlLCB0aGVcbiAgICAvLyBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyB0aGUgYGxvY2tTc2ZpYCBmbGFnIHRvIGB0cnVlYCBwcmV2ZW50cyB0aGUgb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uXG4gICAgLy8gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWAgZmxhZyBpcyBhbHJlYWR5XG4gICAgLy8gc2V0IHRvIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGFzc2VydGlvbi5cbiAgICB2YXIgb3JpZ0xvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgb3JpZ0xvY2tTc2ZpKTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH1cblxuICBhZGRMZW5ndGhHdWFyZChvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUsIGZhbHNlKTtcbiAgY3R4W25hbWVdID0gcHJveGlmeShvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZVByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlUHJvcGVydHkoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZVByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIHZhciBfZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIG5hbWUpXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoX2dldCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX2dldC5nZXQpXG4gICAgX3N1cGVyID0gX2dldC5nZXRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyKCkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcmAgY2F1c2VzIHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXNcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0IGFuZCBwcm94eSBwcm90ZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWRcbiAgICAgICAgLy8gZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWdcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgcHJveHkgcHJvdGVjdGlvbiBpcyBlbmFibGVkLCB0aGVuIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIHNldCBieSB0aGUgcHJveHkgZ2V0dGVyLlxuICAgICAgICBpZiAoIWlzUHJveHlFbmFibGVkKCkgJiYgIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgbG9ja1NzZmlgIGZsYWcgdG8gYHRydWVgIHByZXZlbnRzIHRoZSBvdmVyd3JpdHRlblxuICAgICAgICAvLyBhc3NlcnRpb24gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWBcbiAgICAgICAgLy8gZmxhZyBpcyBhbHJlYWR5IHNldCB0byB0aGUgY29ycmVjdCBzdGFydGluZyBwb2ludCBmb3IgdGhpcyBhc3NlcnRpb24uXG4gICAgICAgIHZhciBvcmlnTG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBvcmlnTG9ja1NzZmkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBDaGFpIC0gcHJveGlmeSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnByb3hpZnkob2JqZWN0KVxuICpcbiAqIFJldHVybiBhIHByb3h5IG9mIGdpdmVuIG9iamVjdCB0aGF0IHRocm93cyBhbiBlcnJvciB3aGVuIGEgbm9uLWV4aXN0ZW50XG4gKiBwcm9wZXJ0eSBpcyByZWFkLiBCeSBkZWZhdWx0LCB0aGUgcm9vdCBjYXVzZSBpcyBhc3N1bWVkIHRvIGJlIGEgbWlzc3BlbGxlZFxuICogcHJvcGVydHksIGFuZCB0aHVzIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBvZmZlciBhIHJlYXNvbmFibGUgc3VnZ2VzdGlvbiBmcm9tXG4gKiB0aGUgbGlzdCBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBIb3dldmVyLCBpZiBhIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgaXNcbiAqIHByb3ZpZGVkLCB0aGVuIHRoZSByb290IGNhdXNlIGlzIGluc3RlYWQgYSBmYWlsdXJlIHRvIGludm9rZSBhIG5vbi1jaGFpbmFibGVcbiAqIG1ldGhvZCBwcmlvciB0byByZWFkaW5nIHRoZSBub24tZXhpc3RlbnQgcHJvcGVydHkuXG4gKlxuICogSWYgcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW5cbiAqIHJldHVybiBvYmplY3Qgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IG5vbkNoYWluYWJsZU1ldGhvZE5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHByb3hpZnlcbiAqL1xuXG52YXIgYnVpbHRpbnMgPSBbJ19fZmxhZ3MnLCAnX19tZXRob2RzJywgJ19vYmonLCAnYXNzZXJ0J107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJveGlmeShvYmosIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpKSByZXR1cm4gb2JqO1xuXG4gIHJldHVybiBuZXcgUHJveHkob2JqLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAvLyBUaGlzIGNoZWNrIGlzIGhlcmUgYmVjYXVzZSB3ZSBzaG91bGQgbm90IHRocm93IGVycm9ycyBvbiBTeW1ib2wgcHJvcGVydGllc1xuICAgICAgLy8gc3VjaCBhcyBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICAgIC8vIFRoZSB2YWx1ZXMgZm9yIHdoaWNoIGFuIGVycm9yIHNob3VsZCBiZSB0aHJvd24gY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmdcbiAgICAgIC8vIHRoZSBgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzYCBzZXR0aW5nLlxuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICBjb25maWcucHJveHlFeGNsdWRlZEtleXMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmXG4gICAgICAgICAgIVJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHkpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgbWVzc2FnZSBmb3IgaW52YWxpZCBwcm9wZXJ0eSBhY2Nlc3Mgb2Ygbm9uLWNoYWluYWJsZSBtZXRob2RzLlxuICAgICAgICBpZiAobm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBub25DaGFpbmFibGVNZXRob2ROYW1lICsgJy4nICtcbiAgICAgICAgICAgIHByb3BlcnR5ICsgJy4gU2VlIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgK1xuICAgICAgICAgICAgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyByZWFzb25hYmx5IGNsb3NlIHRvIGFuIGV4aXN0aW5nIENoYWkgcHJvcGVydHksXG4gICAgICAgIC8vIHN1Z2dlc3QgdGhhdCBwcm9wZXJ0eSB0byB0aGUgdXNlci4gT25seSBzdWdnZXN0IHByb3BlcnRpZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpc3RhbmNlIGxlc3MgdGhhbiA0LlxuICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBzdWdnZXN0aW9uRGlzdGFuY2UgPSA0O1xuICAgICAgICBnZXRQcm9wZXJ0aWVzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiZcbiAgICAgICAgICAgIGJ1aWx0aW5zLmluZGV4T2YocHJvcCkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbkRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBzdWdnZXN0aW9uRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbiA9IHByb3A7XG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb25EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICAnLiBEaWQgeW91IG1lYW4gXCInICsgc3VnZ2VzdGlvbiArICdcIj8nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGlzIHByb3h5IGdldHRlciBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLiBGb3IgcHJvcGVydHlcbiAgICAgIC8vIGFzc2VydGlvbnMsIHRoaXMgcHJldmVudHMgdGhlIHByb3h5IGdldHRlciBmcm9tIHNob3dpbmcgdXAgaW4gdGhlIHN0YWNrXG4gICAgICAvLyB0cmFjZSBzaW5jZSBpdCdzIGludm9rZWQgYmVmb3JlIHRoZSBwcm9wZXJ0eSBnZXR0ZXIuIEZvciBtZXRob2QgYW5kXG4gICAgICAvLyBjaGFpbmFibGUgbWV0aG9kIGFzc2VydGlvbnMsIHRoaXMgZmxhZyB3aWxsIGVuZCB1cCBnZXR0aW5nIGNoYW5nZWQgdG9cbiAgICAgIC8vIHRoZSBtZXRob2Qgd3JhcHBlciwgd2hpY2ggaXMgZ29vZCBzaW5jZSB0aGlzIGZyYW1lIHdpbGwgbm8gbG9uZ2VyIGJlIGluXG4gICAgICAvLyB0aGUgc3RhY2sgb25jZSB0aGUgbWV0aG9kIGlzIGludm9rZWQuIE5vdGUgdGhhdCBDaGFpIGJ1aWx0aW4gYXNzZXJ0aW9uXG4gICAgICAvLyBwcm9wZXJ0aWVzIHN1Y2ggYXMgYF9fZmxhZ3NgIGFyZSBza2lwcGVkIHNpbmNlIHRoaXMgaXMgb25seSBtZWFudCB0b1xuICAgICAgLy8gY2FwdHVyZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYW4gYXNzZXJ0aW9uLiBUaGlzIHN0ZXAgaXMgYWxzbyBza2lwcGVkXG4gICAgICAvLyBpZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGh1cyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhc3NlcnRpb24gaXNcbiAgICAgIC8vIGJlaW5nIGNhbGxlZCBmcm9tIHdpdGhpbiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhhdCBjYXNlLCB0aGUgYHNzZmlgXG4gICAgICAvLyBmbGFnIGlzIGFscmVhZHkgc2V0IHRvIHRoZSBvdXRlciBhc3NlcnRpb24ncyBzdGFydGluZyBwb2ludC5cbiAgICAgIGlmIChidWlsdGlucy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiYgIWZsYWcodGFyZ2V0LCAnbG9ja1NzZmknKSkge1xuICAgICAgICBmbGFnKHRhcmdldCwgJ3NzZmknLCBwcm94eUdldHRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiAjIHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKHN0ckEsIHN0ckIsIGNhcClcbiAqIFJldHVybiB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gc3RyaW5ncywgYnV0IG5vIG1vcmUgdGhhbiBjYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyQVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ckJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm4ge251bWJlcn0gbWluKHN0cmluZyBkaXN0YW5jZSBiZXR3ZWVuIHN0ckEgYW5kIHN0ckIsIGNhcClcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKHN0ckEsIHN0ckIsIGNhcCkge1xuICBpZiAoTWF0aC5hYnMoc3RyQS5sZW5ndGggLSBzdHJCLmxlbmd0aCkgPj0gY2FwKSB7XG4gICAgcmV0dXJuIGNhcDtcbiAgfVxuXG4gIHZhciBtZW1vID0gW107XG4gIC8vIGBtZW1vYCBpcyBhIHR3by1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIGRpc3RhbmNlcy5cbiAgLy8gbWVtb1tpXVtqXSBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzdHJBLnNsaWNlKDAsIGkpIGFuZFxuICAvLyBzdHJCLnNsaWNlKDAsIGopLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBzdHJBLmxlbmd0aDsgaSsrKSB7XG4gICAgbWVtb1tpXSA9IEFycmF5KHN0ckIubGVuZ3RoICsgMSkuZmlsbCgwKTtcbiAgICBtZW1vW2ldWzBdID0gaTtcbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ckIubGVuZ3RoOyBqKyspIHtcbiAgICBtZW1vWzBdW2pdID0gajtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0ckEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2ggPSBzdHJBLmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHN0ckIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhpIC0gaikgPj0gY2FwKSB7XG4gICAgICAgIG1lbW9baV1bal0gPSBjYXA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWVtb1tpXVtqXSA9IE1hdGgubWluKFxuICAgICAgICBtZW1vW2kgLSAxXVtqXSArIDEsXG4gICAgICAgIG1lbW9baV1baiAtIDFdICsgMSxcbiAgICAgICAgbWVtb1tpIC0gMV1baiAtIDFdICtcbiAgICAgICAgICAoY2ggPT09IHN0ckIuY2hhckNvZGVBdChqIC0gMSkgPyAwIDogMSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIHRlc3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qKlxuICogIyMjIC50ZXN0KG9iamVjdCwgZXhwcmVzc2lvbilcbiAqXG4gKiBUZXN0IGFuZCBvYmplY3QgZm9yIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSB0ZXN0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXN0KG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgZXhwciA9IGFyZ3NbMF07XG4gIHJldHVybiBuZWdhdGUgPyAhZXhwciA6IGV4cHI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGBsb2NrU3NmaWAsXG4gKiBhbmQgYG1lc3NhZ2VgKSB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG87IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRyYW5zZmVyRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCkge1xuICB2YXIgZmxhZ3MgPSBhc3NlcnRpb24uX19mbGFncyB8fCAoYXNzZXJ0aW9uLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBpZiAoIW9iamVjdC5fX2ZsYWdzKSB7XG4gICAgb2JqZWN0Ll9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaW5jbHVkZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBpbmNsdWRlQWxsIDogdHJ1ZTtcblxuICBmb3IgKHZhciBmbGFnIGluIGZsYWdzKSB7XG4gICAgaWYgKGluY2x1ZGVBbGwgfHxcbiAgICAgICAgKGZsYWcgIT09ICdvYmplY3QnICYmIGZsYWcgIT09ICdzc2ZpJyAmJiBmbGFnICE9PSAnbG9ja1NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBjaGVja0Vycm9yIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuY2hlY2tFcnJvclxuICpcbiAqIENoZWNrcyB0aGF0IGFuIGVycm9yIGNvbmZvcm1zIHRvIGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhIGFuZC9vciByZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgaXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZUluc3RhbmNlKHRocm93biwgZXJyb3JMaWtlKVxuICpcbiAqIENoZWNrcyBpZiB0d28gaW5zdGFuY2VzIGFyZSBjb21wYXRpYmxlIChzdHJpY3QgZXF1YWwpLlxuICogUmV0dXJucyBmYWxzZSBpZiBlcnJvckxpa2UgaXMgbm90IGFuIGluc3RhbmNlIG9mIEVycm9yLCBiZWNhdXNlIGluc3RhbmNlc1xuICogY2FuIG9ubHkgYmUgY29tcGF0aWJsZSBpZiB0aGV5J3JlIGJvdGggZXJyb3IgaW5zdGFuY2VzLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVJbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVJbnN0YW5jZSh0aHJvd24sIGVycm9yTGlrZSkge1xuICByZXR1cm4gZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgJiYgdGhyb3duID09PSBlcnJvckxpa2U7XG59XG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlQ29uc3RydWN0b3IodGhyb3duLCBlcnJvckxpa2UpXG4gKlxuICogQ2hlY2tzIGlmIHR3byBjb25zdHJ1Y3RvcnMgYXJlIGNvbXBhdGlibGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiByZWNlaXZlIGVpdGhlciBhbiBlcnJvciBjb25zdHJ1Y3RvciBvclxuICogYW4gZXJyb3IgaW5zdGFuY2UgYXMgdGhlIGBlcnJvckxpa2VgIGFyZ3VtZW50LlxuICogQ29uc3RydWN0b3JzIGFyZSBjb21wYXRpYmxlIGlmIHRoZXkncmUgdGhlIHNhbWUgb3IgaWYgb25lIGlzXG4gKiBhbiBpbnN0YW5jZSBvZiBhbm90aGVyLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVDb25zdHJ1Y3Rvcih0aHJvd24sIGVycm9yTGlrZSkge1xuICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBJZiBgZXJyb3JMaWtlYCBpcyBhbiBpbnN0YW5jZSBvZiBhbnkgZXJyb3Igd2UgY29tcGFyZSB0aGVpciBjb25zdHJ1Y3RvcnNcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UuY29uc3RydWN0b3IgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlLmNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGVycm9yTGlrZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvckxpa2UgPT09IEVycm9yKSB7XG4gICAgLy8gSWYgYGVycm9yTGlrZWAgaXMgYSBjb25zdHJ1Y3RvciB0aGF0IGluaGVyaXRzIGZyb20gRXJyb3IsIHdlIGNvbXBhcmUgYHRocm93bmAgdG8gYGVycm9yTGlrZWAgZGlyZWN0bHlcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKVxuICpcbiAqIENoZWNrcyBpZiBhbiBlcnJvcidzIG1lc3NhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIGEgbWF0Y2hlciAoU3RyaW5nIG9yIFJlZ0V4cCkuXG4gKiBJZiB0aGUgbWVzc2FnZSBjb250YWlucyB0aGUgU3RyaW5nIG9yIHBhc3NlcyB0aGUgUmVnRXhwIHRlc3QsXG4gKiBpdCBpcyBjb25zaWRlcmVkIGNvbXBhdGlibGUuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZU1lc3NhZ2VcbiAqIEBwYXJhbSB7RXJyb3J9IHRocm93biBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNYXRjaGVyIHRvIGxvb2sgZm9yIGludG8gdGhlIG1lc3NhZ2VcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKSB7XG4gIHZhciBjb21wYXJpc29uU3RyaW5nID0gdHlwZW9mIHRocm93biA9PT0gJ3N0cmluZycgPyB0aHJvd24gOiB0aHJvd24ubWVzc2FnZTtcbiAgaWYgKGVyck1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXJyTWF0Y2hlci50ZXN0KGNvbXBhcmlzb25TdHJpbmcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJNYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJpc29uU3RyaW5nLmluZGV4T2YoZXJyTWF0Y2hlcikgIT09IC0xOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKVxuICpcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbiAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBjb25zdHJ1Y3RvckZuLm5hbWVgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBuYW1lIGdldEZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JGblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGZ1bmN0aW9uTmFtZU1hdGNoID0gL1xccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqW14oPzoqXFwvKV0rXFwqXFwvXFxzKikqKFteXFwoXFwvXSspLztcbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKSB7XG4gIHZhciBuYW1lID0gJyc7XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3JGbi5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgY29uc3RydWN0b3JGbi5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIG1hdGNoID0gU3RyaW5nKGNvbnN0cnVjdG9yRm4pLm1hdGNoKGZ1bmN0aW9uTmFtZU1hdGNoKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IGNvbnN0cnVjdG9yRm4ubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSlcbiAqXG4gKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBuYW1lIGZvciBhbiBFcnJvciBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvciBpdHNlbGYuXG4gKlxuICogQG5hbWUgZ2V0Q29uc3RydWN0b3JOYW1lXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSB7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBlcnJvckxpa2U7XG4gIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UuY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBgZXJyYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRXJyb3IgaXQgaXMgYW4gZXJyb3IgY29uc3RydWN0b3IgaXRzZWxmIG9yIGFub3RoZXIgZnVuY3Rpb24uXG4gICAgLy8gSWYgd2UndmUgZ290IGEgY29tbW9uIGZ1bmN0aW9uIHdlIGdldCBpdHMgbmFtZSwgb3RoZXJ3aXNlIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgIC8vIG9mIHRoZSBlcnJvciBqdXN0IGluIGNhc2UgaXQncyBhIHBvb3JseS1jb25zdHJ1Y3RlZCBlcnJvci4gUGxlYXNlIHNlZSBjaGFpanMvY2hhaS9pc3N1ZXMvNDUgdG8ga25vdyBtb3JlLlxuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UpLnRyaW0oKSB8fFxuICAgICAgICBnZXRGdW5jdGlvbk5hbWUobmV3IGVycm9yTGlrZSgpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShlcnJvckxpa2UpXG4gKlxuICogR2V0cyB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIGVycm9yLlxuICogSWYgYGVycmAgaXMgYSBTdHJpbmcgaXRzZWxmLCB3ZSByZXR1cm4gaXQuXG4gKiBJZiB0aGUgZXJyb3IgaGFzIG5vIG1lc3NhZ2UsIHdlIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gKlxuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQHBhcmFtIHtFcnJvcnxTdHJpbmd9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGVycm9yTGlrZSkge1xuICB2YXIgbXNnID0gJyc7XG4gIGlmIChlcnJvckxpa2UgJiYgZXJyb3JMaWtlLm1lc3NhZ2UpIHtcbiAgICBtc2cgPSBlcnJvckxpa2UubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JMaWtlID09PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IGVycm9yTGlrZTtcbiAgfVxuXG4gIHJldHVybiBtc2c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXRpYmxlSW5zdGFuY2U6IGNvbXBhdGlibGVJbnN0YW5jZSxcbiAgY29tcGF0aWJsZUNvbnN0cnVjdG9yOiBjb21wYXRpYmxlQ29uc3RydWN0b3IsXG4gIGNvbXBhdGlibGVNZXNzYWdlOiBjb21wYXRpYmxlTWVzc2FnZSxcbiAgZ2V0TWVzc2FnZTogZ2V0TWVzc2FnZSxcbiAgZ2V0Q29uc3RydWN0b3JOYW1lOiBnZXRDb25zdHJ1Y3Rvck5hbWUsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFscyBTeW1ib2w6IGZhbHNlLCBVaW50OEFycmF5OiBmYWxzZSwgV2Vha01hcDogZmFsc2UgKi9cbi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuZnVuY3Rpb24gRmFrZU1hcCgpIHtcbiAgdGhpcy5fa2V5ID0gJ2NoYWkvZGVlcC1lcWxfXycgKyBNYXRoLnJhbmRvbSgpICsgRGF0ZS5ub3coKTtcbn1cblxuRmFrZU1hcC5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0TWFwKGtleSkge1xuICAgIHJldHVybiBrZXlbdGhpcy5fa2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMuX2tleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBNZW1vaXplTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogRmFrZU1hcDtcbi8qIVxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBNZW1vaXplTWFwIGhhcyByZWNvcmRlZCBhIHJlc3VsdCBvZiB0aGUgdHdvIG9wZXJhbmRzXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxlZnRIYW5kTWFwLmdldChyaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBTZXQgdGhlIHJlc3VsdCBvZiB0aGUgZXF1YWxpdHkgaW50byB0aGUgTWVtb2l6ZU1hcFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwLCByZXN1bHQpIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0SGFuZE1hcCA9IG5ldyBNZW1vaXplTWFwKCk7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gICAgbWVtb2l6ZU1hcC5zZXQobGVmdEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE1hcCk7XG4gIH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xubW9kdWxlLmV4cG9ydHMuTWVtb2l6ZU1hcCA9IE1lbW9pemVNYXA7XG5cbi8qKlxuICogQXNzZXJ0IGRlZXBseSBuZXN0ZWQgc2FtZVZhbHVlIGVxdWFsaXR5IGJldHdlZW4gdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJZiB3ZSBoYXZlIGEgY29tcGFyYXRvciwgd2UgY2FuJ3QgYXNzdW1lIGFueXRoaW5nOyBzbyBiYWlsIHRvIGl0cyBjaGVjayBmaXJzdC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICB9XG5cbiAgLy8gRGVlcGVyIGNvbXBhcmlzb25zIGFyZSBwdXNoZWQgdGhyb3VnaCB0byBhIGxhcmdlciBmdW5jdGlvblxuICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTWFueSBjb21wYXJpc29ucyBjYW4gYmUgY2FuY2VsZWQgb3V0IGVhcmx5IHZpYSBzaW1wbGUgZXF1YWxpdHkgb3IgcHJpbWl0aXZlIGNoZWNrcy5cbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgLy8gRXF1YWwgcmVmZXJlbmNlcyAoZXhjZXB0IGZvciBOdW1iZXJzKSBjYW4gYmUgcmV0dXJuZWQgZWFybHlcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZCkge1xuICAgIC8vIEhhbmRsZSArLTAgY2FzZXNcbiAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kICE9PSAwIHx8IDEgLyBsZWZ0SGFuZE9wZXJhbmQgPT09IDEgLyByaWdodEhhbmRPcGVyYW5kO1xuICB9XG5cbiAgLy8gaGFuZGxlIE5hTiBjYXNlc1xuICBpZiAoXG4gICAgbGVmdEhhbmRPcGVyYW5kICE9PSBsZWZ0SGFuZE9wZXJhbmQgJiYgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByaWdodEhhbmRPcGVyYW5kICE9PSByaWdodEhhbmRPcGVyYW5kIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQW55dGhpbmcgdGhhdCBpcyBub3QgYW4gJ29iamVjdCcsIGkuZS4gc3ltYm9scywgZnVuY3Rpb25zLCBib29sZWFucywgbnVtYmVycyxcbiAgLy8gc3RyaW5ncywgYW5kIHVuZGVmaW5lZCwgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZS5cbiAgaWYgKGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICAvLyBFYXN5IG91dCBiL2MgaXQgd291bGQgaGF2ZSBwYXNzZWQgdGhlIGZpcnN0IGVxdWFsaXR5IGNoZWNrXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFRoZSBtYWluIGxvZ2ljIG9mIHRoZSBgZGVlcEVxdWFsYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuKi9cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubWVtb2l6ZSA9IG9wdGlvbnMubWVtb2l6ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IG9wdGlvbnMubWVtb2l6ZSB8fCBuZXcgTWVtb2l6ZU1hcCgpO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yO1xuXG4gIC8vIENoZWNrIGlmIGEgbWVtb2l6ZWQgcmVzdWx0IGV4aXN0cy5cbiAgdmFyIG1lbW9pemVSZXN1bHRMZWZ0ID0gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdExlZnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdExlZnQ7XG4gIH1cbiAgdmFyIG1lbW9pemVSZXN1bHRSaWdodCA9IG1lbW9pemVDb21wYXJlKHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRSaWdodCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0UmlnaHQ7XG4gIH1cblxuICAvLyBJZiBhIGNvbXBhcmF0b3IgaXMgcHJlc2VudCwgdXNlIGl0LlxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHZhciBjb21wYXJhdG9yUmVzdWx0ID0gY29tcGFyYXRvcihsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIC8vIENvbXBhcmF0b3JzIG1heSByZXR1cm4gbnVsbCwgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGdvIGJhY2sgdG8gZGVmYXVsdCBiZWhhdmlvci5cbiAgICBpZiAoY29tcGFyYXRvclJlc3VsdCA9PT0gZmFsc2UgfHwgY29tcGFyYXRvclJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgY29tcGFyYXRvclJlc3VsdCk7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclJlc3VsdDtcbiAgICB9XG4gICAgLy8gVG8gYWxsb3cgY29tcGFyYXRvcnMgdG8gb3ZlcnJpZGUgKmFueSogYmVoYXZpb3IsIHdlIHJhbiB0aGVtIGZpcnN0LiBTaW5jZSBpdCBkaWRuJ3QgZGVjaWRlXG4gICAgLy8gd2hhdCB0byBkbywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSBiYXNpYyB0ZXN0cyBmaXJzdCBiZWZvcmUgd2UgbW92ZSBvbi5cbiAgICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAvLyBEb24ndCBtZW1vaXplIHRoaXMsIGl0IHRha2VzIGxvbmdlciB0byBzZXQvcmV0cmlldmUgdGhhbiB0byBqdXN0IGNvbXBhcmUuXG4gICAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZWZ0SGFuZFR5cGUgPSB0eXBlKGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZFR5cGUgIT09IHR5cGUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVtcG9yYXJpbHkgc2V0IHRoZSBvcGVyYW5kcyBpbiB0aGUgbWVtb2l6ZSBvYmplY3QgdG8gcHJldmVudCBibG93aW5nIHRoZSBzdGFja1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCB0cnVlKTtcblxuICB2YXIgcmVzdWx0ID0gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKTtcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKSB7XG4gIHN3aXRjaCAobGVmdEhhbmRUeXBlKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgLy8gSWYgdGhlc2UgdHlwZXMgYXJlIHRoZWlyIGluc3RhbmNlIHR5cGVzIChlLmcuIGBuZXcgTnVtYmVyYCkgdGhlbiByZS1kZWVwRXF1YWwgYWdhaW5zdCB0aGVpciB2YWx1ZXNcbiAgICAgIHJldHVybiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLnZhbHVlT2YoKSwgcmlnaHRIYW5kT3BlcmFuZC52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1Byb21pc2UnOlxuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgIGNhc2UgJ1dlYWtTZXQnOlxuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQ7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdJbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgICBjYXNlICdJbnQxNkFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBjYXNlICdHZW5lcmF0b3InOlxuICAgICAgcmV0dXJuIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnRGF0YVZpZXcnOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kLmJ1ZmZlciksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQuYnVmZmVyKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnTWFwJzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQudG9TdHJpbmcoKSA9PT0gcmlnaHRIYW5kT3BlcmFuZC50b1N0cmluZygpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFNldHMvTWFwcyBmb3IgZXF1YWxpdHkuIEZhc3RlciB0aGFuIG90aGVyIGVxdWFsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1NldH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1NldH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElFMTEgZG9lc24ndCBzdXBwb3J0IFNldCNlbnRyaWVzIG9yIFNldCNAQGl0ZXJhdG9yLCBzbyB3ZSBuZWVkIG1hbnVhbGx5IHBvcHVsYXRlIHVzaW5nIFNldCNmb3JFYWNoXG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSAhPT0gcmlnaHRIYW5kT3BlcmFuZC5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBsZWZ0SGFuZEl0ZW1zID0gW107XG4gIHZhciByaWdodEhhbmRJdGVtcyA9IFtdO1xuICBsZWZ0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICBsZWZ0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmlnaHRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJpZ2h0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRJdGVtcy5zb3J0KCksIHJpZ2h0SGFuZEl0ZW1zLnNvcnQoKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHMgc3VjaCBhcyBBcnJheXMsIFR5cGVkQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGxlZnRIYW5kT3BlcmFuZC5sZW5ndGg7XG4gIGlmIChsZW5ndGggIT09IHJpZ2h0SGFuZE9wZXJhbmQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtpbmRleF0sIHJpZ2h0SGFuZE9wZXJhbmRbaW5kZXhdLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBnZW5lcmF0b3Igb2JqZWN0cyBzdWNoIGFzIHRob3NlIHJldHVybmVkIGJ5IGdlbmVyYXRvciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChnZXRHZW5lcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCksIGdldEdlbmVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGl0ZXJhdG9yIGVudHJpZXMgZnJvbSB0aGUgZ2l2ZW4gT2JqZWN0LiBJZiB0aGUgT2JqZWN0IGhhcyBubyBAQGl0ZXJhdG9yIGZ1bmN0aW9uLCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICogVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGl0ZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSBAQGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBAQGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRW50cmllcyh0YXJnZXQpIHtcbiAgaWYgKGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2V0R2VuZXJhdG9yRW50cmllcyh0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9IGNhdGNoIChpdGVyYXRvckVycm9yKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBlbnRyaWVzIGZyb20gYSBHZW5lcmF0b3IuIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBnZW5lcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0dlbmVyYXRvcn0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgR2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBnZXRHZW5lcmF0b3JFbnRyaWVzKGdlbmVyYXRvcikge1xuICB2YXIgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgdmFyIGFjY3VtdWxhdG9yID0gWyBnZW5lcmF0b3JSZXN1bHQudmFsdWUgXTtcbiAgd2hpbGUgKGdlbmVyYXRvclJlc3VsdC5kb25lID09PSBmYWxzZSkge1xuICAgIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgYWNjdW11bGF0b3IucHVzaChnZW5lcmF0b3JSZXN1bHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVLZXlzKHRhcmdldCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lcyBpZiB0d28gb2JqZWN0cyBoYXZlIG1hdGNoaW5nIHZhbHVlcywgZ2l2ZW4gYSBzZXQgb2Yga2V5cy4gRGVmZXJzIHRvIGRlZXBFcXVhbCBmb3IgdGhlIGVxdWFsaXR5IGNoZWNrIG9mXG4gKiBlYWNoIGtleS4gSWYgYW55IHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkgaXMgbm90IGVxdWFsLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgKGVhcmx5KS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgQW4gYXJyYXkgb2Yga2V5cyB0byBjb21wYXJlIHRoZSB2YWx1ZXMgb2YgbGVmdEhhbmRPcGVyYW5kIGFuZCByaWdodEhhbmRPcGVyYW5kIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2tleXNbaV1dLCByaWdodEhhbmRPcGVyYW5kW2tleXNbaV1dLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBPYmplY3RzLiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGwgZGVmZXIgdG8gYGRlZXBFcXVhbGBcbiAqIGZvciBlYWNoIGVudW1lcmFibGUga2V5IGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVmdEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggJiYgbGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gcmlnaHRIYW5kS2V5cy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEtleXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEtleXMuc29ydCgpO1xuICAgIGlmIChpdGVyYWJsZUVxdWFsKGxlZnRIYW5kS2V5cywgcmlnaHRIYW5kS2V5cykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZEtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxlZnRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kRW50cmllcy5sZW5ndGggJiYgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gcmlnaHRIYW5kRW50cmllcy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kRW50cmllcywgcmlnaHRIYW5kRW50cmllcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIVxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHByaW1pdGl2ZS5cbiAqXG4gKiBUaGlzIGludGVudGlvbmFsbHkgcmV0dXJucyB0cnVlIGZvciBhbGwgb2JqZWN0cyB0aGF0IGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UsXG4gKiBpbmNsdWRpbmcgZnVuY3Rpb25zIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCc7XG59XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGNvbnZlcnRDaGFuZ2VzVG9ETVA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4vLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICAgIGNoYW5nZSxcbiAgICAgIG9wZXJhdGlvbjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgb3BlcmF0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlqYjI1MlpYSjBMMlJ0Y0M1cWN5SmRMQ0p1WVcxbGN5STZXeUpqYjI1MlpYSjBRMmhoYm1kbGMxUnZSRTFRSWl3aVkyaGhibWRsY3lJc0luSmxkQ0lzSW1Ob1lXNW5aU0lzSW05d1pYSmhkR2x2YmlJc0lta2lMQ0pzWlc1bmRHZ2lMQ0poWkdSbFpDSXNJbkpsYlc5MlpXUWlMQ0p3ZFhOb0lpd2lkbUZzZFdVaVhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenRCUVVGQk8wRkJRMDhzVTBGQlUwRXNiVUpCUVZRc1EwRkJOa0pETEU5QlFUZENMRVZCUVhORE8wRkJRek5ETEUxQlFVbERMRWRCUVVjc1IwRkJSeXhGUVVGV08wRkJRVUVzVFVGRFNVTXNUVUZFU2p0QlFVRkJMRTFCUlVsRExGTkJSa283TzBGQlIwRXNUMEZCU3l4SlFVRkpReXhEUVVGRExFZEJRVWNzUTBGQllpeEZRVUZuUWtFc1EwRkJReXhIUVVGSFNpeFBRVUZQTEVOQlFVTkxMRTFCUVRWQ0xFVkJRVzlEUkN4RFFVRkRMRVZCUVhKRExFVkJRWGxETzBGQlEzWkRSaXhKUVVGQlFTeE5RVUZOTEVkQlFVZEdMRTlCUVU4c1EwRkJRMGtzUTBGQlJDeERRVUZvUWpzN1FVRkRRU3hSUVVGSlJpeE5RVUZOTEVOQlFVTkpMRXRCUVZnc1JVRkJhMEk3UVVGRGFFSklMRTFCUVVGQkxGTkJRVk1zUjBGQlJ5eERRVUZhTzBGQlEwUXNTMEZHUkN4TlFVVlBMRWxCUVVsRUxFMUJRVTBzUTBGQlEwc3NUMEZCV0N4RlFVRnZRanRCUVVONlFrb3NUVUZCUVVFc1UwRkJVeXhIUVVGSExFTkJRVU1zUTBGQllqdEJRVU5FTEV0QlJrMHNUVUZGUVR0QlFVTk1RU3hOUVVGQlFTeFRRVUZUTEVkQlFVY3NRMEZCV2p0QlFVTkVPenRCUVVWRVJpeEpRVUZCUVN4SFFVRkhMRU5CUVVOUExFbEJRVW9zUTBGQlV5eERRVUZEVEN4VFFVRkVMRVZCUVZsRUxFMUJRVTBzUTBGQlEwOHNTMEZCYmtJc1EwRkJWRHRCUVVORU96dEJRVU5FTEZOQlFVOVNMRWRCUVZBN1FVRkRSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4dklGTmxaVG9nYUhSMGNEb3ZMMk52WkdVdVoyOXZaMnhsTG1OdmJTOXdMMmR2YjJkc1pTMWthV1ptTFcxaGRHTm9MWEJoZEdOb0wzZHBhMmt2UVZCSlhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1kyOXVkbVZ5ZEVOb1lXNW5aWE5VYjBSTlVDaGphR0Z1WjJWektTQjdYRzRnSUd4bGRDQnlaWFFnUFNCYlhTeGNiaUFnSUNBZ0lHTm9ZVzVuWlN4Y2JpQWdJQ0FnSUc5d1pYSmhkR2x2Ymp0Y2JpQWdabTl5SUNoc1pYUWdhU0E5SURBN0lHa2dQQ0JqYUdGdVoyVnpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnWTJoaGJtZGxJRDBnWTJoaGJtZGxjMXRwWFR0Y2JpQWdJQ0JwWmlBb1kyaGhibWRsTG1Ga1pHVmtLU0I3WEc0Z0lDQWdJQ0J2Y0dWeVlYUnBiMjRnUFNBeE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb1kyaGhibWRsTG5KbGJXOTJaV1FwSUh0Y2JpQWdJQ0FnSUc5d1pYSmhkR2x2YmlBOUlDMHhPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCdmNHVnlZWFJwYjI0Z1BTQXdPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkQzV3ZFhOb0tGdHZjR1Z5WVhScGIyNHNJR05vWVc1blpTNTJZV3gxWlYwcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5WEc0aVhYMD1cbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvWE1MID0gY29udmVydENoYW5nZXNUb1hNTDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICByZXQucHVzaCgnPGlucz4nKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICB9XG5cbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgdmFyIG4gPSBzO1xuICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgbiA9IG4ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICByZXR1cm4gbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjUyWlhKMEwzaHRiQzVxY3lKZExDSnVZVzFsY3lJNld5SmpiMjUyWlhKMFEyaGhibWRsYzFSdldFMU1JaXdpWTJoaGJtZGxjeUlzSW5KbGRDSXNJbWtpTENKc1pXNW5kR2dpTENKamFHRnVaMlVpTENKaFpHUmxaQ0lzSW5CMWMyZ2lMQ0p5WlcxdmRtVmtJaXdpWlhOallYQmxTRlJOVENJc0luWmhiSFZsSWl3aWFtOXBiaUlzSW5NaUxDSnVJaXdpY21Wd2JHRmpaU0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN08wRkJRVThzVTBGQlUwRXNiVUpCUVZRc1EwRkJOa0pETEU5QlFUZENMRVZCUVhORE8wRkJRek5ETEUxQlFVbERMRWRCUVVjc1IwRkJSeXhGUVVGV096dEJRVU5CTEU5QlFVc3NTVUZCU1VNc1EwRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRU5CUVVNc1IwRkJSMFlzVDBGQlR5eERRVUZEUnl4TlFVRTFRaXhGUVVGdlEwUXNRMEZCUXl4RlFVRnlReXhGUVVGNVF6dEJRVU4yUXl4UlFVRkpSU3hOUVVGTkxFZEJRVWRLTEU5QlFVOHNRMEZCUTBVc1EwRkJSQ3hEUVVGd1FqczdRVUZEUVN4UlFVRkpSU3hOUVVGTkxFTkJRVU5ETEV0QlFWZ3NSVUZCYTBJN1FVRkRhRUpLTEUxQlFVRkJMRWRCUVVjc1EwRkJRMHNzU1VGQlNpeERRVUZUTEU5QlFWUTdRVUZEUkN4TFFVWkVMRTFCUlU4c1NVRkJTVVlzVFVGQlRTeERRVUZEUnl4UFFVRllMRVZCUVc5Q08wRkJRM3BDVGl4TlFVRkJRU3hIUVVGSExFTkJRVU5MTEVsQlFVb3NRMEZCVXl4UFFVRlVPMEZCUTBRN08wRkJSVVJNTEVsQlFVRkJMRWRCUVVjc1EwRkJRMHNzU1VGQlNpeERRVUZUUlN4VlFVRlZMRU5CUVVOS0xFMUJRVTBzUTBGQlEwc3NTMEZCVWl4RFFVRnVRanM3UVVGRlFTeFJRVUZKVEN4TlFVRk5MRU5CUVVORExFdEJRVmdzUlVGQmEwSTdRVUZEYUVKS0xFMUJRVUZCTEVkQlFVY3NRMEZCUTBzc1NVRkJTaXhEUVVGVExGRkJRVlE3UVVGRFJDeExRVVpFTEUxQlJVOHNTVUZCU1VZc1RVRkJUU3hEUVVGRFJ5eFBRVUZZTEVWQlFXOUNPMEZCUTNwQ1RpeE5RVUZCUVN4SFFVRkhMRU5CUVVOTExFbEJRVW9zUTBGQlV5eFJRVUZVTzBGQlEwUTdRVUZEUmpzN1FVRkRSQ3hUUVVGUFRDeEhRVUZITEVOQlFVTlRMRWxCUVVvc1EwRkJVeXhGUVVGVUxFTkJRVkE3UVVGRFJEczdRVUZGUkN4VFFVRlRSaXhWUVVGVUxFTkJRVzlDUnl4RFFVRndRaXhGUVVGMVFqdEJRVU55UWl4TlFVRkpReXhEUVVGRExFZEJRVWRFTEVOQlFWSTdRVUZEUVVNc1JVRkJRVUVzUTBGQlF5eEhRVUZIUVN4RFFVRkRMRU5CUVVORExFOUJRVVlzUTBGQlZTeEpRVUZXTEVWQlFXZENMRTlCUVdoQ0xFTkJRVW83UVVGRFFVUXNSVUZCUVVFc1EwRkJReXhIUVVGSFFTeERRVUZETEVOQlFVTkRMRTlCUVVZc1EwRkJWU3hKUVVGV0xFVkJRV2RDTEUxQlFXaENMRU5CUVVvN1FVRkRRVVFzUlVGQlFVRXNRMEZCUXl4SFFVRkhRU3hEUVVGRExFTkJRVU5ETEU5QlFVWXNRMEZCVlN4SlFVRldMRVZCUVdkQ0xFMUJRV2hDTEVOQlFVbzdRVUZEUVVRc1JVRkJRVUVzUTBGQlF5eEhRVUZIUVN4RFFVRkRMRU5CUVVORExFOUJRVVlzUTBGQlZTeEpRVUZXTEVWQlFXZENMRkZCUVdoQ0xFTkJRVW83UVVGRlFTeFRRVUZQUkN4RFFVRlFPMEZCUTBRaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmxlSEJ2Y25RZ1puVnVZM1JwYjI0Z1kyOXVkbVZ5ZEVOb1lXNW5aWE5VYjFoTlRDaGphR0Z1WjJWektTQjdYRzRnSUd4bGRDQnlaWFFnUFNCYlhUdGNiaUFnWm05eUlDaHNaWFFnYVNBOUlEQTdJR2tnUENCamFHRnVaMlZ6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ2JHVjBJR05vWVc1blpTQTlJR05vWVc1blpYTmJhVjA3WEc0Z0lDQWdhV1lnS0dOb1lXNW5aUzVoWkdSbFpDa2dlMXh1SUNBZ0lDQWdjbVYwTG5CMWMyZ29KenhwYm5NK0p5azdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaGphR0Z1WjJVdWNtVnRiM1psWkNrZ2UxeHVJQ0FnSUNBZ2NtVjBMbkIxYzJnb0p6eGtaV3crSnlrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnY21WMExuQjFjMmdvWlhOallYQmxTRlJOVENoamFHRnVaMlV1ZG1Gc2RXVXBLVHRjYmx4dUlDQWdJR2xtSUNoamFHRnVaMlV1WVdSa1pXUXBJSHRjYmlBZ0lDQWdJSEpsZEM1d2RYTm9LQ2M4TDJsdWN6NG5LVHRjYmlBZ0lDQjlJR1ZzYzJVZ2FXWWdLR05vWVc1blpTNXlaVzF2ZG1Wa0tTQjdYRzRnSUNBZ0lDQnlaWFF1Y0hWemFDZ25QQzlrWld3K0p5azdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCeVpYUXVhbTlwYmlnbkp5azdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHVnpZMkZ3WlVoVVRVd29jeWtnZTF4dUlDQnNaWFFnYmlBOUlITTdYRzRnSUc0Z1BTQnVMbkpsY0d4aFkyVW9MeVl2Wnl3Z0p5WmhiWEE3SnlrN1hHNGdJRzRnUFNCdUxuSmxjR3hoWTJVb0x6d3ZaeXdnSnlac2REc25LVHRjYmlBZ2JpQTlJRzR1Y21Wd2JHRmpaU2d2UGk5bkxDQW5KbWQwT3ljcE8xeHVJQ0J1SUQwZ2JpNXlaWEJzWVdObEtDOWNJaTluTENBbkpuRjFiM1E3SnlrN1hHNWNiaUFnY21WMGRYSnVJRzQ3WEc1OVhHNGlYWDA9XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZkFycmF5cyA9IGRpZmZBcnJheXM7XG5leHBvcnRzLmFycmF5RGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIGFycmF5RGlmZiA9IG5ld1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2Vcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5bXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cImRlZmF1bHRcIlxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbl0oKTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5hcnJheURpZmYgPSBhcnJheURpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5hcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG59O1xuXG5hcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xuICByZXR1cm4gYXJyYXlEaWZmLmRpZmYob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJGeWNtRjVMbXB6SWwwc0ltNWhiV1Z6SWpwYkltRnljbUY1UkdsbVppSXNJa1JwWm1ZaUxDSjBiMnRsYm1sNlpTSXNJblpoYkhWbElpd2ljMnhwWTJVaUxDSnFiMmx1SWl3aWNtVnRiM1psUlcxd2RIa2lMQ0prYVdabVFYSnlZWGx6SWl3aWIyeGtRWEp5SWl3aWJtVjNRWEp5SWl3aVkyRnNiR0poWTJzaUxDSmthV1ptSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdPenM3UVVGRlR5eEpRVUZOUVN4VFFVRlRMRWRCUVVjN1FVRkJTVU03UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNRMEZCU2l4RlFVRnNRanM3T3pzN08wRkJRMUJFTEZOQlFWTXNRMEZCUTBVc1VVRkJWaXhIUVVGeFFpeFZRVUZUUXl4TFFVRlVMRVZCUVdkQ08wRkJRMjVETEZOQlFVOUJMRXRCUVVzc1EwRkJRME1zUzBGQlRpeEZRVUZRTzBGQlEwUXNRMEZHUkRzN1FVRkhRVW9zVTBGQlV5eERRVUZEU3l4SlFVRldMRWRCUVdsQ1RDeFRRVUZUTEVOQlFVTk5MRmRCUVZZc1IwRkJkMElzVlVGQlUwZ3NTMEZCVkN4RlFVRm5RanRCUVVOMlJDeFRRVUZQUVN4TFFVRlFPMEZCUTBRc1EwRkdSRHM3UVVGSlR5eFRRVUZUU1N4VlFVRlVMRU5CUVc5Q1F5eE5RVUZ3UWl4RlFVRTBRa01zVFVGQk5VSXNSVUZCYjBORExGRkJRWEJETEVWQlFUaERPMEZCUVVVc1UwRkJUMVlzVTBGQlV5eERRVUZEVnl4SlFVRldMRU5CUVdWSUxFMUJRV1lzUlVGQmRVSkRMRTFCUVhaQ0xFVkJRU3RDUXl4UlFVRXZRaXhEUVVGUU8wRkJRV3RFSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXMXdiM0owSUVScFptWWdabkp2YlNBbkxpOWlZWE5sSnp0Y2JseHVaWGh3YjNKMElHTnZibk4wSUdGeWNtRjVSR2xtWmlBOUlHNWxkeUJFYVdabUtDazdYRzVoY25KaGVVUnBabVl1ZEc5clpXNXBlbVVnUFNCbWRXNWpkR2x2YmloMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z2RtRnNkV1V1YzJ4cFkyVW9LVHRjYm4wN1hHNWhjbkpoZVVScFptWXVhbTlwYmlBOUlHRnljbUY1UkdsbVppNXlaVzF2ZG1WRmJYQjBlU0E5SUdaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCMllXeDFaVHRjYm4wN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmthV1ptUVhKeVlYbHpLRzlzWkVGeWNpd2dibVYzUVhKeUxDQmpZV3hzWW1GamF5a2dleUJ5WlhSMWNtNGdZWEp5WVhsRWFXWm1MbVJwWm1Zb2IyeGtRWEp5TENCdVpYZEJjbklzSUdOaGJHeGlZV05yS1RzZ2ZWeHVJbDE5XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGlmZjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIERpZmYoKSB7fVxuXG5EaWZmLnByb3RvdHlwZSA9IHtcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgdmFyXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xuXG5cbiAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0cmluZyk7XG4gICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcbiAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgZWRpdExlbmd0aCA9IDE7XG4gICAgdmFyIG1heEVkaXRMZW5ndGggPSBuZXdMZW4gKyBvbGRMZW47XG4gICAgdmFyIGJlc3RQYXRoID0gW3tcbiAgICAgIG5ld1BvczogLTEsXG4gICAgICBjb21wb25lbnRzOiBbXVxuICAgIH1dOyAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuXG4gICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuXG4gICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcbiAgICAgIHJldHVybiBkb25lKFt7XG4gICAgICAgIHZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSxcbiAgICAgICAgY291bnQ6IG5ld1N0cmluZy5sZW5ndGhcbiAgICAgIH1dKTtcbiAgICB9IC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cblxuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICB2YXIgYmFzZVBhdGggPVxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgIHZvaWQgMFxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICA7XG5cbiAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcbiAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXSxcbiAgICAgICAgICAgIF9vbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG5cbiAgICAgICAgaWYgKGFkZFBhdGgpIHtcbiAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbkFkZCA9IGFkZFBhdGggJiYgYWRkUGF0aC5uZXdQb3MgKyAxIDwgbmV3TGVuLFxuICAgICAgICAgICAgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IF9vbGRQb3MgJiYgX29sZFBvcyA8IG9sZExlbjtcblxuICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcblxuXG4gICAgICAgIGlmICghY2FuQWRkIHx8IGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxuXG4gICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfb2xkUG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTsgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgX29sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfSAvLyBQZXJmb3JtcyB0aGUgbGVuZ3RoIG9mIGVkaXQgaXRlcmF0aW9uLiBJcyBhIGJpdCBmdWdseSBhcyB0aGlzIGhhcyB0byBzdXBwb3J0IHRoZVxuICAgIC8vIHN5bmMgYW5kIGFzeW5jIG1vZGUgd2hpY2ggaXMgbmV2ZXIgZnVuLiBMb29wcyBvdmVyIGV4ZWNFZGl0TGVuZ3RoIHVudGlsIGEgdmFsdWVcbiAgICAvLyBpcyBwcm9kdWNlZC5cblxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgcHVzaENvbXBvbmVudDogZnVuY3Rpb24gcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHZhciBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxuICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0ge1xuICAgICAgICBjb3VudDogbGFzdC5jb3VudCArIDEsXG4gICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbiBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcbiAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxuICAgICAgICBjb21tb25Db3VudCA9IDA7XG5cbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICBjb3VudDogY29tbW9uQ291bnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICByZXR1cm4gb2xkUG9zO1xuICB9LFxuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlICYmIGxlZnQudG9Mb3dlckNhc2UoKSA9PT0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIHJlbW92ZUVtcHR5OiBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgY2FzdElucHV0OiBmdW5jdGlvbiBjYXN0SW5wdXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIHRva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gIH0sXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgIG5ld1BvcyA9IDAsXG4gICAgICBvbGRQb3MgPSAwO1xuXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcblxuICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgfVxuXG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBDb21tb24gY2FzZVxuXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4ob2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxuICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcbiAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxuXG4gICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgdmFyIHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZCAoaS5lLiB3aGl0ZXNwYWNlKS5cbiAgLy8gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGUgdGVybWluYWwgaW50byB0aGUgcHJpb3Igc3RyaW5nIGFuZCBkcm9wIHRoZSBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxuXG5cbiAgdmFyIGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuXG4gIGlmIChjb21wb25lbnRMZW4gPiAxICYmIHR5cGVvZiBsYXN0Q29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJyAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpICYmIGRpZmYuZXF1YWxzKCcnLCBsYXN0Q29tcG9uZW50LnZhbHVlKSkge1xuICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gbGFzdENvbXBvbmVudC52YWx1ZTtcbiAgICBjb21wb25lbnRzLnBvcCgpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG5cbmZ1bmN0aW9uIGNsb25lUGF0aChwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgbmV3UG9zOiBwYXRoLm5ld1BvcyxcbiAgICBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMClcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJKaGMyVXVhbk1pWFN3aWJtRnRaWE1pT2xzaVJHbG1aaUlzSW5CeWIzUnZkSGx3WlNJc0ltUnBabVlpTENKdmJHUlRkSEpwYm1jaUxDSnVaWGRUZEhKcGJtY2lMQ0p2Y0hScGIyNXpJaXdpWTJGc2JHSmhZMnNpTENKelpXeG1JaXdpWkc5dVpTSXNJblpoYkhWbElpd2ljMlYwVkdsdFpXOTFkQ0lzSW5WdVpHVm1hVzVsWkNJc0ltTmhjM1JKYm5CMWRDSXNJbkpsYlc5MlpVVnRjSFI1SWl3aWRHOXJaVzVwZW1VaUxDSnVaWGRNWlc0aUxDSnNaVzVuZEdnaUxDSnZiR1JNWlc0aUxDSmxaR2wwVEdWdVozUm9JaXdpYldGNFJXUnBkRXhsYm1kMGFDSXNJbUpsYzNSUVlYUm9JaXdpYm1WM1VHOXpJaXdpWTI5dGNHOXVaVzUwY3lJc0ltOXNaRkJ2Y3lJc0ltVjRkSEpoWTNSRGIyMXRiMjRpTENKcWIybHVJaXdpWTI5MWJuUWlMQ0psZUdWalJXUnBkRXhsYm1kMGFDSXNJbVJwWVdkdmJtRnNVR0YwYUNJc0ltSmhjMlZRWVhSb0lpd2lZV1JrVUdGMGFDSXNJbkpsYlc5MlpWQmhkR2dpTENKallXNUJaR1FpTENKallXNVNaVzF2ZG1VaUxDSmpiRzl1WlZCaGRHZ2lMQ0p3ZFhOb1EyOXRjRzl1Wlc1MElpd2lZblZwYkdSV1lXeDFaWE1pTENKMWMyVk1iMjVuWlhOMFZHOXJaVzRpTENKbGVHVmpJaXdpY21WMElpd2lZV1JrWldRaUxDSnlaVzF2ZG1Wa0lpd2liR0Z6ZENJc0luQjFjMmdpTENKamIyMXRiMjVEYjNWdWRDSXNJbVZ4ZFdGc2N5SXNJbXhsWm5RaUxDSnlhV2RvZENJc0ltTnZiWEJoY21GMGIzSWlMQ0pwWjI1dmNtVkRZWE5sSWl3aWRHOU1iM2RsY2tOaGMyVWlMQ0poY25KaGVTSXNJbWtpTENKemNHeHBkQ0lzSW1Ob1lYSnpJaXdpWTI5dGNHOXVaVzUwVUc5eklpd2lZMjl0Y0c5dVpXNTBUR1Z1SWl3aVkyOXRjRzl1Wlc1MElpd2ljMnhwWTJVaUxDSnRZWEFpTENKdmJHUldZV3gxWlNJc0luUnRjQ0lzSW14aGMzUkRiMjF3YjI1bGJuUWlMQ0p3YjNBaUxDSndZWFJvSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdRVUZCWlN4VFFVRlRRU3hKUVVGVUxFZEJRV2RDTEVOQlFVVTdPMEZCUldwRFFTeEpRVUZKTEVOQlFVTkRMRk5CUVV3c1IwRkJhVUk3UVVGQlFUczdRVUZCUVR0QlFVTm1ReXhGUVVGQlFTeEpRVVJsTEdkQ1FVTldReXhUUVVSVkxFVkJRME5ETEZOQlJFUXNSVUZETUVJN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlpFTXNTVUZCUVVFc1QwRkJZeXgxUlVGQlNpeEZRVUZKTzBGQlEzWkRMRkZCUVVsRExGRkJRVkVzUjBGQlIwUXNUMEZCVHl4RFFVRkRReXhSUVVGMlFqczdRVUZEUVN4UlFVRkpMRTlCUVU5RUxFOUJRVkFzUzBGQmJVSXNWVUZCZGtJc1JVRkJiVU03UVVGRGFrTkRMRTFCUVVGQkxGRkJRVkVzUjBGQlIwUXNUMEZCV0R0QlFVTkJRU3hOUVVGQlFTeFBRVUZQTEVkQlFVY3NSVUZCVmp0QlFVTkVPenRCUVVORUxGTkJRVXRCTEU5QlFVd3NSMEZCWlVFc1QwRkJaanRCUVVWQkxGRkJRVWxGTEVsQlFVa3NSMEZCUnl4SlFVRllPenRCUVVWQkxHRkJRVk5ETEVsQlFWUXNRMEZCWTBNc1MwRkJaQ3hGUVVGeFFqdEJRVU51UWl4VlFVRkpTQ3hSUVVGS0xFVkJRV003UVVGRFdra3NVVUZCUVVFc1ZVRkJWU3hEUVVGRExGbEJRVmM3UVVGQlJVb3NWVUZCUVVFc1VVRkJVU3hEUVVGRFN5eFRRVUZFTEVWQlFWbEdMRXRCUVZvc1EwRkJVanRCUVVFMlFpeFRRVUV6UXl4RlFVRTJReXhEUVVFM1F5eERRVUZXTzBGQlEwRXNaVUZCVHl4SlFVRlFPMEZCUTBRc1QwRklSQ3hOUVVkUE8wRkJRMHdzWlVGQlQwRXNTMEZCVUR0QlFVTkVPMEZCUTBZc1MwRnFRbk5ETEVOQmJVSjJRenM3TzBGQlEwRk9MRWxCUVVGQkxGTkJRVk1zUjBGQlJ5eExRVUZMVXl4VFFVRk1MRU5CUVdWVUxGTkJRV1lzUTBGQldqdEJRVU5CUXl4SlFVRkJRU3hUUVVGVExFZEJRVWNzUzBGQlMxRXNVMEZCVEN4RFFVRmxVaXhUUVVGbUxFTkJRVm83UVVGRlFVUXNTVUZCUVVFc1UwRkJVeXhIUVVGSExFdEJRVXRWTEZkQlFVd3NRMEZCYVVJc1MwRkJTME1zVVVGQlRDeERRVUZqV0N4VFFVRmtMRU5CUVdwQ0xFTkJRVm83UVVGRFFVTXNTVUZCUVVFc1UwRkJVeXhIUVVGSExFdEJRVXRUTEZkQlFVd3NRMEZCYVVJc1MwRkJTME1zVVVGQlRDeERRVUZqVml4VFFVRmtMRU5CUVdwQ0xFTkJRVm83UVVGRlFTeFJRVUZKVnl4TlFVRk5MRWRCUVVkWUxGTkJRVk1zUTBGQlExa3NUVUZCZGtJN1FVRkJRU3hSUVVFclFrTXNUVUZCVFN4SFFVRkhaQ3hUUVVGVExFTkJRVU5oTEUxQlFXeEVPMEZCUTBFc1VVRkJTVVVzVlVGQlZTeEhRVUZITEVOQlFXcENPMEZCUTBFc1VVRkJTVU1zWVVGQllTeEhRVUZIU2l4TlFVRk5MRWRCUVVkRkxFMUJRVGRDTzBGQlEwRXNVVUZCU1Vjc1VVRkJVU3hIUVVGSExFTkJRVU03UVVGQlJVTXNUVUZCUVVFc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQldEdEJRVUZqUXl4TlFVRkJRU3hWUVVGVkxFVkJRVVU3UVVGQk1VSXNTMEZCUkN4RFFVRm1MRU5CTjBKMVF5eERRU3RDZGtNN08wRkJRMEVzVVVGQlNVTXNUVUZCVFN4SFFVRkhMRXRCUVV0RExHRkJRVXdzUTBGQmJVSktMRkZCUVZFc1EwRkJReXhEUVVGRUxFTkJRVE5DTEVWQlFXZERhRUlzVTBGQmFFTXNSVUZCTWtORUxGTkJRVE5ETEVWQlFYTkVMRU5CUVhSRUxFTkJRV0k3TzBGQlEwRXNVVUZCU1dsQ0xGRkJRVkVzUTBGQlF5eERRVUZFTEVOQlFWSXNRMEZCV1VNc1RVRkJXaXhIUVVGeFFpeERRVUZ5UWl4SlFVRXdRazRzVFVGQk1VSXNTVUZCYjBOUkxFMUJRVTBzUjBGQlJ5eERRVUZVTEVsQlFXTk9MRTFCUVhSRUxFVkJRVGhFTzBGQlF6VkVPMEZCUTBFc1lVRkJUMVFzU1VGQlNTeERRVUZETEVOQlFVTTdRVUZCUTBNc1VVRkJRVUVzUzBGQlN5eEZRVUZGTEV0QlFVdG5RaXhKUVVGTUxFTkJRVlZ5UWl4VFFVRldMRU5CUVZJN1FVRkJPRUp6UWl4UlFVRkJRU3hMUVVGTExFVkJRVVYwUWl4VFFVRlRMRU5CUVVOWk8wRkJRUzlETEU5QlFVUXNRMEZCUkN4RFFVRllPMEZCUTBRc1MwRndRM05ETEVOQmMwTjJRenM3TzBGQlEwRXNZVUZCVTFjc1kwRkJWQ3hIUVVFd1FqdEJRVU40UWl4WFFVRkxMRWxCUVVsRExGbEJRVmtzUjBGQlJ5eERRVUZETEVOQlFVUXNSMEZCUzFZc1ZVRkJOMElzUlVGQmVVTlZMRmxCUVZrc1NVRkJTVllzVlVGQmVrUXNSVUZCY1VWVkxGbEJRVmtzU1VGQlNTeERRVUZ5Uml4RlFVRjNSanRCUVVOMFJpeFpRVUZKUXl4UlFVRlJPMEZCUVVFN1FVRkJRVHRCUVVGYU8wRkJRVUU3TzBGQlEwRXNXVUZCU1VNc1QwRkJUeXhIUVVGSFZpeFJRVUZSTEVOQlFVTlJMRmxCUVZrc1IwRkJSeXhEUVVGb1FpeERRVUYwUWp0QlFVRkJMRmxCUTBsSExGVkJRVlVzUjBGQlIxZ3NVVUZCVVN4RFFVRkRVU3haUVVGWkxFZEJRVWNzUTBGQmFFSXNRMEZFZWtJN1FVRkJRU3haUVVWSlRDeFBRVUZOTEVkQlFVY3NRMEZCUTFFc1ZVRkJWU3hIUVVGSFFTeFZRVUZWTEVOQlFVTldMRTFCUVdRc1IwRkJkVUlzUTBGQmJFTXNTVUZCZFVOUExGbEJSbkJFT3p0QlFVZEJMRmxCUVVsRkxFOUJRVW9zUlVGQllUdEJRVU5ZTzBGQlEwRldMRlZCUVVGQkxGRkJRVkVzUTBGQlExRXNXVUZCV1N4SFFVRkhMRU5CUVdoQ0xFTkJRVklzUjBGQk5rSnFRaXhUUVVFM1FqdEJRVU5FT3p0QlFVVkVMRmxCUVVseFFpeE5RVUZOTEVkQlFVZEdMRTlCUVU4c1NVRkJTVUVzVDBGQlR5eERRVUZEVkN4TlFVRlNMRWRCUVdsQ0xFTkJRV3BDTEVkQlFYRkNUaXhOUVVFM1F6dEJRVUZCTEZsQlEwbHJRaXhUUVVGVExFZEJRVWRHTEZWQlFWVXNTVUZCU1N4TFFVRkxVaXhQUVVGdVFpeEpRVUUyUWtFc1QwRkJUU3hIUVVGSFRpeE5RVVIwUkRzN1FVRkZRU3haUVVGSkxFTkJRVU5sTEUxQlFVUXNTVUZCVnl4RFFVRkRReXhUUVVGb1FpeEZRVUV5UWp0QlFVTjZRanRCUVVOQllpeFZRVUZCUVN4UlFVRlJMRU5CUVVOUkxGbEJRVVFzUTBGQlVpeEhRVUY1UW1wQ0xGTkJRWHBDTzBGQlEwRTdRVUZEUkN4VFFXaENjVVlzUTBGclFuUkdPMEZCUTBFN1FVRkRRVHM3TzBGQlEwRXNXVUZCU1N4RFFVRkRjVUlzVFVGQlJDeEpRVUZaUXl4VFFVRlRMRWxCUVVsSUxFOUJRVThzUTBGQlExUXNUVUZCVWl4SFFVRnBRbFVzVlVGQlZTeERRVUZEVml4TlFVRjZSQ3hGUVVGclJUdEJRVU5vUlZFc1ZVRkJRVUVzVVVGQlVTeEhRVUZIU3l4VFFVRlRMRU5CUVVOSUxGVkJRVVFzUTBGQmNFSTdRVUZEUVhoQ0xGVkJRVUZCTEVsQlFVa3NRMEZCUXpSQ0xHRkJRVXdzUTBGQmJVSk9MRkZCUVZFc1EwRkJRMUFzVlVGQk5VSXNSVUZCZDBOWUxGTkJRWGhETEVWQlFXMUVMRWxCUVc1RU8wRkJRMFFzVTBGSVJDeE5RVWRQTzBGQlEweHJRaXhWUVVGQlFTeFJRVUZSTEVkQlFVZERMRTlCUVZnc1EwRkVTeXhEUVVObE96dEJRVU53UWtRc1ZVRkJRVUVzVVVGQlVTeERRVUZEVWl4TlFVRlVPMEZCUTBGa0xGVkJRVUZCTEVsQlFVa3NRMEZCUXpSQ0xHRkJRVXdzUTBGQmJVSk9MRkZCUVZFc1EwRkJRMUFzVlVGQk5VSXNSVUZCZDBNc1NVRkJlRU1zUlVGQk9FTllMRk5CUVRsRE8wRkJRMFE3TzBGQlJVUlpMRkZCUVVGQkxFOUJRVTBzUjBGQlIyaENMRWxCUVVrc1EwRkJRMmxDTEdGQlFVd3NRMEZCYlVKTExGRkJRVzVDTEVWQlFUWkNla0lzVTBGQk4wSXNSVUZCZDBORUxGTkJRWGhETEVWQlFXMUVlVUlzV1VGQmJrUXNRMEZCVkN4RFFUbENjMFlzUTBGblEzUkdPenRCUVVOQkxGbEJRVWxETEZGQlFWRXNRMEZCUTFJc1RVRkJWQ3hIUVVGclFpeERRVUZzUWl4SlFVRjFRazRzVFVGQmRrSXNTVUZCYVVOUkxFOUJRVTBzUjBGQlJ5eERRVUZVTEVsQlFXTk9MRTFCUVc1RUxFVkJRVEpFTzBGQlEzcEVMR2xDUVVGUFZDeEpRVUZKTEVOQlFVTTBRaXhYUVVGWExFTkJRVU0zUWl4SlFVRkVMRVZCUVU5elFpeFJRVUZSTEVOQlFVTlFMRlZCUVdoQ0xFVkJRVFJDYkVJc1UwRkJOVUlzUlVGQmRVTkVMRk5CUVhaRExFVkJRV3RFU1N4SlFVRkpMRU5CUVVNNFFpeGxRVUYyUkN4RFFVRmFMRU5CUVZnN1FVRkRSQ3hUUVVaRUxFMUJSVTg3UVVGRFREdEJRVU5CYWtJc1ZVRkJRVUVzVVVGQlVTeERRVUZEVVN4WlFVRkVMRU5CUVZJc1IwRkJlVUpETEZGQlFYcENPMEZCUTBRN1FVRkRSanM3UVVGRlJGZ3NUVUZCUVVFc1ZVRkJWVHRCUVVOWUxFdEJiRVp6UXl4RFFXOUdka003UVVGRFFUdEJRVU5CT3pzN1FVRkRRU3hSUVVGSldpeFJRVUZLTEVWQlFXTTdRVUZEV0N4blFrRkJVMmRETEVsQlFWUXNSMEZCWjBJN1FVRkRaalZDTEZGQlFVRkJMRlZCUVZVc1EwRkJReXhaUVVGWE8wRkJRM0JDT3p0QlFVTkJPMEZCUTBFc1kwRkJTVkVzVlVGQlZTeEhRVUZIUXl4aFFVRnFRaXhGUVVGblF6dEJRVU01UWl4dFFrRkJUMklzVVVGQlVTeEZRVUZtTzBGQlEwUTdPMEZCUlVRc1kwRkJTU3hEUVVGRGNVSXNZMEZCWXl4RlFVRnVRaXhGUVVGMVFqdEJRVU55UWxjc1dVRkJRVUVzU1VGQlNUdEJRVU5NTzBGQlEwWXNVMEZXVXl4RlFWVlFMRU5CVms4c1EwRkJWanRCUVZkRUxFOUJXa0VzUjBGQlJEdEJRV0ZFTEV0QlpFUXNUVUZqVHp0QlFVTk1MR0ZCUVU5d1FpeFZRVUZWTEVsQlFVbERMR0ZCUVhKQ0xFVkJRVzlETzBGQlEyeERMRmxCUVVsdlFpeEhRVUZITEVkQlFVZGFMR05CUVdNc1JVRkJlRUk3TzBGQlEwRXNXVUZCU1Zrc1IwRkJTaXhGUVVGVE8wRkJRMUFzYVVKQlFVOUJMRWRCUVZBN1FVRkRSRHRCUVVOR08wRkJRMFk3UVVGRFJpeEhRVGxIWXpzN1FVRkJRVHM3UVVGQlFUdEJRV2RJWmtvc1JVRkJRVUVzWVVGb1NHVXNlVUpCWjBoRVlpeFZRV2hJUXl4RlFXZElWMnRDTEV0QmFFaFlMRVZCWjBoclFrTXNUMEZvU0d4Q0xFVkJaMGd5UWp0QlFVTjRReXhSUVVGSlF5eEpRVUZKTEVkQlFVZHdRaXhWUVVGVkxFTkJRVU5CTEZWQlFWVXNRMEZCUTA0c1RVRkJXQ3hIUVVGdlFpeERRVUZ5UWl4RFFVRnlRanM3UVVGRFFTeFJRVUZKTUVJc1NVRkJTU3hKUVVGSlFTeEpRVUZKTEVOQlFVTkdMRXRCUVV3c1MwRkJaVUVzUzBGQmRrSXNTVUZCWjBORkxFbEJRVWtzUTBGQlEwUXNUMEZCVEN4TFFVRnBRa0VzVDBGQmNrUXNSVUZCT0VRN1FVRkROVVE3UVVGRFFUdEJRVU5CYmtJc1RVRkJRVUVzVlVGQlZTeERRVUZEUVN4VlFVRlZMRU5CUVVOT0xFMUJRVmdzUjBGQmIwSXNRMEZCY2tJc1EwRkJWaXhIUVVGdlF6dEJRVUZEVlN4UlFVRkJRU3hMUVVGTExFVkJRVVZuUWl4SlFVRkpMRU5CUVVOb1FpeExRVUZNTEVkQlFXRXNRMEZCY2tJN1FVRkJkMEpqTEZGQlFVRkJMRXRCUVVzc1JVRkJSVUVzUzBGQkwwSTdRVUZCYzBORExGRkJRVUZCTEU5QlFVOHNSVUZCUlVFN1FVRkJMME1zVDBGQmNFTTdRVUZEUkN4TFFVcEVMRTFCU1U4N1FVRkRURzVDTEUxQlFVRkJMRlZCUVZVc1EwRkJRM0ZDTEVsQlFWZ3NRMEZCWjBJN1FVRkJRMnBDTEZGQlFVRkJMRXRCUVVzc1JVRkJSU3hEUVVGU08wRkJRVmRqTEZGQlFVRkJMRXRCUVVzc1JVRkJSVUVzUzBGQmJFSTdRVUZCZVVKRExGRkJRVUZCTEU5QlFVOHNSVUZCUlVFN1FVRkJiRU1zVDBGQmFFSTdRVUZEUkR0QlFVTkdMRWRCZWtoak96dEJRVUZCT3p0QlFVRkJPMEZCTUVobWFrSXNSVUZCUVVFc1lVRXhTR1VzZVVKQk1FaEVTeXhSUVRGSVF5eEZRVEJJVTNwQ0xGTkJNVWhVTEVWQk1FaHZRa1FzVTBFeFNIQkNMRVZCTUVnclFubENMRmxCTVVndlFpeEZRVEJJTmtNN1FVRkRNVVFzVVVGQlNXSXNUVUZCVFN4SFFVRkhXQ3hUUVVGVExFTkJRVU5aTEUxQlFYWkNPMEZCUVVFc1VVRkRTVU1zVFVGQlRTeEhRVUZIWkN4VFFVRlRMRU5CUVVOaExFMUJSSFpDTzBGQlFVRXNVVUZGU1Vzc1RVRkJUU3hIUVVGSFVTeFJRVUZSTEVOQlFVTlNMRTFCUm5SQ08wRkJRVUVzVVVGSFNVVXNUVUZCVFN4SFFVRkhSaXhOUVVGTkxFZEJRVWRQTEZsQlNIUkNPMEZCUVVFc1VVRkxTV2RDTEZkQlFWY3NSMEZCUnl4RFFVeHNRanM3UVVGTlFTeFhRVUZQZGtJc1RVRkJUU3hIUVVGSExFTkJRVlFzUjBGQllVNHNUVUZCWWl4SlFVRjFRbEVzVFVGQlRTeEhRVUZITEVOQlFWUXNSMEZCWVU0c1RVRkJjRU1zU1VGQk9FTXNTMEZCU3pSQ0xFMUJRVXdzUTBGQldYcERMRk5CUVZNc1EwRkJRMmxDTEUxQlFVMHNSMEZCUnl4RFFVRldMRU5CUVhKQ0xFVkJRVzFEYkVJc1UwRkJVeXhEUVVGRGIwSXNUVUZCVFN4SFFVRkhMRU5CUVZZc1EwRkJOVU1zUTBGQmNrUXNSVUZCWjBnN1FVRkRPVWRHTEUxQlFVRkJMRTFCUVUwN1FVRkRUa1VzVFVGQlFVRXNUVUZCVFR0QlFVTk9jVUlzVFVGQlFVRXNWMEZCVnp0QlFVTmFPenRCUVVWRUxGRkJRVWxCTEZkQlFVb3NSVUZCYVVJN1FVRkRabVlzVFVGQlFVRXNVVUZCVVN4RFFVRkRVQ3hWUVVGVUxFTkJRVzlDY1VJc1NVRkJjRUlzUTBGQmVVSTdRVUZCUTJwQ0xGRkJRVUZCTEV0QlFVc3NSVUZCUld0Q08wRkJRVklzVDBGQmVrSTdRVUZEUkRzN1FVRkZSR1lzU1VGQlFVRXNVVUZCVVN4RFFVRkRVaXhOUVVGVUxFZEJRV3RDUVN4TlFVRnNRanRCUVVOQkxGZEJRVTlGTEUxQlFWQTdRVUZEUkN4SFFUZEpZenM3UVVGQlFUczdRVUZCUVR0QlFTdEpabk5DTEVWQlFVRkJMRTFCTDBsbExHdENRU3RKVWtNc1NVRXZTVkVzUlVFclNVWkRMRXRCTDBsRkxFVkJLMGxMTzBGQlEyeENMRkZCUVVrc1MwRkJTekZETEU5QlFVd3NRMEZCWVRKRExGVkJRV3BDTEVWQlFUWkNPMEZCUXpOQ0xHRkJRVThzUzBGQlN6TkRMRTlCUVV3c1EwRkJZVEpETEZWQlFXSXNRMEZCZDBKR0xFbEJRWGhDTEVWQlFUaENReXhMUVVFNVFpeERRVUZRTzBGQlEwUXNTMEZHUkN4TlFVVlBPMEZCUTB3c1lVRkJUMFFzU1VGQlNTeExRVUZMUXl4TFFVRlVMRWxCUTBRc1MwRkJTekZETEU5QlFVd3NRMEZCWVRSRExGVkJRV0lzU1VGQk1rSklMRWxCUVVrc1EwRkJRMGtzVjBGQlRDeFBRVUYxUWtnc1MwRkJTeXhEUVVGRFJ5eFhRVUZPTEVWQlJIaEVPMEZCUlVRN1FVRkRSaXhIUVhSS1l6czdRVUZCUVRzN1FVRkJRVHRCUVhWS1puSkRMRVZCUVVGQkxGZEJka3BsTEhWQ1FYVktTSE5ETEV0QmRrcEhMRVZCZFVwSk8wRkJRMnBDTEZGQlFVbGFMRWRCUVVjc1IwRkJSeXhGUVVGV096dEJRVU5CTEZOQlFVc3NTVUZCU1dFc1EwRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRU5CUVVNc1IwRkJSMFFzUzBGQlN5eERRVUZEYmtNc1RVRkJNVUlzUlVGQmEwTnZReXhEUVVGRExFVkJRVzVETEVWQlFYVkRPMEZCUTNKRExGVkJRVWxFTEV0QlFVc3NRMEZCUTBNc1EwRkJSQ3hEUVVGVUxFVkJRV003UVVGRFdtSXNVVUZCUVVFc1IwRkJSeXhEUVVGRFNTeEpRVUZLTEVOQlFWTlJMRXRCUVVzc1EwRkJRME1zUTBGQlJDeERRVUZrTzBGQlEwUTdRVUZEUmpzN1FVRkRSQ3hYUVVGUFlpeEhRVUZRTzBGQlEwUXNSMEV2U21NN08wRkJRVUU3TzBGQlFVRTdRVUZuUzJZelFpeEZRVUZCUVN4VFFXaExaU3h4UWtGblMweElMRXRCYUV0TExFVkJaMHRGTzBGQlEyWXNWMEZCVDBFc1MwRkJVRHRCUVVORUxFZEJiRXRqT3p0QlFVRkJPenRCUVVGQk8wRkJiVXRtU3l4RlFVRkJRU3hSUVc1TFpTeHZRa0Z0UzA1TUxFdEJia3ROTEVWQmJVdERPMEZCUTJRc1YwRkJUMEVzUzBGQlN5eERRVUZETkVNc1MwRkJUaXhEUVVGWkxFVkJRVm9zUTBGQlVEdEJRVU5FTEVkQmNrdGpPenRCUVVGQk96dEJRVUZCTzBGQmMwdG1OVUlzUlVGQlFVRXNTVUYwUzJVc1owSkJjMHRXTmtJc1MwRjBTMVVzUlVGelMwZzdRVUZEVml4WFFVRlBRU3hMUVVGTExFTkJRVU0zUWl4SlFVRk9MRU5CUVZjc1JVRkJXQ3hEUVVGUU8wRkJRMFE3UVVGNFMyTXNRMEZCYWtJN08wRkJNa3RCTEZOQlFWTlhMRmRCUVZRc1EwRkJjVUpzUXl4SlFVRnlRaXhGUVVFeVFtOUNMRlZCUVROQ0xFVkJRWFZEYkVJc1UwRkJka01zUlVGQmEwUkVMRk5CUVd4RUxFVkJRVFpFYTBNc1pVRkJOMFFzUlVGQk9FVTdRVUZETlVVc1RVRkJTV3RDTEZsQlFWa3NSMEZCUnl4RFFVRnVRanRCUVVGQkxFMUJRMGxETEZsQlFWa3NSMEZCUjJ4RExGVkJRVlVzUTBGQlEwNHNUVUZFT1VJN1FVRkJRU3hOUVVWSlN5eE5RVUZOTEVkQlFVY3NRMEZHWWp0QlFVRkJMRTFCUjBsRkxFMUJRVTBzUjBGQlJ5eERRVWhpT3p0QlFVdEJMRk5CUVU5blF5eFpRVUZaTEVkQlFVZERMRmxCUVhSQ0xFVkJRVzlEUkN4WlFVRlpMRVZCUVdoRUxFVkJRVzlFTzBGQlEyeEVMRkZCUVVsRkxGTkJRVk1zUjBGQlIyNURMRlZCUVZVc1EwRkJRMmxETEZsQlFVUXNRMEZCTVVJN08wRkJRMEVzVVVGQlNTeERRVUZEUlN4VFFVRlRMRU5CUVVOb1FpeFBRVUZtTEVWQlFYZENPMEZCUTNSQ0xGVkJRVWtzUTBGQlEyZENMRk5CUVZNc1EwRkJRMnBDTEV0QlFWZ3NTVUZCYjBKSUxHVkJRWGhDTEVWQlFYbERPMEZCUTNaRExGbEJRVWsxUWl4TFFVRkxMRWRCUVVkTUxGTkJRVk1zUTBGQlEzTkVMRXRCUVZZc1EwRkJaMEp5UXl4TlFVRm9RaXhGUVVGM1FrRXNUVUZCVFN4SFFVRkhiME1zVTBGQlV5eERRVUZETDBJc1MwRkJNME1zUTBGQldqdEJRVU5CYWtJc1VVRkJRVUVzUzBGQlN5eEhRVUZIUVN4TFFVRkxMRU5CUVVOclJDeEhRVUZPTEVOQlFWVXNWVUZCVTJ4RUxFdEJRVlFzUlVGQlowSXlReXhEUVVGb1FpeEZRVUZ0UWp0QlFVTnVReXhqUVVGSlVTeFJRVUZSTEVkQlFVZDZSQ3hUUVVGVExFTkJRVU52UWl4TlFVRk5MRWRCUVVjMlFpeERRVUZXTEVOQlFYaENPMEZCUTBFc2FVSkJRVTlSTEZGQlFWRXNRMEZCUXpWRExFMUJRVlFzUjBGQmEwSlFMRXRCUVVzc1EwRkJRMDhzVFVGQmVFSXNSMEZCYVVNMFF5eFJRVUZxUXl4SFFVRTBRMjVFTEV0QlFXNUVPMEZCUTBRc1UwRklUeXhEUVVGU08wRkJTMEZuUkN4UlFVRkJRU3hUUVVGVExFTkJRVU5vUkN4TFFVRldMRWRCUVd0Q1VDeEpRVUZKTEVOQlFVTjFRaXhKUVVGTUxFTkJRVlZvUWl4TFFVRldMRU5CUVd4Q08wRkJRMFFzVDBGU1JDeE5RVkZQTzBGQlEweG5SQ3hSUVVGQlFTeFRRVUZUTEVOQlFVTm9SQ3hMUVVGV0xFZEJRV3RDVUN4SlFVRkpMRU5CUVVOMVFpeEpRVUZNTEVOQlFWVnlRaXhUUVVGVExFTkJRVU56UkN4TFFVRldMRU5CUVdkQ2NrTXNUVUZCYUVJc1JVRkJkMEpCTEUxQlFVMHNSMEZCUjI5RExGTkJRVk1zUTBGQlF5OUNMRXRCUVRORExFTkJRVllzUTBGQmJFSTdRVUZEUkRzN1FVRkRSRXdzVFVGQlFVRXNUVUZCVFN4SlFVRkpiME1zVTBGQlV5eERRVUZETDBJc1MwRkJjRUlzUTBGYWMwSXNRMEZqZEVJN08wRkJRMEVzVlVGQlNTeERRVUZESzBJc1UwRkJVeXhEUVVGRGFrSXNTMEZCWml4RlFVRnpRanRCUVVOd1FtcENMRkZCUVVGQkxFMUJRVTBzU1VGQlNXdERMRk5CUVZNc1EwRkJReTlDTEV0QlFYQkNPMEZCUTBRN1FVRkRSaXhMUVd4Q1JDeE5RV3RDVHp0QlFVTk1LMElzVFVGQlFVRXNVMEZCVXl4RFFVRkRhRVFzUzBGQlZpeEhRVUZyUWxBc1NVRkJTU3hEUVVGRGRVSXNTVUZCVEN4RFFVRlZkRUlzVTBGQlV5eERRVUZEZFVRc1MwRkJWaXhEUVVGblFtNURMRTFCUVdoQ0xFVkJRWGRDUVN4TlFVRk5MRWRCUVVkclF5eFRRVUZUTEVOQlFVTXZRaXhMUVVFelF5eERRVUZXTEVOQlFXeENPMEZCUTBGSUxFMUJRVUZCTEUxQlFVMHNTVUZCU1d0RExGTkJRVk1zUTBGQlF5OUNMRXRCUVhCQ0xFTkJSa3NzUTBGSlREdEJRVU5CTzBGQlEwRTdPMEZCUTBFc1ZVRkJTVFpDTEZsQlFWa3NTVUZCU1dwRExGVkJRVlVzUTBGQlEybERMRmxCUVZrc1IwRkJSeXhEUVVGb1FpeERRVUZXTEVOQlFUWkNaaXhMUVVGcVJDeEZRVUYzUkR0QlFVTjBSQ3haUVVGSmNVSXNSMEZCUnl4SFFVRkhka01zVlVGQlZTeERRVUZEYVVNc1dVRkJXU3hIUVVGSExFTkJRV2hDTEVOQlFYQkNPMEZCUTBGcVF5eFJRVUZCUVN4VlFVRlZMRU5CUVVOcFF5eFpRVUZaTEVkQlFVY3NRMEZCYUVJc1EwRkJWaXhIUVVFclFtcERMRlZCUVZVc1EwRkJRMmxETEZsQlFVUXNRMEZCZWtNN1FVRkRRV3BETEZGQlFVRkJMRlZCUVZVc1EwRkJRMmxETEZsQlFVUXNRMEZCVml4SFFVRXlRazBzUjBGQk0wSTdRVUZEUkR0QlFVTkdPMEZCUTBZc1IwRjJRekpGTEVOQmVVTTFSVHRCUVVOQk8wRkJRMEU3T3p0QlFVTkJMRTFCUVVsRExHRkJRV0VzUjBGQlIzaERMRlZCUVZVc1EwRkJRMnRETEZsQlFWa3NSMEZCUnl4RFFVRm9RaXhEUVVFNVFqczdRVUZEUVN4TlFVRkpRU3haUVVGWkxFZEJRVWNzUTBGQlppeEpRVU5ITEU5QlFVOU5MR0ZCUVdFc1EwRkJRM0pFTEV0QlFYSkNMRXRCUVN0Q0xGRkJSR3hETEV0QlJVbHhSQ3hoUVVGaExFTkJRVU4wUWl4TFFVRmtMRWxCUVhWQ2MwSXNZVUZCWVN4RFFVRkRja0lzVDBGR2VrTXNTMEZIUjNaRExFbEJRVWtzUTBGQlF6SkRMRTFCUVV3c1EwRkJXU3hGUVVGYUxFVkJRV2RDYVVJc1lVRkJZU3hEUVVGRGNrUXNTMEZCT1VJc1EwRklVQ3hGUVVjMlF6dEJRVU16UTJFc1NVRkJRVUVzVlVGQlZTeERRVUZEYTBNc1dVRkJXU3hIUVVGSExFTkJRV2hDTEVOQlFWWXNRMEZCTmtJdlF5eExRVUUzUWl4SlFVRnpRM0ZFTEdGQlFXRXNRMEZCUTNKRUxFdEJRWEJFTzBGQlEwRmhMRWxCUVVGQkxGVkJRVlVzUTBGQlEzbERMRWRCUVZnN1FVRkRSRHM3UVVGRlJDeFRRVUZQZWtNc1ZVRkJVRHRCUVVORU96dEJRVVZFTEZOQlFWTlpMRk5CUVZRc1EwRkJiVUk0UWl4SlFVRnVRaXhGUVVGNVFqdEJRVU4yUWl4VFFVRlBPMEZCUVVVelF5eEpRVUZCUVN4TlFVRk5MRVZCUVVVeVF5eEpRVUZKTEVOQlFVTXpReXhOUVVGbU8wRkJRWFZDUXl4SlFVRkJRU3hWUVVGVkxFVkJRVVV3UXl4SlFVRkpMRU5CUVVNeFF5eFZRVUZNTEVOQlFXZENiME1zUzBGQmFFSXNRMEZCYzBJc1EwRkJkRUk3UVVGQmJrTXNSMEZCVUR0QlFVTkVJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWlhod2IzSjBJR1JsWm1GMWJIUWdablZ1WTNScGIyNGdSR2xtWmlncElIdDlYRzVjYmtScFptWXVjSEp2ZEc5MGVYQmxJRDBnZTF4dUlDQmthV1ptS0c5c1pGTjBjbWx1Wnl3Z2JtVjNVM1J5YVc1bkxDQnZjSFJwYjI1eklEMGdlMzBwSUh0Y2JpQWdJQ0JzWlhRZ1kyRnNiR0poWTJzZ1BTQnZjSFJwYjI1ekxtTmhiR3hpWVdOck8xeHVJQ0FnSUdsbUlDaDBlWEJsYjJZZ2IzQjBhVzl1Y3lBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJQ0FnWTJGc2JHSmhZMnNnUFNCdmNIUnBiMjV6TzF4dUlDQWdJQ0FnYjNCMGFXOXVjeUE5SUh0OU8xeHVJQ0FnSUgxY2JpQWdJQ0IwYUdsekxtOXdkR2x2Ym5NZ1BTQnZjSFJwYjI1ek8xeHVYRzRnSUNBZ2JHVjBJSE5sYkdZZ1BTQjBhR2x6TzF4dVhHNGdJQ0FnWm5WdVkzUnBiMjRnWkc5dVpTaDJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ2FXWWdLR05oYkd4aVlXTnJLU0I3WEc0Z0lDQWdJQ0FnSUhObGRGUnBiV1Z2ZFhRb1puVnVZM1JwYjI0b0tTQjdJR05oYkd4aVlXTnJLSFZ1WkdWbWFXNWxaQ3dnZG1Gc2RXVXBPeUI5TENBd0tUdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzZFdVN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1FXeHNiM2NnYzNWaVkyeGhjM05sY3lCMGJ5QnRZWE56WVdkbElIUm9aU0JwYm5CMWRDQndjbWx2Y2lCMGJ5QnlkVzV1YVc1blhHNGdJQ0FnYjJ4a1UzUnlhVzVuSUQwZ2RHaHBjeTVqWVhOMFNXNXdkWFFvYjJ4a1UzUnlhVzVuS1R0Y2JpQWdJQ0J1WlhkVGRISnBibWNnUFNCMGFHbHpMbU5oYzNSSmJuQjFkQ2h1WlhkVGRISnBibWNwTzF4dVhHNGdJQ0FnYjJ4a1UzUnlhVzVuSUQwZ2RHaHBjeTV5WlcxdmRtVkZiWEIwZVNoMGFHbHpMblJ2YTJWdWFYcGxLRzlzWkZOMGNtbHVaeWtwTzF4dUlDQWdJRzVsZDFOMGNtbHVaeUE5SUhSb2FYTXVjbVZ0YjNabFJXMXdkSGtvZEdocGN5NTBiMnRsYm1sNlpTaHVaWGRUZEhKcGJtY3BLVHRjYmx4dUlDQWdJR3hsZENCdVpYZE1aVzRnUFNCdVpYZFRkSEpwYm1jdWJHVnVaM1JvTENCdmJHUk1aVzRnUFNCdmJHUlRkSEpwYm1jdWJHVnVaM1JvTzF4dUlDQWdJR3hsZENCbFpHbDBUR1Z1WjNSb0lEMGdNVHRjYmlBZ0lDQnNaWFFnYldGNFJXUnBkRXhsYm1kMGFDQTlJRzVsZDB4bGJpQXJJRzlzWkV4bGJqdGNiaUFnSUNCc1pYUWdZbVZ6ZEZCaGRHZ2dQU0JiZXlCdVpYZFFiM002SUMweExDQmpiMjF3YjI1bGJuUnpPaUJiWFNCOVhUdGNibHh1SUNBZ0lDOHZJRk5sWldRZ1pXUnBkRXhsYm1kMGFDQTlJREFzSUdrdVpTNGdkR2hsSUdOdmJuUmxiblFnYzNSaGNuUnpJSGRwZEdnZ2RHaGxJSE5oYldVZ2RtRnNkV1Z6WEc0Z0lDQWdiR1YwSUc5c1pGQnZjeUE5SUhSb2FYTXVaWGgwY21GamRFTnZiVzF2YmloaVpYTjBVR0YwYUZzd1hTd2dibVYzVTNSeWFXNW5MQ0J2YkdSVGRISnBibWNzSURBcE8xeHVJQ0FnSUdsbUlDaGlaWE4wVUdGMGFGc3dYUzV1WlhkUWIzTWdLeUF4SUQ0OUlHNWxkMHhsYmlBbUppQnZiR1JRYjNNZ0t5QXhJRDQ5SUc5c1pFeGxiaWtnZTF4dUlDQWdJQ0FnTHk4Z1NXUmxiblJwZEhrZ2NHVnlJSFJvWlNCbGNYVmhiR2wwZVNCaGJtUWdkRzlyWlc1cGVtVnlYRzRnSUNBZ0lDQnlaWFIxY200Z1pHOXVaU2hiZTNaaGJIVmxPaUIwYUdsekxtcHZhVzRvYm1WM1UzUnlhVzVuS1N3Z1kyOTFiblE2SUc1bGQxTjBjbWx1Wnk1c1pXNW5kR2g5WFNrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1RXRnBiaUIzYjNKclpYSWdiV1YwYUc5a0xpQmphR1ZqYTNNZ1lXeHNJSEJsY20xMWRHRjBhVzl1Y3lCdlppQmhJR2RwZG1WdUlHVmthWFFnYkdWdVozUm9JR1p2Y2lCaFkyTmxjSFJoYm1ObExseHVJQ0FnSUdaMWJtTjBhVzl1SUdWNFpXTkZaR2wwVEdWdVozUm9LQ2tnZTF4dUlDQWdJQ0FnWm05eUlDaHNaWFFnWkdsaFoyOXVZV3hRWVhSb0lEMGdMVEVnS2lCbFpHbDBUR1Z1WjNSb095QmthV0ZuYjI1aGJGQmhkR2dnUEQwZ1pXUnBkRXhsYm1kMGFEc2daR2xoWjI5dVlXeFFZWFJvSUNzOUlESXBJSHRjYmlBZ0lDQWdJQ0FnYkdWMElHSmhjMlZRWVhSb08xeHVJQ0FnSUNBZ0lDQnNaWFFnWVdSa1VHRjBhQ0E5SUdKbGMzUlFZWFJvVzJScFlXZHZibUZzVUdGMGFDQXRJREZkTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjbVZ0YjNabFVHRjBhQ0E5SUdKbGMzUlFZWFJvVzJScFlXZHZibUZzVUdGMGFDQXJJREZkTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiMnhrVUc5eklEMGdLSEpsYlc5MlpWQmhkR2dnUHlCeVpXMXZkbVZRWVhSb0xtNWxkMUJ2Y3lBNklEQXBJQzBnWkdsaFoyOXVZV3hRWVhSb08xeHVJQ0FnSUNBZ0lDQnBaaUFvWVdSa1VHRjBhQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDOHZJRTV2SUc5dVpTQmxiSE5sSUdseklHZHZhVzVuSUhSdklHRjBkR1Z0Y0hRZ2RHOGdkWE5sSUhSb2FYTWdkbUZzZFdVc0lHTnNaV0Z5SUdsMFhHNGdJQ0FnSUNBZ0lDQWdZbVZ6ZEZCaGRHaGJaR2xoWjI5dVlXeFFZWFJvSUMwZ01WMGdQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQnNaWFFnWTJGdVFXUmtJRDBnWVdSa1VHRjBhQ0FtSmlCaFpHUlFZWFJvTG01bGQxQnZjeUFySURFZ1BDQnVaWGRNWlc0c1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVc1U1pXMXZkbVVnUFNCeVpXMXZkbVZRWVhSb0lDWW1JREFnUEQwZ2IyeGtVRzl6SUNZbUlHOXNaRkJ2Y3lBOElHOXNaRXhsYmp0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZqWVc1QlpHUWdKaVlnSVdOaGJsSmxiVzkyWlNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUVsbUlIUm9hWE1nY0dGMGFDQnBjeUJoSUhSbGNtMXBibUZzSUhSb1pXNGdjSEoxYm1WY2JpQWdJQ0FnSUNBZ0lDQmlaWE4wVUdGMGFGdGthV0ZuYjI1aGJGQmhkR2hkSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdVMlZzWldOMElIUm9aU0JrYVdGbmIyNWhiQ0IwYUdGMElIZGxJSGRoYm5RZ2RHOGdZbkpoYm1Ob0lHWnliMjB1SUZkbElITmxiR1ZqZENCMGFHVWdjSEpwYjNKY2JpQWdJQ0FnSUNBZ0x5OGdjR0YwYUNCM2FHOXpaU0J3YjNOcGRHbHZiaUJwYmlCMGFHVWdibVYzSUhOMGNtbHVaeUJwY3lCMGFHVWdabUZ5ZEdobGMzUWdabkp2YlNCMGFHVWdiM0pwWjJsdVhHNGdJQ0FnSUNBZ0lDOHZJR0Z1WkNCa2IyVnpJRzV2ZENCd1lYTnpJSFJvWlNCaWIzVnVaSE1nYjJZZ2RHaGxJR1JwWm1ZZ1ozSmhjR2hjYmlBZ0lDQWdJQ0FnYVdZZ0tDRmpZVzVCWkdRZ2ZId2dLR05oYmxKbGJXOTJaU0FtSmlCaFpHUlFZWFJvTG01bGQxQnZjeUE4SUhKbGJXOTJaVkJoZEdndWJtVjNVRzl6S1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR0poYzJWUVlYUm9JRDBnWTJ4dmJtVlFZWFJvS0hKbGJXOTJaVkJoZEdncE8xeHVJQ0FnSUNBZ0lDQWdJSE5sYkdZdWNIVnphRU52YlhCdmJtVnVkQ2hpWVhObFVHRjBhQzVqYjIxd2IyNWxiblJ6TENCMWJtUmxabWx1WldRc0lIUnlkV1VwTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHSmhjMlZRWVhSb0lEMGdZV1JrVUdGMGFEc2dMeThnVG04Z2JtVmxaQ0IwYnlCamJHOXVaU3dnZDJVbmRtVWdjSFZzYkdWa0lHbDBJR1p5YjIwZ2RHaGxJR3hwYzNSY2JpQWdJQ0FnSUNBZ0lDQmlZWE5sVUdGMGFDNXVaWGRRYjNNckt6dGNiaUFnSUNBZ0lDQWdJQ0J6Wld4bUxuQjFjMmhEYjIxd2IyNWxiblFvWW1GelpWQmhkR2d1WTI5dGNHOXVaVzUwY3l3Z2RISjFaU3dnZFc1a1pXWnBibVZrS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJRzlzWkZCdmN5QTlJSE5sYkdZdVpYaDBjbUZqZEVOdmJXMXZiaWhpWVhObFVHRjBhQ3dnYm1WM1UzUnlhVzVuTENCdmJHUlRkSEpwYm1jc0lHUnBZV2R2Ym1Gc1VHRjBhQ2s3WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdTV1lnZDJVZ2FHRjJaU0JvYVhRZ2RHaGxJR1Z1WkNCdlppQmliM1JvSUhOMGNtbHVaM01zSUhSb1pXNGdkMlVnWVhKbElHUnZibVZjYmlBZ0lDQWdJQ0FnYVdZZ0tHSmhjMlZRWVhSb0xtNWxkMUJ2Y3lBcklERWdQajBnYm1WM1RHVnVJQ1ltSUc5c1pGQnZjeUFySURFZ1BqMGdiMnhrVEdWdUtTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR1J2Ym1Vb1luVnBiR1JXWVd4MVpYTW9jMlZzWml3Z1ltRnpaVkJoZEdndVkyOXRjRzl1Wlc1MGN5d2dibVYzVTNSeWFXNW5MQ0J2YkdSVGRISnBibWNzSUhObGJHWXVkWE5sVEc5dVoyVnpkRlJ2YTJWdUtTazdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1QzUm9aWEozYVhObElIUnlZV05ySUhSb2FYTWdjR0YwYUNCaGN5QmhJSEJ2ZEdWdWRHbGhiQ0JqWVc1a2FXUmhkR1VnWVc1a0lHTnZiblJwYm5WbExseHVJQ0FnSUNBZ0lDQWdJR0psYzNSUVlYUm9XMlJwWVdkdmJtRnNVR0YwYUYwZ1BTQmlZWE5sVUdGMGFEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JsWkdsMFRHVnVaM1JvS3lzN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1VHVnlabTl5YlhNZ2RHaGxJR3hsYm1kMGFDQnZaaUJsWkdsMElHbDBaWEpoZEdsdmJpNGdTWE1nWVNCaWFYUWdablZuYkhrZ1lYTWdkR2hwY3lCb1lYTWdkRzhnYzNWd2NHOXlkQ0IwYUdWY2JpQWdJQ0F2THlCemVXNWpJR0Z1WkNCaGMzbHVZeUJ0YjJSbElIZG9hV05vSUdseklHNWxkbVZ5SUdaMWJpNGdURzl2Y0hNZ2IzWmxjaUJsZUdWalJXUnBkRXhsYm1kMGFDQjFiblJwYkNCaElIWmhiSFZsWEc0Z0lDQWdMeThnYVhNZ2NISnZaSFZqWldRdVhHNGdJQ0FnYVdZZ0tHTmhiR3hpWVdOcktTQjdYRzRnSUNBZ0lDQW9ablZ1WTNScGIyNGdaWGhsWXlncElIdGNiaUFnSUNBZ0lDQWdjMlYwVkdsdFpXOTFkQ2htZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJVYUdseklITm9iM1ZzWkNCdWIzUWdhR0Z3Y0dWdUxDQmlkWFFnZDJVZ2QyRnVkQ0IwYnlCaVpTQnpZV1psTGx4dUlDQWdJQ0FnSUNBZ0lDOHFJR2x6ZEdGdVluVnNJR2xuYm05eVpTQnVaWGgwSUNvdlhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0dWa2FYUk1aVzVuZEdnZ1BpQnRZWGhGWkdsMFRHVnVaM1JvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdZMkZzYkdKaFkyc29LVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb0lXVjRaV05GWkdsMFRHVnVaM1JvS0NrcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUdWNFpXTW9LVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lIMHNJREFwTzF4dUlDQWdJQ0FnZlNncEtUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnZDJocGJHVWdLR1ZrYVhSTVpXNW5kR2dnUEQwZ2JXRjRSV1JwZEV4bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNCc1pYUWdjbVYwSUQwZ1pYaGxZMFZrYVhSTVpXNW5kR2dvS1R0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEpsZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnlaWFE3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMHNYRzVjYmlBZ2NIVnphRU52YlhCdmJtVnVkQ2hqYjIxd2IyNWxiblJ6TENCaFpHUmxaQ3dnY21WdGIzWmxaQ2tnZTF4dUlDQWdJR3hsZENCc1lYTjBJRDBnWTI5dGNHOXVaVzUwYzF0amIyMXdiMjVsYm5SekxteGxibWQwYUNBdElERmRPMXh1SUNBZ0lHbG1JQ2hzWVhOMElDWW1JR3hoYzNRdVlXUmtaV1FnUFQwOUlHRmtaR1ZrSUNZbUlHeGhjM1F1Y21WdGIzWmxaQ0E5UFQwZ2NtVnRiM1psWkNrZ2UxeHVJQ0FnSUNBZ0x5OGdWMlVnYm1WbFpDQjBieUJqYkc5dVpTQm9aWEpsSUdGeklIUm9aU0JqYjIxd2IyNWxiblFnWTJ4dmJtVWdiM0JsY21GMGFXOXVJR2x6SUdwMWMzUmNiaUFnSUNBZ0lDOHZJR0Z6SUhOb1lXeHNiM2NnWVhKeVlYa2dZMnh2Ym1WY2JpQWdJQ0FnSUdOdmJYQnZibVZ1ZEhOYlkyOXRjRzl1Wlc1MGN5NXNaVzVuZEdnZ0xTQXhYU0E5SUh0amIzVnVkRG9nYkdGemRDNWpiM1Z1ZENBcklERXNJR0ZrWkdWa09pQmhaR1JsWkN3Z2NtVnRiM1psWkRvZ2NtVnRiM1psWkNCOU8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JqYjIxd2IyNWxiblJ6TG5CMWMyZ29lMk52ZFc1ME9pQXhMQ0JoWkdSbFpEb2dZV1JrWldRc0lISmxiVzkyWldRNklISmxiVzkyWldRZ2ZTazdYRzRnSUNBZ2ZWeHVJQ0I5TEZ4dUlDQmxlSFJ5WVdOMFEyOXRiVzl1S0dKaGMyVlFZWFJvTENCdVpYZFRkSEpwYm1jc0lHOXNaRk4wY21sdVp5d2daR2xoWjI5dVlXeFFZWFJvS1NCN1hHNGdJQ0FnYkdWMElHNWxkMHhsYmlBOUlHNWxkMU4wY21sdVp5NXNaVzVuZEdnc1hHNGdJQ0FnSUNBZ0lHOXNaRXhsYmlBOUlHOXNaRk4wY21sdVp5NXNaVzVuZEdnc1hHNGdJQ0FnSUNBZ0lHNWxkMUJ2Y3lBOUlHSmhjMlZRWVhSb0xtNWxkMUJ2Y3l4Y2JpQWdJQ0FnSUNBZ2IyeGtVRzl6SUQwZ2JtVjNVRzl6SUMwZ1pHbGhaMjl1WVd4UVlYUm9MRnh1WEc0Z0lDQWdJQ0FnSUdOdmJXMXZia052ZFc1MElEMGdNRHRjYmlBZ0lDQjNhR2xzWlNBb2JtVjNVRzl6SUNzZ01TQThJRzVsZDB4bGJpQW1KaUJ2YkdSUWIzTWdLeUF4SUR3Z2IyeGtUR1Z1SUNZbUlIUm9hWE11WlhGMVlXeHpLRzVsZDFOMGNtbHVaMXR1WlhkUWIzTWdLeUF4WFN3Z2IyeGtVM1J5YVc1blcyOXNaRkJ2Y3lBcklERmRLU2tnZTF4dUlDQWdJQ0FnYm1WM1VHOXpLeXM3WEc0Z0lDQWdJQ0J2YkdSUWIzTXJLenRjYmlBZ0lDQWdJR052YlcxdmJrTnZkVzUwS3lzN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnYVdZZ0tHTnZiVzF2YmtOdmRXNTBLU0I3WEc0Z0lDQWdJQ0JpWVhObFVHRjBhQzVqYjIxd2IyNWxiblJ6TG5CMWMyZ29lMk52ZFc1ME9pQmpiMjF0YjI1RGIzVnVkSDBwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR0poYzJWUVlYUm9MbTVsZDFCdmN5QTlJRzVsZDFCdmN6dGNiaUFnSUNCeVpYUjFjbTRnYjJ4a1VHOXpPMXh1SUNCOUxGeHVYRzRnSUdWeGRXRnNjeWhzWldaMExDQnlhV2RvZENrZ2UxeHVJQ0FnSUdsbUlDaDBhR2x6TG05d2RHbHZibk11WTI5dGNHRnlZWFJ2Y2lrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXViM0IwYVc5dWN5NWpiMjF3WVhKaGRHOXlLR3hsWm5Rc0lISnBaMmgwS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHeGxablFnUFQwOUlISnBaMmgwWEc0Z0lDQWdJQ0FnSUh4OElDaDBhR2x6TG05d2RHbHZibk11YVdkdWIzSmxRMkZ6WlNBbUppQnNaV1owTG5SdlRHOTNaWEpEWVhObEtDa2dQVDA5SUhKcFoyaDBMblJ2VEc5M1pYSkRZWE5sS0NrcE8xeHVJQ0FnSUgxY2JpQWdmU3hjYmlBZ2NtVnRiM1psUlcxd2RIa29ZWEp5WVhrcElIdGNiaUFnSUNCc1pYUWdjbVYwSUQwZ1cxMDdYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmhjbkpoZVM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdhV1lnS0dGeWNtRjVXMmxkS1NCN1hHNGdJQ0FnSUNBZ0lISmxkQzV3ZFhOb0tHRnljbUY1VzJsZEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJSEpsZER0Y2JpQWdmU3hjYmlBZ1kyRnpkRWx1Y0hWMEtIWmhiSFZsS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFpoYkhWbE8xeHVJQ0I5TEZ4dUlDQjBiMnRsYm1sNlpTaDJZV3gxWlNrZ2UxeHVJQ0FnSUhKbGRIVnliaUIyWVd4MVpTNXpjR3hwZENnbkp5azdYRzRnSUgwc1hHNGdJR3B2YVc0b1kyaGhjbk1wSUh0Y2JpQWdJQ0J5WlhSMWNtNGdZMmhoY25NdWFtOXBiaWduSnlrN1hHNGdJSDFjYm4wN1hHNWNibVoxYm1OMGFXOXVJR0oxYVd4a1ZtRnNkV1Z6S0dScFptWXNJR052YlhCdmJtVnVkSE1zSUc1bGQxTjBjbWx1Wnl3Z2IyeGtVM1J5YVc1bkxDQjFjMlZNYjI1blpYTjBWRzlyWlc0cElIdGNiaUFnYkdWMElHTnZiWEJ2Ym1WdWRGQnZjeUE5SURBc1hHNGdJQ0FnSUNCamIyMXdiMjVsYm5STVpXNGdQU0JqYjIxd2IyNWxiblJ6TG14bGJtZDBhQ3hjYmlBZ0lDQWdJRzVsZDFCdmN5QTlJREFzWEc0Z0lDQWdJQ0J2YkdSUWIzTWdQU0F3TzF4dVhHNGdJR1p2Y2lBb095QmpiMjF3YjI1bGJuUlFiM01nUENCamIyMXdiMjVsYm5STVpXNDdJR052YlhCdmJtVnVkRkJ2Y3lzcktTQjdYRzRnSUNBZ2JHVjBJR052YlhCdmJtVnVkQ0E5SUdOdmJYQnZibVZ1ZEhOYlkyOXRjRzl1Wlc1MFVHOXpYVHRjYmlBZ0lDQnBaaUFvSVdOdmJYQnZibVZ1ZEM1eVpXMXZkbVZrS1NCN1hHNGdJQ0FnSUNCcFppQW9JV052YlhCdmJtVnVkQzVoWkdSbFpDQW1KaUIxYzJWTWIyNW5aWE4wVkc5clpXNHBJSHRjYmlBZ0lDQWdJQ0FnYkdWMElIWmhiSFZsSUQwZ2JtVjNVM1J5YVc1bkxuTnNhV05sS0c1bGQxQnZjeXdnYm1WM1VHOXpJQ3NnWTI5dGNHOXVaVzUwTG1OdmRXNTBLVHRjYmlBZ0lDQWdJQ0FnZG1Gc2RXVWdQU0IyWVd4MVpTNXRZWEFvWm5WdVkzUnBiMjRvZG1Gc2RXVXNJR2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnNaWFFnYjJ4a1ZtRnNkV1VnUFNCdmJHUlRkSEpwYm1kYmIyeGtVRzl6SUNzZ2FWMDdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJRzlzWkZaaGJIVmxMbXhsYm1kMGFDQStJSFpoYkhWbExteGxibWQwYUNBL0lHOXNaRlpoYkhWbElEb2dkbUZzZFdVN1hHNGdJQ0FnSUNBZ0lIMHBPMXh1WEc0Z0lDQWdJQ0FnSUdOdmJYQnZibVZ1ZEM1MllXeDFaU0E5SUdScFptWXVhbTlwYmloMllXeDFaU2s3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JqYjIxd2IyNWxiblF1ZG1Gc2RXVWdQU0JrYVdabUxtcHZhVzRvYm1WM1UzUnlhVzVuTG5Oc2FXTmxLRzVsZDFCdmN5d2dibVYzVUc5eklDc2dZMjl0Y0c5dVpXNTBMbU52ZFc1MEtTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnVaWGRRYjNNZ0t6MGdZMjl0Y0c5dVpXNTBMbU52ZFc1ME8xeHVYRzRnSUNBZ0lDQXZMeUJEYjIxdGIyNGdZMkZ6WlZ4dUlDQWdJQ0FnYVdZZ0tDRmpiMjF3YjI1bGJuUXVZV1JrWldRcElIdGNiaUFnSUNBZ0lDQWdiMnhrVUc5eklDczlJR052YlhCdmJtVnVkQzVqYjNWdWREdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnWTI5dGNHOXVaVzUwTG5aaGJIVmxJRDBnWkdsbVppNXFiMmx1S0c5c1pGTjBjbWx1Wnk1emJHbGpaU2h2YkdSUWIzTXNJRzlzWkZCdmN5QXJJR052YlhCdmJtVnVkQzVqYjNWdWRDa3BPMXh1SUNBZ0lDQWdiMnhrVUc5eklDczlJR052YlhCdmJtVnVkQzVqYjNWdWREdGNibHh1SUNBZ0lDQWdMeThnVW1WMlpYSnpaU0JoWkdRZ1lXNWtJSEpsYlc5MlpTQnpieUJ5WlcxdmRtVnpJR0Z5WlNCdmRYUndkWFFnWm1seWMzUWdkRzhnYldGMFkyZ2dZMjl0Ylc5dUlHTnZiblpsYm5ScGIyNWNiaUFnSUNBZ0lDOHZJRlJvWlNCa2FXWm1hVzVuSUdGc1oyOXlhWFJvYlNCcGN5QjBhV1ZrSUhSdklHRmtaQ0IwYUdWdUlISmxiVzkyWlNCdmRYUndkWFFnWVc1a0lIUm9hWE1nYVhNZ2RHaGxJSE5wYlhCc1pYTjBYRzRnSUNBZ0lDQXZMeUJ5YjNWMFpTQjBieUJuWlhRZ2RHaGxJR1JsYzJseVpXUWdiM1YwY0hWMElIZHBkR2dnYldsdWFXMWhiQ0J2ZG1WeWFHVmhaQzVjYmlBZ0lDQWdJR2xtSUNoamIyMXdiMjVsYm5SUWIzTWdKaVlnWTI5dGNHOXVaVzUwYzF0amIyMXdiMjVsYm5SUWIzTWdMU0F4WFM1aFpHUmxaQ2tnZTF4dUlDQWdJQ0FnSUNCc1pYUWdkRzF3SUQwZ1kyOXRjRzl1Wlc1MGMxdGpiMjF3YjI1bGJuUlFiM01nTFNBeFhUdGNiaUFnSUNBZ0lDQWdZMjl0Y0c5dVpXNTBjMXRqYjIxd2IyNWxiblJRYjNNZ0xTQXhYU0E5SUdOdmJYQnZibVZ1ZEhOYlkyOXRjRzl1Wlc1MFVHOXpYVHRjYmlBZ0lDQWdJQ0FnWTI5dGNHOXVaVzUwYzF0amIyMXdiMjVsYm5SUWIzTmRJRDBnZEcxd08xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lDOHZJRk53WldOcFlXd2dZMkZ6WlNCb1lXNWtiR1VnWm05eUlIZG9aVzRnYjI1bElIUmxjbTFwYm1Gc0lHbHpJR2xuYm05eVpXUWdLR2t1WlM0Z2QyaHBkR1Z6Y0dGalpTa3VYRzRnSUM4dklFWnZjaUIwYUdseklHTmhjMlVnZDJVZ2JXVnlaMlVnZEdobElIUmxjbTFwYm1Gc0lHbHVkRzhnZEdobElIQnlhVzl5SUhOMGNtbHVaeUJoYm1RZ1pISnZjQ0IwYUdVZ1kyaGhibWRsTGx4dUlDQXZMeUJVYUdseklHbHpJRzl1YkhrZ1lYWmhhV3hoWW14bElHWnZjaUJ6ZEhKcGJtY2diVzlrWlM1Y2JpQWdiR1YwSUd4aGMzUkRiMjF3YjI1bGJuUWdQU0JqYjIxd2IyNWxiblJ6VzJOdmJYQnZibVZ1ZEV4bGJpQXRJREZkTzF4dUlDQnBaaUFvWTI5dGNHOXVaVzUwVEdWdUlENGdNVnh1SUNBZ0lDQWdKaVlnZEhsd1pXOW1JR3hoYzNSRGIyMXdiMjVsYm5RdWRtRnNkV1VnUFQwOUlDZHpkSEpwYm1jblhHNGdJQ0FnSUNBbUppQW9iR0Z6ZEVOdmJYQnZibVZ1ZEM1aFpHUmxaQ0I4ZkNCc1lYTjBRMjl0Y0c5dVpXNTBMbkpsYlc5MlpXUXBYRzRnSUNBZ0lDQW1KaUJrYVdabUxtVnhkV0ZzY3lnbkp5d2diR0Z6ZEVOdmJYQnZibVZ1ZEM1MllXeDFaU2twSUh0Y2JpQWdJQ0JqYjIxd2IyNWxiblJ6VzJOdmJYQnZibVZ1ZEV4bGJpQXRJREpkTG5aaGJIVmxJQ3M5SUd4aGMzUkRiMjF3YjI1bGJuUXVkbUZzZFdVN1hHNGdJQ0FnWTI5dGNHOXVaVzUwY3k1d2IzQW9LVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJqYjIxd2IyNWxiblJ6TzF4dWZWeHVYRzVtZFc1amRHbHZiaUJqYkc5dVpWQmhkR2dvY0dGMGFDa2dlMXh1SUNCeVpYUjFjbTRnZXlCdVpYZFFiM002SUhCaGRHZ3VibVYzVUc5ekxDQmpiMjF3YjI1bGJuUnpPaUJ3WVhSb0xtTnZiWEJ2Ym1WdWRITXVjMnhwWTJVb01Da2dmVHRjYm4xY2JpSmRmUT09XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZkNoYXJzID0gZGlmZkNoYXJzO1xuZXhwb3J0cy5jaGFyYWN0ZXJEaWZmID0gdm9pZCAwO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fYmFzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmFzZVwiKSlcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXIgY2hhcmFjdGVyRGlmZiA9IG5ld1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2Vcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5bXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cImRlZmF1bHRcIlxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbl0oKTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5jaGFyYWN0ZXJEaWZmID0gY2hhcmFjdGVyRGlmZjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJOb1lYSmhZM1JsY2k1cWN5SmRMQ0p1WVcxbGN5STZXeUpqYUdGeVlXTjBaWEpFYVdabUlpd2lSR2xtWmlJc0ltUnBabVpEYUdGeWN5SXNJbTlzWkZOMGNpSXNJbTVsZDFOMGNpSXNJbTl3ZEdsdmJuTWlMQ0prYVdabUlsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3T3pzN1FVRkZUeXhKUVVGTlFTeGhRVUZoTEVkQlFVYzdRVUZCU1VNN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUVzUTBGQlNpeEZRVUYwUWpzN096czdPMEZCUTBFc1UwRkJVME1zVTBGQlZDeERRVUZ0UWtNc1RVRkJia0lzUlVGQk1rSkRMRTFCUVROQ0xFVkJRVzFEUXl4UFFVRnVReXhGUVVFMFF6dEJRVUZGTEZOQlFVOU1MR0ZCUVdFc1EwRkJRMDBzU1VGQlpDeERRVUZ0UWtnc1RVRkJia0lzUlVGQk1rSkRMRTFCUVROQ0xFVkJRVzFEUXl4UFFVRnVReXhEUVVGUU8wRkJRWEZFSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXMXdiM0owSUVScFptWWdabkp2YlNBbkxpOWlZWE5sSnp0Y2JseHVaWGh3YjNKMElHTnZibk4wSUdOb1lYSmhZM1JsY2tScFptWWdQU0J1WlhjZ1JHbG1aaWdwTzF4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdScFptWkRhR0Z5Y3lodmJHUlRkSElzSUc1bGQxTjBjaXdnYjNCMGFXOXVjeWtnZXlCeVpYUjFjbTRnWTJoaGNtRmpkR1Z5UkdsbVppNWthV1ptS0c5c1pGTjBjaXdnYm1WM1UzUnlMQ0J2Y0hScGIyNXpLVHNnZlZ4dUlsMTlcbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaWZmQ3NzID0gZGlmZkNzcztcbmV4cG9ydHMuY3NzRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIGNzc0RpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbmV4cG9ydHMuY3NzRGlmZiA9IGNzc0RpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5jc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbn07XG5cbmZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJOemN5NXFjeUpkTENKdVlXMWxjeUk2V3lKamMzTkVhV1ptSWl3aVJHbG1aaUlzSW5SdmEyVnVhWHBsSWl3aWRtRnNkV1VpTENKemNHeHBkQ0lzSW1ScFptWkRjM01pTENKdmJHUlRkSElpTENKdVpYZFRkSElpTENKallXeHNZbUZqYXlJc0ltUnBabVlpWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96czdPenRCUVVWUExFbEJRVTFCTEU5QlFVOHNSMEZCUnp0QlFVRkpRenRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFTeERRVUZLTEVWQlFXaENPenM3T3pzN1FVRkRVRVFzVDBGQlR5eERRVUZEUlN4UlFVRlNMRWRCUVcxQ0xGVkJRVk5ETEV0QlFWUXNSVUZCWjBJN1FVRkRha01zVTBGQlQwRXNTMEZCU3l4RFFVRkRReXhMUVVGT0xFTkJRVmtzWlVGQldpeERRVUZRTzBGQlEwUXNRMEZHUkRzN1FVRkpUeXhUUVVGVFF5eFBRVUZVTEVOQlFXbENReXhOUVVGcVFpeEZRVUY1UWtNc1RVRkJla0lzUlVGQmFVTkRMRkZCUVdwRExFVkJRVEpETzBGQlFVVXNVMEZCVDFJc1QwRkJUeXhEUVVGRFV5eEpRVUZTTEVOQlFXRklMRTFCUVdJc1JVRkJjVUpETEUxQlFYSkNMRVZCUVRaQ1F5eFJRVUUzUWl4RFFVRlFPMEZCUVdkRUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibHh1Wlhod2IzSjBJR052Ym5OMElHTnpjMFJwWm1ZZ1BTQnVaWGNnUkdsbVppZ3BPMXh1WTNOelJHbG1aaTUwYjJ0bGJtbDZaU0E5SUdaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc0Z0lISmxkSFZ5YmlCMllXeDFaUzV6Y0d4cGRDZ3ZLRnQ3ZlRvN0xGMThYRnh6S3lrdktUdGNibjA3WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCa2FXWm1RM056S0c5c1pGTjBjaXdnYm1WM1UzUnlMQ0JqWVd4c1ltRmpheWtnZXlCeVpYUjFjbTRnWTNOelJHbG1aaTVrYVdabUtHOXNaRk4wY2l3Z2JtVjNVM1J5TENCallXeHNZbUZqYXlrN0lIMWNiaUpkZlE9PVxuIiwiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpZmZKc29uID0gZGlmZkpzb247XG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcbmV4cG9ydHMuanNvbkRpZmYgPSB2b2lkIDA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fbGluZSA9IHJlcXVpcmUoXCIuL2xpbmVcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIganNvbkRpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4vLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5qc29uRGlmZiA9IGpzb25EaWZmO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcbmpzb25EaWZmLnRva2VuaXplID1cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9saW5lXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuLlxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xubGluZURpZmZcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4udG9rZW5pemU7XG5cbmpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIHZhciBfdGhpcyRvcHRpb25zID1cbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgdGhpcy5vcHRpb25zLFxuICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfdGhpcyRvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxuICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyID0gX3RoaXMkb3B0aW9ucyRzdHJpbmdpID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoaywgdilcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHZcbiAgICApO1xuICB9IDogX3RoaXMkb3B0aW9ucyRzdHJpbmdpO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbn07XG5cbmpzb25EaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gKFxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfYmFzZVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgW1xuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBcImRlZmF1bHRcIlxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgXS5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKVxuICApO1xufTtcblxuZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbi8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSkge1xuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcblxuICBpZiAocmVwbGFjZXIpIHtcbiAgICBvYmogPSByZXBsYWNlcihrZXksIG9iaik7XG4gIH1cblxuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XG5cbiAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbaV0gPSBjYW5vbmljYWxpemUob2JqW2ldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSk7XG4gICAgfVxuXG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xuICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgfVxuXG4gIGlmIChcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfdHlwZW9mKFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHtcbiAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgIF9rZXk7XG5cbiAgICBmb3IgKF9rZXkgaW4gb2JqKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICBzb3J0ZWRLZXlzLnB1c2goX2tleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydGVkS2V5cy5zb3J0KCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcbiAgICB9XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJwemIyNHVhbk1pWFN3aWJtRnRaWE1pT2xzaWIySnFaV04wVUhKdmRHOTBlWEJsVkc5VGRISnBibWNpTENKUFltcGxZM1FpTENKd2NtOTBiM1I1Y0dVaUxDSjBiMU4wY21sdVp5SXNJbXB6YjI1RWFXWm1JaXdpUkdsbVppSXNJblZ6WlV4dmJtZGxjM1JVYjJ0bGJpSXNJblJ2YTJWdWFYcGxJaXdpYkdsdVpVUnBabVlpTENKallYTjBTVzV3ZFhRaUxDSjJZV3gxWlNJc0ltOXdkR2x2Ym5NaUxDSjFibVJsWm1sdVpXUlNaWEJzWVdObGJXVnVkQ0lzSW5OMGNtbHVaMmxtZVZKbGNHeGhZMlZ5SWl3aWF5SXNJbllpTENKS1UwOU9JaXdpYzNSeWFXNW5hV1o1SWl3aVkyRnViMjVwWTJGc2FYcGxJaXdpWlhGMVlXeHpJaXdpYkdWbWRDSXNJbkpwWjJoMElpd2lZMkZzYkNJc0luSmxjR3hoWTJVaUxDSmthV1ptU25OdmJpSXNJbTlzWkU5aWFpSXNJbTVsZDA5aWFpSXNJbVJwWm1ZaUxDSnZZbW9pTENKemRHRmpheUlzSW5KbGNHeGhZMlZ0Wlc1MFUzUmhZMnNpTENKeVpYQnNZV05sY2lJc0ltdGxlU0lzSW1raUxDSnNaVzVuZEdnaUxDSmpZVzV2Ym1sallXeHBlbVZrVDJKcUlpd2ljSFZ6YUNJc0lrRnljbUY1SWl3aWNHOXdJaXdpZEc5S1UwOU9JaXdpYzI5eWRHVmtTMlY1Y3lJc0ltaGhjMDkzYmxCeWIzQmxjblI1SWl3aWMyOXlkQ0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN096czdPenM3UVVGRlFTeEpRVUZOUVN4MVFrRkJkVUlzUjBGQlIwTXNUVUZCVFN4RFFVRkRReXhUUVVGUUxFTkJRV2xDUXl4UlFVRnFSRHRCUVVkUExFbEJRVTFETEZGQlFWRXNSMEZCUnp0QlFVRkpRenRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFTeERRVUZLTEVWQlFXcENMRU1zUTBGRFVEdEJRVU5CT3pzN096czdRVUZEUVVRc1VVRkJVU3hEUVVGRFJTeGxRVUZVTEVkQlFUSkNMRWxCUVROQ08wRkJSVUZHTEZGQlFWRXNRMEZCUTBjc1VVRkJWRHRCUVVGdlFrTTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFUdEJRVUZCTEVOQlFWTkVMRkZCUVRkQ096dEJRVU5CU0N4UlFVRlJMRU5CUVVOTExGTkJRVlFzUjBGQmNVSXNWVUZCVTBNc1MwRkJWQ3hGUVVGblFqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVTXJSU3hQUVVGTFF5eFBRVVJ3Ump0QlFVRkJMRTFCUXpWQ1F5eHZRa0ZFTkVJc2FVSkJRelZDUVN4dlFrRkVORUk3UVVGQlFTdzBRMEZEVGtNc2FVSkJSRTA3UVVGQlFTeE5RVU5PUVN4cFFrRkVUU3h6UTBGRFl5eFZRVUZEUXl4RFFVRkVMRVZCUVVsRExFTkJRVW83UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRlZMR0ZCUVU5QkxFTkJRVkFzUzBGQllTeFhRVUZpTEVkQlFUSkNTQ3h2UWtGQk0wSXNSMEZCYTBSSE8wRkJRVFZFTzBGQlFVRXNSMEZFWkR0QlFVZHVReXhUUVVGUExFOUJRVTlNTEV0QlFWQXNTMEZCYVVJc1VVRkJha0lzUjBGQk5FSkJMRXRCUVRWQ0xFZEJRVzlEVFN4SlFVRkpMRU5CUVVORExGTkJRVXdzUTBGQlpVTXNXVUZCV1N4RFFVRkRVaXhMUVVGRUxFVkJRVkVzU1VGQlVpeEZRVUZqTEVsQlFXUXNSVUZCYjBKSExHbENRVUZ3UWl4RFFVRXpRaXhGUVVGdFJVRXNhVUpCUVc1RkxFVkJRWE5HTEVsQlFYUkdMRU5CUVRORE8wRkJRMFFzUTBGS1JEczdRVUZMUVZRc1VVRkJVU3hEUVVGRFpTeE5RVUZVTEVkQlFXdENMRlZCUVZORExFbEJRVlFzUlVGQlpVTXNTMEZCWml4RlFVRnpRanRCUVVOMFF5eFRRVUZQYUVJN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNUVUZCUzBnc1UwRkJUQ3hEUVVGbGFVSXNUVUZCWml4RFFVRnpRa2NzU1VGQmRFSXNRMEZCTWtKc1FpeFJRVUV6UWl4RlFVRnhRMmRDTEVsQlFVa3NRMEZCUTBjc1QwRkJUQ3hEUVVGaExGbEJRV0lzUlVGQk1rSXNTVUZCTTBJc1EwRkJja01zUlVGQmRVVkdMRXRCUVVzc1EwRkJRMFVzVDBGQlRpeERRVUZqTEZsQlFXUXNSVUZCTkVJc1NVRkJOVUlzUTBGQmRrVTdRVUZCVUR0QlFVTkVMRU5CUmtRN08wRkJTVThzVTBGQlUwTXNVVUZCVkN4RFFVRnJRa01zVFVGQmJFSXNSVUZCTUVKRExFMUJRVEZDTEVWQlFXdERaaXhQUVVGc1F5eEZRVUV5UXp0QlFVRkZMRk5CUVU5UUxGRkJRVkVzUTBGQlEzVkNMRWxCUVZRc1EwRkJZMFlzVFVGQlpDeEZRVUZ6UWtNc1RVRkJkRUlzUlVGQk9FSm1MRTlCUVRsQ0xFTkJRVkE3UVVGQlowUXNReXhEUVVWd1J6dEJRVU5CT3pzN1FVRkRUeXhUUVVGVFR5eFpRVUZVTEVOQlFYTkNWU3hIUVVGMFFpeEZRVUV5UWtNc1MwRkJNMElzUlVGQmEwTkRMR2RDUVVGc1F5eEZRVUZ2UkVNc1VVRkJjRVFzUlVGQk9FUkRMRWRCUVRsRUxFVkJRVzFGTzBGQlEzaEZTQ3hGUVVGQlFTeExRVUZMTEVkQlFVZEJMRXRCUVVzc1NVRkJTU3hGUVVGcVFqdEJRVU5CUXl4RlFVRkJRU3huUWtGQlowSXNSMEZCUjBFc1owSkJRV2RDTEVsQlFVa3NSVUZCZGtNN08wRkJSVUVzVFVGQlNVTXNVVUZCU2l4RlFVRmpPMEZCUTFwSUxFbEJRVUZCTEVkQlFVY3NSMEZCUjBjc1VVRkJVU3hEUVVGRFF5eEhRVUZFTEVWQlFVMUtMRWRCUVU0c1EwRkJaRHRCUVVORU96dEJRVVZFTEUxQlFVbExMRU5CUVVvN08wRkJSVUVzVDBGQlMwRXNRMEZCUXl4SFFVRkhMRU5CUVZRc1JVRkJXVUVzUTBGQlF5eEhRVUZIU2l4TFFVRkxMRU5CUVVOTExFMUJRWFJDTEVWQlFUaENSQ3hEUVVGRExFbEJRVWtzUTBGQmJrTXNSVUZCYzBNN1FVRkRjRU1zVVVGQlNVb3NTMEZCU3l4RFFVRkRTU3hEUVVGRUxFTkJRVXdzUzBGQllVd3NSMEZCYWtJc1JVRkJjMEk3UVVGRGNFSXNZVUZCVDBVc1owSkJRV2RDTEVOQlFVTkhMRU5CUVVRc1EwRkJka0k3UVVGRFJEdEJRVU5HT3p0QlFVVkVMRTFCUVVsRkxHZENRVUZLT3p0QlFVVkJMRTFCUVVrc2NVSkJRWEZDYmtNc2RVSkJRWFZDTEVOQlFVTnpRaXhKUVVGNFFpeERRVUUyUWswc1IwRkJOMElzUTBGQmVrSXNSVUZCTkVRN1FVRkRNVVJETEVsQlFVRkJMRXRCUVVzc1EwRkJRMDhzU1VGQlRpeERRVUZYVWl4SFFVRllPMEZCUTBGUExFbEJRVUZCTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWxGTEV0QlFVb3NRMEZCVlZRc1IwRkJSeXhEUVVGRFRTeE5RVUZrTEVOQlFXNUNPMEZCUTBGS0xFbEJRVUZCTEdkQ1FVRm5RaXhEUVVGRFRTeEpRVUZxUWl4RFFVRnpRa1FzWjBKQlFYUkNPenRCUVVOQkxGTkJRVXRHTEVOQlFVTXNSMEZCUnl4RFFVRlVMRVZCUVZsQkxFTkJRVU1zUjBGQlIwd3NSMEZCUnl4RFFVRkRUU3hOUVVGd1FpeEZRVUUwUWtRc1EwRkJReXhKUVVGSkxFTkJRV3BETEVWQlFXOURPMEZCUTJ4RFJTeE5RVUZCUVN4blFrRkJaMElzUTBGQlEwWXNRMEZCUkN4RFFVRm9RaXhIUVVGelFtWXNXVUZCV1N4RFFVRkRWU3hIUVVGSExFTkJRVU5MTEVOQlFVUXNRMEZCU2l4RlFVRlRTaXhMUVVGVUxFVkJRV2RDUXl4blFrRkJhRUlzUlVGQmEwTkRMRkZCUVd4RExFVkJRVFJEUXl4SFFVRTFReXhEUVVGc1F6dEJRVU5FT3p0QlFVTkVTQ3hKUVVGQlFTeExRVUZMTEVOQlFVTlRMRWRCUVU0N1FVRkRRVklzU1VGQlFVRXNaMEpCUVdkQ0xFTkJRVU5STEVkQlFXcENPMEZCUTBFc1YwRkJUMGdzWjBKQlFWQTdRVUZEUkRzN1FVRkZSQ3hOUVVGSlVDeEhRVUZITEVsQlFVbEJMRWRCUVVjc1EwRkJRMWNzVFVGQlppeEZRVUYxUWp0QlFVTnlRbGdzU1VGQlFVRXNSMEZCUnl4SFFVRkhRU3hIUVVGSExFTkJRVU5YTEUxQlFVb3NSVUZCVGp0QlFVTkVPenRCUVVWRU8wRkJRVWs3UVVGQlFUdEJRVUZCTzBGQlFVOVlMRVZCUVVGQkxFZEJRVkFzVFVGQlpTeFJRVUZtTEVsQlFUSkNRU3hIUVVGSExFdEJRVXNzU1VGQmRrTXNSVUZCTmtNN1FVRkRNME5ETEVsQlFVRkJMRXRCUVVzc1EwRkJRMDhzU1VGQlRpeERRVUZYVWl4SFFVRllPMEZCUTBGUExFbEJRVUZCTEdkQ1FVRm5RaXhIUVVGSExFVkJRVzVDTzBGQlEwRk1MRWxCUVVGQkxHZENRVUZuUWl4RFFVRkRUU3hKUVVGcVFpeERRVUZ6UWtRc1owSkJRWFJDT3p0QlFVTkJMRkZCUVVsTExGVkJRVlVzUjBGQlJ5eEZRVUZxUWp0QlFVRkJMRkZCUTBsU0xFbEJSRW83TzBGQlJVRXNVMEZCUzBFc1NVRkJUQ3hKUVVGWlNpeEhRVUZhTEVWQlFXbENPMEZCUTJZN1FVRkRRU3hWUVVGSlFTeEhRVUZITEVOQlFVTmhMR05CUVVvc1EwRkJiVUpVTEVsQlFXNUNMRU5CUVVvc1JVRkJOa0k3UVVGRE0wSlJMRkZCUVVGQkxGVkJRVlVzUTBGQlEwb3NTVUZCV0N4RFFVRm5Ra29zU1VGQmFFSTdRVUZEUkR0QlFVTkdPenRCUVVORVVTeEpRVUZCUVN4VlFVRlZMRU5CUVVORkxFbEJRVmc3TzBGQlEwRXNVMEZCUzFRc1EwRkJReXhIUVVGSExFTkJRVlFzUlVGQldVRXNRMEZCUXl4SFFVRkhUeXhWUVVGVkxFTkJRVU5PTEUxQlFUTkNMRVZCUVcxRFJDeERRVUZETEVsQlFVa3NRMEZCZUVNc1JVRkJNa003UVVGRGVrTkVMRTFCUVVGQkxFbEJRVWNzUjBGQlIxRXNWVUZCVlN4RFFVRkRVQ3hEUVVGRUxFTkJRV2hDTzBGQlEwRkZMRTFCUVVGQkxHZENRVUZuUWl4RFFVRkRTQ3hKUVVGRUxFTkJRV2hDTEVkQlFYZENaQ3haUVVGWkxFTkJRVU5WTEVkQlFVY3NRMEZCUTBrc1NVRkJSQ3hEUVVGS0xFVkJRVmRJTEV0QlFWZ3NSVUZCYTBKRExHZENRVUZzUWl4RlFVRnZRME1zVVVGQmNFTXNSVUZCT0VORExFbEJRVGxETEVOQlFYQkRPMEZCUTBRN08wRkJRMFJJTEVsQlFVRkJMRXRCUVVzc1EwRkJRMU1zUjBGQlRqdEJRVU5CVWl4SlFVRkJRU3huUWtGQlowSXNRMEZCUTFFc1IwRkJha0k3UVVGRFJDeEhRVzVDUkN4TlFXMUNUenRCUVVOTVNDeEpRVUZCUVN4blFrRkJaMElzUjBGQlIxQXNSMEZCYmtJN1FVRkRSRHM3UVVGRFJDeFRRVUZQVHl4blFrRkJVRHRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibWx0Y0c5eWRDQjdiR2x1WlVScFptWjlJR1p5YjIwZ0p5NHZiR2x1WlNjN1hHNWNibU52Ym5OMElHOWlhbVZqZEZCeWIzUnZkSGx3WlZSdlUzUnlhVzVuSUQwZ1QySnFaV04wTG5CeWIzUnZkSGx3WlM1MGIxTjBjbWx1Wnp0Y2JseHVYRzVsZUhCdmNuUWdZMjl1YzNRZ2FuTnZia1JwWm1ZZ1BTQnVaWGNnUkdsbVppZ3BPMXh1THk4Z1JHbHpZM0pwYldsdVlYUmxJR0psZEhkbFpXNGdkSGR2SUd4cGJtVnpJRzltSUhCeVpYUjBlUzF3Y21sdWRHVmtMQ0J6WlhKcFlXeHBlbVZrSUVwVFQwNGdkMmhsY21VZ2IyNWxJRzltSUhSb1pXMGdhR0Z6SUdGY2JpOHZJR1JoYm1kc2FXNW5JR052YlcxaElHRnVaQ0IwYUdVZ2IzUm9aWElnWkc5bGMyNG5kQzRnVkhWeWJuTWdiM1YwSUdsdVkyeDFaR2x1WnlCMGFHVWdaR0Z1WjJ4cGJtY2dZMjl0YldFZ2VXbGxiR1J6SUhSb1pTQnVhV05sYzNRZ2IzVjBjSFYwT2x4dWFuTnZia1JwWm1ZdWRYTmxURzl1WjJWemRGUnZhMlZ1SUQwZ2RISjFaVHRjYmx4dWFuTnZia1JwWm1ZdWRHOXJaVzVwZW1VZ1BTQnNhVzVsUkdsbVppNTBiMnRsYm1sNlpUdGNibXB6YjI1RWFXWm1MbU5oYzNSSmJuQjFkQ0E5SUdaMWJtTjBhVzl1S0haaGJIVmxLU0I3WEc0Z0lHTnZibk4wSUh0MWJtUmxabWx1WldSU1pYQnNZV05sYldWdWRDd2djM1J5YVc1bmFXWjVVbVZ3YkdGalpYSWdQU0FvYXl3Z2Rpa2dQVDRnZEhsd1pXOW1JSFlnUFQwOUlDZDFibVJsWm1sdVpXUW5JRDhnZFc1a1pXWnBibVZrVW1Wd2JHRmpaVzFsYm5RZ09pQjJmU0E5SUhSb2FYTXViM0IwYVc5dWN6dGNibHh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JSFpoYkhWbElEMDlQU0FuYzNSeWFXNW5KeUEvSUhaaGJIVmxJRG9nU2xOUFRpNXpkSEpwYm1kcFpua29ZMkZ1YjI1cFkyRnNhWHBsS0haaGJIVmxMQ0J1ZFd4c0xDQnVkV3hzTENCemRISnBibWRwWm5sU1pYQnNZV05sY2lrc0lITjBjbWx1WjJsbWVWSmxjR3hoWTJWeUxDQW5JQ0FuS1R0Y2JuMDdYRzVxYzI5dVJHbG1aaTVsY1hWaGJITWdQU0JtZFc1amRHbHZiaWhzWldaMExDQnlhV2RvZENrZ2UxeHVJQ0J5WlhSMWNtNGdSR2xtWmk1d2NtOTBiM1I1Y0dVdVpYRjFZV3h6TG1OaGJHd29hbk52YmtScFptWXNJR3hsWm5RdWNtVndiR0ZqWlNndkxDaGJYRnh5WEZ4dVhTa3ZaeXdnSnlReEp5a3NJSEpwWjJoMExuSmxjR3hoWTJVb0x5d29XMXhjY2x4Y2JsMHBMMmNzSUNja01TY3BLVHRjYm4wN1hHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmthV1ptU25OdmJpaHZiR1JQWW1vc0lHNWxkMDlpYWl3Z2IzQjBhVzl1Y3lrZ2V5QnlaWFIxY200Z2FuTnZia1JwWm1ZdVpHbG1aaWh2YkdSUFltb3NJRzVsZDA5aWFpd2diM0IwYVc5dWN5azdJSDFjYmx4dUx5OGdWR2hwY3lCbWRXNWpkR2x2YmlCb1lXNWtiR1Z6SUhSb1pTQndjbVZ6Wlc1alpTQnZaaUJqYVhKamRXeGhjaUJ5WldabGNtVnVZMlZ6SUdKNUlHSmhhV3hwYm1jZ2IzVjBJSGRvWlc0Z1pXNWpiM1Z1ZEdWeWFXNW5JR0Z1WEc0dkx5QnZZbXBsWTNRZ2RHaGhkQ0JwY3lCaGJISmxZV1I1SUc5dUlIUm9aU0JjSW5OMFlXTnJYQ0lnYjJZZ2FYUmxiWE1nWW1WcGJtY2djSEp2WTJWemMyVmtMaUJCWTJObGNIUnpJR0Z1SUc5d2RHbHZibUZzSUhKbGNHeGhZMlZ5WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWTJGdWIyNXBZMkZzYVhwbEtHOWlhaXdnYzNSaFkyc3NJSEpsY0d4aFkyVnRaVzUwVTNSaFkyc3NJSEpsY0d4aFkyVnlMQ0JyWlhrcElIdGNiaUFnYzNSaFkyc2dQU0J6ZEdGamF5QjhmQ0JiWFR0Y2JpQWdjbVZ3YkdGalpXMWxiblJUZEdGamF5QTlJSEpsY0d4aFkyVnRaVzUwVTNSaFkyc2dmSHdnVzEwN1hHNWNiaUFnYVdZZ0tISmxjR3hoWTJWeUtTQjdYRzRnSUNBZ2IySnFJRDBnY21Wd2JHRmpaWElvYTJWNUxDQnZZbW9wTzF4dUlDQjlYRzVjYmlBZ2JHVjBJR2s3WEc1Y2JpQWdabTl5SUNocElEMGdNRHNnYVNBOElITjBZV05yTG14bGJtZDBhRHNnYVNBclBTQXhLU0I3WEc0Z0lDQWdhV1lnS0hOMFlXTnJXMmxkSUQwOVBTQnZZbW9wSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJ5WlhCc1lXTmxiV1Z1ZEZOMFlXTnJXMmxkTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUd4bGRDQmpZVzV2Ym1sallXeHBlbVZrVDJKcU8xeHVYRzRnSUdsbUlDZ25XMjlpYW1WamRDQkJjbkpoZVYwbklEMDlQU0J2WW1wbFkzUlFjbTkwYjNSNWNHVlViMU4wY21sdVp5NWpZV3hzS0c5aWFpa3BJSHRjYmlBZ0lDQnpkR0ZqYXk1d2RYTm9LRzlpYWlrN1hHNGdJQ0FnWTJGdWIyNXBZMkZzYVhwbFpFOWlhaUE5SUc1bGR5QkJjbkpoZVNodlltb3ViR1Z1WjNSb0tUdGNiaUFnSUNCeVpYQnNZV05sYldWdWRGTjBZV05yTG5CMWMyZ29ZMkZ1YjI1cFkyRnNhWHBsWkU5aWFpazdYRzRnSUNBZ1ptOXlJQ2hwSUQwZ01Ec2dhU0E4SUc5aWFpNXNaVzVuZEdnN0lHa2dLejBnTVNrZ2UxeHVJQ0FnSUNBZ1kyRnViMjVwWTJGc2FYcGxaRTlpYWx0cFhTQTlJR05oYm05dWFXTmhiR2w2WlNodlltcGJhVjBzSUhOMFlXTnJMQ0J5WlhCc1lXTmxiV1Z1ZEZOMFlXTnJMQ0J5WlhCc1lXTmxjaXdnYTJWNUtUdGNiaUFnSUNCOVhHNGdJQ0FnYzNSaFkyc3VjRzl3S0NrN1hHNGdJQ0FnY21Wd2JHRmpaVzFsYm5SVGRHRmpheTV3YjNBb0tUdGNiaUFnSUNCeVpYUjFjbTRnWTJGdWIyNXBZMkZzYVhwbFpFOWlhanRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHZZbW9nSmlZZ2IySnFMblJ2U2xOUFRpa2dlMXh1SUNBZ0lHOWlhaUE5SUc5aWFpNTBiMHBUVDA0b0tUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoMGVYQmxiMllnYjJKcUlEMDlQU0FuYjJKcVpXTjBKeUFtSmlCdlltb2dJVDA5SUc1MWJHd3BJSHRjYmlBZ0lDQnpkR0ZqYXk1d2RYTm9LRzlpYWlrN1hHNGdJQ0FnWTJGdWIyNXBZMkZzYVhwbFpFOWlhaUE5SUh0OU8xeHVJQ0FnSUhKbGNHeGhZMlZ0Wlc1MFUzUmhZMnN1Y0hWemFDaGpZVzV2Ym1sallXeHBlbVZrVDJKcUtUdGNiaUFnSUNCc1pYUWdjMjl5ZEdWa1MyVjVjeUE5SUZ0ZExGeHVJQ0FnSUNBZ0lDQnJaWGs3WEc0Z0lDQWdabTl5SUNoclpYa2dhVzRnYjJKcUtTQjdYRzRnSUNBZ0lDQXZLaUJwYzNSaGJtSjFiQ0JwWjI1dmNtVWdaV3h6WlNBcUwxeHVJQ0FnSUNBZ2FXWWdLRzlpYWk1b1lYTlBkMjVRY205d1pYSjBlU2hyWlhrcEtTQjdYRzRnSUNBZ0lDQWdJSE52Y25SbFpFdGxlWE11Y0hWemFDaHJaWGtwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ0lDQnpiM0owWldSTFpYbHpMbk52Y25Rb0tUdGNiaUFnSUNCbWIzSWdLR2tnUFNBd095QnBJRHdnYzI5eWRHVmtTMlY1Y3k1c1pXNW5kR2c3SUdrZ0t6MGdNU2tnZTF4dUlDQWdJQ0FnYTJWNUlEMGdjMjl5ZEdWa1MyVjVjMXRwWFR0Y2JpQWdJQ0FnSUdOaGJtOXVhV05oYkdsNlpXUlBZbXBiYTJWNVhTQTlJR05oYm05dWFXTmhiR2w2WlNodlltcGJhMlY1WFN3Z2MzUmhZMnNzSUhKbGNHeGhZMlZ0Wlc1MFUzUmhZMnNzSUhKbGNHeGhZMlZ5TENCclpYa3BPMXh1SUNBZ0lIMWNiaUFnSUNCemRHRmpheTV3YjNBb0tUdGNiaUFnSUNCeVpYQnNZV05sYldWdWRGTjBZV05yTG5CdmNDZ3BPMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR05oYm05dWFXTmhiR2w2WldSUFltb2dQU0J2WW1vN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUdOaGJtOXVhV05oYkdsNlpXUlBZbW83WEc1OVhHNGlYWDA9XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZkxpbmVzID0gZGlmZkxpbmVzO1xuZXhwb3J0cy5kaWZmVHJpbW1lZExpbmVzID0gZGlmZlRyaW1tZWRMaW5lcztcbmV4cG9ydHMubGluZURpZmYgPSB2b2lkIDA7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fcGFyYW1zID0gcmVxdWlyZShcIi4uL3V0aWwvcGFyYW1zXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIGxpbmVEaWZmID0gbmV3XG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fYmFzZVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbltcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwiZGVmYXVsdFwiXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXSgpO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5leHBvcnRzLmxpbmVEaWZmID0gbGluZURpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5saW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcmV0TGluZXMgPSBbXSxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcbnxcXHJcXG4pLyk7IC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxuXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgfSAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcbiAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldExpbmVzO1xufTtcblxuZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICB2YXIgb3B0aW9ucyA9XG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgKDAsXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBfcGFyYW1zXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIC5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICBnZW5lcmF0ZU9wdGlvbnMpXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIChjYWxsYmFjaywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDJ4cGJtVXVhbk1pWFN3aWJtRnRaWE1pT2xzaWJHbHVaVVJwWm1ZaUxDSkVhV1ptSWl3aWRHOXJaVzVwZW1VaUxDSjJZV3gxWlNJc0luSmxkRXhwYm1Weklpd2liR2x1WlhOQmJtUk9aWGRzYVc1bGN5SXNJbk53YkdsMElpd2liR1Z1WjNSb0lpd2ljRzl3SWl3aWFTSXNJbXhwYm1VaUxDSnZjSFJwYjI1eklpd2libVYzYkdsdVpVbHpWRzlyWlc0aUxDSnBaMjV2Y21WWGFHbDBaWE53WVdObElpd2lkSEpwYlNJc0luQjFjMmdpTENKa2FXWm1UR2x1WlhNaUxDSnZiR1JUZEhJaUxDSnVaWGRUZEhJaUxDSmpZV3hzWW1GamF5SXNJbVJwWm1ZaUxDSmthV1ptVkhKcGJXMWxaRXhwYm1Weklpd2laMlZ1WlhKaGRHVlBjSFJwYjI1eklsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3T3pzN1FVRkZUeXhKUVVGTlFTeFJRVUZSTEVkQlFVYzdRVUZCU1VNN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUVzUTBGQlNpeEZRVUZxUWpzN096czdPMEZCUTFCRUxGRkJRVkVzUTBGQlEwVXNVVUZCVkN4SFFVRnZRaXhWUVVGVFF5eExRVUZVTEVWQlFXZENPMEZCUTJ4RExFMUJRVWxETEZGQlFWRXNSMEZCUnl4RlFVRm1PMEZCUVVFc1RVRkRTVU1zWjBKQlFXZENMRWRCUVVkR0xFdEJRVXNzUTBGQlEwY3NTMEZCVGl4RFFVRlpMRmRCUVZvc1EwRkVka0lzUTBGRWEwTXNRMEZKYkVNN08wRkJRMEVzVFVGQlNTeERRVUZEUkN4blFrRkJaMElzUTBGQlEwRXNaMEpCUVdkQ0xFTkJRVU5GTEUxQlFXcENMRWRCUVRCQ0xFTkJRVE5DTEVOQlFYSkNMRVZCUVc5RU8wRkJRMnhFUml4SlFVRkJRU3huUWtGQlowSXNRMEZCUTBjc1IwRkJha0k3UVVGRFJDeEhRVkJwUXl4RFFWTnNRenM3TzBGQlEwRXNUMEZCU3l4SlFVRkpReXhEUVVGRExFZEJRVWNzUTBGQllpeEZRVUZuUWtFc1EwRkJReXhIUVVGSFNpeG5Ra0ZCWjBJc1EwRkJRMFVzVFVGQmNrTXNSVUZCTmtORkxFTkJRVU1zUlVGQk9VTXNSVUZCYTBRN1FVRkRhRVFzVVVGQlNVTXNTVUZCU1N4SFFVRkhUQ3huUWtGQlowSXNRMEZCUTBrc1EwRkJSQ3hEUVVFelFqczdRVUZGUVN4UlFVRkpRU3hEUVVGRExFZEJRVWNzUTBGQlNpeEpRVUZUTEVOQlFVTXNTMEZCUzBVc1QwRkJUQ3hEUVVGaFF5eGpRVUV6UWl4RlFVRXlRenRCUVVONlExSXNUVUZCUVVFc1VVRkJVU3hEUVVGRFFTeFJRVUZSTEVOQlFVTkhMRTFCUVZRc1IwRkJhMElzUTBGQmJrSXNRMEZCVWl4SlFVRnBRMGNzU1VGQmFrTTdRVUZEUkN4TFFVWkVMRTFCUlU4N1FVRkRUQ3hWUVVGSkxFdEJRVXRETEU5QlFVd3NRMEZCWVVVc1owSkJRV3BDTEVWQlFXMURPMEZCUTJwRFNDeFJRVUZCUVN4SlFVRkpMRWRCUVVkQkxFbEJRVWtzUTBGQlEwa3NTVUZCVEN4RlFVRlFPMEZCUTBRN08wRkJRMFJXTEUxQlFVRkJMRkZCUVZFc1EwRkJRMWNzU1VGQlZDeERRVUZqVEN4SlFVRmtPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFRRVUZQVGl4UlFVRlFPMEZCUTBRc1EwRjRRa1E3TzBGQk1FSlBMRk5CUVZOWkxGTkJRVlFzUTBGQmJVSkRMRTFCUVc1Q0xFVkJRVEpDUXl4TlFVRXpRaXhGUVVGdFEwTXNVVUZCYmtNc1JVRkJOa003UVVGQlJTeFRRVUZQYmtJc1VVRkJVU3hEUVVGRGIwSXNTVUZCVkN4RFFVRmpTQ3hOUVVGa0xFVkJRWE5DUXl4TlFVRjBRaXhGUVVFNFFrTXNVVUZCT1VJc1EwRkJVRHRCUVVGcFJEczdRVUZEYUVjc1UwRkJVMFVzWjBKQlFWUXNRMEZCTUVKS0xFMUJRVEZDTEVWQlFXdERReXhOUVVGc1F5eEZRVUV3UTBNc1VVRkJNVU1zUlVGQmIwUTdRVUZEZWtRc1RVRkJTVklzVDBGQlR6dEJRVUZITzBGQlFVRTdRVUZCUVRzN1FVRkJRVmM3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVHRCUVVGQkxFZEJRV2RDU0N4UlFVRm9RaXhGUVVFd1FqdEJRVUZEVGl4SlFVRkJRU3huUWtGQlowSXNSVUZCUlR0QlFVRnVRaXhIUVVFeFFpeERRVUZrTzBGQlEwRXNVMEZCVDJJc1VVRkJVU3hEUVVGRGIwSXNTVUZCVkN4RFFVRmpTQ3hOUVVGa0xFVkJRWE5DUXl4TlFVRjBRaXhGUVVFNFFsQXNUMEZCT1VJc1EwRkJVRHRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibWx0Y0c5eWRDQjdaMlZ1WlhKaGRHVlBjSFJwYjI1emZTQm1jbTl0SUNjdUxpOTFkR2xzTDNCaGNtRnRjeWM3WEc1Y2JtVjRjRzl5ZENCamIyNXpkQ0JzYVc1bFJHbG1aaUE5SUc1bGR5QkVhV1ptS0NrN1hHNXNhVzVsUkdsbVppNTBiMnRsYm1sNlpTQTlJR1oxYm1OMGFXOXVLSFpoYkhWbEtTQjdYRzRnSUd4bGRDQnlaWFJNYVc1bGN5QTlJRnRkTEZ4dUlDQWdJQ0FnYkdsdVpYTkJibVJPWlhkc2FXNWxjeUE5SUhaaGJIVmxMbk53YkdsMEtDOG9YRnh1ZkZ4Y2NseGNiaWt2S1R0Y2JseHVJQ0F2THlCSloyNXZjbVVnZEdobElHWnBibUZzSUdWdGNIUjVJSFJ2YTJWdUlIUm9ZWFFnYjJOamRYSnpJR2xtSUhSb1pTQnpkSEpwYm1jZ1pXNWtjeUIzYVhSb0lHRWdibVYzSUd4cGJtVmNiaUFnYVdZZ0tDRnNhVzVsYzBGdVpFNWxkMnhwYm1WelcyeHBibVZ6UVc1a1RtVjNiR2x1WlhNdWJHVnVaM1JvSUMwZ01WMHBJSHRjYmlBZ0lDQnNhVzVsYzBGdVpFNWxkMnhwYm1WekxuQnZjQ2dwTzF4dUlDQjlYRzVjYmlBZ0x5OGdUV1Z5WjJVZ2RHaGxJR052Ym5SbGJuUWdZVzVrSUd4cGJtVWdjMlZ3WVhKaGRHOXljeUJwYm5SdklITnBibWRzWlNCMGIydGxibk5jYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQnNhVzVsYzBGdVpFNWxkMnhwYm1WekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdiR1YwSUd4cGJtVWdQU0JzYVc1bGMwRnVaRTVsZDJ4cGJtVnpXMmxkTzF4dVhHNGdJQ0FnYVdZZ0tHa2dKU0F5SUNZbUlDRjBhR2x6TG05d2RHbHZibk11Ym1WM2JHbHVaVWx6Vkc5clpXNHBJSHRjYmlBZ0lDQWdJSEpsZEV4cGJtVnpXM0psZEV4cGJtVnpMbXhsYm1kMGFDQXRJREZkSUNzOUlHeHBibVU3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxtOXdkR2x2Ym5NdWFXZHViM0psVjJocGRHVnpjR0ZqWlNrZ2UxeHVJQ0FnSUNBZ0lDQnNhVzVsSUQwZ2JHbHVaUzUwY21sdEtDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnlaWFJNYVc1bGN5NXdkWE5vS0d4cGJtVXBPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQnlaWFJNYVc1bGN6dGNibjA3WEc1Y2JtVjRjRzl5ZENCbWRXNWpkR2x2YmlCa2FXWm1UR2x1WlhNb2IyeGtVM1J5TENCdVpYZFRkSElzSUdOaGJHeGlZV05yS1NCN0lISmxkSFZ5YmlCc2FXNWxSR2xtWmk1a2FXWm1LRzlzWkZOMGNpd2dibVYzVTNSeUxDQmpZV3hzWW1GamF5azdJSDFjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJrYVdabVZISnBiVzFsWkV4cGJtVnpLRzlzWkZOMGNpd2dibVYzVTNSeUxDQmpZV3hzWW1GamF5a2dlMXh1SUNCc1pYUWdiM0IwYVc5dWN5QTlJR2RsYm1WeVlYUmxUM0IwYVc5dWN5aGpZV3hzWW1GamF5d2dlMmxuYm05eVpWZG9hWFJsYzNCaFkyVTZJSFJ5ZFdWOUtUdGNiaUFnY21WMGRYSnVJR3hwYm1WRWFXWm1MbVJwWm1Zb2IyeGtVM1J5TENCdVpYZFRkSElzSUc5d2RHbHZibk1wTzF4dWZWeHVJbDE5XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlmZlNlbnRlbmNlcyA9IGRpZmZTZW50ZW5jZXM7XG5leHBvcnRzLnNlbnRlbmNlRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xudmFyIHNlbnRlbmNlRGlmZiA9IG5ld1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2Vcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5bXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cImRlZmF1bHRcIlxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbl0oKTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuZXhwb3J0cy5zZW50ZW5jZURpZmYgPSBzZW50ZW5jZURpZmY7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5zZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xufTtcblxuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrYVdabUwzTmxiblJsYm1ObExtcHpJbDBzSW01aGJXVnpJanBiSW5ObGJuUmxibU5sUkdsbVppSXNJa1JwWm1ZaUxDSjBiMnRsYm1sNlpTSXNJblpoYkhWbElpd2ljM0JzYVhRaUxDSmthV1ptVTJWdWRHVnVZMlZ6SWl3aWIyeGtVM1J5SWl3aWJtVjNVM1J5SWl3aVkyRnNiR0poWTJzaUxDSmthV1ptSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdPenM3UVVGSFR5eEpRVUZOUVN4WlFVRlpMRWRCUVVjN1FVRkJTVU03UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNRMEZCU2l4RlFVRnlRanM3T3pzN08wRkJRMUJFTEZsQlFWa3NRMEZCUTBVc1VVRkJZaXhIUVVGM1FpeFZRVUZUUXl4TFFVRlVMRVZCUVdkQ08wRkJRM1JETEZOQlFVOUJMRXRCUVVzc1EwRkJRME1zUzBGQlRpeERRVUZaTEhWQ1FVRmFMRU5CUVZBN1FVRkRSQ3hEUVVaRU96dEJRVWxQTEZOQlFWTkRMR0ZCUVZRc1EwRkJkVUpETEUxQlFYWkNMRVZCUVN0Q1F5eE5RVUV2UWl4RlFVRjFRME1zVVVGQmRrTXNSVUZCYVVRN1FVRkJSU3hUUVVGUFVpeFpRVUZaTEVOQlFVTlRMRWxCUVdJc1EwRkJhMEpJTEUxQlFXeENMRVZCUVRCQ1F5eE5RVUV4UWl4RlFVRnJRME1zVVVGQmJFTXNRMEZCVUR0QlFVRnhSQ0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0JFYVdabUlHWnliMjBnSnk0dlltRnpaU2M3WEc1Y2JseHVaWGh3YjNKMElHTnZibk4wSUhObGJuUmxibU5sUkdsbVppQTlJRzVsZHlCRWFXWm1LQ2s3WEc1elpXNTBaVzVqWlVScFptWXVkRzlyWlc1cGVtVWdQU0JtZFc1amRHbHZiaWgyWVd4MVpTa2dlMXh1SUNCeVpYUjFjbTRnZG1Gc2RXVXVjM0JzYVhRb0x5aGNYRk11S3o5YkxpRS9YU2tvUHoxY1hITXJmQ1FwTHlrN1hHNTlPMXh1WEc1bGVIQnZjblFnWm5WdVkzUnBiMjRnWkdsbVpsTmxiblJsYm1ObGN5aHZiR1JUZEhJc0lHNWxkMU4wY2l3Z1kyRnNiR0poWTJzcElIc2djbVYwZFhKdUlITmxiblJsYm1ObFJHbG1aaTVrYVdabUtHOXNaRk4wY2l3Z2JtVjNVM1J5TENCallXeHNZbUZqYXlrN0lIMWNiaUpkZlE9PVxuIiwiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpZmZXb3JkcyA9IGRpZmZXb3JkcztcbmV4cG9ydHMuZGlmZldvcmRzV2l0aFNwYWNlID0gZGlmZldvcmRzV2l0aFNwYWNlO1xuZXhwb3J0cy53b3JkRGlmZiA9IHZvaWQgMDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2VcIikpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9wYXJhbXMgPSByZXF1aXJlKFwiLi4vdXRpbC9wYXJhbXNcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4vLyBCYXNlZCBvbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9zY3JpcHRfaW5fVW5pY29kZVxuLy9cbi8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcbi8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcbi8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxuLy8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXG4vLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3RlxuLy8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcbi8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxuLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxuLy8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXG4vLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcbi8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcbi8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXG4vLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXG4vLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcbi8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XG4vLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG52YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG52YXIgd29yZERpZmYgPSBuZXdcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9iYXNlXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuW1xuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJkZWZhdWx0XCJcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5dKCk7XG5cbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbmV4cG9ydHMud29yZERpZmYgPSB3b3JkRGlmZjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcbiAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgIHJpZ2h0ID0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcbn07XG5cbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIEFsbCB3aGl0ZXNwYWNlIHN5bWJvbHMgZXhjZXB0IG5ld2xpbmUgZ3JvdXAgaW50byBvbmUgdG9rZW4sIGVhY2ggbmV3bGluZSAtIGluIHNlcGFyYXRlIHRva2VuXG4gIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFteXFxTXFxyXFxuXSt8WygpW1xcXXt9J1wiXFxyXFxuXXxcXGIpLyk7IC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcbiAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpXSkgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufTtcblxuZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPVxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICgwLFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgX3BhcmFtc1xuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgZ2VuZXJhdGVPcHRpb25zKVxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAob3B0aW9ucywge1xuICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV1ptTDNkdmNtUXVhbk1pWFN3aWJtRnRaWE1pT2xzaVpYaDBaVzVrWldSWGIzSmtRMmhoY25NaUxDSnlaVmRvYVhSbGMzQmhZMlVpTENKM2IzSmtSR2xtWmlJc0lrUnBabVlpTENKbGNYVmhiSE1pTENKc1pXWjBJaXdpY21sbmFIUWlMQ0p2Y0hScGIyNXpJaXdpYVdkdWIzSmxRMkZ6WlNJc0luUnZURzkzWlhKRFlYTmxJaXdpYVdkdWIzSmxWMmhwZEdWemNHRmpaU0lzSW5SbGMzUWlMQ0owYjJ0bGJtbDZaU0lzSW5aaGJIVmxJaXdpZEc5clpXNXpJaXdpYzNCc2FYUWlMQ0pwSWl3aWJHVnVaM1JvSWl3aWMzQnNhV05sSWl3aVpHbG1abGR2Y21Seklpd2liMnhrVTNSeUlpd2libVYzVTNSeUlpd2laMlZ1WlhKaGRHVlBjSFJwYjI1eklpd2laR2xtWmlJc0ltUnBabVpYYjNKa2MxZHBkR2hUY0dGalpTSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3p0QlFVTkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3T3pzN08wRkJSVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVzU1VGQlRVRXNhVUpCUVdsQ0xFZEJRVWNzSzBSQlFURkNPMEZCUlVFc1NVRkJUVU1zV1VGQldTeEhRVUZITEVsQlFYSkNPMEZCUlU4c1NVRkJUVU1zVVVGQlVTeEhRVUZITzBGQlFVbERPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQkxFTkJRVW9zUlVGQmFrSTdPenM3T3p0QlFVTlFSQ3hSUVVGUkxFTkJRVU5GTEUxQlFWUXNSMEZCYTBJc1ZVRkJVME1zU1VGQlZDeEZRVUZsUXl4TFFVRm1MRVZCUVhOQ08wRkJRM1JETEUxQlFVa3NTMEZCUzBNc1QwRkJUQ3hEUVVGaFF5eFZRVUZxUWl4RlFVRTJRanRCUVVNelFrZ3NTVUZCUVVFc1NVRkJTU3hIUVVGSFFTeEpRVUZKTEVOQlFVTkpMRmRCUVV3c1JVRkJVRHRCUVVOQlNDeEpRVUZCUVN4TFFVRkxMRWRCUVVkQkxFdEJRVXNzUTBGQlEwY3NWMEZCVGl4RlFVRlNPMEZCUTBRN08wRkJRMFFzVTBGQlQwb3NTVUZCU1N4TFFVRkxReXhMUVVGVUxFbEJRVzFDTEV0QlFVdERMRTlCUVV3c1EwRkJZVWNzWjBKQlFXSXNTVUZCYVVNc1EwRkJRMVFzV1VGQldTeERRVUZEVlN4SlFVRmlMRU5CUVd0Q1RpeEpRVUZzUWl4RFFVRnNReXhKUVVFMlJDeERRVUZEU2l4WlFVRlpMRU5CUVVOVkxFbEJRV0lzUTBGQmEwSk1MRXRCUVd4Q0xFTkJRWGhHTzBGQlEwUXNRMEZPUkRzN1FVRlBRVW9zVVVGQlVTeERRVUZEVlN4UlFVRlVMRWRCUVc5Q0xGVkJRVk5ETEV0QlFWUXNSVUZCWjBJN1FVRkRiRU03UVVGRFFTeE5RVUZKUXl4TlFVRk5MRWRCUVVkRUxFdEJRVXNzUTBGQlEwVXNTMEZCVGl4RFFVRlpMR2xEUVVGYUxFTkJRV0lzUTBGR2EwTXNRMEZKYkVNN08wRkJRMEVzVDBGQlN5eEpRVUZKUXl4RFFVRkRMRWRCUVVjc1EwRkJZaXhGUVVGblFrRXNRMEZCUXl4SFFVRkhSaXhOUVVGTkxFTkJRVU5ITEUxQlFWQXNSMEZCWjBJc1EwRkJjRU1zUlVGQmRVTkVMRU5CUVVNc1JVRkJlRU1zUlVGQk5FTTdRVUZETVVNN1FVRkRRU3hSUVVGSkxFTkJRVU5HTEUxQlFVMHNRMEZCUTBVc1EwRkJReXhIUVVGSExFTkJRVXdzUTBGQlVDeEpRVUZyUWtZc1RVRkJUU3hEUVVGRFJTeERRVUZETEVkQlFVY3NRMEZCVEN4RFFVRjRRaXhKUVVOTGFFSXNhVUpCUVdsQ0xFTkJRVU5YTEVsQlFXeENMRU5CUVhWQ1J5eE5RVUZOTEVOQlFVTkZMRU5CUVVRc1EwRkJOMElzUTBGRVRDeEpRVVZMYUVJc2FVSkJRV2xDTEVOQlFVTlhMRWxCUVd4Q0xFTkJRWFZDUnl4TlFVRk5MRU5CUVVORkxFTkJRVU1zUjBGQlJ5eERRVUZNTEVOQlFUZENMRU5CUmxRc1JVRkZaMFE3UVVGRE9VTkdMRTFCUVVGQkxFMUJRVTBzUTBGQlEwVXNRMEZCUkN4RFFVRk9MRWxCUVdGR0xFMUJRVTBzUTBGQlEwVXNRMEZCUXl4SFFVRkhMRU5CUVV3c1EwRkJia0k3UVVGRFFVWXNUVUZCUVVFc1RVRkJUU3hEUVVGRFNTeE5RVUZRTEVOQlFXTkdMRU5CUVVNc1IwRkJSeXhEUVVGc1FpeEZRVUZ4UWl4RFFVRnlRanRCUVVOQlFTeE5RVUZCUVN4RFFVRkRPMEZCUTBZN1FVRkRSanM3UVVGRlJDeFRRVUZQUml4TlFVRlFPMEZCUTBRc1EwRnFRa1E3TzBGQmJVSlBMRk5CUVZOTExGTkJRVlFzUTBGQmJVSkRMRTFCUVc1Q0xFVkJRVEpDUXl4TlFVRXpRaXhGUVVGdFEyUXNUMEZCYmtNc1JVRkJORU03UVVGRGFrUkJMRVZCUVVGQkxFOUJRVTg3UVVGQlJ6dEJRVUZCTzBGQlFVRTdPMEZCUVVGbE8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVFN1FVRkJRU3hIUVVGblFtWXNUMEZCYUVJc1JVRkJlVUk3UVVGQlEwY3NTVUZCUVVFc1owSkJRV2RDTEVWQlFVVTdRVUZCYmtJc1IwRkJla0lzUTBGQlZqdEJRVU5CTEZOQlFVOVNMRkZCUVZFc1EwRkJRM0ZDTEVsQlFWUXNRMEZCWTBnc1RVRkJaQ3hGUVVGelFrTXNUVUZCZEVJc1JVRkJPRUprTEU5QlFUbENMRU5CUVZBN1FVRkRSRHM3UVVGRlRTeFRRVUZUYVVJc2EwSkJRVlFzUTBGQk5FSktMRTFCUVRWQ0xFVkJRVzlEUXl4TlFVRndReXhGUVVFMFEyUXNUMEZCTlVNc1JVRkJjVVE3UVVGRE1VUXNVMEZCVDB3c1VVRkJVU3hEUVVGRGNVSXNTVUZCVkN4RFFVRmpTQ3hOUVVGa0xFVkJRWE5DUXl4TlFVRjBRaXhGUVVFNFFtUXNUMEZCT1VJc1EwRkJVRHRCUVVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElFUnBabVlnWm5KdmJTQW5MaTlpWVhObEp6dGNibWx0Y0c5eWRDQjdaMlZ1WlhKaGRHVlBjSFJwYjI1emZTQm1jbTl0SUNjdUxpOTFkR2xzTDNCaGNtRnRjeWM3WEc1Y2JpOHZJRUpoYzJWa0lHOXVJR2gwZEhCek9pOHZaVzR1ZDJscmFYQmxaR2xoTG05eVp5OTNhV3RwTDB4aGRHbHVYM05qY21sd2RGOXBibDlWYm1samIyUmxYRzR2TDF4dUx5OGdVbUZ1WjJWeklHRnVaQ0JsZUdObGNIUnBiMjV6T2x4dUx5OGdUR0YwYVc0dE1TQlRkWEJ3YkdWdFpXNTBMQ0F3TURndzRvQ1RNREJHUmx4dUx5OGdJQzBnVlNzd01FUTNJQ0REbHlCTmRXeDBhWEJzYVdOaGRHbHZiaUJ6YVdkdVhHNHZMeUFnTFNCVkt6QXdSamNnSU1PM0lFUnBkbWx6YVc5dUlITnBaMjVjYmk4dklFeGhkR2x1SUVWNGRHVnVaR1ZrTFVFc0lEQXhNRERpZ0pNd01UZEdYRzR2THlCTVlYUnBiaUJGZUhSbGJtUmxaQzFDTENBd01UZ3c0b0NUTURJMFJseHVMeThnU1ZCQklFVjRkR1Z1YzJsdmJuTXNJREF5TlREaWdKTXdNa0ZHWEc0dkx5QlRjR0ZqYVc1bklFMXZaR2xtYVdWeUlFeGxkSFJsY25Nc0lEQXlRakRpZ0pNd01rWkdYRzR2THlBZ0xTQlZLekF5UXpjZ0lNdUhJQ1lqTnpFeE95QWdRMkZ5YjI1Y2JpOHZJQ0F0SUZVck1ESkVPQ0FneTVnZ0ppTTNNamc3SUNCQ2NtVjJaVnh1THk4Z0lDMGdWU3N3TWtRNUlDRExtU0FtSXpjeU9Uc2dJRVJ2ZENCQlltOTJaVnh1THk4Z0lDMGdWU3N3TWtSQklDRExtaUFtSXpjek1Ec2dJRkpwYm1jZ1FXSnZkbVZjYmk4dklDQXRJRlVyTURKRVFpQWd5NXNnSmlNM016RTdJQ0JQWjI5dVpXdGNiaTh2SUNBdElGVXJNREpFUXlBZ3k1d2dKaU0zTXpJN0lDQlRiV0ZzYkNCVWFXeGtaVnh1THk4Z0lDMGdWU3N3TWtSRUlDRExuU0FtSXpjek16c2dJRVJ2ZFdKc1pTQkJZM1YwWlNCQlkyTmxiblJjYmk4dklFeGhkR2x1SUVWNGRHVnVaR1ZrSUVGa1pHbDBhVzl1WVd3c0lERkZNRERpZ0pNeFJVWkdYRzVqYjI1emRDQmxlSFJsYm1SbFpGZHZjbVJEYUdGeWN5QTlJQzllVzJFdGVrRXRXbHhjZFh0RE1IMHRYRngxZTBaR2ZWeGNkWHRFT0gwdFhGeDFlMFkyZlZ4Y2RYdEdPSDB0WEZ4MWV6SkRObjFjWEhWN01rTTRmUzFjWEhWN01rUTNmVnhjZFhzeVJFVjlMVnhjZFhzeVJrWjlYRngxZXpGRk1EQjlMVnhjZFhzeFJVWkdmVjBySkM5MU8xeHVYRzVqYjI1emRDQnlaVmRvYVhSbGMzQmhZMlVnUFNBdlhGeFRMenRjYmx4dVpYaHdiM0owSUdOdmJuTjBJSGR2Y21SRWFXWm1JRDBnYm1WM0lFUnBabVlvS1R0Y2JuZHZjbVJFYVdabUxtVnhkV0ZzY3lBOUlHWjFibU4wYVc5dUtHeGxablFzSUhKcFoyaDBLU0I3WEc0Z0lHbG1JQ2gwYUdsekxtOXdkR2x2Ym5NdWFXZHViM0psUTJGelpTa2dlMXh1SUNBZ0lHeGxablFnUFNCc1pXWjBMblJ2VEc5M1pYSkRZWE5sS0NrN1hHNGdJQ0FnY21sbmFIUWdQU0J5YVdkb2RDNTBiMHh2ZDJWeVEyRnpaU2dwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJzWldaMElEMDlQU0J5YVdkb2RDQjhmQ0FvZEdocGN5NXZjSFJwYjI1ekxtbG5ibTl5WlZkb2FYUmxjM0JoWTJVZ0ppWWdJWEpsVjJocGRHVnpjR0ZqWlM1MFpYTjBLR3hsWm5RcElDWW1JQ0Z5WlZkb2FYUmxjM0JoWTJVdWRHVnpkQ2h5YVdkb2RDa3BPMXh1ZlR0Y2JuZHZjbVJFYVdabUxuUnZhMlZ1YVhwbElEMGdablZ1WTNScGIyNG9kbUZzZFdVcElIdGNiaUFnTHk4Z1FXeHNJSGRvYVhSbGMzQmhZMlVnYzNsdFltOXNjeUJsZUdObGNIUWdibVYzYkdsdVpTQm5jbTkxY0NCcGJuUnZJRzl1WlNCMGIydGxiaXdnWldGamFDQnVaWGRzYVc1bElDMGdhVzRnYzJWd1lYSmhkR1VnZEc5clpXNWNiaUFnYkdWMElIUnZhMlZ1Y3lBOUlIWmhiSFZsTG5Od2JHbDBLQzhvVzE1Y1hGTmNYSEpjWEc1ZEszeGJLQ2xiWEZ4ZGUzMG5YQ0pjWEhKY1hHNWRmRnhjWWlrdktUdGNibHh1SUNBdkx5QktiMmx1SUhSb1pTQmliM1Z1WkdGeWVTQnpjR3hwZEhNZ2RHaGhkQ0IzWlNCa2J5QnViM1FnWTI5dWMybGtaWElnZEc4Z1ltVWdZbTkxYm1SaGNtbGxjeTRnVkdocGN5QnBjeUJ3Y21sdFlYSnBiSGtnZEdobElHVjRkR1Z1WkdWa0lFeGhkR2x1SUdOb1lYSmhZM1JsY2lCelpYUXVYRzRnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z2RHOXJaVzV6TG14bGJtZDBhQ0F0SURFN0lHa3JLeWtnZTF4dUlDQWdJQzh2SUVsbUlIZGxJR2hoZG1VZ1lXNGdaVzF3ZEhrZ2MzUnlhVzVuSUdsdUlIUm9aU0J1WlhoMElHWnBaV3hrSUdGdVpDQjNaU0JvWVhabElHOXViSGtnZDI5eVpDQmphR0Z5Y3lCaVpXWnZjbVVnWVc1a0lHRm1kR1Z5TENCdFpYSm5aVnh1SUNBZ0lHbG1JQ2doZEc5clpXNXpXMmtnS3lBeFhTQW1KaUIwYjJ0bGJuTmJhU0FySURKZFhHNGdJQ0FnSUNBZ0lDQWdKaVlnWlhoMFpXNWtaV1JYYjNKa1EyaGhjbk11ZEdWemRDaDBiMnRsYm5OYmFWMHBYRzRnSUNBZ0lDQWdJQ0FnSmlZZ1pYaDBaVzVrWldSWGIzSmtRMmhoY25NdWRHVnpkQ2gwYjJ0bGJuTmJhU0FySURKZEtTa2dlMXh1SUNBZ0lDQWdkRzlyWlc1elcybGRJQ3M5SUhSdmEyVnVjMXRwSUNzZ01sMDdYRzRnSUNBZ0lDQjBiMnRsYm5NdWMzQnNhV05sS0drZ0t5QXhMQ0F5S1R0Y2JpQWdJQ0FnSUdrdExUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2RHOXJaVzV6TzF4dWZUdGNibHh1Wlhod2IzSjBJR1oxYm1OMGFXOXVJR1JwWm1aWGIzSmtjeWh2YkdSVGRISXNJRzVsZDFOMGNpd2diM0IwYVc5dWN5a2dlMXh1SUNCdmNIUnBiMjV6SUQwZ1oyVnVaWEpoZEdWUGNIUnBiMjV6S0c5d2RHbHZibk1zSUh0cFoyNXZjbVZYYUdsMFpYTndZV05sT2lCMGNuVmxmU2s3WEc0Z0lISmxkSFZ5YmlCM2IzSmtSR2xtWmk1a2FXWm1LRzlzWkZOMGNpd2dibVYzVTNSeUxDQnZjSFJwYjI1ektUdGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdScFptWlhiM0prYzFkcGRHaFRjR0ZqWlNodmJHUlRkSElzSUc1bGQxTjBjaXdnYjNCMGFXOXVjeWtnZTF4dUlDQnlaWFIxY200Z2QyOXlaRVJwWm1ZdVpHbG1aaWh2YkdSVGRISXNJRzVsZDFOMGNpd2diM0IwYVc5dWN5azdYRzU5WEc0aVhYMD1cbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlmZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYmFzZVtcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZkNoYXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jaGFyYWN0ZXIuZGlmZkNoYXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZXb3Jkc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29yZC5kaWZmV29yZHM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZldvcmRzV2l0aFNwYWNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JkLmRpZmZXb3Jkc1dpdGhTcGFjZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmTGluZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xpbmUuZGlmZkxpbmVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZUcmltbWVkTGluZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xpbmUuZGlmZlRyaW1tZWRMaW5lcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWZmU2VudGVuY2VzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZW50ZW5jZS5kaWZmU2VudGVuY2VzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZDc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Nzcy5kaWZmQ3NzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpZmZKc29uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9qc29uLmRpZmZKc29uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhbm9uaWNhbGl6ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfanNvbi5jYW5vbmljYWxpemU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGlmZkFycmF5c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXkuZGlmZkFycmF5cztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcHBseVBhdGNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcHBseS5hcHBseVBhdGNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGx5UGF0Y2hlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBwbHkuYXBwbHlQYXRjaGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlUGF0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlLnBhcnNlUGF0Y2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWVyZ2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lcmdlLm1lcmdlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cnVjdHVyZWRQYXRjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlLnN0cnVjdHVyZWRQYXRjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVUd29GaWxlc1BhdGNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGUuY3JlYXRlVHdvRmlsZXNQYXRjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQYXRjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlLmNyZWF0ZVBhdGNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRDaGFuZ2VzVG9ETVBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2RtcC5jb252ZXJ0Q2hhbmdlc1RvRE1QO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRDaGFuZ2VzVG9YTUxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3htbC5jb252ZXJ0Q2hhbmdlc1RvWE1MO1xuICB9XG59KTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Jhc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RpZmYvYmFzZVwiKSlcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NoYXJhY3RlciA9IHJlcXVpcmUoXCIuL2RpZmYvY2hhcmFjdGVyXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl93b3JkID0gcmVxdWlyZShcIi4vZGlmZi93b3JkXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9saW5lID0gcmVxdWlyZShcIi4vZGlmZi9saW5lXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9zZW50ZW5jZSA9IHJlcXVpcmUoXCIuL2RpZmYvc2VudGVuY2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NzcyA9IHJlcXVpcmUoXCIuL2RpZmYvY3NzXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9qc29uID0gcmVxdWlyZShcIi4vZGlmZi9qc29uXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG52YXJcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbl9hcnJheSA9IHJlcXVpcmUoXCIuL2RpZmYvYXJyYXlcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2FwcGx5ID0gcmVxdWlyZShcIi4vcGF0Y2gvYXBwbHlcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3BhcnNlID0gcmVxdWlyZShcIi4vcGF0Y2gvcGFyc2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX21lcmdlID0gcmVxdWlyZShcIi4vcGF0Y2gvbWVyZ2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NyZWF0ZSA9IHJlcXVpcmUoXCIuL3BhdGNoL2NyZWF0ZVwiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fZG1wID0gcmVxdWlyZShcIi4vY29udmVydC9kbXBcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3htbCA9IHJlcXVpcmUoXCIuL2NvbnZlcnQveG1sXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUwzTnlZeTlwYm1SbGVDNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenRCUVdkQ1FUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdRVUZEUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJSVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN1FVRkRRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3p0QlFVVkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlJVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3UVVGRFFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenRCUVVOQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUTBFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUczdRVUZGUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk96dEJRVU5CTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaUJUWldVZ1RFbERSVTVUUlNCbWFXeGxJR1p2Y2lCMFpYSnRjeUJ2WmlCMWMyVWdLaTljYmx4dUx5cGNiaUFxSUZSbGVIUWdaR2xtWmlCcGJYQnNaVzFsYm5SaGRHbHZiaTVjYmlBcVhHNGdLaUJVYUdseklHeHBZbkpoY25rZ2MzVndjRzl5ZEhNZ2RHaGxJR1p2Ykd4dmQybHVaeUJCVUVsVE9seHVJQ29nU25ORWFXWm1MbVJwWm1aRGFHRnljem9nUTJoaGNtRmpkR1Z5SUdKNUlHTm9ZWEpoWTNSbGNpQmthV1ptWEc0Z0tpQktjMFJwWm1ZdVpHbG1abGR2Y21Sek9pQlhiM0prSUNoaGN5QmtaV1pwYm1Wa0lHSjVJRnhjWWlCeVpXZGxlQ2tnWkdsbVppQjNhR2xqYUNCcFoyNXZjbVZ6SUhkb2FYUmxjM0JoWTJWY2JpQXFJRXB6UkdsbVppNWthV1ptVEdsdVpYTTZJRXhwYm1VZ1ltRnpaV1FnWkdsbVpseHVJQ3BjYmlBcUlFcHpSR2xtWmk1a2FXWm1RM056T2lCRWFXWm1JSFJoY21kbGRHVmtJR0YwSUVOVFV5QmpiMjUwWlc1MFhHNGdLbHh1SUNvZ1ZHaGxjMlVnYldWMGFHOWtjeUJoY21VZ1ltRnpaV1FnYjI0Z2RHaGxJR2x0Y0d4bGJXVnVkR0YwYVc5dUlIQnliM0J2YzJWa0lHbHVYRzRnS2lCY0lrRnVJRThvVGtRcElFUnBabVpsY21WdVkyVWdRV3huYjNKcGRHaHRJR0Z1WkNCcGRITWdWbUZ5YVdGMGFXOXVjMXdpSUNoTmVXVnljeXdnTVRrNE5pa3VYRzRnS2lCb2RIUndPaTh2WTJsMFpYTmxaWEo0TG1semRDNXdjM1V1WldSMUwzWnBaWGRrYjJNdmMzVnRiV0Z5ZVQ5a2IyazlNVEF1TVM0eExqUXVOamt5TjF4dUlDb3ZYRzVwYlhCdmNuUWdSR2xtWmlCbWNtOXRJQ2N1TDJScFptWXZZbUZ6WlNjN1hHNXBiWEJ2Y25RZ2UyUnBabVpEYUdGeWMzMGdabkp2YlNBbkxpOWthV1ptTDJOb1lYSmhZM1JsY2ljN1hHNXBiWEJ2Y25RZ2UyUnBabVpYYjNKa2N5d2daR2xtWmxkdmNtUnpWMmwwYUZOd1lXTmxmU0JtY205dElDY3VMMlJwWm1ZdmQyOXlaQ2M3WEc1cGJYQnZjblFnZTJScFptWk1hVzVsY3l3Z1pHbG1abFJ5YVcxdFpXUk1hVzVsYzMwZ1puSnZiU0FuTGk5a2FXWm1MMnhwYm1Vbk8xeHVhVzF3YjNKMElIdGthV1ptVTJWdWRHVnVZMlZ6ZlNCbWNtOXRJQ2N1TDJScFptWXZjMlZ1ZEdWdVkyVW5PMXh1WEc1cGJYQnZjblFnZTJScFptWkRjM045SUdaeWIyMGdKeTR2WkdsbVppOWpjM01uTzF4dWFXMXdiM0owSUh0a2FXWm1Tbk52Yml3Z1kyRnViMjVwWTJGc2FYcGxmU0JtY205dElDY3VMMlJwWm1ZdmFuTnZiaWM3WEc1Y2JtbHRjRzl5ZENCN1pHbG1aa0Z5Y21GNWMzMGdabkp2YlNBbkxpOWthV1ptTDJGeWNtRjVKenRjYmx4dWFXMXdiM0owSUh0aGNIQnNlVkJoZEdOb0xDQmhjSEJzZVZCaGRHTm9aWE45SUdaeWIyMGdKeTR2Y0dGMFkyZ3ZZWEJ3Ykhrbk8xeHVhVzF3YjNKMElIdHdZWEp6WlZCaGRHTm9mU0JtY205dElDY3VMM0JoZEdOb0wzQmhjbk5sSnp0Y2JtbHRjRzl5ZENCN2JXVnlaMlY5SUdaeWIyMGdKeTR2Y0dGMFkyZ3ZiV1Z5WjJVbk8xeHVhVzF3YjNKMElIdHpkSEoxWTNSMWNtVmtVR0YwWTJnc0lHTnlaV0YwWlZSM2IwWnBiR1Z6VUdGMFkyZ3NJR055WldGMFpWQmhkR05vZlNCbWNtOXRJQ2N1TDNCaGRHTm9MMk55WldGMFpTYzdYRzVjYm1sdGNHOXlkQ0I3WTI5dWRtVnlkRU5vWVc1blpYTlViMFJOVUgwZ1puSnZiU0FuTGk5amIyNTJaWEowTDJSdGNDYzdYRzVwYlhCdmNuUWdlMk52Ym5abGNuUkRhR0Z1WjJWelZHOVlUVXg5SUdaeWIyMGdKeTR2WTI5dWRtVnlkQzk0Yld3bk8xeHVYRzVsZUhCdmNuUWdlMXh1SUNCRWFXWm1MRnh1WEc0Z0lHUnBabVpEYUdGeWN5eGNiaUFnWkdsbVpsZHZjbVJ6TEZ4dUlDQmthV1ptVjI5eVpITlhhWFJvVTNCaFkyVXNYRzRnSUdScFptWk1hVzVsY3l4Y2JpQWdaR2xtWmxSeWFXMXRaV1JNYVc1bGN5eGNiaUFnWkdsbVpsTmxiblJsYm1ObGN5eGNibHh1SUNCa2FXWm1RM056TEZ4dUlDQmthV1ptU25OdmJpeGNibHh1SUNCa2FXWm1RWEp5WVhsekxGeHVYRzRnSUhOMGNuVmpkSFZ5WldSUVlYUmphQ3hjYmlBZ1kzSmxZWFJsVkhkdlJtbHNaWE5RWVhSamFDeGNiaUFnWTNKbFlYUmxVR0YwWTJnc1hHNGdJR0Z3Y0d4NVVHRjBZMmdzWEc0Z0lHRndjR3g1VUdGMFkyaGxjeXhjYmlBZ2NHRnljMlZRWVhSamFDeGNiaUFnYldWeVoyVXNYRzRnSUdOdmJuWmxjblJEYUdGdVoyVnpWRzlFVFZBc1hHNGdJR052Ym5abGNuUkRhR0Z1WjJWelZHOVlUVXdzWEc0Z0lHTmhibTl1YVdOaGJHbDZaVnh1ZlR0Y2JpSmRmUT09XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XG5leHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX3BhcnNlID0gcmVxdWlyZShcIi4vcGFyc2VcIilcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG47XG5cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2Rpc3RhbmNlSXRlcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yXCIpKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmKSB7XG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgdmFyXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICB1bmlEaWZmID1cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgKDAsXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfcGFyc2VcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIC5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgcGFyc2VQYXRjaClcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICh1bmlEaWZmKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICB9XG5cbiAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcbiAgfSAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcblxuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudClcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBsaW5lID09PSBwYXRjaENvbnRlbnRcbiAgICApO1xuICB9LFxuICAgICAgZXJyb3JDb3VudCA9IDAsXG4gICAgICBmdXp6RmFjdG9yID0gb3B0aW9ucy5mdXp6RmFjdG9yIHx8IDAsXG4gICAgICBtaW5MaW5lID0gMCxcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICByZW1vdmVFT0ZOTCxcbiAgICAgIGFkZEVPRk5MO1xuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiBodW5rRml0cyhodW5rLCB0b1Bvcykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXG4gICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZTtcblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXG4gICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcbiAgICAgICAgICBlcnJvckNvdW50Kys7XG5cbiAgICAgICAgICBpZiAoZXJyb3JDb3VudCA+IGZ1enpGYWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b1BvcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcbiAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxuICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xuICAgIHZhciBpdGVyYXRvciA9XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICgwLFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2Rpc3RhbmNlSXRlcmF0b3JcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIFtcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgXCJkZWZhdWx0XCJcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIF0pKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcblxuICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcbiAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xuICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFNldCBsb3dlciB0ZXh0IGxpbWl0IHRvIGVuZCBvZiB0aGUgY3VycmVudCBodW5rLCBzbyBuZXh0IG9uZXMgZG9uJ3QgdHJ5XG4gICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcblxuXG4gICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XG4gIH0gLy8gQXBwbHkgcGF0Y2ggaHVua3NcblxuXG4gIHZhciBkaWZmT2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaHVua3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9odW5rID0gaHVua3NbX2ldLFxuICAgICAgICBfdG9Qb3MgPSBfaHVuay5vbGRTdGFydCArIF9odW5rLm9mZnNldCArIGRpZmZPZmZzZXQgLSAxO1xuXG4gICAgZGlmZk9mZnNldCArPSBfaHVuay5uZXdMaW5lcyAtIF9odW5rLm9sZExpbmVzO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxpbmUgPSBfaHVuay5saW5lc1tqXSxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxuICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUsXG4gICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICBfdG9Qb3MrKztcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xuICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDAsIGRlbGltaXRlcik7XG4gICAgICAgIF90b1BvcysrO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRpb24gPSBfaHVuay5saW5lc1tqIC0gMV0gPyBfaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xuXG4gICAgICAgIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICBhZGRFT0ZOTCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXG5cblxuICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICB3aGlsZSAoIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lcy5wb3AoKTtcbiAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgZGVsaW1pdGVycy5wdXNoKCdcXG4nKTtcbiAgfVxuXG4gIGZvciAodmFyIF9rID0gMDsgX2sgPCBsaW5lcy5sZW5ndGggLSAxOyBfaysrKSB7XG4gICAgbGluZXNbX2tdID0gbGluZXNbX2tdICsgZGVsaW1pdGVyc1tfa107XG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbignJyk7XG59IC8vIFdyYXBwZXIgdGhhdCBzdXBwb3J0cyBtdWx0aXBsZSBmaWxlIHBhdGNoZXMgdmlhIGNhbGxiYWNrcy5cblxuXG5mdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgdW5pRGlmZiA9XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICgwLFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX3BhcnNlXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIHBhcnNlUGF0Y2gpXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAodW5pRGlmZik7XG4gIH1cblxuICB2YXIgY3VycmVudEluZGV4ID0gMDtcblxuICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XG4gICAgdmFyIGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG5cbiAgICBpZiAoIWluZGV4KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc0luZGV4KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByb2Nlc3NJbmRleCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5d1lYUmphQzloY0hCc2VTNXFjeUpkTENKdVlXMWxjeUk2V3lKaGNIQnNlVkJoZEdOb0lpd2ljMjkxY21ObElpd2lkVzVwUkdsbVppSXNJbTl3ZEdsdmJuTWlMQ0p3WVhKelpWQmhkR05vSWl3aVFYSnlZWGtpTENKcGMwRnljbUY1SWl3aWJHVnVaM1JvSWl3aVJYSnliM0lpTENKc2FXNWxjeUlzSW5Od2JHbDBJaXdpWkdWc2FXMXBkR1Z5Y3lJc0ltMWhkR05vSWl3aWFIVnVhM01pTENKamIyMXdZWEpsVEdsdVpTSXNJbXhwYm1WT2RXMWlaWElpTENKc2FXNWxJaXdpYjNCbGNtRjBhVzl1SWl3aWNHRjBZMmhEYjI1MFpXNTBJaXdpWlhKeWIzSkRiM1Z1ZENJc0ltWjFlbnBHWVdOMGIzSWlMQ0p0YVc1TWFXNWxJaXdpYjJabWMyVjBJaXdpY21WdGIzWmxSVTlHVGt3aUxDSmhaR1JGVDBaT1RDSXNJbWgxYm10R2FYUnpJaXdpYUhWdWF5SXNJblJ2VUc5eklpd2lhaUlzSW1OdmJuUmxiblFpTENKemRXSnpkSElpTENKcElpd2liV0Y0VEdsdVpTSXNJbTlzWkV4cGJtVnpJaXdpYkc5allXeFBabVp6WlhRaUxDSnZiR1JUZEdGeWRDSXNJbWwwWlhKaGRHOXlJaXdpWkdsemRHRnVZMlZKZEdWeVlYUnZjaUlzSW5WdVpHVm1hVzVsWkNJc0ltUnBabVpQWm1aelpYUWlMQ0p1WlhkTWFXNWxjeUlzSW1SbGJHbHRhWFJsY2lJc0lteHBibVZrWld4cGJXbDBaWEp6SWl3aWMzQnNhV05sSWl3aWNISmxkbWx2ZFhOUGNHVnlZWFJwYjI0aUxDSndiM0FpTENKd2RYTm9JaXdpWDJzaUxDSnFiMmx1SWl3aVlYQndiSGxRWVhSamFHVnpJaXdpWTNWeWNtVnVkRWx1WkdWNElpd2ljSEp2WTJWemMwbHVaR1Y0SWl3aWFXNWtaWGdpTENKamIyMXdiR1YwWlNJc0lteHZZV1JHYVd4bElpd2laWEp5SWl3aVpHRjBZU0lzSW5Wd1pHRjBaV1JEYjI1MFpXNTBJaXdpY0dGMFkyaGxaQ0pkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN08wRkJRMEU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVRzN096czdRVUZGVHl4VFFVRlRRU3hWUVVGVUxFTkJRVzlDUXl4TlFVRndRaXhGUVVFMFFrTXNUMEZCTlVJc1JVRkJiVVE3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCWkVNc1JVRkJRVUVzVDBGQll5eDFSVUZCU2l4RlFVRkpPenRCUVVONFJDeE5RVUZKTEU5QlFVOUVMRTlCUVZBc1MwRkJiVUlzVVVGQmRrSXNSVUZCYVVNN1FVRkRMMEpCTEVsQlFVRkJMRTlCUVU4N1FVRkJSenRCUVVGQk8wRkJRVUU3TzBGQlFVRkZPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRTdRVUZCUVN4TFFVRlhSaXhQUVVGWUxFTkJRVlk3UVVGRFJEczdRVUZGUkN4TlFVRkpSeXhMUVVGTExFTkJRVU5ETEU5QlFVNHNRMEZCWTBvc1QwRkJaQ3hEUVVGS0xFVkJRVFJDTzBGQlF6RkNMRkZCUVVsQkxFOUJRVThzUTBGQlEwc3NUVUZCVWl4SFFVRnBRaXhEUVVGeVFpeEZRVUYzUWp0QlFVTjBRaXhaUVVGTkxFbEJRVWxETEV0QlFVb3NRMEZCVlN3MFEwRkJWaXhEUVVGT08wRkJRMFE3TzBGQlJVUk9MRWxCUVVGQkxFOUJRVThzUjBGQlIwRXNUMEZCVHl4RFFVRkRMRU5CUVVRc1EwRkJha0k3UVVGRFJDeEhRVmgxUkN4RFFXRjRSRHM3TzBGQlEwRXNUVUZCU1U4c1MwRkJTeXhIUVVGSFVpeE5RVUZOTEVOQlFVTlRMRXRCUVZBc1EwRkJZU3h4UWtGQllpeERRVUZhTzBGQlFVRXNUVUZEU1VNc1ZVRkJWU3hIUVVGSFZpeE5RVUZOTEVOQlFVTlhMRXRCUVZBc1EwRkJZU3h6UWtGQllpeExRVUYzUXl4RlFVUjZSRHRCUVVGQkxFMUJSVWxETEV0QlFVc3NSMEZCUjFnc1QwRkJUeXhEUVVGRFZ5eExRVVp3UWp0QlFVRkJMRTFCU1VsRExGZEJRVmNzUjBGQlIxZ3NUMEZCVHl4RFFVRkRWeXhYUVVGU0xFbEJRWGRDTEZWQlFVTkRMRlZCUVVRc1JVRkJZVU1zU1VGQllpeEZRVUZ0UWtNc1UwRkJia0lzUlVGQk9FSkRMRmxCUVRsQ08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCSzBOR0xFMUJRVUZCTEVsQlFVa3NTMEZCUzBVN1FVRkJlRVE3UVVGQlFTeEhRVW94UXp0QlFVRkJMRTFCUzBsRExGVkJRVlVzUjBGQlJ5eERRVXhxUWp0QlFVRkJMRTFCVFVsRExGVkJRVlVzUjBGQlIycENMRTlCUVU4c1EwRkJRMmxDTEZWQlFWSXNTVUZCYzBJc1EwRk9ka003UVVGQlFTeE5RVTlKUXl4UFFVRlBMRWRCUVVjc1EwRlFaRHRCUVVGQkxFMUJVVWxETEUxQlFVMHNSMEZCUnl4RFFWSmlPMEZCUVVFc1RVRlZTVU1zVjBGV1NqdEJRVUZCTEUxQlYwbERMRkZCV0VvN1FVRmhRVHM3T3pzN1FVRkhRU3hYUVVGVFF5eFJRVUZVTEVOQlFXdENReXhKUVVGc1FpeEZRVUYzUWtNc1MwRkJlRUlzUlVGQkswSTdRVUZETjBJc1UwRkJTeXhKUVVGSlF5eERRVUZETEVkQlFVY3NRMEZCWWl4RlFVRm5Ra0VzUTBGQlF5eEhRVUZIUml4SlFVRkpMRU5CUVVOcVFpeExRVUZNTEVOQlFWZEdMRTFCUVM5Q0xFVkJRWFZEY1VJc1EwRkJReXhGUVVGNFF5eEZRVUUwUXp0QlFVTXhReXhWUVVGSldpeEpRVUZKTEVkQlFVZFZMRWxCUVVrc1EwRkJRMnBDTEV0QlFVd3NRMEZCVjIxQ0xFTkJRVmdzUTBGQldEdEJRVUZCTEZWQlEwbFlMRk5CUVZNc1IwRkJTVVFzU1VGQlNTeERRVUZEVkN4TlFVRk1MRWRCUVdNc1EwRkJaQ3hIUVVGclFsTXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJkRUlzUjBGQk5FSXNSMEZFTjBNN1FVRkJRU3hWUVVWSllTeFBRVUZQTEVkQlFVbGlMRWxCUVVrc1EwRkJRMVFzVFVGQlRDeEhRVUZqTEVOQlFXUXNSMEZCYTBKVExFbEJRVWtzUTBGQlEyTXNUVUZCVEN4RFFVRlpMRU5CUVZvc1EwRkJiRUlzUjBGQmJVTmtMRWxCUm14RU96dEJRVWxCTEZWQlFVbERMRk5CUVZNc1MwRkJTeXhIUVVGa0xFbEJRWEZDUVN4VFFVRlRMRXRCUVVzc1IwRkJka01zUlVGQk5FTTdRVUZETVVNN1FVRkRRU3haUVVGSkxFTkJRVU5JTEZkQlFWY3NRMEZCUTJFc1MwRkJTeXhIUVVGSExFTkJRVlFzUlVGQldXeENMRXRCUVVzc1EwRkJRMnRDTEV0QlFVUXNRMEZCYWtJc1JVRkJNRUpXTEZOQlFURkNMRVZCUVhGRFdTeFBRVUZ5UXl4RFFVRm9RaXhGUVVFclJEdEJRVU0zUkZZc1ZVRkJRVUVzVlVGQlZUczdRVUZGVml4alFVRkpRU3hWUVVGVkxFZEJRVWRETEZWQlFXcENMRVZCUVRaQ08wRkJRek5DTEcxQ1FVRlBMRXRCUVZBN1FVRkRSRHRCUVVOR096dEJRVU5FVHl4UlFVRkJRU3hMUVVGTE8wRkJRMDQ3UVVGRFJqczdRVUZGUkN4WFFVRlBMRWxCUVZBN1FVRkRSQ3hIUVd4RWRVUXNRMEZ2UkhoRU96czdRVUZEUVN4UFFVRkxMRWxCUVVsSkxFTkJRVU1zUjBGQlJ5eERRVUZpTEVWQlFXZENRU3hEUVVGRExFZEJRVWRzUWl4TFFVRkxMRU5CUVVOT0xFMUJRVEZDTEVWQlFXdERkMElzUTBGQlF5eEZRVUZ1UXl4RlFVRjFRenRCUVVOeVF5eFJRVUZKVEN4SlFVRkpMRWRCUVVkaUxFdEJRVXNzUTBGQlEydENMRU5CUVVRc1EwRkJhRUk3UVVGQlFTeFJRVU5KUXl4UFFVRlBMRWRCUVVkMlFpeExRVUZMTEVOQlFVTkdMRTFCUVU0c1IwRkJaVzFDTEVsQlFVa3NRMEZCUTA4c1VVRkViRU03UVVGQlFTeFJRVVZKUXl4WFFVRlhMRWRCUVVjc1EwRkdiRUk3UVVGQlFTeFJRVWRKVUN4TFFVRkxMRWRCUVVkTUxFMUJRVTBzUjBGQlIwa3NTVUZCU1N4RFFVRkRVeXhSUVVGa0xFZEJRWGxDTEVOQlNISkRPMEZCUzBFc1VVRkJTVU1zVVVGQlVUdEJRVUZITzBGQlFVRTdRVUZCUVRzN1FVRkJRVU03UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRXNUMEZCYVVKV0xFdEJRV3BDTEVWQlFYZENUaXhQUVVGNFFpeEZRVUZwUTFjc1QwRkJha01zUTBGQlpqczdRVUZGUVN4WFFVRlBSU3hYUVVGWExFdEJRVXRKTEZOQlFYWkNMRVZCUVd0RFNpeFhRVUZYTEVkQlFVZEZMRkZCUVZFc1JVRkJlRVFzUlVGQk5FUTdRVUZETVVRc1ZVRkJTVmdzVVVGQlVTeERRVUZEUXl4SlFVRkVMRVZCUVU5RExFdEJRVXNzUjBGQlIwOHNWMEZCWml4RFFVRmFMRVZCUVhsRE8wRkJRM1pEVWl4UlFVRkJRU3hKUVVGSkxFTkJRVU5LTEUxQlFVd3NSMEZCWTBFc1RVRkJUU3hKUVVGSldTeFhRVUY0UWp0QlFVTkJPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFJRVUZKUVN4WFFVRlhMRXRCUVV0SkxGTkJRWEJDTEVWQlFTdENPMEZCUXpkQ0xHRkJRVThzUzBGQlVEdEJRVU5FTEV0QmFrSnZReXhEUVcxQ2NrTTdRVUZEUVRzN08wRkJRMEZxUWl4SlFVRkJRU3hQUVVGUExFZEJRVWRMTEVsQlFVa3NRMEZCUTBvc1RVRkJUQ3hIUVVGalNTeEpRVUZKTEVOQlFVTlRMRkZCUVc1Q0xFZEJRVGhDVkN4SlFVRkpMRU5CUVVOUExGRkJRVGRETzBGQlEwUXNSMEV6UlhWRUxFTkJOa1Y0UkRzN08wRkJRMEVzVFVGQlNVMHNWVUZCVlN4SFFVRkhMRU5CUVdwQ096dEJRVU5CTEU5QlFVc3NTVUZCU1ZJc1JVRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRVZCUVVNc1IwRkJSMnhDTEV0QlFVc3NRMEZCUTA0c1RVRkJNVUlzUlVGQmEwTjNRaXhGUVVGRExFVkJRVzVETEVWQlFYVkRPMEZCUTNKRExGRkJRVWxNTEV0QlFVa3NSMEZCUjJJc1MwRkJTeXhEUVVGRGEwSXNSVUZCUkN4RFFVRm9RanRCUVVGQkxGRkJRMGxLTEUxQlFVc3NSMEZCUjBRc1MwRkJTU3hEUVVGRFV5eFJRVUZNTEVkQlFXZENWQ3hMUVVGSkxFTkJRVU5LTEUxQlFYSkNMRWRCUVRoQ2FVSXNWVUZCT1VJc1IwRkJNa01zUTBGRWRrUTdPMEZCUlVGQkxFbEJRVUZCTEZWQlFWVXNTVUZCU1dJc1MwRkJTU3hEUVVGRFl5eFJRVUZNTEVkQlFXZENaQ3hMUVVGSkxFTkJRVU5QTEZGQlFXNURPenRCUVVWQkxGTkJRVXNzU1VGQlNVd3NRMEZCUXl4SFFVRkhMRU5CUVdJc1JVRkJaMEpCTEVOQlFVTXNSMEZCUjBZc1MwRkJTU3hEUVVGRGFrSXNTMEZCVEN4RFFVRlhSaXhOUVVFdlFpeEZRVUYxUTNGQ0xFTkJRVU1zUlVGQmVFTXNSVUZCTkVNN1FVRkRNVU1zVlVGQlNWb3NTVUZCU1N4SFFVRkhWU3hMUVVGSkxFTkJRVU5xUWl4TFFVRk1MRU5CUVZkdFFpeERRVUZZTEVOQlFWZzdRVUZCUVN4VlFVTkpXQ3hUUVVGVExFZEJRVWxFTEVsQlFVa3NRMEZCUTFRc1RVRkJUQ3hIUVVGakxFTkJRV1FzUjBGQmEwSlRMRWxCUVVrc1EwRkJReXhEUVVGRUxFTkJRWFJDTEVkQlFUUkNMRWRCUkRkRE8wRkJRVUVzVlVGRlNXRXNUMEZCVHl4SFFVRkpZaXhKUVVGSkxFTkJRVU5VTEUxQlFVd3NSMEZCWXl4RFFVRmtMRWRCUVd0Q1V5eEpRVUZKTEVOQlFVTmpMRTFCUVV3c1EwRkJXU3hEUVVGYUxFTkJRV3hDTEVkQlFXMURaQ3hKUVVac1JEdEJRVUZCTEZWQlIwbDVRaXhUUVVGVExFZEJRVWRtTEV0QlFVa3NRMEZCUTJkQ0xHTkJRVXdzUTBGQmIwSmtMRU5CUVhCQ0xFTkJTR2hDT3p0QlFVdEJMRlZCUVVsWUxGTkJRVk1zUzBGQlN5eEhRVUZzUWl4RlFVRjFRanRCUVVOeVFsVXNVVUZCUVVFc1RVRkJTenRCUVVOT0xFOUJSa1FzVFVGRlR5eEpRVUZKVml4VFFVRlRMRXRCUVVzc1IwRkJiRUlzUlVGQmRVSTdRVUZETlVKU0xGRkJRVUZCTEV0QlFVc3NRMEZCUTJ0RExFMUJRVTRzUTBGQllXaENMRTFCUVdJc1JVRkJiMElzUTBGQmNFSTdRVUZEUVdoQ0xGRkJRVUZCTEZWQlFWVXNRMEZCUTJkRExFMUJRVmdzUTBGQmEwSm9RaXhOUVVGc1FpeEZRVUY1UWl4RFFVRjZRanRCUVVOR08wRkJRME1zVDBGS1RTeE5RVWxCTEVsQlFVbFdMRk5CUVZNc1MwRkJTeXhIUVVGc1FpeEZRVUYxUWp0QlFVTTFRbElzVVVGQlFVRXNTMEZCU3l4RFFVRkRhME1zVFVGQlRpeERRVUZoYUVJc1RVRkJZaXhGUVVGdlFpeERRVUZ3UWl4RlFVRjFRa1VzVDBGQmRrSTdRVUZEUVd4Q0xGRkJRVUZCTEZWQlFWVXNRMEZCUTJkRExFMUJRVmdzUTBGQmEwSm9RaXhOUVVGc1FpeEZRVUY1UWl4RFFVRjZRaXhGUVVFMFFtTXNVMEZCTlVJN1FVRkRRV1FzVVVGQlFVRXNUVUZCU3p0QlFVTk9MRTlCU2swc1RVRkpRU3hKUVVGSlZpeFRRVUZUTEV0QlFVc3NTVUZCYkVJc1JVRkJkMEk3UVVGRE4wSXNXVUZCU1RKQ0xHbENRVUZwUWl4SFFVRkhiRUlzUzBGQlNTeERRVUZEYWtJc1MwRkJUQ3hEUVVGWGJVSXNRMEZCUXl4SFFVRkhMRU5CUVdZc1NVRkJiMEpHTEV0QlFVa3NRMEZCUTJwQ0xFdEJRVXdzUTBGQlYyMUNMRU5CUVVNc1IwRkJSeXhEUVVGbUxFVkJRV3RDTEVOQlFXeENMRU5CUVhCQ0xFZEJRVEpETEVsQlFXNUZPenRCUVVOQkxGbEJRVWxuUWl4cFFrRkJhVUlzUzBGQlN5eEhRVUV4UWl4RlFVRXJRanRCUVVNM1FuSkNMRlZCUVVGQkxGZEJRVmNzUjBGQlJ5eEpRVUZrTzBGQlEwUXNVMEZHUkN4TlFVVlBMRWxCUVVseFFpeHBRa0ZCYVVJc1MwRkJTeXhIUVVFeFFpeEZRVUVyUWp0QlFVTndRM0JDTEZWQlFVRkJMRkZCUVZFc1IwRkJSeXhKUVVGWU8wRkJRMFE3UVVGRFJqdEJRVU5HTzBGQlEwWXNSMEUzUjNWRUxFTkJLMGQ0UkRzN08wRkJRMEVzVFVGQlNVUXNWMEZCU2l4RlFVRnBRanRCUVVObUxGZEJRVThzUTBGQlEyUXNTMEZCU3l4RFFVRkRRU3hMUVVGTExFTkJRVU5HTEUxQlFVNHNSMEZCWlN4RFFVRm9RaXhEUVVGaUxFVkJRV2xETzBGQlF5OUNSU3hOUVVGQlFTeExRVUZMTEVOQlFVTnZReXhIUVVGT08wRkJRMEZzUXl4TlFVRkJRU3hWUVVGVkxFTkJRVU5yUXl4SFFVRllPMEZCUTBRN1FVRkRSaXhIUVV4RUxFMUJTMDhzU1VGQlNYSkNMRkZCUVVvc1JVRkJZenRCUVVOdVFtWXNTVUZCUVVFc1MwRkJTeXhEUVVGRGNVTXNTVUZCVGl4RFFVRlhMRVZCUVZnN1FVRkRRVzVETEVsQlFVRkJMRlZCUVZVc1EwRkJRMjFETEVsQlFWZ3NRMEZCWjBJc1NVRkJhRUk3UVVGRFJEczdRVUZEUkN4UFFVRkxMRWxCUVVsRExFVkJRVVVzUjBGQlJ5eERRVUZrTEVWQlFXbENRU3hGUVVGRkxFZEJRVWQwUXl4TFFVRkxMRU5CUVVOR0xFMUJRVTRzUjBGQlpTeERRVUZ5UXl4RlFVRjNRM2RETEVWQlFVVXNSVUZCTVVNc1JVRkJPRU03UVVGRE5VTjBReXhKUVVGQlFTeExRVUZMTEVOQlFVTnpReXhGUVVGRUxFTkJRVXdzUjBGQldYUkRMRXRCUVVzc1EwRkJRM05ETEVWQlFVUXNRMEZCVEN4SFFVRlpjRU1zVlVGQlZTeERRVUZEYjBNc1JVRkJSQ3hEUVVGc1F6dEJRVU5FT3p0QlFVTkVMRk5CUVU5MFF5eExRVUZMTEVOQlFVTjFReXhKUVVGT0xFTkJRVmNzUlVGQldDeERRVUZRTzBGQlEwUXNReXhEUVVWRU96czdRVUZEVHl4VFFVRlRReXhaUVVGVUxFTkJRWE5DTDBNc1QwRkJkRUlzUlVGQkswSkRMRTlCUVM5Q0xFVkJRWGRETzBGQlF6ZERMRTFCUVVrc1QwRkJUMFFzVDBGQlVDeExRVUZ0UWl4UlFVRjJRaXhGUVVGcFF6dEJRVU12UWtFc1NVRkJRVUVzVDBGQlR6dEJRVUZITzBGQlFVRTdRVUZCUVRzN1FVRkJRVVU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVUU3UVVGQlFVRTdRVUZCUVVFN1FVRkJRVHRCUVVGQkxFdEJRVmRHTEU5QlFWZ3NRMEZCVmp0QlFVTkVPenRCUVVWRUxFMUJRVWxuUkN4WlFVRlpMRWRCUVVjc1EwRkJia0k3TzBGQlEwRXNWMEZCVTBNc1dVRkJWQ3hIUVVGM1FqdEJRVU4wUWl4UlFVRkpReXhMUVVGTExFZEJRVWRzUkN4UFFVRlBMRU5CUVVOblJDeFpRVUZaTEVWQlFXSXNRMEZCYmtJN08wRkJRMEVzVVVGQlNTeERRVUZEUlN4TFFVRk1MRVZCUVZrN1FVRkRWaXhoUVVGUGFrUXNUMEZCVHl4RFFVRkRhMFFzVVVGQlVpeEZRVUZRTzBGQlEwUTdPMEZCUlVSc1JDeEpRVUZCUVN4UFFVRlBMRU5CUVVOdFJDeFJRVUZTTEVOQlFXbENSaXhMUVVGcVFpeEZRVUYzUWl4VlFVRlRSeXhIUVVGVUxFVkJRV05ETEVsQlFXUXNSVUZCYjBJN1FVRkRNVU1zVlVGQlNVUXNSMEZCU2l4RlFVRlRPMEZCUTFBc1pVRkJUM0JFTEU5QlFVOHNRMEZCUTJ0RUxGRkJRVklzUTBGQmFVSkZMRWRCUVdwQ0xFTkJRVkE3UVVGRFJEczdRVUZGUkN4VlFVRkpSU3hqUVVGakxFZEJRVWQ2UkN4VlFVRlZMRU5CUVVOM1JDeEpRVUZFTEVWQlFVOUtMRXRCUVZBc1JVRkJZMnBFTEU5QlFXUXNRMEZCTDBJN1FVRkRRVUVzVFVGQlFVRXNUMEZCVHl4RFFVRkRkVVFzVDBGQlVpeERRVUZuUWs0c1MwRkJhRUlzUlVGQmRVSkxMR05CUVhaQ0xFVkJRWFZETEZWQlFWTkdMRWRCUVZRc1JVRkJZenRCUVVOdVJDeFpRVUZKUVN4SFFVRktMRVZCUVZNN1FVRkRVQ3hwUWtGQlQzQkVMRTlCUVU4c1EwRkJRMnRFTEZGQlFWSXNRMEZCYVVKRkxFZEJRV3BDTEVOQlFWQTdRVUZEUkRzN1FVRkZSRW9zVVVGQlFVRXNXVUZCV1R0QlFVTmlMRTlCVGtRN1FVRlBSQ3hMUVdKRU8wRkJZMFE3TzBGQlEwUkJMRVZCUVVGQkxGbEJRVms3UVVGRFlpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdjR0Z5YzJWUVlYUmphSDBnWm5KdmJTQW5MaTl3WVhKelpTYzdYRzVwYlhCdmNuUWdaR2x6ZEdGdVkyVkpkR1Z5WVhSdmNpQm1jbTl0SUNjdUxpOTFkR2xzTDJScGMzUmhibU5sTFdsMFpYSmhkRzl5Snp0Y2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHRndjR3g1VUdGMFkyZ29jMjkxY21ObExDQjFibWxFYVdabUxDQnZjSFJwYjI1eklEMGdlMzBwSUh0Y2JpQWdhV1lnS0hSNWNHVnZaaUIxYm1sRWFXWm1JRDA5UFNBbmMzUnlhVzVuSnlrZ2UxeHVJQ0FnSUhWdWFVUnBabVlnUFNCd1lYSnpaVkJoZEdOb0tIVnVhVVJwWm1ZcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0VGeWNtRjVMbWx6UVhKeVlYa29kVzVwUkdsbVppa3BJSHRjYmlBZ0lDQnBaaUFvZFc1cFJHbG1aaTVzWlc1bmRHZ2dQaUF4S1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjJGd2NHeDVVR0YwWTJnZ2IyNXNlU0IzYjNKcmN5QjNhWFJvSUdFZ2MybHVaMnhsSUdsdWNIVjBMaWNwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSFZ1YVVScFptWWdQU0IxYm1sRWFXWm1XekJkTzF4dUlDQjlYRzVjYmlBZ0x5OGdRWEJ3YkhrZ2RHaGxJR1JwWm1ZZ2RHOGdkR2hsSUdsdWNIVjBYRzRnSUd4bGRDQnNhVzVsY3lBOUlITnZkWEpqWlM1emNHeHBkQ2d2WEZ4eVhGeHVmRnRjWEc1Y1hIWmNYR1pjWEhKY1hIZzROVjB2S1N4Y2JpQWdJQ0FnSUdSbGJHbHRhWFJsY25NZ1BTQnpiM1Z5WTJVdWJXRjBZMmdvTDF4Y2NseGNibnhiWEZ4dVhGeDJYRnhtWEZ4eVhGeDRPRFZkTDJjcElIeDhJRnRkTEZ4dUlDQWdJQ0FnYUhWdWEzTWdQU0IxYm1sRWFXWm1MbWgxYm10ekxGeHVYRzRnSUNBZ0lDQmpiMjF3WVhKbFRHbHVaU0E5SUc5d2RHbHZibk11WTI5dGNHRnlaVXhwYm1VZ2ZId2dLQ2hzYVc1bFRuVnRZbVZ5TENCc2FXNWxMQ0J2Y0dWeVlYUnBiMjRzSUhCaGRHTm9RMjl1ZEdWdWRDa2dQVDRnYkdsdVpTQTlQVDBnY0dGMFkyaERiMjUwWlc1MEtTeGNiaUFnSUNBZ0lHVnljbTl5UTI5MWJuUWdQU0F3TEZ4dUlDQWdJQ0FnWm5WNmVrWmhZM1J2Y2lBOUlHOXdkR2x2Ym5NdVpuVjZla1poWTNSdmNpQjhmQ0F3TEZ4dUlDQWdJQ0FnYldsdVRHbHVaU0E5SURBc1hHNGdJQ0FnSUNCdlptWnpaWFFnUFNBd0xGeHVYRzRnSUNBZ0lDQnlaVzF2ZG1WRlQwWk9UQ3hjYmlBZ0lDQWdJR0ZrWkVWUFJrNU1PMXh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkRhR1ZqYTNNZ2FXWWdkR2hsSUdoMWJtc2daWGhoWTNSc2VTQm1hWFJ6SUc5dUlIUm9aU0J3Y205MmFXUmxaQ0JzYjJOaGRHbHZibHh1SUNBZ0tpOWNiaUFnWm5WdVkzUnBiMjRnYUhWdWEwWnBkSE1vYUhWdWF5d2dkRzlRYjNNcElIdGNiaUFnSUNCbWIzSWdLR3hsZENCcUlEMGdNRHNnYWlBOElHaDFibXN1YkdsdVpYTXViR1Z1WjNSb095QnFLeXNwSUh0Y2JpQWdJQ0FnSUd4bGRDQnNhVzVsSUQwZ2FIVnVheTVzYVc1bGMxdHFYU3hjYmlBZ0lDQWdJQ0FnSUNCdmNHVnlZWFJwYjI0Z1BTQW9iR2x1WlM1c1pXNW5kR2dnUGlBd0lEOGdiR2x1WlZzd1hTQTZJQ2NnSnlrc1hHNGdJQ0FnSUNBZ0lDQWdZMjl1ZEdWdWRDQTlJQ2hzYVc1bExteGxibWQwYUNBK0lEQWdQeUJzYVc1bExuTjFZbk4wY2lneEtTQTZJR3hwYm1VcE8xeHVYRzRnSUNBZ0lDQnBaaUFvYjNCbGNtRjBhVzl1SUQwOVBTQW5JQ2NnZkh3Z2IzQmxjbUYwYVc5dUlEMDlQU0FuTFNjcElIdGNiaUFnSUNBZ0lDQWdMeThnUTI5dWRHVjRkQ0J6WVc1cGRIa2dZMmhsWTJ0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZqYjIxd1lYSmxUR2x1WlNoMGIxQnZjeUFySURFc0lHeHBibVZ6VzNSdlVHOXpYU3dnYjNCbGNtRjBhVzl1TENCamIyNTBaVzUwS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJR1Z5Y205eVEyOTFiblFyS3p0Y2JseHVJQ0FnSUNBZ0lDQWdJR2xtSUNobGNuSnZja052ZFc1MElENGdablY2ZWtaaFkzUnZjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0IwYjFCdmN5c3JPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCMGNuVmxPMXh1SUNCOVhHNWNiaUFnTHk4Z1UyVmhjbU5vSUdKbGMzUWdabWwwSUc5bVpuTmxkSE1nWm05eUlHVmhZMmdnYUhWdWF5QmlZWE5sWkNCdmJpQjBhR1VnY0hKbGRtbHZkWE1nYjI1bGMxeHVJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUdoMWJtdHpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnYkdWMElHaDFibXNnUFNCb2RXNXJjMXRwWFN4Y2JpQWdJQ0FnSUNBZ2JXRjRUR2x1WlNBOUlHeHBibVZ6TG14bGJtZDBhQ0F0SUdoMWJtc3ViMnhrVEdsdVpYTXNYRzRnSUNBZ0lDQWdJR3h2WTJGc1QyWm1jMlYwSUQwZ01DeGNiaUFnSUNBZ0lDQWdkRzlRYjNNZ1BTQnZabVp6WlhRZ0t5Qm9kVzVyTG05c1pGTjBZWEowSUMwZ01UdGNibHh1SUNBZ0lHeGxkQ0JwZEdWeVlYUnZjaUE5SUdScGMzUmhibU5sU1hSbGNtRjBiM0lvZEc5UWIzTXNJRzFwYmt4cGJtVXNJRzFoZUV4cGJtVXBPMXh1WEc0Z0lDQWdabTl5SUNnN0lHeHZZMkZzVDJabWMyVjBJQ0U5UFNCMWJtUmxabWx1WldRN0lHeHZZMkZzVDJabWMyVjBJRDBnYVhSbGNtRjBiM0lvS1NrZ2UxeHVJQ0FnSUNBZ2FXWWdLR2gxYm10R2FYUnpLR2gxYm1zc0lIUnZVRzl6SUNzZ2JHOWpZV3hQWm1aelpYUXBLU0I3WEc0Z0lDQWdJQ0FnSUdoMWJtc3ViMlptYzJWMElEMGdiMlptYzJWMElDczlJR3h2WTJGc1QyWm1jMlYwTzF4dUlDQWdJQ0FnSUNCaWNtVmhhenRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvYkc5allXeFBabVp6WlhRZ1BUMDlJSFZ1WkdWbWFXNWxaQ2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklGTmxkQ0JzYjNkbGNpQjBaWGgwSUd4cGJXbDBJSFJ2SUdWdVpDQnZaaUIwYUdVZ1kzVnljbVZ1ZENCb2RXNXJMQ0J6YnlCdVpYaDBJRzl1WlhNZ1pHOXVKM1FnZEhKNVhHNGdJQ0FnTHk4Z2RHOGdabWwwSUc5MlpYSWdZV3h5WldGa2VTQndZWFJqYUdWa0lIUmxlSFJjYmlBZ0lDQnRhVzVNYVc1bElEMGdhSFZ1YXk1dlptWnpaWFFnS3lCb2RXNXJMbTlzWkZOMFlYSjBJQ3NnYUhWdWF5NXZiR1JNYVc1bGN6dGNiaUFnZlZ4dVhHNGdJQzh2SUVGd2NHeDVJSEJoZEdOb0lHaDFibXR6WEc0Z0lHeGxkQ0JrYVdabVQyWm1jMlYwSUQwZ01EdGNiaUFnWm05eUlDaHNaWFFnYVNBOUlEQTdJR2tnUENCb2RXNXJjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUd4bGRDQm9kVzVySUQwZ2FIVnVhM05iYVYwc1hHNGdJQ0FnSUNBZ0lIUnZVRzl6SUQwZ2FIVnVheTV2YkdSVGRHRnlkQ0FySUdoMWJtc3ViMlptYzJWMElDc2daR2xtWms5bVpuTmxkQ0F0SURFN1hHNGdJQ0FnWkdsbVprOW1abk5sZENBclBTQm9kVzVyTG01bGQweHBibVZ6SUMwZ2FIVnVheTV2YkdSTWFXNWxjenRjYmx4dUlDQWdJR1p2Y2lBb2JHVjBJR29nUFNBd095QnFJRHdnYUhWdWF5NXNhVzVsY3k1c1pXNW5kR2c3SUdvckt5a2dlMXh1SUNBZ0lDQWdiR1YwSUd4cGJtVWdQU0JvZFc1ckxteHBibVZ6VzJwZExGeHVJQ0FnSUNBZ0lDQWdJRzl3WlhKaGRHbHZiaUE5SUNoc2FXNWxMbXhsYm1kMGFDQStJREFnUHlCc2FXNWxXekJkSURvZ0p5QW5LU3hjYmlBZ0lDQWdJQ0FnSUNCamIyNTBaVzUwSUQwZ0tHeHBibVV1YkdWdVozUm9JRDRnTUNBL0lHeHBibVV1YzNWaWMzUnlLREVwSURvZ2JHbHVaU2tzWEc0Z0lDQWdJQ0FnSUNBZ1pHVnNhVzFwZEdWeUlEMGdhSFZ1YXk1c2FXNWxaR1ZzYVcxcGRHVnljMXRxWFR0Y2JseHVJQ0FnSUNBZ2FXWWdLRzl3WlhKaGRHbHZiaUE5UFQwZ0p5QW5LU0I3WEc0Z0lDQWdJQ0FnSUhSdlVHOXpLeXM3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeTBuS1NCN1hHNGdJQ0FnSUNBZ0lHeHBibVZ6TG5Od2JHbGpaU2gwYjFCdmN5d2dNU2s3WEc0Z0lDQWdJQ0FnSUdSbGJHbHRhWFJsY25NdWMzQnNhV05sS0hSdlVHOXpMQ0F4S1R0Y2JpQWdJQ0FnSUM4cUlHbHpkR0Z1WW5Wc0lHbG5ibTl5WlNCbGJITmxJQ292WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeXNuS1NCN1hHNGdJQ0FnSUNBZ0lHeHBibVZ6TG5Od2JHbGpaU2gwYjFCdmN5d2dNQ3dnWTI5dWRHVnVkQ2s3WEc0Z0lDQWdJQ0FnSUdSbGJHbHRhWFJsY25NdWMzQnNhV05sS0hSdlVHOXpMQ0F3TENCa1pXeHBiV2wwWlhJcE8xeHVJQ0FnSUNBZ0lDQjBiMUJ2Y3lzck8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHZjR1Z5WVhScGIyNGdQVDA5SUNkY1hGeGNKeWtnZTF4dUlDQWdJQ0FnSUNCc1pYUWdjSEpsZG1sdmRYTlBjR1Z5WVhScGIyNGdQU0JvZFc1ckxteHBibVZ6VzJvZ0xTQXhYU0EvSUdoMWJtc3ViR2x1WlhOYmFpQXRJREZkV3pCZElEb2diblZzYkR0Y2JpQWdJQ0FnSUNBZ2FXWWdLSEJ5WlhacGIzVnpUM0JsY21GMGFXOXVJRDA5UFNBbkt5Y3BJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZGVDBaT1RDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9jSEpsZG1sdmRYTlBjR1Z5WVhScGIyNGdQVDA5SUNjdEp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdGa1pFVlBSazVNSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUM4dklFaGhibVJzWlNCRlQwWk9UQ0JwYm5ObGNuUnBiMjR2Y21WdGIzWmhiRnh1SUNCcFppQW9jbVZ0YjNabFJVOUdUa3dwSUh0Y2JpQWdJQ0IzYUdsc1pTQW9JV3hwYm1WelcyeHBibVZ6TG14bGJtZDBhQ0F0SURGZEtTQjdYRzRnSUNBZ0lDQnNhVzVsY3k1d2IzQW9LVHRjYmlBZ0lDQWdJR1JsYkdsdGFYUmxjbk11Y0c5d0tDazdYRzRnSUNBZ2ZWeHVJQ0I5SUdWc2MyVWdhV1lnS0dGa1pFVlBSazVNS1NCN1hHNGdJQ0FnYkdsdVpYTXVjSFZ6YUNnbkp5azdYRzRnSUNBZ1pHVnNhVzFwZEdWeWN5NXdkWE5vS0NkY1hHNG5LVHRjYmlBZ2ZWeHVJQ0JtYjNJZ0tHeGxkQ0JmYXlBOUlEQTdJRjlySUR3Z2JHbHVaWE11YkdWdVozUm9JQzBnTVRzZ1gyc3JLeWtnZTF4dUlDQWdJR3hwYm1WelcxOXJYU0E5SUd4cGJtVnpXMTlyWFNBcklHUmxiR2x0YVhSbGNuTmJYMnRkTzF4dUlDQjlYRzRnSUhKbGRIVnliaUJzYVc1bGN5NXFiMmx1S0NjbktUdGNibjFjYmx4dUx5OGdWM0poY0hCbGNpQjBhR0YwSUhOMWNIQnZjblJ6SUcxMWJIUnBjR3hsSUdacGJHVWdjR0YwWTJobGN5QjJhV0VnWTJGc2JHSmhZMnR6TGx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdGd2NHeDVVR0YwWTJobGN5aDFibWxFYVdabUxDQnZjSFJwYjI1ektTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2RXNXBSR2xtWmlBOVBUMGdKM04wY21sdVp5Y3BJSHRjYmlBZ0lDQjFibWxFYVdabUlEMGdjR0Z5YzJWUVlYUmphQ2gxYm1sRWFXWm1LVHRjYmlBZ2ZWeHVYRzRnSUd4bGRDQmpkWEp5Wlc1MFNXNWtaWGdnUFNBd08xeHVJQ0JtZFc1amRHbHZiaUJ3Y205alpYTnpTVzVrWlhnb0tTQjdYRzRnSUNBZ2JHVjBJR2x1WkdWNElEMGdkVzVwUkdsbVpsdGpkWEp5Wlc1MFNXNWtaWGdySzEwN1hHNGdJQ0FnYVdZZ0tDRnBibVJsZUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUc5d2RHbHZibk11WTI5dGNHeGxkR1VvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J2Y0hScGIyNXpMbXh2WVdSR2FXeGxLR2x1WkdWNExDQm1kVzVqZEdsdmJpaGxjbklzSUdSaGRHRXBJSHRjYmlBZ0lDQWdJR2xtSUNobGNuSXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJRzl3ZEdsdmJuTXVZMjl0Y0d4bGRHVW9aWEp5S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2JHVjBJSFZ3WkdGMFpXUkRiMjUwWlc1MElEMGdZWEJ3YkhsUVlYUmphQ2hrWVhSaExDQnBibVJsZUN3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCdmNIUnBiMjV6TG5CaGRHTm9aV1FvYVc1a1pYZ3NJSFZ3WkdGMFpXUkRiMjUwWlc1MExDQm1kVzVqZEdsdmJpaGxjbklwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z5Y2lrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQnZjSFJwYjI1ekxtTnZiWEJzWlhSbEtHVnljaWs3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQndjbTlqWlhOelNXNWtaWGdvS1R0Y2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc0Z0lIQnliMk5sYzNOSmJtUmxlQ2dwTzF4dWZWeHVJbDE5XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RydWN0dXJlZFBhdGNoID0gc3RydWN0dXJlZFBhdGNoO1xuZXhwb3J0cy5mb3JtYXRQYXRjaCA9IGZvcm1hdFBhdGNoO1xuZXhwb3J0cy5jcmVhdGVUd29GaWxlc1BhdGNoID0gY3JlYXRlVHdvRmlsZXNQYXRjaDtcbmV4cG9ydHMuY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2xpbmUgPSByZXF1aXJlKFwiLi4vZGlmZi9saW5lXCIpXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuO1xuXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbmZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLmNvbnRleHQgPSA0O1xuICB9XG5cbiAgdmFyIGRpZmYgPVxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICgwLFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgX2xpbmVcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgLlxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIGRpZmZMaW5lcylcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgZGlmZi5wdXNoKHtcbiAgICB2YWx1ZTogJycsXG4gICAgbGluZXM6IFtdXG4gIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxuXG4gIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICByZXR1cm4gJyAnICsgZW50cnk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaHVua3MgPSBbXTtcbiAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxuICAgICAgbmV3UmFuZ2VTdGFydCA9IDAsXG4gICAgICBjdXJSYW5nZSA9IFtdLFxuICAgICAgb2xkTGluZSA9IDEsXG4gICAgICBuZXdMaW5lID0gMTtcblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKFxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBpKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG5cbiAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIHZhciBfY3VyUmFuZ2U7XG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XG4gICAgICAgIG9sZFJhbmdlU3RhcnQgPSBvbGRMaW5lO1xuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IC8vIE91dHB1dCBvdXIgY2hhbmdlc1xuXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgKF9jdXJSYW5nZSA9XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgY3VyUmFuZ2UpLnB1c2guYXBwbHkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfY3VyUmFuZ2VcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAsXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfdG9Db25zdW1hYmxlQXJyYXkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICB9KSkpOyAvLyBUcmFjayB0aGUgdXBkYXRlZCBmaWxlIHBvc2l0aW9uXG5cblxuICAgICAgaWYgKGN1cnJlbnQuYWRkZWQpIHtcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWRlbnRpY2FsIGNvbnRleHQgbGluZXMuIFRyYWNrIGxpbmUgY2hhbmdlc1xuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQgKiAyICYmIGkgPCBkaWZmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgdmFyIF9jdXJSYW5nZTI7XG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgIC8vIE92ZXJsYXBwaW5nXG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICAgIChfY3VyUmFuZ2UyID1cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgIGN1clJhbmdlKS5wdXNoLmFwcGx5KFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgICBfY3VyUmFuZ2UyXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgICAsXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgIGNvbnRleHRMaW5lcyhsaW5lcykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgdmFyIF9jdXJSYW5nZTM7XG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuICAgICAgICAgIHZhciBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgKF9jdXJSYW5nZTMgPVxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgY3VyUmFuZ2UpLnB1c2guYXBwbHkoXG4gICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICAgIF9jdXJSYW5nZTNcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAgICxcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAgICAgY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcblxuICAgICAgICAgIHZhciBodW5rID0ge1xuICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICBvbGRMaW5lczogb2xkTGluZSAtIG9sZFJhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICBsaW5lczogY3VyUmFuZ2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXG4gICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG9sZFN0cik7XG4gICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG5ld1N0cik7XG4gICAgICAgICAgICB2YXIgbm9ObEJlZm9yZUFkZHMgPSBsaW5lcy5sZW5ndGggPT0gMCAmJiBjdXJSYW5nZS5sZW5ndGggPiBodW5rLm9sZExpbmVzO1xuXG4gICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMgJiYgb2xkU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xuICAgICAgICAgICAgICAvLyBob3dldmVyLCBpZiB0aGUgb2xkIGZpbGUgaXMgZW1wdHksIGRvIG5vdCBvdXRwdXQgdGhlIG5vLW5sIGxpbmVcbiAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvbGRFT0ZOZXdsaW5lICYmICFub05sQmVmb3JlQWRkcyB8fCAhbmV3RU9GTmV3bGluZSkge1xuICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIF9sb29wKFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgaSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9sZEZpbGVOYW1lOiBvbGRGaWxlTmFtZSxcbiAgICBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsXG4gICAgbmV3SGVhZGVyOiBuZXdIZWFkZXIsXG4gICAgaHVua3M6IGh1bmtzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFBhdGNoKGRpZmYpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIGlmIChkaWZmLm9sZEZpbGVOYW1lID09IGRpZmYubmV3RmlsZU5hbWUpIHtcbiAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBkaWZmLm9sZEZpbGVOYW1lKTtcbiAgfVxuXG4gIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gIHJldC5wdXNoKCctLS0gJyArIGRpZmYub2xkRmlsZU5hbWUgKyAodHlwZW9mIGRpZmYub2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcdCcgKyBkaWZmLm9sZEhlYWRlcikpO1xuICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaHVuayA9IGRpZmYuaHVua3NbaV07IC8vIFVuaWZpZWQgRGlmZiBGb3JtYXQgcXVpcms6IElmIHRoZSBjaHVuayBzaXplIGlzIDAsXG4gICAgLy8gdGhlIGZpcnN0IG51bWJlciBpcyBvbmUgbG93ZXIgdGhhbiBvbmUgd291bGQgZXhwZWN0LlxuICAgIC8vIGh0dHBzOi8vd3d3LmFydGltYS5jb20vd2VibG9ncy92aWV3cG9zdC5qc3A/dGhyZWFkPTE2NDI5M1xuXG4gICAgaWYgKGh1bmsub2xkTGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsub2xkU3RhcnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoaHVuay5uZXdMaW5lcyA9PT0gMCkge1xuICAgICAgaHVuay5uZXdTdGFydCAtPSAxO1xuICAgIH1cblxuICAgIHJldC5wdXNoKCdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzICsgJyBAQCcpO1xuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZvcm1hdFBhdGNoKHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWFJqYUM5amNtVmhkR1V1YW5NaVhTd2libUZ0WlhNaU9sc2ljM1J5ZFdOMGRYSmxaRkJoZEdOb0lpd2liMnhrUm1sc1pVNWhiV1VpTENKdVpYZEdhV3hsVG1GdFpTSXNJbTlzWkZOMGNpSXNJbTVsZDFOMGNpSXNJbTlzWkVobFlXUmxjaUlzSW01bGQwaGxZV1JsY2lJc0ltOXdkR2x2Ym5NaUxDSmpiMjUwWlhoMElpd2laR2xtWmlJc0ltUnBabVpNYVc1bGN5SXNJbkIxYzJnaUxDSjJZV3gxWlNJc0lteHBibVZ6SWl3aVkyOXVkR1Y0ZEV4cGJtVnpJaXdpYldGd0lpd2laVzUwY25raUxDSm9kVzVyY3lJc0ltOXNaRkpoYm1kbFUzUmhjblFpTENKdVpYZFNZVzVuWlZOMFlYSjBJaXdpWTNWeVVtRnVaMlVpTENKdmJHUk1hVzVsSWl3aWJtVjNUR2x1WlNJc0lta2lMQ0pqZFhKeVpXNTBJaXdpY21Wd2JHRmpaU0lzSW5Od2JHbDBJaXdpWVdSa1pXUWlMQ0p5WlcxdmRtVmtJaXdpY0hKbGRpSXNJbk5zYVdObElpd2liR1Z1WjNSb0lpd2lZMjl1ZEdWNGRGTnBlbVVpTENKTllYUm9JaXdpYldsdUlpd2lhSFZ1YXlJc0ltOXNaRk4wWVhKMElpd2liMnhrVEdsdVpYTWlMQ0p1WlhkVGRHRnlkQ0lzSW01bGQweHBibVZ6SWl3aWIyeGtSVTlHVG1WM2JHbHVaU0lzSW5SbGMzUWlMQ0p1WlhkRlQwWk9aWGRzYVc1bElpd2libTlPYkVKbFptOXlaVUZrWkhNaUxDSnpjR3hwWTJVaUxDSm1iM0p0WVhSUVlYUmphQ0lzSW5KbGRDSXNJbUZ3Y0d4NUlpd2lhbTlwYmlJc0ltTnlaV0YwWlZSM2IwWnBiR1Z6VUdGMFkyZ2lMQ0pqY21WaGRHVlFZWFJqYUNJc0ltWnBiR1ZPWVcxbElsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCT3pzN096czdPenM3T3pzN096czdRVUZGVHl4VFFVRlRRU3hsUVVGVUxFTkJRWGxDUXl4WFFVRjZRaXhGUVVGelEwTXNWMEZCZEVNc1JVRkJiVVJETEUxQlFXNUVMRVZCUVRKRVF5eE5RVUV6UkN4RlFVRnRSVU1zVTBGQmJrVXNSVUZCT0VWRExGTkJRVGxGTEVWQlFYbEdReXhQUVVGNlJpeEZRVUZyUnp0QlFVTjJSeXhOUVVGSkxFTkJRVU5CTEU5QlFVd3NSVUZCWXp0QlFVTmFRU3hKUVVGQlFTeFBRVUZQTEVkQlFVY3NSVUZCVmp0QlFVTkVPenRCUVVORUxFMUJRVWtzVDBGQlQwRXNUMEZCVHl4RFFVRkRReXhQUVVGbUxFdEJRVEpDTEZkQlFTOUNMRVZCUVRSRE8wRkJRekZEUkN4SlFVRkJRU3hQUVVGUExFTkJRVU5ETEU5QlFWSXNSMEZCYTBJc1EwRkJiRUk3UVVGRFJEczdRVUZGUkN4TlFVRk5ReXhKUVVGSk8wRkJRVWM3UVVGQlFUdEJRVUZCT3p0QlFVRkJRenRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJPMEZCUVVFc1IwRkJWVkFzVFVGQlZpeEZRVUZyUWtNc1RVRkJiRUlzUlVGQk1FSkhMRTlCUVRGQ0xFTkJRV0k3UVVGRFFVVXNSVUZCUVVFc1NVRkJTU3hEUVVGRFJTeEpRVUZNTEVOQlFWVTdRVUZCUTBNc1NVRkJRVUVzUzBGQlN5eEZRVUZGTEVWQlFWSTdRVUZCV1VNc1NVRkJRVUVzUzBGQlN5eEZRVUZGTzBGQlFXNUNMRWRCUVZZc1JVRlVkVWNzUTBGVGNFVTdPMEZCUlc1RExGZEJRVk5ETEZsQlFWUXNRMEZCYzBKRUxFdEJRWFJDTEVWQlFUWkNPMEZCUXpOQ0xGZEJRVTlCTEV0QlFVc3NRMEZCUTBVc1IwRkJUaXhEUVVGVkxGVkJRVk5ETEV0QlFWUXNSVUZCWjBJN1FVRkJSU3hoUVVGUExFMUJRVTFCTEV0QlFXSTdRVUZCY1VJc1MwRkJha1FzUTBGQlVEdEJRVU5FT3p0QlFVVkVMRTFCUVVsRExFdEJRVXNzUjBGQlJ5eEZRVUZhTzBGQlEwRXNUVUZCU1VNc1lVRkJZU3hIUVVGSExFTkJRWEJDTzBGQlFVRXNUVUZCZFVKRExHRkJRV0VzUjBGQlJ5eERRVUYyUXp0QlFVRkJMRTFCUVRCRFF5eFJRVUZSTEVkQlFVY3NSVUZCY2tRN1FVRkJRU3hOUVVOSlF5eFBRVUZQTEVkQlFVY3NRMEZFWkR0QlFVRkJMRTFCUTJsQ1F5eFBRVUZQTEVkQlFVY3NRMEZFTTBJN08wRkJhRUoxUnp0QlFVRkJPMEZCUVVFN1FVRnJRamxHUXl4RlFVRkJRU3hEUVd4Q09FWTdRVUZ0UW5KSExGRkJRVTFETEU5QlFVOHNSMEZCUjJZc1NVRkJTU3hEUVVGRFl5eERRVUZFTEVOQlFYQkNPMEZCUVVFc1VVRkRUVllzUzBGQlN5eEhRVUZIVnl4UFFVRlBMRU5CUVVOWUxFdEJRVklzU1VGQmFVSlhMRTlCUVU4c1EwRkJRMW9zUzBGQlVpeERRVUZqWVN4UFFVRmtMRU5CUVhOQ0xFdEJRWFJDTEVWQlFUWkNMRVZCUVRkQ0xFVkJRV2xEUXl4TFFVRnFReXhEUVVGMVF5eEpRVUYyUXl4RFFVUXZRanRCUVVWQlJpeEpRVUZCUVN4UFFVRlBMRU5CUVVOWUxFdEJRVklzUjBGQlowSkJMRXRCUVdoQ096dEJRVVZCTEZGQlFVbFhMRTlCUVU4c1EwRkJRMGNzUzBGQlVpeEpRVUZwUWtnc1QwRkJUeXhEUVVGRFNTeFBRVUUzUWl4RlFVRnpRenRCUVVGQk8wRkJRVUU3TzBGQlFVRTdRVUZEY0VNN1FVRkRRU3hWUVVGSkxFTkJRVU5XTEdGQlFVd3NSVUZCYjBJN1FVRkRiRUlzV1VGQlRWY3NTVUZCU1N4SFFVRkhjRUlzU1VGQlNTeERRVUZEWXl4RFFVRkRMRWRCUVVjc1EwRkJUQ3hEUVVGcVFqdEJRVU5CVEN4UlFVRkJRU3hoUVVGaExFZEJRVWRITEU5QlFXaENPMEZCUTBGR0xGRkJRVUZCTEdGQlFXRXNSMEZCUjBjc1QwRkJhRUk3TzBGQlJVRXNXVUZCU1U4c1NVRkJTaXhGUVVGVk8wRkJRMUpVTEZWQlFVRkJMRkZCUVZFc1IwRkJSMklzVDBGQlR5eERRVUZEUXl4UFFVRlNMRWRCUVd0Q0xFTkJRV3hDTEVkQlFYTkNUU3haUVVGWkxFTkJRVU5sTEVsQlFVa3NRMEZCUTJoQ0xFdEJRVXdzUTBGQlYybENMRXRCUVZnc1EwRkJhVUlzUTBGQlEzWkNMRTlCUVU4c1EwRkJRME1zVDBGQk1VSXNRMEZCUkN4RFFVRnNReXhIUVVGNVJTeEZRVUZ3Ump0QlFVTkJWU3hWUVVGQlFTeGhRVUZoTEVsQlFVbEZMRkZCUVZFc1EwRkJRMWNzVFVGQk1VSTdRVUZEUVZvc1ZVRkJRVUVzWVVGQllTeEpRVUZKUXl4UlFVRlJMRU5CUVVOWExFMUJRVEZDTzBGQlEwUTdRVUZEUml4UFFWcHRReXhEUVdOd1F6czdPMEZCUTBFN08wRkJRVUU3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVGWUxFMUJRVUZCTEZGQlFWRXNSVUZCUTFRc1NVRkJWRHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVd0Q1JTeE5RVUZCUVN4TFFVRkxMRU5CUVVORkxFZEJRVTRzUTBGQlZTeFZRVUZUUXl4TFFVRlVMRVZCUVdkQ08wRkJRekZETEdWQlFVOHNRMEZCUTFFc1QwRkJUeXhEUVVGRFJ5eExRVUZTTEVkQlFXZENMRWRCUVdoQ0xFZEJRWE5DTEVkQlFYWkNMRWxCUVRoQ1dDeExRVUZ5UXp0QlFVTkVMRTlCUm1sQ0xFTkJRV3hDTEVkQlptOURMRU5CYlVKd1F6czdPMEZCUTBFc1ZVRkJTVkVzVDBGQlR5eERRVUZEUnl4TFFVRmFMRVZCUVcxQ08wRkJRMnBDVEN4UlFVRkJRU3hQUVVGUExFbEJRVWxVTEV0QlFVc3NRMEZCUTJ0Q0xFMUJRV3BDTzBGQlEwUXNUMEZHUkN4TlFVVlBPMEZCUTB4V0xGRkJRVUZCTEU5QlFVOHNTVUZCU1ZJc1MwRkJTeXhEUVVGRGEwSXNUVUZCYWtJN1FVRkRSRHRCUVVOR0xFdEJla0pFTEUxQmVVSlBPMEZCUTB3N1FVRkRRU3hWUVVGSllpeGhRVUZLTEVWQlFXMUNPMEZCUTJwQ08wRkJRMEVzV1VGQlNVd3NTMEZCU3l4RFFVRkRhMElzVFVGQlRpeEpRVUZuUW5oQ0xFOUJRVThzUTBGQlEwTXNUMEZCVWl4SFFVRnJRaXhEUVVGc1F5eEpRVUYxUTJVc1EwRkJReXhIUVVGSFpDeEpRVUZKTEVOQlFVTnpRaXhOUVVGTUxFZEJRV01zUTBGQk4wUXNSVUZCWjBVN1FVRkJRVHRCUVVGQk96dEJRVUZCTzBGQlF6bEVPenRCUVVOQk96dEJRVUZCT3p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQldDeFZRVUZCUVN4UlFVRlJMRVZCUVVOVUxFbEJRVlE3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGclFrY3NWVUZCUVVFc1dVRkJXU3hEUVVGRFJDeExRVUZFTEVOQlFUbENPMEZCUTBRc1UwRklSQ3hOUVVkUE8wRkJRVUU3UVVGQlFUczdRVUZCUVR0QlFVTk1PMEZCUTBFc1kwRkJTVzFDTEZkQlFWY3NSMEZCUjBNc1NVRkJTU3hEUVVGRFF5eEhRVUZNTEVOQlFWTnlRaXhMUVVGTExFTkJRVU5yUWl4TlFVRm1MRVZCUVhWQ2VFSXNUMEZCVHl4RFFVRkRReXhQUVVFdlFpeERRVUZzUWpzN1FVRkRRVHM3UVVGQlFUczdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVmtzVlVGQlFVRXNVVUZCVVN4RlFVRkRWQ3hKUVVGVU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJhMEpITEZWQlFVRkJMRmxCUVZrc1EwRkJRMFFzUzBGQlN5eERRVUZEYVVJc1MwRkJUaXhEUVVGWkxFTkJRVm9zUlVGQlpVVXNWMEZCWml4RFFVRkVMRU5CUVRsQ096dEJRVVZCTEdOQlFVbEhMRWxCUVVrc1IwRkJSenRCUVVOVVF5eFpRVUZCUVN4UlFVRlJMRVZCUVVWc1FpeGhRVVJFTzBGQlJWUnRRaXhaUVVGQlFTeFJRVUZSTEVWQlFVZG9RaXhQUVVGUExFZEJRVWRJTEdGQlFWWXNSMEZCTUVKakxGZEJSalZDTzBGQlIxUk5MRmxCUVVGQkxGRkJRVkVzUlVGQlJXNUNMR0ZCU0VRN1FVRkpWRzlDTEZsQlFVRkJMRkZCUVZFc1JVRkJSMnBDTEU5QlFVOHNSMEZCUjBnc1lVRkJWaXhIUVVFd1FtRXNWMEZLTlVJN1FVRkxWRzVDTEZsQlFVRkJMRXRCUVVzc1JVRkJSVTg3UVVGTVJTeFhRVUZZT3p0QlFVOUJMR05CUVVsSExFTkJRVU1zU1VGQlNXUXNTVUZCU1N4RFFVRkRjMElzVFVGQlRDeEhRVUZqTEVOQlFXNUNMRWxCUVhkQ2JFSXNTMEZCU3l4RFFVRkRhMElzVFVGQlRpeEpRVUZuUW5oQ0xFOUJRVThzUTBGQlEwTXNUMEZCY0VRc1JVRkJOa1E3UVVGRE0wUTdRVUZEUVN4blFrRkJTV2RETEdGQlFXRXNSMEZCU3l4TFFVRkVMRU5CUVZGRExFbEJRVklzUTBGQllYUkRMRTFCUVdJc1EwRkJja0k3UVVGRFFTeG5Ra0ZCU1hWRExHRkJRV0VzUjBGQlN5eExRVUZFTEVOQlFWRkVMRWxCUVZJc1EwRkJZWEpETEUxQlFXSXNRMEZCY2tJN1FVRkRRU3huUWtGQlNYVkRMR05CUVdNc1IwRkJSemxDTEV0QlFVc3NRMEZCUTJ0Q0xFMUJRVTRzU1VGQlowSXNRMEZCYUVJc1NVRkJjVUpZTEZGQlFWRXNRMEZCUTFjc1RVRkJWQ3hIUVVGclFra3NTVUZCU1N4RFFVRkRSU3hSUVVGcVJUczdRVUZEUVN4blFrRkJTU3hEUVVGRFJ5eGhRVUZFTEVsQlFXdENSeXhqUVVGc1FpeEpRVUZ2UTNoRExFMUJRVTBzUTBGQlF6UkNMRTFCUVZBc1IwRkJaMElzUTBGQmVFUXNSVUZCTWtRN1FVRkRla1E3UVVGRFFUdEJRVU5CV0N4alFVRkJRU3hSUVVGUkxFTkJRVU4zUWl4TlFVRlVMRU5CUVdkQ1ZDeEpRVUZKTEVOQlFVTkZMRkZCUVhKQ0xFVkJRU3RDTEVOQlFTOUNMRVZCUVd0RExEaENRVUZzUXp0QlFVTkVPenRCUVVORUxHZENRVUZMTEVOQlFVTkhMR0ZCUVVRc1NVRkJhMElzUTBGQlEwY3NZMEZCY0VJc1NVRkJkVU1zUTBGQlEwUXNZVUZCTlVNc1JVRkJNa1E3UVVGRGVrUjBRaXhqUVVGQlFTeFJRVUZSTEVOQlFVTlVMRWxCUVZRc1EwRkJZeXc0UWtGQlpEdEJRVU5FTzBGQlEwWTdPMEZCUTBSTkxGVkJRVUZCTEV0QlFVc3NRMEZCUTA0c1NVRkJUaXhEUVVGWGQwSXNTVUZCV0R0QlFVVkJha0lzVlVGQlFVRXNZVUZCWVN4SFFVRkhMRU5CUVdoQ08wRkJRMEZETEZWQlFVRkJMR0ZCUVdFc1IwRkJSeXhEUVVGb1FqdEJRVU5CUXl4VlFVRkJRU3hSUVVGUkxFZEJRVWNzUlVGQldEdEJRVU5FTzBGQlEwWTdPMEZCUTBSRExFMUJRVUZCTEU5QlFVOHNTVUZCU1ZJc1MwRkJTeXhEUVVGRGEwSXNUVUZCYWtJN1FVRkRRVlFzVFVGQlFVRXNUMEZCVHl4SlFVRkpWQ3hMUVVGTExFTkJRVU5yUWl4TlFVRnFRanRCUVVORU8wRkJNVVp2UnpzN1FVRnJRblpITEU5QlFVc3NTVUZCU1ZJc1EwRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRU5CUVVNc1IwRkJSMlFzU1VGQlNTeERRVUZEYzBJc1RVRkJla0lzUlVGQmFVTlNMRU5CUVVNc1JVRkJiRU1zUlVGQmMwTTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJOMEpCTEVsQlFVRkJMRU5CUVRaQ08wRkJlVVZ5UXpzN1FVRkZSQ3hUUVVGUE8wRkJRMHgwUWl4SlFVRkJRU3hYUVVGWExFVkJRVVZCTEZkQlJGSTdRVUZEY1VKRExFbEJRVUZCTEZkQlFWY3NSVUZCUlVFc1YwRkViRU03UVVGRlRFY3NTVUZCUVVFc1UwRkJVeXhGUVVGRlFTeFRRVVpPTzBGQlJXbENReXhKUVVGQlFTeFRRVUZUTEVWQlFVVkJMRk5CUmpWQ08wRkJSMHhYTEVsQlFVRkJMRXRCUVVzc1JVRkJSVUU3UVVGSVJpeEhRVUZRTzBGQlMwUTdPMEZCUlUwc1UwRkJVelJDTEZkQlFWUXNRMEZCY1VKd1F5eEpRVUZ5UWl4RlFVRXlRanRCUVVOb1F5eE5RVUZOY1VNc1IwRkJSeXhIUVVGSExFVkJRVm83TzBGQlEwRXNUVUZCU1hKRExFbEJRVWtzUTBGQlExSXNWMEZCVEN4SlFVRnZRbEVzU1VGQlNTeERRVUZEVUN4WFFVRTNRaXhGUVVFd1F6dEJRVU40UXpSRExFbEJRVUZCTEVkQlFVY3NRMEZCUTI1RExFbEJRVW9zUTBGQlV5eFpRVUZaUml4SlFVRkpMRU5CUVVOU0xGZEJRVEZDTzBGQlEwUTdPMEZCUTBRMlF5eEZRVUZCUVN4SFFVRkhMRU5CUVVOdVF5eEpRVUZLTEVOQlFWTXNjVVZCUVZRN1FVRkRRVzFETEVWQlFVRkJMRWRCUVVjc1EwRkJRMjVETEVsQlFVb3NRMEZCVXl4VFFVRlRSaXhKUVVGSkxFTkJRVU5TTEZkQlFXUXNTVUZCTmtJc1QwRkJUMUVzU1VGQlNTeERRVUZEU2l4VFFVRmFMRXRCUVRCQ0xGZEJRVEZDTEVkQlFYZERMRVZCUVhoRExFZEJRVFpETEU5QlFVOUpMRWxCUVVrc1EwRkJRMG9zVTBGQmRFWXNRMEZCVkR0QlFVTkJlVU1zUlVGQlFVRXNSMEZCUnl4RFFVRkRia01zU1VGQlNpeERRVUZUTEZOQlFWTkdMRWxCUVVrc1EwRkJRMUFzVjBGQlpDeEpRVUUyUWl4UFFVRlBUeXhKUVVGSkxFTkJRVU5JTEZOQlFWb3NTMEZCTUVJc1YwRkJNVUlzUjBGQmQwTXNSVUZCZUVNc1IwRkJOa01zVDBGQlQwY3NTVUZCU1N4RFFVRkRTQ3hUUVVGMFJpeERRVUZVT3p0QlFVVkJMRTlCUVVzc1NVRkJTV2xDTEVOQlFVTXNSMEZCUnl4RFFVRmlMRVZCUVdkQ1FTeERRVUZETEVkQlFVZGtMRWxCUVVrc1EwRkJRMUVzUzBGQlRDeERRVUZYWXl4TlFVRXZRaXhGUVVGMVExSXNRMEZCUXl4RlFVRjRReXhGUVVFMFF6dEJRVU14UXl4UlFVRk5XU3hKUVVGSkxFZEJRVWN4UWl4SlFVRkpMRU5CUVVOUkxFdEJRVXdzUTBGQlYwMHNRMEZCV0N4RFFVRmlMRU5CUkRCRExFTkJSVEZETzBGQlEwRTdRVUZEUVRzN1FVRkRRU3hSUVVGSldTeEpRVUZKTEVOQlFVTkZMRkZCUVV3c1MwRkJhMElzUTBGQmRFSXNSVUZCZVVJN1FVRkRka0pHTEUxQlFVRkJMRWxCUVVrc1EwRkJRME1zVVVGQlRDeEpRVUZwUWl4RFFVRnFRanRCUVVORU96dEJRVU5FTEZGQlFVbEVMRWxCUVVrc1EwRkJRMGtzVVVGQlRDeExRVUZyUWl4RFFVRjBRaXhGUVVGNVFqdEJRVU4yUWtvc1RVRkJRVUVzU1VGQlNTeERRVUZEUnl4UlFVRk1MRWxCUVdsQ0xFTkJRV3BDTzBGQlEwUTdPMEZCUTBSUkxFbEJRVUZCTEVkQlFVY3NRMEZCUTI1RExFbEJRVW9zUTBGRFJTeFRRVUZUZDBJc1NVRkJTU3hEUVVGRFF5eFJRVUZrTEVkQlFYbENMRWRCUVhwQ0xFZEJRU3RDUkN4SlFVRkpMRU5CUVVORkxGRkJRWEJETEVkQlEwVXNTVUZFUml4SFFVTlRSaXhKUVVGSkxFTkJRVU5ITEZGQlJHUXNSMEZEZVVJc1IwRkVla0lzUjBGREswSklMRWxCUVVrc1EwRkJRMGtzVVVGRWNFTXNSMEZGUlN4TFFVaEtPMEZCUzBGUExFbEJRVUZCTEVkQlFVY3NRMEZCUTI1RExFbEJRVW9zUTBGQlUyOURMRXRCUVZRc1EwRkJaVVFzUjBGQlppeEZRVUZ2UWxnc1NVRkJTU3hEUVVGRGRFSXNTMEZCZWtJN1FVRkRSRHM3UVVGRlJDeFRRVUZQYVVNc1IwRkJSeXhEUVVGRFJTeEpRVUZLTEVOQlFWTXNTVUZCVkN4SlFVRnBRaXhKUVVGNFFqdEJRVU5FT3p0QlFVVk5MRk5CUVZORExHMUNRVUZVTEVOQlFUWkNhRVFzVjBGQk4wSXNSVUZCTUVORExGZEJRVEZETEVWQlFYVkVReXhOUVVGMlJDeEZRVUVyUkVNc1RVRkJMMFFzUlVGQmRVVkRMRk5CUVhaRkxFVkJRV3RHUXl4VFFVRnNSaXhGUVVFMlJrTXNUMEZCTjBZc1JVRkJjMGM3UVVGRE0wY3NVMEZCVDNORExGZEJRVmNzUTBGQlF6ZERMR1ZCUVdVc1EwRkJRME1zVjBGQlJDeEZRVUZqUXl4WFFVRmtMRVZCUVRKQ1F5eE5RVUV6UWl4RlFVRnRRME1zVFVGQmJrTXNSVUZCTWtORExGTkJRVE5ETEVWQlFYTkVReXhUUVVGMFJDeEZRVUZwUlVNc1QwRkJha1VzUTBGQmFFSXNRMEZCYkVJN1FVRkRSRHM3UVVGRlRTeFRRVUZUTWtNc1YwRkJWQ3hEUVVGeFFrTXNVVUZCY2tJc1JVRkJLMEpvUkN4TlFVRXZRaXhGUVVGMVEwTXNUVUZCZGtNc1JVRkJLME5ETEZOQlFTOURMRVZCUVRCRVF5eFRRVUV4UkN4RlFVRnhSVU1zVDBGQmNrVXNSVUZCT0VVN1FVRkRia1lzVTBGQlR6QkRMRzFDUVVGdFFpeERRVUZEUlN4UlFVRkVMRVZCUVZkQkxGRkJRVmdzUlVGQmNVSm9SQ3hOUVVGeVFpeEZRVUUyUWtNc1RVRkJOMElzUlVGQmNVTkRMRk5CUVhKRExFVkJRV2RFUXl4VFFVRm9SQ3hGUVVFeVJFTXNUMEZCTTBRc1EwRkJNVUk3UVVGRFJDSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbWx0Y0c5eWRDQjdaR2xtWmt4cGJtVnpmU0JtY205dElDY3VMaTlrYVdabUwyeHBibVVuTzF4dVhHNWxlSEJ2Y25RZ1puVnVZM1JwYjI0Z2MzUnlkV04wZFhKbFpGQmhkR05vS0c5c1pFWnBiR1ZPWVcxbExDQnVaWGRHYVd4bFRtRnRaU3dnYjJ4a1UzUnlMQ0J1WlhkVGRISXNJRzlzWkVobFlXUmxjaXdnYm1WM1NHVmhaR1Z5TENCdmNIUnBiMjV6S1NCN1hHNGdJR2xtSUNnaGIzQjBhVzl1Y3lrZ2UxeHVJQ0FnSUc5d2RHbHZibk1nUFNCN2ZUdGNiaUFnZlZ4dUlDQnBaaUFvZEhsd1pXOW1JRzl3ZEdsdmJuTXVZMjl1ZEdWNGRDQTlQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCdmNIUnBiMjV6TG1OdmJuUmxlSFFnUFNBME8xeHVJQ0I5WEc1Y2JpQWdZMjl1YzNRZ1pHbG1aaUE5SUdScFptWk1hVzVsY3lodmJHUlRkSElzSUc1bGQxTjBjaXdnYjNCMGFXOXVjeWs3WEc0Z0lHUnBabVl1Y0hWemFDaDdkbUZzZFdVNklDY25MQ0JzYVc1bGN6b2dXMTE5S1RzZ0x5OGdRWEJ3Wlc1a0lHRnVJR1Z0Y0hSNUlIWmhiSFZsSUhSdklHMWhhMlVnWTJ4bFlXNTFjQ0JsWVhOcFpYSmNibHh1SUNCbWRXNWpkR2x2YmlCamIyNTBaWGgwVEdsdVpYTW9iR2x1WlhNcElIdGNiaUFnSUNCeVpYUjFjbTRnYkdsdVpYTXViV0Z3S0daMWJtTjBhVzl1S0dWdWRISjVLU0I3SUhKbGRIVnliaUFuSUNjZ0t5QmxiblJ5ZVRzZ2ZTazdYRzRnSUgxY2JseHVJQ0JzWlhRZ2FIVnVhM01nUFNCYlhUdGNiaUFnYkdWMElHOXNaRkpoYm1kbFUzUmhjblFnUFNBd0xDQnVaWGRTWVc1blpWTjBZWEowSUQwZ01Dd2dZM1Z5VW1GdVoyVWdQU0JiWFN4Y2JpQWdJQ0FnSUc5c1pFeHBibVVnUFNBeExDQnVaWGRNYVc1bElEMGdNVHRjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmthV1ptTG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ1kyOXVjM1FnWTNWeWNtVnVkQ0E5SUdScFptWmJhVjBzWEc0Z0lDQWdJQ0FnSUNBZ2JHbHVaWE1nUFNCamRYSnlaVzUwTG14cGJtVnpJSHg4SUdOMWNuSmxiblF1ZG1Gc2RXVXVjbVZ3YkdGalpTZ3ZYRnh1SkM4c0lDY25LUzV6Y0d4cGRDZ25YRnh1SnlrN1hHNGdJQ0FnWTNWeWNtVnVkQzVzYVc1bGN5QTlJR3hwYm1Wek8xeHVYRzRnSUNBZ2FXWWdLR04xY25KbGJuUXVZV1JrWldRZ2ZId2dZM1Z5Y21WdWRDNXlaVzF2ZG1Wa0tTQjdYRzRnSUNBZ0lDQXZMeUJKWmlCM1pTQm9ZWFpsSUhCeVpYWnBiM1Z6SUdOdmJuUmxlSFFzSUhOMFlYSjBJSGRwZEdnZ2RHaGhkRnh1SUNBZ0lDQWdhV1lnS0NGdmJHUlNZVzVuWlZOMFlYSjBLU0I3WEc0Z0lDQWdJQ0FnSUdOdmJuTjBJSEJ5WlhZZ1BTQmthV1ptVzJrZ0xTQXhYVHRjYmlBZ0lDQWdJQ0FnYjJ4a1VtRnVaMlZUZEdGeWRDQTlJRzlzWkV4cGJtVTdYRzRnSUNBZ0lDQWdJRzVsZDFKaGJtZGxVM1JoY25RZ1BTQnVaWGRNYVc1bE8xeHVYRzRnSUNBZ0lDQWdJR2xtSUNod2NtVjJLU0I3WEc0Z0lDQWdJQ0FnSUNBZ1kzVnlVbUZ1WjJVZ1BTQnZjSFJwYjI1ekxtTnZiblJsZUhRZ1BpQXdJRDhnWTI5dWRHVjRkRXhwYm1WektIQnlaWFl1YkdsdVpYTXVjMnhwWTJVb0xXOXdkR2x2Ym5NdVkyOXVkR1Y0ZENrcElEb2dXMTA3WEc0Z0lDQWdJQ0FnSUNBZ2IyeGtVbUZ1WjJWVGRHRnlkQ0F0UFNCamRYSlNZVzVuWlM1c1pXNW5kR2c3WEc0Z0lDQWdJQ0FnSUNBZ2JtVjNVbUZ1WjJWVGRHRnlkQ0F0UFNCamRYSlNZVzVuWlM1c1pXNW5kR2c3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdUM1YwY0hWMElHOTFjaUJqYUdGdVoyVnpYRzRnSUNBZ0lDQmpkWEpTWVc1blpTNXdkWE5vS0M0dUxpQnNhVzVsY3k1dFlYQW9ablZ1WTNScGIyNG9aVzUwY25rcElIdGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDaGpkWEp5Wlc1MExtRmtaR1ZrSUQ4Z0p5c25JRG9nSnkwbktTQXJJR1Z1ZEhKNU8xeHVJQ0FnSUNBZ2ZTa3BPMXh1WEc0Z0lDQWdJQ0F2THlCVWNtRmpheUIwYUdVZ2RYQmtZWFJsWkNCbWFXeGxJSEJ2YzJsMGFXOXVYRzRnSUNBZ0lDQnBaaUFvWTNWeWNtVnVkQzVoWkdSbFpDa2dlMXh1SUNBZ0lDQWdJQ0J1WlhkTWFXNWxJQ3M5SUd4cGJtVnpMbXhsYm1kMGFEdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHOXNaRXhwYm1VZ0t6MGdiR2x1WlhNdWJHVnVaM1JvTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQXZMeUJKWkdWdWRHbGpZV3dnWTI5dWRHVjRkQ0JzYVc1bGN5NGdWSEpoWTJzZ2JHbHVaU0JqYUdGdVoyVnpYRzRnSUNBZ0lDQnBaaUFvYjJ4a1VtRnVaMlZUZEdGeWRDa2dlMXh1SUNBZ0lDQWdJQ0F2THlCRGJHOXpaU0J2ZFhRZ1lXNTVJR05vWVc1blpYTWdkR2hoZENCb1lYWmxJR0psWlc0Z2IzVjBjSFYwSUNodmNpQnFiMmx1SUc5MlpYSnNZWEJ3YVc1bktWeHVJQ0FnSUNBZ0lDQnBaaUFvYkdsdVpYTXViR1Z1WjNSb0lEdzlJRzl3ZEdsdmJuTXVZMjl1ZEdWNGRDQXFJRElnSmlZZ2FTQThJR1JwWm1ZdWJHVnVaM1JvSUMwZ01pa2dlMXh1SUNBZ0lDQWdJQ0FnSUM4dklFOTJaWEpzWVhCd2FXNW5YRzRnSUNBZ0lDQWdJQ0FnWTNWeVVtRnVaMlV1Y0hWemFDZ3VMaTRnWTI5dWRHVjRkRXhwYm1WektHeHBibVZ6S1NrN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdMeThnWlc1a0lIUm9aU0J5WVc1blpTQmhibVFnYjNWMGNIVjBYRzRnSUNBZ0lDQWdJQ0FnYkdWMElHTnZiblJsZUhSVGFYcGxJRDBnVFdGMGFDNXRhVzRvYkdsdVpYTXViR1Z1WjNSb0xDQnZjSFJwYjI1ekxtTnZiblJsZUhRcE8xeHVJQ0FnSUNBZ0lDQWdJR04xY2xKaGJtZGxMbkIxYzJnb0xpNHVJR052Ym5SbGVIUk1hVzVsY3loc2FXNWxjeTV6YkdsalpTZ3dMQ0JqYjI1MFpYaDBVMmw2WlNrcEtUdGNibHh1SUNBZ0lDQWdJQ0FnSUd4bGRDQm9kVzVySUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYjJ4a1UzUmhjblE2SUc5c1pGSmhibWRsVTNSaGNuUXNYRzRnSUNBZ0lDQWdJQ0FnSUNCdmJHUk1hVzVsY3pvZ0tHOXNaRXhwYm1VZ0xTQnZiR1JTWVc1blpWTjBZWEowSUNzZ1kyOXVkR1Y0ZEZOcGVtVXBMRnh1SUNBZ0lDQWdJQ0FnSUNBZ2JtVjNVM1JoY25RNklHNWxkMUpoYm1kbFUzUmhjblFzWEc0Z0lDQWdJQ0FnSUNBZ0lDQnVaWGRNYVc1bGN6b2dLRzVsZDB4cGJtVWdMU0J1WlhkU1lXNW5aVk4wWVhKMElDc2dZMjl1ZEdWNGRGTnBlbVVwTEZ4dUlDQWdJQ0FnSUNBZ0lDQWdiR2x1WlhNNklHTjFjbEpoYm1kbFhHNGdJQ0FnSUNBZ0lDQWdmVHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9hU0ErUFNCa2FXWm1MbXhsYm1kMGFDQXRJRElnSmlZZ2JHbHVaWE11YkdWdVozUm9JRHc5SUc5d2RHbHZibk11WTI5dWRHVjRkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnUlU5R0lHbHpJR2x1YzJsa1pTQjBhR2x6SUdoMWJtdGNiaUFnSUNBZ0lDQWdJQ0FnSUd4bGRDQnZiR1JGVDBaT1pYZHNhVzVsSUQwZ0tDZ3ZYRnh1SkM4cExuUmxjM1FvYjJ4a1UzUnlLU2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaWFFnYm1WM1JVOUdUbVYzYkdsdVpTQTlJQ2dvTDF4Y2JpUXZLUzUwWlhOMEtHNWxkMU4wY2lrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYkdWMElHNXZUbXhDWldadmNtVkJaR1J6SUQwZ2JHbHVaWE11YkdWdVozUm9JRDA5SURBZ0ppWWdZM1Z5VW1GdVoyVXViR1Z1WjNSb0lENGdhSFZ1YXk1dmJHUk1hVzVsY3p0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xtSUNnaGIyeGtSVTlHVG1WM2JHbHVaU0FtSmlCdWIwNXNRbVZtYjNKbFFXUmtjeUFtSmlCdmJHUlRkSEl1YkdWdVozUm9JRDRnTUNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QnpjR1ZqYVdGc0lHTmhjMlU2SUc5c1pDQm9ZWE1nYm04Z1pXOXNJR0Z1WkNCdWJ5QjBjbUZwYkdsdVp5QmpiMjUwWlhoME95QnVieTF1YkNCallXNGdaVzVrSUhWd0lHSmxabTl5WlNCaFpHUnpYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDOHZJR2h2ZDJWMlpYSXNJR2xtSUhSb1pTQnZiR1FnWm1sc1pTQnBjeUJsYlhCMGVTd2daRzhnYm05MElHOTFkSEIxZENCMGFHVWdibTh0Ym13Z2JHbHVaVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmpkWEpTWVc1blpTNXpjR3hwWTJVb2FIVnVheTV2YkdSTWFXNWxjeXdnTUN3Z0oxeGNYRndnVG04Z2JtVjNiR2x1WlNCaGRDQmxibVFnYjJZZ1ptbHNaU2NwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLQ2doYjJ4a1JVOUdUbVYzYkdsdVpTQW1KaUFoYm05T2JFSmxabTl5WlVGa1pITXBJSHg4SUNGdVpYZEZUMFpPWlhkc2FXNWxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJR04xY2xKaGJtZGxMbkIxYzJnb0oxeGNYRndnVG04Z2JtVjNiR2x1WlNCaGRDQmxibVFnYjJZZ1ptbHNaU2NwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQm9kVzVyY3k1d2RYTm9LR2gxYm1zcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnYjJ4a1VtRnVaMlZUZEdGeWRDQTlJREE3WEc0Z0lDQWdJQ0FnSUNBZ2JtVjNVbUZ1WjJWVGRHRnlkQ0E5SURBN1hHNGdJQ0FnSUNBZ0lDQWdZM1Z5VW1GdVoyVWdQU0JiWFR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2IyeGtUR2x1WlNBclBTQnNhVzVsY3k1c1pXNW5kR2c3WEc0Z0lDQWdJQ0J1WlhkTWFXNWxJQ3M5SUd4cGJtVnpMbXhsYm1kMGFEdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2UxeHVJQ0FnSUc5c1pFWnBiR1ZPWVcxbE9pQnZiR1JHYVd4bFRtRnRaU3dnYm1WM1JtbHNaVTVoYldVNklHNWxkMFpwYkdWT1lXMWxMRnh1SUNBZ0lHOXNaRWhsWVdSbGNqb2diMnhrU0dWaFpHVnlMQ0J1WlhkSVpXRmtaWEk2SUc1bGQwaGxZV1JsY2l4Y2JpQWdJQ0JvZFc1cmN6b2dhSFZ1YTNOY2JpQWdmVHRjYm4xY2JseHVaWGh3YjNKMElHWjFibU4wYVc5dUlHWnZjbTFoZEZCaGRHTm9LR1JwWm1ZcElIdGNiaUFnWTI5dWMzUWdjbVYwSUQwZ1cxMDdYRzRnSUdsbUlDaGthV1ptTG05c1pFWnBiR1ZPWVcxbElEMDlJR1JwWm1ZdWJtVjNSbWxzWlU1aGJXVXBJSHRjYmlBZ0lDQnlaWFF1Y0hWemFDZ25TVzVrWlhnNklDY2dLeUJrYVdabUxtOXNaRVpwYkdWT1lXMWxLVHRjYmlBZ2ZWeHVJQ0J5WlhRdWNIVnphQ2duUFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBTY3BPMXh1SUNCeVpYUXVjSFZ6YUNnbkxTMHRJQ2NnS3lCa2FXWm1MbTlzWkVacGJHVk9ZVzFsSUNzZ0tIUjVjR1Z2WmlCa2FXWm1MbTlzWkVobFlXUmxjaUE5UFQwZ0ozVnVaR1ZtYVc1bFpDY2dQeUFuSnlBNklDZGNYSFFuSUNzZ1pHbG1aaTV2YkdSSVpXRmtaWElwS1R0Y2JpQWdjbVYwTG5CMWMyZ29KeXNyS3lBbklDc2daR2xtWmk1dVpYZEdhV3hsVG1GdFpTQXJJQ2gwZVhCbGIyWWdaR2xtWmk1dVpYZElaV0ZrWlhJZ1BUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z0p5Y2dPaUFuWEZ4MEp5QXJJR1JwWm1ZdWJtVjNTR1ZoWkdWeUtTazdYRzVjYmlBZ1ptOXlJQ2hzWlhRZ2FTQTlJREE3SUdrZ1BDQmthV1ptTG1oMWJtdHpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnWTI5dWMzUWdhSFZ1YXlBOUlHUnBabVl1YUhWdWEzTmJhVjA3WEc0Z0lDQWdMeThnVlc1cFptbGxaQ0JFYVdabUlFWnZjbTFoZENCeGRXbHlhem9nU1dZZ2RHaGxJR05vZFc1cklITnBlbVVnYVhNZ01DeGNiaUFnSUNBdkx5QjBhR1VnWm1seWMzUWdiblZ0WW1WeUlHbHpJRzl1WlNCc2IzZGxjaUIwYUdGdUlHOXVaU0IzYjNWc1pDQmxlSEJsWTNRdVhHNGdJQ0FnTHk4Z2FIUjBjSE02THk5M2QzY3VZWEowYVcxaExtTnZiUzkzWldKc2IyZHpMM1pwWlhkd2IzTjBMbXB6Y0Q5MGFISmxZV1E5TVRZME1qa3pYRzRnSUNBZ2FXWWdLR2gxYm1zdWIyeGtUR2x1WlhNZ1BUMDlJREFwSUh0Y2JpQWdJQ0FnSUdoMWJtc3ViMnhrVTNSaGNuUWdMVDBnTVR0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0doMWJtc3VibVYzVEdsdVpYTWdQVDA5SURBcElIdGNiaUFnSUNBZ0lHaDFibXN1Ym1WM1UzUmhjblFnTFQwZ01UdGNiaUFnSUNCOVhHNGdJQ0FnY21WMExuQjFjMmdvWEc0Z0lDQWdJQ0FuUUVBZ0xTY2dLeUJvZFc1ckxtOXNaRk4wWVhKMElDc2dKeXduSUNzZ2FIVnVheTV2YkdSTWFXNWxjMXh1SUNBZ0lDQWdLeUFuSUNzbklDc2dhSFZ1YXk1dVpYZFRkR0Z5ZENBcklDY3NKeUFySUdoMWJtc3VibVYzVEdsdVpYTmNiaUFnSUNBZ0lDc2dKeUJBUUNkY2JpQWdJQ0FwTzF4dUlDQWdJSEpsZEM1d2RYTm9MbUZ3Y0d4NUtISmxkQ3dnYUhWdWF5NXNhVzVsY3lrN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2NtVjBMbXB2YVc0b0oxeGNiaWNwSUNzZ0oxeGNiaWM3WEc1OVhHNWNibVY0Y0c5eWRDQm1kVzVqZEdsdmJpQmpjbVZoZEdWVWQyOUdhV3hsYzFCaGRHTm9LRzlzWkVacGJHVk9ZVzFsTENCdVpYZEdhV3hsVG1GdFpTd2diMnhrVTNSeUxDQnVaWGRUZEhJc0lHOXNaRWhsWVdSbGNpd2dibVYzU0dWaFpHVnlMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lISmxkSFZ5YmlCbWIzSnRZWFJRWVhSamFDaHpkSEoxWTNSMWNtVmtVR0YwWTJnb2IyeGtSbWxzWlU1aGJXVXNJRzVsZDBacGJHVk9ZVzFsTENCdmJHUlRkSElzSUc1bGQxTjBjaXdnYjJ4a1NHVmhaR1Z5TENCdVpYZElaV0ZrWlhJc0lHOXdkR2x2Ym5NcEtUdGNibjFjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdOeVpXRjBaVkJoZEdOb0tHWnBiR1ZPWVcxbExDQnZiR1JUZEhJc0lHNWxkMU4wY2l3Z2IyeGtTR1ZoWkdWeUxDQnVaWGRJWldGa1pYSXNJRzl3ZEdsdmJuTXBJSHRjYmlBZ2NtVjBkWEp1SUdOeVpXRjBaVlIzYjBacGJHVnpVR0YwWTJnb1ptbHNaVTVoYldVc0lHWnBiR1ZPWVcxbExDQnZiR1JUZEhJc0lHNWxkMU4wY2l3Z2IyeGtTR1ZoWkdWeUxDQnVaWGRJWldGa1pYSXNJRzl3ZEdsdmJuTXBPMXh1ZlZ4dUlsMTlcbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYWxjTGluZUNvdW50ID0gY2FsY0xpbmVDb3VudDtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbnZhclxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2NyZWF0ZSA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZVwiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxudmFyXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5fYXJyYXkgPSByZXF1aXJlKFwiLi4vdXRpbC9hcnJheVwiKVxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbjtcblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB2YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPVxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICBjYWxjT2xkTmV3TGluZUNvdW50KGh1bmsubGluZXMpLFxuICAgICAgb2xkTGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5vbGRMaW5lcyxcbiAgICAgIG5ld0xpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQubmV3TGluZXM7XG5cbiAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gIH1cblxuICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZShtaW5lLCB0aGVpcnMsIGJhc2UpIHtcbiAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcbiAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG4gIHZhciByZXQgPSB7fTsgLy8gRm9yIGluZGV4IHdlIGp1c3QgbGV0IGl0IHBhc3MgdGhyb3VnaCBhcyBpdCBkb2Vzbid0IGhhdmUgYW55IG5lY2Vzc2FyeSBtZWFuaW5nLlxuICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcbiAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cblxuICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcbiAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgfVxuXG4gIGlmIChtaW5lLm5ld0ZpbGVOYW1lIHx8IHRoZWlycy5uZXdGaWxlTmFtZSkge1xuICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHRoZWlycy5vbGRGaWxlTmFtZSB8fCBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgIHJldC5uZXdIZWFkZXIgPSB0aGVpcnMubmV3SGVhZGVyIHx8IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgIHJldC5vbGRGaWxlTmFtZSA9IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IG1pbmUubmV3SGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEZpbGVOYW1lLCB0aGVpcnMub2xkRmlsZU5hbWUpO1xuICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgcmV0Lm5ld0hlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdIZWFkZXIsIHRoZWlycy5uZXdIZWFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldC5odW5rcyA9IFtdO1xuICB2YXIgbWluZUluZGV4ID0gMCxcbiAgICAgIHRoZWlyc0luZGV4ID0gMCxcbiAgICAgIG1pbmVPZmZzZXQgPSAwLFxuICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcblxuICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XG4gICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5odW5rc1ttaW5lSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH0sXG4gICAgICAgIHRoZWlyc0N1cnJlbnQgPSB0aGVpcnMuaHVua3NbdGhlaXJzSW5kZXhdIHx8IHtcbiAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgIH07XG5cbiAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcbiAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XG4gICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cbiAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgdmFyIG1lcmdlZEh1bmsgPSB7XG4gICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXG4gICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcbiAgICAgICAgbmV3TGluZXM6IDAsXG4gICAgICAgIGxpbmVzOiBbXVxuICAgICAgfTtcbiAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcbiAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICBtaW5lSW5kZXgrKztcbiAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xuICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgICAoMCxcbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAgIF9wYXJzZVxuICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgICAuXG4gICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICAgcGFyc2VQYXRjaClcbiAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICAgKHBhcmFtKVswXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgYmFzZSByZWZlcmVuY2Ugb3IgcGFzcyBpbiBhIHBhdGNoJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgICgwLFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgX2NyZWF0ZVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIC5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIHN0cnVjdHVyZWRQYXRjaClcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICAodW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2UsIHBhcmFtKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFyYW07XG59XG5cbmZ1bmN0aW9uIGZpbGVOYW1lQ2hhbmdlZChwYXRjaCkge1xuICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RGaWVsZChpbmRleCwgbWluZSwgdGhlaXJzKSB7XG4gIGlmIChtaW5lID09PSB0aGVpcnMpIHtcbiAgICByZXR1cm4gbWluZTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleC5jb25mbGljdCA9IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbmU6IG1pbmUsXG4gICAgICB0aGVpcnM6IHRoZWlyc1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0ICYmIHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzIDwgY2hlY2sub2xkU3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICBuZXdTdGFydDogaHVuay5uZXdTdGFydCArIG9mZnNldCxcbiAgICBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICBsaW5lczogaHVuay5saW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgLy8gVGhpcyB3aWxsIGdlbmVyYWxseSByZXN1bHQgaW4gYSBjb25mbGljdGVkIGh1bmssIGJ1dCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGNvbnRleHRcbiAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXG4gIHZhciBtaW5lID0ge1xuICAgIG9mZnNldDogbWluZU9mZnNldCxcbiAgICBsaW5lczogbWluZUxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH0sXG4gICAgICB0aGVpciA9IHtcbiAgICBvZmZzZXQ6IHRoZWlyT2Zmc2V0LFxuICAgIGxpbmVzOiB0aGVpckxpbmVzLFxuICAgIGluZGV4OiAwXG4gIH07IC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG5cbiAgaW5zZXJ0TGVhZGluZyhodW5rLCBtaW5lLCB0aGVpcik7XG4gIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpOyAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG5cbiAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUubGluZXNbbWluZS5pbmRleF0sXG4gICAgICAgIHRoZWlyQ3VycmVudCA9IHRoZWlyLmxpbmVzW3RoZWlyLmluZGV4XTtcblxuICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XG4gICAgICAvLyBCb3RoIG1vZGlmaWVkIC4uLlxuICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIHZhciBfaHVuayRsaW5lcztcblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIC8vIE1pbmUgaW5zZXJ0ZWRcblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAoX2h1bmskbGluZXMgPVxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIGh1bmsubGluZXMpLnB1c2guYXBwbHkoXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICBfaHVuayRsaW5lc1xuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBjb2xsZWN0Q2hhbmdlKG1pbmUpKSk7XG4gICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICcrJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICB2YXIgX2h1bmskbGluZXMyO1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgLy8gVGhlaXJzIGluc2VydGVkXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgKF9odW5rJGxpbmVzMiA9XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgaHVuay5saW5lcykucHVzaC5hcHBseShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF9odW5rJGxpbmVzMlxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBjb2xsZWN0Q2hhbmdlKHRoZWlyKSkpO1xuICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICctJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgLy8gTWluZSByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBUaGVpciByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgcmVtb3ZhbChodW5rLCB0aGVpciwgbWluZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudCA9PT0gdGhlaXJDdXJyZW50KSB7XG4gICAgICAvLyBDb250ZXh0IGlkZW50aXR5XG4gICAgICBodW5rLmxpbmVzLnB1c2gobWluZUN1cnJlbnQpO1xuICAgICAgbWluZS5pbmRleCsrO1xuICAgICAgdGhlaXIuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGV4dCBtaXNtYXRjaFxuICAgICAgY29uZmxpY3QoaHVuaywgY29sbGVjdENoYW5nZShtaW5lKSwgY29sbGVjdENoYW5nZSh0aGVpcikpO1xuICAgIH1cbiAgfSAvLyBOb3cgcHVzaCBhbnl0aGluZyB0aGF0IG1heSBiZSByZW1haW5pbmdcblxuXG4gIGluc2VydFRyYWlsaW5nKGh1bmssIG1pbmUpO1xuICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XG4gIGNhbGNMaW5lQ291bnQoaHVuayk7XG59XG5cbmZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xuICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UodGhlaXIpO1xuXG4gIGlmIChhbGxSZW1vdmVzKG15Q2hhbmdlcykgJiYgYWxsUmVtb3Zlcyh0aGVpckNoYW5nZXMpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciByZW1vdmUgY2hhbmdlcyB0aGF0IGFyZSBzdXBlcnNldHMgb2Ygb25lIGFub3RoZXJcbiAgICBpZiAoXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICgwLFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX2FycmF5XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgIGFycmF5U3RhcnRzV2l0aClcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgdmFyIF9odW5rJGxpbmVzMztcblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgICAoX2h1bmskbGluZXMzID1cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgX2h1bmskbGluZXMzXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgLFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgIG15Q2hhbmdlcykpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgKDAsXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfYXJyYXlcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgIC5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgYXJyYXlTdGFydHNXaXRoKVxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIHZhciBfaHVuayRsaW5lczQ7XG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAgICAgKF9odW5rJGxpbmVzNCA9XG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICAgaHVuay5saW5lcykucHVzaC5hcHBseShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF9odW5rJGxpbmVzNFxuICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICAgICxcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICAgIF90b0NvbnN1bWFibGVBcnJheShcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgICB0aGVpckNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICAoMCxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gIF9hcnJheVxuICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAuXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgYXJyYXlFcXVhbClcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICB2YXIgX2h1bmskbGluZXM1O1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgKF9odW5rJGxpbmVzNSA9XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KFxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfaHVuayRsaW5lczVcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICxcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgbXlDaGFuZ2VzKSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25mbGljdChodW5rLCBteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIsIHN3YXApIHtcbiAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q29udGV4dCh0aGVpciwgbXlDaGFuZ2VzKTtcblxuICBpZiAodGhlaXJDaGFuZ2VzLm1lcmdlZCkge1xuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICB2YXIgX2h1bmskbGluZXM2O1xuXG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5cbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgKF9odW5rJGxpbmVzNiA9XG4gICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgICBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KFxuICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cbiAgICBfaHVuayRsaW5lczZcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xuICAgICxcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG4gICAgX3RvQ29uc3VtYWJsZUFycmF5KFxuICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4gICAgdGhlaXJDaGFuZ2VzLm1lcmdlZCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZsaWN0KGh1bmssIHN3YXAgPyB0aGVpckNoYW5nZXMgOiBteUNoYW5nZXMsIHN3YXAgPyBteUNoYW5nZXMgOiB0aGVpckNoYW5nZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZsaWN0KGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gIGh1bmsuY29uZmxpY3QgPSB0cnVlO1xuICBodW5rLmxpbmVzLnB1c2goe1xuICAgIGNvbmZsaWN0OiB0cnVlLFxuICAgIG1pbmU6IG1pbmUsXG4gICAgdGhlaXJzOiB0aGVpclxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TGVhZGluZyhodW5rLCBpbnNlcnQsIHRoZWlyKSB7XG4gIHdoaWxlIChpbnNlcnQub2Zmc2V0IDwgdGhlaXIub2Zmc2V0ICYmIGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICAgIGluc2VydC5vZmZzZXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcbiAgd2hpbGUgKGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RDaGFuZ2Uoc3RhdGUpIHtcbiAgdmFyIHJldCA9IFtdLFxuICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xuXG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgIHZhciBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdOyAvLyBHcm91cCBhZGRpdGlvbnMgdGhhdCBhcmUgaW1tZWRpYXRlbHkgYWZ0ZXIgc3VidHJhY3Rpb25zIGFuZCB0cmVhdCB0aGVtIGFzIG9uZSBcImF0b21pY1wiIG1vZGlmeSBjaGFuZ2UuXG5cbiAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XG4gICAgICBvcGVyYXRpb24gPSAnKyc7XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xuICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICBzdGF0ZS5pbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gIHZhciBjaGFuZ2VzID0gW10sXG4gICAgICBtZXJnZWQgPSBbXSxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcbiAgICAgIGNvbmZsaWN0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGggJiYgc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICB2YXIgY2hhbmdlID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdLFxuICAgICAgICBtYXRjaCA9IG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XTsgLy8gT25jZSB3ZSd2ZSBoaXQgb3VyIGFkZCwgdGhlbiB3ZSBhcmUgZG9uZVxuXG4gICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG4gICAgbWVyZ2VkLnB1c2gobWF0Y2gpO1xuICAgIG1hdGNoSW5kZXgrKzsgLy8gQ29uc3VtZSBhbnkgYWRkaXRpb25zIGluIHRoZSBvdGhlciBibG9jayBhcyBhIGNvbmZsaWN0IHRvIGF0dGVtcHRcbiAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG5cbiAgICBpZiAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIGNoYW5nZSA9IHN0YXRlLmxpbmVzWysrc3RhdGUuaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRjaC5zdWJzdHIoMSkgPT09IGNoYW5nZS5zdWJzdHIoMSkpIHtcbiAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF0gfHwgJycpWzBdID09PSAnKycgJiYgY29udGV4dENoYW5nZXMpIHtcbiAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb25mbGljdGVkKSB7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cblxuICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICBtZXJnZWQucHVzaChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleCsrXSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lcmdlZDogbWVyZ2VkLFxuICAgIGNoYW5nZXM6IGNoYW5nZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxsUmVtb3ZlcyhjaGFuZ2VzKSB7XG4gIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY2hhbmdlKSB7XG4gICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XG4gIH0sIHRydWUpO1xufVxuXG5mdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4ICsgaV0gIT09ICcgJyArIGNoYW5nZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5pbmRleCArPSBkZWx0YTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNhbGNPbGROZXdMaW5lQ291bnQobGluZXMpIHtcbiAgdmFyIG9sZExpbmVzID0gMDtcbiAgdmFyIG5ld0xpbmVzID0gMDtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBteUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLm1pbmUpO1xuICAgICAgdmFyIHRoZWlyQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUudGhlaXJzKTtcblxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG15Q291bnQub2xkTGluZXMgPT09IHRoZWlyQ291bnQub2xkTGluZXMpIHtcbiAgICAgICAgICBvbGRMaW5lcyArPSBteUNvdW50Lm9sZExpbmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZExpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChteUNvdW50Lm5ld0xpbmVzID09PSB0aGVpckNvdW50Lm5ld0xpbmVzKSB7XG4gICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgbmV3TGluZXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgIG9sZExpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvbGRMaW5lczogb2xkTGluZXMsXG4gICAgbmV3TGluZXM6IG5ld0xpbmVzXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl3WVhSamFDOXRaWEpuWlM1cWN5SmRMQ0p1WVcxbGN5STZXeUpqWVd4alRHbHVaVU52ZFc1MElpd2lhSFZ1YXlJc0ltTmhiR05QYkdST1pYZE1hVzVsUTI5MWJuUWlMQ0pzYVc1bGN5SXNJbTlzWkV4cGJtVnpJaXdpYm1WM1RHbHVaWE1pTENKMWJtUmxabWx1WldRaUxDSnRaWEpuWlNJc0ltMXBibVVpTENKMGFHVnBjbk1pTENKaVlYTmxJaXdpYkc5aFpGQmhkR05vSWl3aWNtVjBJaXdpYVc1a1pYZ2lMQ0p1WlhkR2FXeGxUbUZ0WlNJc0ltWnBiR1ZPWVcxbFEyaGhibWRsWkNJc0ltOXNaRVpwYkdWT1lXMWxJaXdpYjJ4a1NHVmhaR1Z5SWl3aWJtVjNTR1ZoWkdWeUlpd2ljMlZzWldOMFJtbGxiR1FpTENKb2RXNXJjeUlzSW0xcGJtVkpibVJsZUNJc0luUm9aV2x5YzBsdVpHVjRJaXdpYldsdVpVOW1abk5sZENJc0luUm9aV2x5YzA5bVpuTmxkQ0lzSW14bGJtZDBhQ0lzSW0xcGJtVkRkWEp5Wlc1MElpd2liMnhrVTNSaGNuUWlMQ0pKYm1acGJtbDBlU0lzSW5Sb1pXbHljME4xY25KbGJuUWlMQ0pvZFc1clFtVm1iM0psSWl3aWNIVnphQ0lzSW1Oc2IyNWxTSFZ1YXlJc0ltMWxjbWRsWkVoMWJtc2lMQ0pOWVhSb0lpd2liV2x1SWl3aWJtVjNVM1JoY25RaUxDSnRaWEpuWlV4cGJtVnpJaXdpY0dGeVlXMGlMQ0owWlhOMElpd2ljR0Z5YzJWUVlYUmphQ0lzSWtWeWNtOXlJaXdpYzNSeWRXTjBkWEpsWkZCaGRHTm9JaXdpY0dGMFkyZ2lMQ0pqYjI1bWJHbGpkQ0lzSW1Ob1pXTnJJaXdpYjJabWMyVjBJaXdpYldsdVpVeHBibVZ6SWl3aWRHaGxhWEpQWm1aelpYUWlMQ0owYUdWcGNreHBibVZ6SWl3aWRHaGxhWElpTENKcGJuTmxjblJNWldGa2FXNW5JaXdpZEdobGFYSkRkWEp5Wlc1MElpd2liWFYwZFdGc1EyaGhibWRsSWl3aVkyOXNiR1ZqZEVOb1lXNW5aU0lzSW5KbGJXOTJZV3dpTENKcGJuTmxjblJVY21GcGJHbHVaeUlzSW0xNVEyaGhibWRsY3lJc0luUm9aV2x5UTJoaGJtZGxjeUlzSW1Gc2JGSmxiVzkyWlhNaUxDSmhjbkpoZVZOMFlYSjBjMWRwZEdnaUxDSnphMmx3VW1WdGIzWmxVM1Z3WlhKelpYUWlMQ0poY25KaGVVVnhkV0ZzSWl3aWMzZGhjQ0lzSW1OdmJHeGxZM1JEYjI1MFpYaDBJaXdpYldWeVoyVmtJaXdpYVc1elpYSjBJaXdpYkdsdVpTSXNJbk4wWVhSbElpd2liM0JsY21GMGFXOXVJaXdpYldGMFkyaERhR0Z1WjJWeklpd2lZMmhoYm1kbGN5SXNJbTFoZEdOb1NXNWtaWGdpTENKamIyNTBaWGgwUTJoaGJtZGxjeUlzSW1OdmJtWnNhV04wWldRaUxDSmphR0Z1WjJVaUxDSnRZWFJqYUNJc0luTjFZbk4wY2lJc0luSmxaSFZqWlNJc0luQnlaWFlpTENKeVpXMXZkbVZEYUdGdVoyVnpJaXdpWkdWc2RHRWlMQ0pwSWl3aVkyaGhibWRsUTI5dWRHVnVkQ0lzSW1admNrVmhZMmdpTENKdGVVTnZkVzUwSWl3aWRHaGxhWEpEYjNWdWRDSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlEwRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHM3UVVGRlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPenM3T3pzN096czdPenM3T3pzN1FVRkZUeXhUUVVGVFFTeGhRVUZVTEVOQlFYVkNReXhKUVVGMlFpeEZRVUUyUWp0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVOTVF5eEZRVUZCUVN4dFFrRkJiVUlzUTBGQlEwUXNTVUZCU1N4RFFVRkRSU3hMUVVGT0xFTkJSR1E3UVVGQlFTeE5RVU16UWtNc1VVRkVNa0lzZDBKQlF6TkNRU3hSUVVReVFqdEJRVUZCTEUxQlEycENReXhSUVVScFFpeDNRa0ZEYWtKQkxGRkJSR2xDT3p0QlFVZHNReXhOUVVGSlJDeFJRVUZSTEV0QlFVdEZMRk5CUVdwQ0xFVkJRVFJDTzBGQlF6RkNUQ3hKUVVGQlFTeEpRVUZKTEVOQlFVTkhMRkZCUVV3c1IwRkJaMEpCTEZGQlFXaENPMEZCUTBRc1IwRkdSQ3hOUVVWUE8wRkJRMHdzVjBGQlQwZ3NTVUZCU1N4RFFVRkRSeXhSUVVGYU8wRkJRMFE3TzBGQlJVUXNUVUZCU1VNc1VVRkJVU3hMUVVGTFF5eFRRVUZxUWl4RlFVRTBRanRCUVVNeFFrd3NTVUZCUVVFc1NVRkJTU3hEUVVGRFNTeFJRVUZNTEVkQlFXZENRU3hSUVVGb1FqdEJRVU5FTEVkQlJrUXNUVUZGVHp0QlFVTk1MRmRCUVU5S0xFbEJRVWtzUTBGQlEwa3NVVUZCV2p0QlFVTkVPMEZCUTBZN08wRkJSVTBzVTBGQlUwVXNTMEZCVkN4RFFVRmxReXhKUVVGbUxFVkJRWEZDUXl4TlFVRnlRaXhGUVVFMlFrTXNTVUZCTjBJc1JVRkJiVU03UVVGRGVFTkdMRVZCUVVGQkxFbEJRVWtzUjBGQlIwY3NVMEZCVXl4RFFVRkRTQ3hKUVVGRUxFVkJRVTlGTEVsQlFWQXNRMEZCYUVJN1FVRkRRVVFzUlVGQlFVRXNUVUZCVFN4SFFVRkhSU3hUUVVGVExFTkJRVU5HTEUxQlFVUXNSVUZCVTBNc1NVRkJWQ3hEUVVGc1FqdEJRVVZCTEUxQlFVbEZMRWRCUVVjc1IwRkJSeXhGUVVGV0xFTkJTbmRETEVOQlRYaERPMEZCUTBFN1FVRkRRVHM3UVVGRFFTeE5RVUZKU2l4SlFVRkpMRU5CUVVOTExFdEJRVXdzU1VGQlkwb3NUVUZCVFN4RFFVRkRTU3hMUVVGNlFpeEZRVUZuUXp0QlFVTTVRa1FzU1VGQlFVRXNSMEZCUnl4RFFVRkRReXhMUVVGS0xFZEJRVmxNTEVsQlFVa3NRMEZCUTBzc1MwRkJUQ3hKUVVGalNpeE5RVUZOTEVOQlFVTkpMRXRCUVdwRE8wRkJRMFE3TzBGQlJVUXNUVUZCU1V3c1NVRkJTU3hEUVVGRFRTeFhRVUZNTEVsQlFXOUNUQ3hOUVVGTkxFTkJRVU5MTEZkQlFTOUNMRVZCUVRSRE8wRkJRekZETEZGQlFVa3NRMEZCUTBNc1pVRkJaU3hEUVVGRFVDeEpRVUZFTEVOQlFYQkNMRVZCUVRSQ08wRkJRekZDTzBGQlEwRkpMRTFCUVVGQkxFZEJRVWNzUTBGQlEwa3NWMEZCU2l4SFFVRnJRbEFzVFVGQlRTeERRVUZEVHl4WFFVRlFMRWxCUVhOQ1VpeEpRVUZKTEVOQlFVTlJMRmRCUVRkRE8wRkJRMEZLTEUxQlFVRkJMRWRCUVVjc1EwRkJRMFVzVjBGQlNpeEhRVUZyUWt3c1RVRkJUU3hEUVVGRFN5eFhRVUZRTEVsQlFYTkNUaXhKUVVGSkxFTkJRVU5OTEZkQlFUZERPMEZCUTBGR0xFMUJRVUZCTEVkQlFVY3NRMEZCUTBzc1UwRkJTaXhIUVVGblFsSXNUVUZCVFN4RFFVRkRVU3hUUVVGUUxFbEJRVzlDVkN4SlFVRkpMRU5CUVVOVExGTkJRWHBETzBGQlEwRk1MRTFCUVVGQkxFZEJRVWNzUTBGQlEwMHNVMEZCU2l4SFFVRm5RbFFzVFVGQlRTeERRVUZEVXl4VFFVRlFMRWxCUVc5Q1ZpeEpRVUZKTEVOQlFVTlZMRk5CUVhwRE8wRkJRMFFzUzBGT1JDeE5RVTFQTEVsQlFVa3NRMEZCUTBnc1pVRkJaU3hEUVVGRFRpeE5RVUZFTEVOQlFYQkNMRVZCUVRoQ08wRkJRMjVETzBGQlEwRkhMRTFCUVVGQkxFZEJRVWNzUTBGQlEwa3NWMEZCU2l4SFFVRnJRbElzU1VGQlNTeERRVUZEVVN4WFFVRjJRanRCUVVOQlNpeE5RVUZCUVN4SFFVRkhMRU5CUVVORkxGZEJRVW9zUjBGQmEwSk9MRWxCUVVrc1EwRkJRMDBzVjBGQmRrSTdRVUZEUVVZc1RVRkJRVUVzUjBGQlJ5eERRVUZEU3l4VFFVRktMRWRCUVdkQ1ZDeEpRVUZKTEVOQlFVTlRMRk5CUVhKQ08wRkJRMEZNTEUxQlFVRkJMRWRCUVVjc1EwRkJRMDBzVTBGQlNpeEhRVUZuUWxZc1NVRkJTU3hEUVVGRFZTeFRRVUZ5UWp0QlFVTkVMRXRCVGswc1RVRk5RVHRCUVVOTU8wRkJRMEZPTEUxQlFVRkJMRWRCUVVjc1EwRkJRMGtzVjBGQlNpeEhRVUZyUWtjc1YwRkJWeXhEUVVGRFVDeEhRVUZFTEVWQlFVMUtMRWxCUVVrc1EwRkJRMUVzVjBGQldDeEZRVUYzUWxBc1RVRkJUU3hEUVVGRFR5eFhRVUV2UWl4RFFVRTNRanRCUVVOQlNpeE5RVUZCUVN4SFFVRkhMRU5CUVVORkxGZEJRVW9zUjBGQmEwSkxMRmRCUVZjc1EwRkJRMUFzUjBGQlJDeEZRVUZOU2l4SlFVRkpMRU5CUVVOTkxGZEJRVmdzUlVGQmQwSk1MRTFCUVUwc1EwRkJRMHNzVjBGQkwwSXNRMEZCTjBJN1FVRkRRVVlzVFVGQlFVRXNSMEZCUnl4RFFVRkRTeXhUUVVGS0xFZEJRV2RDUlN4WFFVRlhMRU5CUVVOUUxFZEJRVVFzUlVGQlRVb3NTVUZCU1N4RFFVRkRVeXhUUVVGWUxFVkJRWE5DVWl4TlFVRk5MRU5CUVVOUkxGTkJRVGRDTEVOQlFUTkNPMEZCUTBGTUxFMUJRVUZCTEVkQlFVY3NRMEZCUTAwc1UwRkJTaXhIUVVGblFrTXNWMEZCVnl4RFFVRkRVQ3hIUVVGRUxFVkJRVTFLTEVsQlFVa3NRMEZCUTFVc1UwRkJXQ3hGUVVGelFsUXNUVUZCVFN4RFFVRkRVeXhUUVVFM1FpeERRVUV6UWp0QlFVTkVPMEZCUTBZN08wRkJSVVJPTEVWQlFVRkJMRWRCUVVjc1EwRkJRMUVzUzBGQlNpeEhRVUZaTEVWQlFWbzdRVUZGUVN4TlFVRkpReXhUUVVGVExFZEJRVWNzUTBGQmFFSTdRVUZCUVN4TlFVTkpReXhYUVVGWExFZEJRVWNzUTBGRWJFSTdRVUZCUVN4TlFVVkpReXhWUVVGVkxFZEJRVWNzUTBGR2FrSTdRVUZCUVN4TlFVZEpReXhaUVVGWkxFZEJRVWNzUTBGSWJrSTdPMEZCUzBFc1UwRkJUMGdzVTBGQlV5eEhRVUZIWWl4SlFVRkpMRU5CUVVOWkxFdEJRVXdzUTBGQlYwc3NUVUZCZGtJc1NVRkJhVU5JTEZkQlFWY3NSMEZCUjJJc1RVRkJUU3hEUVVGRFZ5eExRVUZRTEVOQlFXRkxMRTFCUVc1RkxFVkJRVEpGTzBGQlEzcEZMRkZCUVVsRExGZEJRVmNzUjBGQlIyeENMRWxCUVVrc1EwRkJRMWtzUzBGQlRDeERRVUZYUXl4VFFVRllMRXRCUVhsQ08wRkJRVU5OTEUxQlFVRkJMRkZCUVZFc1JVRkJSVU03UVVGQldDeExRVUV6UXp0QlFVRkJMRkZCUTBsRExHRkJRV0VzUjBGQlIzQkNMRTFCUVUwc1EwRkJRMWNzUzBGQlVDeERRVUZoUlN4WFFVRmlMRXRCUVRaQ08wRkJRVU5MTEUxQlFVRkJMRkZCUVZFc1JVRkJSVU03UVVGQldDeExRVVJxUkRzN1FVRkhRU3hSUVVGSlJTeFZRVUZWTEVOQlFVTktMRmRCUVVRc1JVRkJZMGNzWVVGQlpDeERRVUZrTEVWQlFUUkRPMEZCUXpGRE8wRkJRMEZxUWl4TlFVRkJRU3hIUVVGSExFTkJRVU5STEV0QlFVb3NRMEZCVlZjc1NVRkJWaXhEUVVGbFF5eFRRVUZUTEVOQlFVTk9MRmRCUVVRc1JVRkJZMGdzVlVGQlpDeERRVUY0UWp0QlFVTkJSaXhOUVVGQlFTeFRRVUZUTzBGQlExUkhMRTFCUVVGQkxGbEJRVmtzU1VGQlNVVXNWMEZCVnl4RFFVRkRja0lzVVVGQldpeEhRVUYxUW5GQ0xGZEJRVmNzUTBGQlEzUkNMRkZCUVc1RU8wRkJRMFFzUzBGTVJDeE5RVXRQTEVsQlFVa3dRaXhWUVVGVkxFTkJRVU5FTEdGQlFVUXNSVUZCWjBKSUxGZEJRV2hDTEVOQlFXUXNSVUZCTkVNN1FVRkRha1E3UVVGRFFXUXNUVUZCUVVFc1IwRkJSeXhEUVVGRFVTeExRVUZLTEVOQlFWVlhMRWxCUVZZc1EwRkJaVU1zVTBGQlV5eERRVUZEU0N4aFFVRkVMRVZCUVdkQ1RDeFpRVUZvUWl4RFFVRjRRanRCUVVOQlJpeE5RVUZCUVN4WFFVRlhPMEZCUTFoRExFMUJRVUZCTEZWQlFWVXNTVUZCU1Uwc1lVRkJZU3hEUVVGRGVFSXNVVUZCWkN4SFFVRjVRbmRDTEdGQlFXRXNRMEZCUTNwQ0xGRkJRWEpFTzBGQlEwUXNTMEZNVFN4TlFVdEJPMEZCUTB3N1FVRkRRU3hWUVVGSk5rSXNWVUZCVlN4SFFVRkhPMEZCUTJaT0xGRkJRVUZCTEZGQlFWRXNSVUZCUlU4c1NVRkJTU3hEUVVGRFF5eEhRVUZNTEVOQlFWTlVMRmRCUVZjc1EwRkJRME1zVVVGQmNrSXNSVUZCSzBKRkxHRkJRV0VzUTBGQlEwWXNVVUZCTjBNc1EwRkVTenRCUVVWbWRrSXNVVUZCUVVFc1VVRkJVU3hGUVVGRkxFTkJSa3M3UVVGSFptZERMRkZCUVVGQkxGRkJRVkVzUlVGQlJVWXNTVUZCU1N4RFFVRkRReXhIUVVGTUxFTkJRVk5VTEZkQlFWY3NRMEZCUTFVc1VVRkJXaXhIUVVGMVFtSXNWVUZCYUVNc1JVRkJORU5OTEdGQlFXRXNRMEZCUTBZc1VVRkJaQ3hIUVVGNVFrZ3NXVUZCY2tVc1EwRklTenRCUVVsbWJrSXNVVUZCUVVFc1VVRkJVU3hGUVVGRkxFTkJTa3M3UVVGTFprWXNVVUZCUVVFc1MwRkJTeXhGUVVGRk8wRkJURkVzVDBGQmFrSTdRVUZQUVd0RExFMUJRVUZCTEZWQlFWVXNRMEZCUTBvc1ZVRkJSQ3hGUVVGaFVDeFhRVUZYTEVOQlFVTkRMRkZCUVhwQ0xFVkJRVzFEUkN4WFFVRlhMRU5CUVVOMlFpeExRVUV2UXl4RlFVRnpSREJDTEdGQlFXRXNRMEZCUTBZc1VVRkJjRVVzUlVGQk9FVkZMR0ZCUVdFc1EwRkJRekZDTEV0QlFUVkdMRU5CUVZZN1FVRkRRVzFDTEUxQlFVRkJMRmRCUVZjN1FVRkRXRVFzVFVGQlFVRXNVMEZCVXp0QlFVVlVWQ3hOUVVGQlFTeEhRVUZITEVOQlFVTlJMRXRCUVVvc1EwRkJWVmNzU1VGQlZpeERRVUZsUlN4VlFVRm1PMEZCUTBRN1FVRkRSanM3UVVGRlJDeFRRVUZQY2tJc1IwRkJVRHRCUVVORU96dEJRVVZFTEZOQlFWTkVMRk5CUVZRc1EwRkJiVUl5UWl4TFFVRnVRaXhGUVVFd1FqVkNMRWxCUVRGQ0xFVkJRV2RETzBGQlF6bENMRTFCUVVrc1QwRkJUelJDTEV0QlFWQXNTMEZCYVVJc1VVRkJja0lzUlVGQkswSTdRVUZETjBJc1VVRkJTeXhOUVVGRUxFTkJRVk5ETEVsQlFWUXNRMEZCWTBRc1MwRkJaQ3hMUVVFd1FpeFZRVUZFTEVOQlFXRkRMRWxCUVdJc1EwRkJhMEpFTEV0QlFXeENMRU5CUVRkQ0xFVkJRWGRFTzBGQlEzUkVMR0ZCUVU4N1FVRkJRVHRCUVVGQk8wRkJRVUU3TzBGQlFVRkZPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRTdRVUZCUVN4VFFVRlhSaXhMUVVGWUxFVkJRV3RDTEVOQlFXeENPMEZCUVZBN1FVRkRSRHM3UVVGRlJDeFJRVUZKTEVOQlFVTTFRaXhKUVVGTUxFVkJRVmM3UVVGRFZDeFpRVUZOTEVsQlFVa3JRaXhMUVVGS0xFTkJRVlVzYTBSQlFWWXNRMEZCVGp0QlFVTkVPenRCUVVORUxGZEJRVTg3UVVGQlFUdEJRVUZCTzBGQlFVRTdPMEZCUVVGRE8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVFN1FVRkJRU3hQUVVGblFuQkRMRk5CUVdoQ0xFVkJRVEpDUVN4VFFVRXpRaXhGUVVGelEwa3NTVUZCZEVNc1JVRkJORU0wUWl4TFFVRTFRenRCUVVGUU8wRkJRMFE3TzBGQlJVUXNVMEZCVDBFc1MwRkJVRHRCUVVORU96dEJRVVZFTEZOQlFWTjJRaXhsUVVGVUxFTkJRWGxDTkVJc1MwRkJla0lzUlVGQlowTTdRVUZET1VJc1UwRkJUMEVzUzBGQlN5eERRVUZETjBJc1YwRkJUaXhKUVVGeFFqWkNMRXRCUVVzc1EwRkJRemRDTEZkQlFVNHNTMEZCYzBJMlFpeExRVUZMTEVOQlFVTXpRaXhYUVVGNFJEdEJRVU5FT3p0QlFVVkVMRk5CUVZOSExGZEJRVlFzUTBGQmNVSk9MRXRCUVhKQ0xFVkJRVFJDVEN4SlFVRTFRaXhGUVVGclEwTXNUVUZCYkVNc1JVRkJNRU03UVVGRGVFTXNUVUZCU1VRc1NVRkJTU3hMUVVGTFF5eE5RVUZpTEVWQlFYRkNPMEZCUTI1Q0xGZEJRVTlFTEVsQlFWQTdRVUZEUkN4SFFVWkVMRTFCUlU4N1FVRkRURXNzU1VGQlFVRXNTMEZCU3l4RFFVRkRLMElzVVVGQlRpeEhRVUZwUWl4SlFVRnFRanRCUVVOQkxGZEJRVTg3UVVGQlEzQkRMRTFCUVVGQkxFbEJRVWtzUlVGQlNrRXNTVUZCUkR0QlFVRlBReXhOUVVGQlFTeE5RVUZOTEVWQlFVNUJPMEZCUVZBc1MwRkJVRHRCUVVORU8wRkJRMFk3TzBGQlJVUXNVMEZCVTNGQ0xGVkJRVlFzUTBGQmIwSlRMRWxCUVhCQ0xFVkJRVEJDVFN4TFFVRXhRaXhGUVVGcFF6dEJRVU12UWl4VFFVRlBUaXhKUVVGSkxFTkJRVU5hTEZGQlFVd3NSMEZCWjBKclFpeExRVUZMTEVOQlFVTnNRaXhSUVVGMFFpeEpRVU5FV1N4SlFVRkpMRU5CUVVOYUxGRkJRVXdzUjBGQlowSlpMRWxCUVVrc1EwRkJRMjVETEZGQlFYUkNMRWRCUVd0RGVVTXNTMEZCU3l4RFFVRkRiRUlzVVVGRU4wTTdRVUZGUkRzN1FVRkZSQ3hUUVVGVFN5eFRRVUZVTEVOQlFXMUNMMElzU1VGQmJrSXNSVUZCZVVJMlF5eE5RVUY2UWl4RlFVRnBRenRCUVVNdlFpeFRRVUZQTzBGQlEweHVRaXhKUVVGQlFTeFJRVUZSTEVWQlFVVXhRaXhKUVVGSkxFTkJRVU13UWl4UlFVUldPMEZCUTI5Q2RrSXNTVUZCUVVFc1VVRkJVU3hGUVVGRlNDeEpRVUZKTEVOQlFVTkhMRkZCUkc1RE8wRkJSVXhuUXl4SlFVRkJRU3hSUVVGUkxFVkJRVVZ1UXl4SlFVRkpMRU5CUVVOdFF5eFJRVUZNTEVkQlFXZENWU3hOUVVaeVFqdEJRVVUyUW5wRExFbEJRVUZCTEZGQlFWRXNSVUZCUlVvc1NVRkJTU3hEUVVGRFNTeFJRVVkxUXp0QlFVZE1SaXhKUVVGQlFTeExRVUZMTEVWQlFVVkdMRWxCUVVrc1EwRkJRMFU3UVVGSVVDeEhRVUZRTzBGQlMwUTdPMEZCUlVRc1UwRkJVMnRETEZWQlFWUXNRMEZCYjBKd1F5eEpRVUZ3UWl4RlFVRXdRbk5DTEZWQlFURkNMRVZCUVhORGQwSXNVMEZCZEVNc1JVRkJhVVJETEZkQlFXcEVMRVZCUVRoRVF5eFZRVUU1UkN4RlFVRXdSVHRCUVVONFJUdEJRVU5CTzBGQlEwRXNUVUZCU1hwRExFbEJRVWtzUjBGQlJ6dEJRVUZEYzBNc1NVRkJRVUVzVFVGQlRTeEZRVUZGZGtJc1ZVRkJWRHRCUVVGeFFuQkNMRWxCUVVGQkxFdEJRVXNzUlVGQlJUUkRMRk5CUVRWQ08wRkJRWFZEYkVNc1NVRkJRVUVzUzBGQlN5eEZRVUZGTzBGQlFUbERMRWRCUVZnN1FVRkJRU3hOUVVOSmNVTXNTMEZCU3l4SFFVRkhPMEZCUVVOS0xFbEJRVUZCTEUxQlFVMHNSVUZCUlVVc1YwRkJWRHRCUVVGelFqZERMRWxCUVVGQkxFdEJRVXNzUlVGQlJUaERMRlZCUVRkQ08wRkJRWGxEY0VNc1NVRkJRVUVzUzBGQlN5eEZRVUZGTzBGQlFXaEVMRWRCUkZvc1EwRklkMFVzUTBGTmVFVTdPMEZCUTBGelF5eEZRVUZCUVN4aFFVRmhMRU5CUVVOc1JDeEpRVUZFTEVWQlFVOVBMRWxCUVZBc1JVRkJZVEJETEV0QlFXSXNRMEZCWWp0QlFVTkJReXhGUVVGQlFTeGhRVUZoTEVOQlFVTnNSQ3hKUVVGRUxFVkJRVTlwUkN4TFFVRlFMRVZCUVdNeFF5eEpRVUZrTEVOQlFXSXNRMEZTZDBVc1EwRlZlRVU3TzBGQlEwRXNVMEZCVDBFc1NVRkJTU3hEUVVGRFN5eExRVUZNTEVkQlFXRk1MRWxCUVVrc1EwRkJRMHdzUzBGQlRDeERRVUZYYzBJc1RVRkJlRUlzU1VGQmEwTjVRaXhMUVVGTExFTkJRVU55UXl4TFFVRk9MRWRCUVdOeFF5eExRVUZMTEVOQlFVTXZReXhMUVVGT0xFTkJRVmx6UWl4TlFVRnVSU3hGUVVFeVJUdEJRVU42UlN4UlFVRkpReXhYUVVGWExFZEJRVWRzUWl4SlFVRkpMRU5CUVVOTUxFdEJRVXdzUTBGQlYwc3NTVUZCU1N4RFFVRkRTeXhMUVVGb1FpeERRVUZzUWp0QlFVRkJMRkZCUTBsMVF5eFpRVUZaTEVkQlFVZEdMRXRCUVVzc1EwRkJReTlETEV0QlFVNHNRMEZCV1N0RExFdEJRVXNzUTBGQlEzSkRMRXRCUVd4Q0xFTkJSRzVDT3p0QlFVZEJMRkZCUVVrc1EwRkJRMkVzVjBGQlZ5eERRVUZETEVOQlFVUXNRMEZCV0N4TFFVRnRRaXhIUVVGdVFpeEpRVUV3UWtFc1YwRkJWeXhEUVVGRExFTkJRVVFzUTBGQldDeExRVUZ0UWl4SFFVRTVReXhOUVVOSk1FSXNXVUZCV1N4RFFVRkRMRU5CUVVRc1EwRkJXaXhMUVVGdlFpeEhRVUZ3UWl4SlFVRXlRa0VzV1VGQldTeERRVUZETEVOQlFVUXNRMEZCV2l4TFFVRnZRaXhIUVVSdVJDeERRVUZLTEVWQlF6WkVPMEZCUXpORU8wRkJRMEZETEUxQlFVRkJMRmxCUVZrc1EwRkJRM0JFTEVsQlFVUXNSVUZCVDA4c1NVRkJVQ3hGUVVGaE1FTXNTMEZCWWl4RFFVRmFPMEZCUTBRc1MwRktSQ3hOUVVsUExFbEJRVWw0UWl4WFFVRlhMRU5CUVVNc1EwRkJSQ3hEUVVGWUxFdEJRVzFDTEVkQlFXNUNMRWxCUVRCQ01FSXNXVUZCV1N4RFFVRkRMRU5CUVVRc1EwRkJXaXhMUVVGdlFpeEhRVUZzUkN4RlFVRjFSRHRCUVVGQk8wRkJRVUU3TzBGQlFVRTdRVUZETlVRN08wRkJRMEU3TzBGQlFVRTdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUZ1UkN4TlFVRkJRU3hKUVVGSkxFTkJRVU5GTEV0QlFVd3NSVUZCVnpSQ0xFbEJRVmc3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGdlFuVkNMRTFCUVVGQkxHRkJRV0VzUTBGQlF6bERMRWxCUVVRc1EwRkJha003UVVGRFJDeExRVWhOTEUxQlIwRXNTVUZCU1RSRExGbEJRVmtzUTBGQlF5eERRVUZFTEVOQlFWb3NTMEZCYjBJc1IwRkJjRUlzU1VGQk1rSXhRaXhYUVVGWExFTkJRVU1zUTBGQlJDeERRVUZZTEV0QlFXMUNMRWRCUVd4RUxFVkJRWFZFTzBGQlFVRTdRVUZCUVRzN1FVRkJRVHRCUVVNMVJEczdRVUZEUVRzN1FVRkJRVHM3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVhwQ0xFMUJRVUZCTEVsQlFVa3NRMEZCUTBVc1MwRkJUQ3hGUVVGWE5FSXNTVUZCV0R0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFXOUNkVUlzVFVGQlFVRXNZVUZCWVN4RFFVRkRTaXhMUVVGRUxFTkJRV3BETzBGQlEwUXNTMEZJVFN4TlFVZEJMRWxCUVVsNFFpeFhRVUZYTEVOQlFVTXNRMEZCUkN4RFFVRllMRXRCUVcxQ0xFZEJRVzVDTEVsQlFUQkNNRUlzV1VGQldTeERRVUZETEVOQlFVUXNRMEZCV2l4TFFVRnZRaXhIUVVGc1JDeEZRVUYxUkR0QlFVTTFSRHRCUVVOQlJ5eE5RVUZCUVN4UFFVRlBMRU5CUVVOMFJDeEpRVUZFTEVWQlFVOVBMRWxCUVZBc1JVRkJZVEJETEV0QlFXSXNRMEZCVUR0QlFVTkVMRXRCU0Uwc1RVRkhRU3hKUVVGSlJTeFpRVUZaTEVOQlFVTXNRMEZCUkN4RFFVRmFMRXRCUVc5Q0xFZEJRWEJDTEVsQlFUSkNNVUlzVjBGQlZ5eERRVUZETEVOQlFVUXNRMEZCV0N4TFFVRnRRaXhIUVVGc1JDeEZRVUYxUkR0QlFVTTFSRHRCUVVOQk5rSXNUVUZCUVVFc1QwRkJUeXhEUVVGRGRFUXNTVUZCUkN4RlFVRlBhVVFzUzBGQlVDeEZRVUZqTVVNc1NVRkJaQ3hGUVVGdlFpeEpRVUZ3UWl4RFFVRlFPMEZCUTBRc1MwRklUU3hOUVVkQkxFbEJRVWxyUWl4WFFVRlhMRXRCUVVzd1FpeFpRVUZ3UWl4RlFVRnJRenRCUVVOMlF6dEJRVU5CYmtRc1RVRkJRVUVzU1VGQlNTeERRVUZEUlN4TFFVRk1MRU5CUVZjMFFpeEpRVUZZTEVOQlFXZENUQ3hYUVVGb1FqdEJRVU5CYkVJc1RVRkJRVUVzU1VGQlNTeERRVUZEU3l4TFFVRk1PMEZCUTBGeFF5eE5RVUZCUVN4TFFVRkxMRU5CUVVOeVF5eExRVUZPTzBGQlEwUXNTMEZNVFN4TlFVdEJPMEZCUTB3N1FVRkRRU3RDTEUxQlFVRkJMRkZCUVZFc1EwRkJRek5ETEVsQlFVUXNSVUZCVDNGRUxHRkJRV0VzUTBGQlF6bERMRWxCUVVRc1EwRkJjRUlzUlVGQk5FSTRReXhoUVVGaExFTkJRVU5LTEV0QlFVUXNRMEZCZWtNc1EwRkJVanRCUVVORU8wRkJRMFlzUjBGNFEzVkZMRU5CTUVONFJUczdPMEZCUTBGTkxFVkJRVUZCTEdOQlFXTXNRMEZCUTNaRUxFbEJRVVFzUlVGQlQwOHNTVUZCVUN4RFFVRmtPMEZCUTBGblJDeEZRVUZCUVN4alFVRmpMRU5CUVVOMlJDeEpRVUZFTEVWQlFVOXBSQ3hMUVVGUUxFTkJRV1E3UVVGRlFXeEVMRVZCUVVGQkxHRkJRV0VzUTBGQlEwTXNTVUZCUkN4RFFVRmlPMEZCUTBRN08wRkJSVVFzVTBGQlUyOUVMRmxCUVZRc1EwRkJjMEp3UkN4SlFVRjBRaXhGUVVFMFFrOHNTVUZCTlVJc1JVRkJhME13UXl4TFFVRnNReXhGUVVGNVF6dEJRVU4yUXl4TlFVRkpUeXhUUVVGVExFZEJRVWRJTEdGQlFXRXNRMEZCUXpsRExFbEJRVVFzUTBGQk4wSTdRVUZCUVN4TlFVTkphMFFzV1VGQldTeEhRVUZIU2l4aFFVRmhMRU5CUVVOS0xFdEJRVVFzUTBGRWFFTTdPMEZCUjBFc1RVRkJTVk1zVlVGQlZTeERRVUZEUml4VFFVRkVMRU5CUVZZc1NVRkJlVUpGTEZWQlFWVXNRMEZCUTBRc1dVRkJSQ3hEUVVGMlF5eEZRVUYxUkR0QlFVTnlSRHRCUVVOQk8wRkJRVWs3UVVGQlFUdEJRVUZCT3p0QlFVRkJSVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJRVHRCUVVGQlFUdEJRVUZCUVR0QlFVRkJPMEZCUVVFc1MwRkJaMEpJTEZOQlFXaENMRVZCUVRKQ1F5eFpRVUV6UWl4TFFVTkhSeXhyUWtGQmEwSXNRMEZCUTFnc1MwRkJSQ3hGUVVGUlR5eFRRVUZTTEVWQlFXMUNRU3hUUVVGVExFTkJRVU5vUXl4TlFVRldMRWRCUVcxQ2FVTXNXVUZCV1N4RFFVRkRha01zVFVGQmJrUXNRMEZFZWtJc1JVRkRjVVk3UVVGQlFUdEJRVUZCT3p0QlFVRkJPenRCUVVOdVJqczdRVUZCUVRzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFYaENMRTFCUVVGQkxFbEJRVWtzUTBGQlEwVXNTMEZCVEN4RlFVRlhORUlzU1VGQldEdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVzlDTUVJc1RVRkJRVUVzVTBGQmNFSTdPMEZCUTBFN1FVRkRSQ3hMUVVwRUxFMUJTVTg3UVVGQlNUdEJRVUZCTzBGQlFVRTdPMEZCUVVGSE8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVFN1FVRkJRU3hMUVVGblFrWXNXVUZCYUVJc1JVRkJPRUpFTEZOQlFUbENMRXRCUTBwSkxHdENRVUZyUWl4RFFVRkRja1FzU1VGQlJDeEZRVUZQYTBRc1dVRkJVQ3hGUVVGeFFrRXNXVUZCV1N4RFFVRkRha01zVFVGQllpeEhRVUZ6UW1kRExGTkJRVk1zUTBGQlEyaERMRTFCUVhKRUxFTkJSR3hDTEVWQlEyZEdPMEZCUVVFN1FVRkJRVHM3UVVGQlFUczdRVUZEY2tZN08wRkJRVUU3TzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVGNFFpeE5RVUZCUVN4SlFVRkpMRU5CUVVORkxFdEJRVXdzUlVGQlZ6UkNMRWxCUVZnN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRnZRakpDTEUxQlFVRkJMRmxCUVhCQ096dEJRVU5CTzBGQlEwUTdRVUZEUml4SFFWaEVMRTFCVjA4N1FVRkJTVHRCUVVGQk8wRkJRVUU3TzBGQlFVRkpPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRkJPMEZCUVVGQk8wRkJRVUZCTzBGQlFVRTdRVUZCUVN4SFFVRlhUQ3hUUVVGWUxFVkJRWE5DUXl4WlFVRjBRaXhEUVVGS0xFVkJRWGxETzBGQlFVRTdRVUZCUVRzN1FVRkJRVHM3UVVGRE9VTTdPMEZCUVVFN08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRjZSQ3hKUVVGQlFTeEpRVUZKTEVOQlFVTkZMRXRCUVV3c1JVRkJWelJDTEVsQlFWZzdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZ2UWpCQ0xFbEJRVUZCTEZOQlFYQkNPenRCUVVOQk8wRkJRMFE3TzBGQlJVUmlMRVZCUVVGQkxGRkJRVkVzUTBGQlF6TkRMRWxCUVVRc1JVRkJUM2RFTEZOQlFWQXNSVUZCYTBKRExGbEJRV3hDTEVOQlFWSTdRVUZEUkRzN1FVRkZSQ3hUUVVGVFNDeFBRVUZVTEVOQlFXbENkRVFzU1VGQmFrSXNSVUZCZFVKUExFbEJRWFpDTEVWQlFUWkNNRU1zUzBGQk4wSXNSVUZCYjBOaExFbEJRWEJETEVWQlFUQkRPMEZCUTNoRExFMUJRVWxPTEZOQlFWTXNSMEZCUjBnc1lVRkJZU3hEUVVGRE9VTXNTVUZCUkN4RFFVRTNRanRCUVVGQkxFMUJRMGxyUkN4WlFVRlpMRWRCUVVkTkxHTkJRV01zUTBGQlEyUXNTMEZCUkN4RlFVRlJUeXhUUVVGU0xFTkJSR3BET3p0QlFVVkJMRTFCUVVsRExGbEJRVmtzUTBGQlEwOHNUVUZCYWtJc1JVRkJlVUk3UVVGQlFUdEJRVUZCT3p0QlFVRkJPenRCUVVOMlFqczdRVUZCUVRzN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFXaEZMRWxCUVVGQkxFbEJRVWtzUTBGQlEwVXNTMEZCVEN4RlFVRlhORUlzU1VGQldEdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVzlDTWtJc1NVRkJRVUVzV1VGQldTeERRVUZEVHl4TlFVRnFRenRCUVVORUxFZEJSa1FzVFVGRlR6dEJRVU5NY2tJc1NVRkJRVUVzVVVGQlVTeERRVUZETTBNc1NVRkJSQ3hGUVVGUE9FUXNTVUZCU1N4SFFVRkhUQ3haUVVGSUxFZEJRV3RDUkN4VFFVRTNRaXhGUVVGM1EwMHNTVUZCU1N4SFFVRkhUaXhUUVVGSUxFZEJRV1ZETEZsQlFUTkVMRU5CUVZJN1FVRkRSRHRCUVVOR096dEJRVVZFTEZOQlFWTmtMRkZCUVZRc1EwRkJhMEl6UXl4SlFVRnNRaXhGUVVGM1FrOHNTVUZCZUVJc1JVRkJPRUl3UXl4TFFVRTVRaXhGUVVGeFF6dEJRVU51UTJwRUxFVkJRVUZCTEVsQlFVa3NRMEZCUXpKRExGRkJRVXdzUjBGQlowSXNTVUZCYUVJN1FVRkRRVE5ETEVWQlFVRkJMRWxCUVVrc1EwRkJRMFVzUzBGQlRDeERRVUZYTkVJc1NVRkJXQ3hEUVVGblFqdEJRVU5rWVN4SlFVRkJRU3hSUVVGUkxFVkJRVVVzU1VGRVNUdEJRVVZrY0VNc1NVRkJRVUVzU1VGQlNTeEZRVUZGUVN4SlFVWlJPMEZCUjJSRExFbEJRVUZCTEUxQlFVMHNSVUZCUlhsRE8wRkJTRTBzUjBGQmFFSTdRVUZMUkRzN1FVRkZSQ3hUUVVGVFF5eGhRVUZVTEVOQlFYVkNiRVFzU1VGQmRrSXNSVUZCTmtKcFJTeE5RVUUzUWl4RlFVRnhRMmhDTEV0QlFYSkRMRVZCUVRSRE8wRkJRekZETEZOQlFVOW5RaXhOUVVGTkxFTkJRVU53UWl4TlFVRlFMRWRCUVdkQ1NTeExRVUZMTEVOQlFVTktMRTFCUVhSQ0xFbEJRV2REYjBJc1RVRkJUU3hEUVVGRGNrUXNTMEZCVUN4SFFVRmxjVVFzVFVGQlRTeERRVUZETDBRc1MwRkJVQ3hEUVVGaGMwSXNUVUZCYmtVc1JVRkJNa1U3UVVGRGVrVXNVVUZCU1RCRExFbEJRVWtzUjBGQlIwUXNUVUZCVFN4RFFVRkRMMFFzUzBGQlVDeERRVUZoSzBRc1RVRkJUU3hEUVVGRGNrUXNTMEZCVUN4RlFVRmlMRU5CUVZnN1FVRkRRVm9zU1VGQlFVRXNTVUZCU1N4RFFVRkRSU3hMUVVGTUxFTkJRVmMwUWl4SlFVRllMRU5CUVdkQ2IwTXNTVUZCYUVJN1FVRkRRVVFzU1VGQlFVRXNUVUZCVFN4RFFVRkRjRUlzVFVGQlVEdEJRVU5FTzBGQlEwWTdPMEZCUTBRc1UwRkJVMVVzWTBGQlZDeERRVUYzUW5aRUxFbEJRWGhDTEVWQlFUaENhVVVzVFVGQk9VSXNSVUZCYzBNN1FVRkRjRU1zVTBGQlQwRXNUVUZCVFN4RFFVRkRja1FzUzBGQlVDeEhRVUZsY1VRc1RVRkJUU3hEUVVGREwwUXNTMEZCVUN4RFFVRmhjMElzVFVGQmJrTXNSVUZCTWtNN1FVRkRla01zVVVGQlNUQkRMRWxCUVVrc1IwRkJSMFFzVFVGQlRTeERRVUZETDBRc1MwRkJVQ3hEUVVGaEswUXNUVUZCVFN4RFFVRkRja1FzUzBGQlVDeEZRVUZpTEVOQlFWZzdRVUZEUVZvc1NVRkJRVUVzU1VGQlNTeERRVUZEUlN4TFFVRk1MRU5CUVZjMFFpeEpRVUZZTEVOQlFXZENiME1zU1VGQmFFSTdRVUZEUkR0QlFVTkdPenRCUVVWRUxGTkJRVk5pTEdGQlFWUXNRMEZCZFVKakxFdEJRWFpDTEVWQlFUaENPMEZCUXpWQ0xFMUJRVWw0UkN4SFFVRkhMRWRCUVVjc1JVRkJWanRCUVVGQkxFMUJRMGw1UkN4VFFVRlRMRWRCUVVkRUxFdEJRVXNzUTBGQlEycEZMRXRCUVU0c1EwRkJXV2xGTEV0QlFVc3NRMEZCUTNaRUxFdEJRV3hDTEVWQlFYbENMRU5CUVhwQ0xFTkJSR2hDT3p0QlFVVkJMRk5CUVU5MVJDeExRVUZMTEVOQlFVTjJSQ3hMUVVGT0xFZEJRV04xUkN4TFFVRkxMRU5CUVVOcVJTeExRVUZPTEVOQlFWbHpRaXhOUVVGcVF5eEZRVUY1UXp0QlFVTjJReXhSUVVGSk1FTXNTVUZCU1N4SFFVRkhReXhMUVVGTExFTkJRVU5xUlN4TFFVRk9MRU5CUVZscFJTeExRVUZMTEVOQlFVTjJSQ3hMUVVGc1FpeERRVUZZTEVOQlJIVkRMRU5CUjNaRE96dEJRVU5CTEZGQlFVbDNSQ3hUUVVGVExFdEJRVXNzUjBGQlpDeEpRVUZ4UWtZc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQlNpeExRVUZaTEVkQlFYSkRMRVZCUVRCRE8wRkJRM2hEUlN4TlFVRkJRU3hUUVVGVExFZEJRVWNzUjBGQldqdEJRVU5FT3p0QlFVVkVMRkZCUVVsQkxGTkJRVk1zUzBGQlMwWXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJkRUlzUlVGQk1rSTdRVUZEZWtKMlJDeE5RVUZCUVN4SFFVRkhMRU5CUVVOdFFpeEpRVUZLTEVOQlFWTnZReXhKUVVGVU8wRkJRMEZETEUxQlFVRkJMRXRCUVVzc1EwRkJRM1pFTEV0QlFVNDdRVUZEUkN4TFFVaEVMRTFCUjA4N1FVRkRURHRCUVVORU8wRkJRMFk3TzBGQlJVUXNVMEZCVDBRc1IwRkJVRHRCUVVORU96dEJRVU5FTEZOQlFWTnZSQ3hqUVVGVUxFTkJRWGRDU1N4TFFVRjRRaXhGUVVFclFrVXNXVUZCTDBJc1JVRkJOa003UVVGRE0wTXNUVUZCU1VNc1QwRkJUeXhIUVVGSExFVkJRV1E3UVVGQlFTeE5RVU5KVGl4TlFVRk5MRWRCUVVjc1JVRkVZanRCUVVGQkxFMUJSVWxQTEZWQlFWVXNSMEZCUnl4RFFVWnFRanRCUVVGQkxFMUJSMGxETEdOQlFXTXNSMEZCUnl4TFFVaHlRanRCUVVGQkxFMUJTVWxETEZWQlFWVXNSMEZCUnl4TFFVcHFRanM3UVVGTFFTeFRRVUZQUml4VlFVRlZMRWRCUVVkR0xGbEJRVmtzUTBGQlF6ZERMRTFCUVRGQ0xFbEJRMFV5UXl4TFFVRkxMRU5CUVVOMlJDeExRVUZPTEVkQlFXTjFSQ3hMUVVGTExFTkJRVU5xUlN4TFFVRk9MRU5CUVZselFpeE5RVVJ1UXl4RlFVTXlRenRCUVVONlF5eFJRVUZKYTBRc1RVRkJUU3hIUVVGSFVDeExRVUZMTEVOQlFVTnFSU3hMUVVGT0xFTkJRVmxwUlN4TFFVRkxMRU5CUVVOMlJDeExRVUZzUWl4RFFVRmlPMEZCUVVFc1VVRkRTU3RFTEV0QlFVc3NSMEZCUjA0c1dVRkJXU3hEUVVGRFJTeFZRVUZFTEVOQlJIaENMRU5CUkhsRExFTkJTWHBET3p0QlFVTkJMRkZCUVVsSkxFdEJRVXNzUTBGQlF5eERRVUZFTEVOQlFVd3NTMEZCWVN4SFFVRnFRaXhGUVVGelFqdEJRVU53UWp0QlFVTkVPenRCUVVWRVNDeEpRVUZCUVN4alFVRmpMRWRCUVVkQkxHTkJRV01zU1VGQlNVVXNUVUZCVFN4RFFVRkRMRU5CUVVRc1EwRkJUaXhMUVVGakxFZEJRV3BFTzBGQlJVRldMRWxCUVVGQkxFMUJRVTBzUTBGQlEyeERMRWxCUVZBc1EwRkJXVFpETEV0QlFWbzdRVUZEUVVvc1NVRkJRVUVzVlVGQlZTeEhRVm9yUWl4RFFXTjZRenRCUVVOQk96dEJRVU5CTEZGQlFVbEhMRTFCUVUwc1EwRkJReXhEUVVGRUxFTkJRVTRzUzBGQll5eEhRVUZzUWl4RlFVRjFRanRCUVVOeVFrUXNUVUZCUVVFc1ZVRkJWU3hIUVVGSExFbEJRV0k3TzBGQlJVRXNZVUZCVDBNc1RVRkJUU3hEUVVGRExFTkJRVVFzUTBGQlRpeExRVUZqTEVkQlFYSkNMRVZCUVRCQ08wRkJRM2hDU2l4UlFVRkJRU3hQUVVGUExFTkJRVU40UXl4SlFVRlNMRU5CUVdFMFF5eE5RVUZpTzBGQlEwRkJMRkZCUVVGQkxFMUJRVTBzUjBGQlIxQXNTMEZCU3l4RFFVRkRha1VzUzBGQlRpeERRVUZaTEVWQlFVVnBSU3hMUVVGTExFTkJRVU4yUkN4TFFVRndRaXhEUVVGVU8wRkJRMFE3UVVGRFJqczdRVUZGUkN4UlFVRkpLMFFzUzBGQlN5eERRVUZEUXl4TlFVRk9MRU5CUVdFc1EwRkJZaXhOUVVGdlFrWXNUVUZCVFN4RFFVRkRSU3hOUVVGUUxFTkJRV01zUTBGQlpDeERRVUY0UWl4RlFVRXdRenRCUVVONFEwNHNUVUZCUVVFc1QwRkJUeXhEUVVGRGVFTXNTVUZCVWl4RFFVRmhORU1zVFVGQllqdEJRVU5CVUN4TlFVRkJRU3hMUVVGTExFTkJRVU4yUkN4TFFVRk9PMEZCUTBRc1MwRklSQ3hOUVVkUE8wRkJRMHcyUkN4TlFVRkJRU3hWUVVGVkxFZEJRVWNzU1VGQllqdEJRVU5FTzBGQlEwWTdPMEZCUlVRc1RVRkJTU3hEUVVGRFNpeFpRVUZaTEVOQlFVTkZMRlZCUVVRc1EwRkJXaXhKUVVFMFFpeEZRVUUzUWl4RlFVRnBReXhEUVVGcVF5eE5RVUYzUXl4SFFVRjRReXhKUVVOSFF5eGpRVVJRTEVWQlEzVkNPMEZCUTNKQ1F5eEpRVUZCUVN4VlFVRlZMRWRCUVVjc1NVRkJZanRCUVVORU96dEJRVVZFTEUxQlFVbEJMRlZCUVVvc1JVRkJaMEk3UVVGRFpDeFhRVUZQU0N4UFFVRlFPMEZCUTBRN08wRkJSVVFzVTBGQlQwTXNWVUZCVlN4SFFVRkhSaXhaUVVGWkxFTkJRVU0zUXl4TlFVRnFReXhGUVVGNVF6dEJRVU4yUTNkRExFbEJRVUZCTEUxQlFVMHNRMEZCUTJ4RExFbEJRVkFzUTBGQldYVkRMRmxCUVZrc1EwRkJRMFVzVlVGQlZTeEZRVUZZTEVOQlFYaENPMEZCUTBRN08wRkJSVVFzVTBGQlR6dEJRVU5NVUN4SlFVRkJRU3hOUVVGTkxFVkJRVTVCTEUxQlJFczdRVUZGVEUwc1NVRkJRVUVzVDBGQlR5eEZRVUZRUVR0QlFVWkxMRWRCUVZBN1FVRkpSRHM3UVVGRlJDeFRRVUZUV2l4VlFVRlVMRU5CUVc5Q1dTeFBRVUZ3UWl4RlFVRTJRanRCUVVNelFpeFRRVUZQUVN4UFFVRlBMRU5CUVVOUExFMUJRVklzUTBGQlpTeFZRVUZUUXl4SlFVRlVMRVZCUVdWS0xFMUJRV1lzUlVGQmRVSTdRVUZETTBNc1YwRkJUMGtzU1VGQlNTeEpRVUZKU2l4TlFVRk5MRU5CUVVNc1EwRkJSQ3hEUVVGT0xFdEJRV01zUjBGQk4wSTdRVUZEUkN4SFFVWk5MRVZCUlVvc1NVRkdTU3hEUVVGUU8wRkJSMFE3TzBGQlEwUXNVMEZCVTJRc2EwSkJRVlFzUTBGQk5FSlBMRXRCUVRWQ0xFVkJRVzFEV1N4aFFVRnVReXhGUVVGclJFTXNTMEZCYkVRc1JVRkJlVVE3UVVGRGRrUXNUMEZCU3l4SlFVRkpReXhEUVVGRExFZEJRVWNzUTBGQllpeEZRVUZuUWtFc1EwRkJReXhIUVVGSFJDeExRVUZ3UWl4RlFVRXlRa01zUTBGQlF5eEZRVUUxUWl4RlFVRm5RenRCUVVNNVFpeFJRVUZKUXl4aFFVRmhMRWRCUVVkSUxHRkJRV0VzUTBGQlEwRXNZVUZCWVN4RFFVRkRka1FzVFVGQlpDeEhRVUYxUW5kRUxFdEJRWFpDTEVkQlFTdENReXhEUVVGb1F5eERRVUZpTEVOQlFXZEVUQ3hOUVVGb1JDeERRVUYxUkN4RFFVRjJSQ3hEUVVGd1FqczdRVUZEUVN4UlFVRkpWQ3hMUVVGTExFTkJRVU5xUlN4TFFVRk9MRU5CUVZscFJTeExRVUZMTEVOQlFVTjJSQ3hMUVVGT0xFZEJRV054UlN4RFFVRXhRaXhOUVVGcFF5eE5RVUZOUXl4aFFVRXpReXhGUVVFd1JEdEJRVU40UkN4aFFVRlBMRXRCUVZBN1FVRkRSRHRCUVVOR096dEJRVVZFWml4RlFVRkJRU3hMUVVGTExFTkJRVU4yUkN4TFFVRk9MRWxCUVdWdlJTeExRVUZtTzBGQlEwRXNVMEZCVHl4SlFVRlFPMEZCUTBRN08wRkJSVVFzVTBGQlV5OUZMRzFDUVVGVUxFTkJRVFpDUXl4TFFVRTNRaXhGUVVGdlF6dEJRVU5zUXl4TlFVRkpReXhSUVVGUkxFZEJRVWNzUTBGQlpqdEJRVU5CTEUxQlFVbERMRkZCUVZFc1IwRkJSeXhEUVVGbU8wRkJSVUZHTEVWQlFVRkJMRXRCUVVzc1EwRkJRMmxHTEU5QlFVNHNRMEZCWXl4VlFVRlRha0lzU1VGQlZDeEZRVUZsTzBGQlF6TkNMRkZCUVVrc1QwRkJUMEVzU1VGQlVDeExRVUZuUWl4UlFVRndRaXhGUVVFNFFqdEJRVU0xUWl4VlFVRkphMElzVDBGQlR5eEhRVUZIYmtZc2JVSkJRVzFDTEVOQlFVTnBSU3hKUVVGSkxFTkJRVU16UkN4SlFVRk9MRU5CUVdwRE8wRkJRMEVzVlVGQlNUaEZMRlZCUVZVc1IwRkJSM0JHTEcxQ1FVRnRRaXhEUVVGRGFVVXNTVUZCU1N4RFFVRkRNVVFzVFVGQlRpeERRVUZ3UXpzN1FVRkZRU3hWUVVGSlRDeFJRVUZSTEV0QlFVdEZMRk5CUVdwQ0xFVkJRVFJDTzBGQlF6RkNMRmxCUVVrclJTeFBRVUZQTEVOQlFVTnFSaXhSUVVGU0xFdEJRWEZDYTBZc1ZVRkJWU3hEUVVGRGJFWXNVVUZCY0VNc1JVRkJPRU03UVVGRE5VTkJMRlZCUVVGQkxGRkJRVkVzU1VGQlNXbEdMRTlCUVU4c1EwRkJRMnBHTEZGQlFYQkNPMEZCUTBRc1UwRkdSQ3hOUVVWUE8wRkJRMHhCTEZWQlFVRkJMRkZCUVZFc1IwRkJSMFVzVTBGQldEdEJRVU5FTzBGQlEwWTdPMEZCUlVRc1ZVRkJTVVFzVVVGQlVTeExRVUZMUXl4VFFVRnFRaXhGUVVFMFFqdEJRVU14UWl4WlFVRkpLMFVzVDBGQlR5eERRVUZEYUVZc1VVRkJVaXhMUVVGeFFtbEdMRlZCUVZVc1EwRkJRMnBHTEZGQlFYQkRMRVZCUVRoRE8wRkJRelZEUVN4VlFVRkJRU3hSUVVGUkxFbEJRVWxuUml4UFFVRlBMRU5CUVVOb1JpeFJRVUZ3UWp0QlFVTkVMRk5CUmtRc1RVRkZUenRCUVVOTVFTeFZRVUZCUVN4UlFVRlJMRWRCUVVkRExGTkJRVmc3UVVGRFJEdEJRVU5HTzBGQlEwWXNTMEZ1UWtRc1RVRnRRazg3UVVGRFRDeFZRVUZKUkN4UlFVRlJMRXRCUVV0RExGTkJRV0lzUzBGQk1rSTJSQ3hKUVVGSkxFTkJRVU1zUTBGQlJDeERRVUZLTEV0QlFWa3NSMEZCV2l4SlFVRnRRa0VzU1VGQlNTeERRVUZETEVOQlFVUXNRMEZCU2l4TFFVRlpMRWRCUVRGRUxFTkJRVW9zUlVGQmIwVTdRVUZEYkVVNVJDeFJRVUZCUVN4UlFVRlJPMEZCUTFRN08wRkJRMFFzVlVGQlNVUXNVVUZCVVN4TFFVRkxSU3hUUVVGaUxFdEJRVEpDTmtRc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQlNpeExRVUZaTEVkQlFWb3NTVUZCYlVKQkxFbEJRVWtzUTBGQlF5eERRVUZFTEVOQlFVb3NTMEZCV1N4SFFVRXhSQ3hEUVVGS0xFVkJRVzlGTzBGQlEyeEZMMFFzVVVGQlFVRXNVVUZCVVR0QlFVTlVPMEZCUTBZN1FVRkRSaXhIUVRWQ1JEdEJRVGhDUVN4VFFVRlBPMEZCUVVOQkxFbEJRVUZCTEZGQlFWRXNSVUZCVWtFc1VVRkJSRHRCUVVGWFF5eEpRVUZCUVN4UlFVRlJMRVZCUVZKQk8wRkJRVmdzUjBGQlVEdEJRVU5FSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaWFXMXdiM0owSUh0emRISjFZM1IxY21Wa1VHRjBZMmg5SUdaeWIyMGdKeTR2WTNKbFlYUmxKenRjYm1sdGNHOXlkQ0I3Y0dGeWMyVlFZWFJqYUgwZ1puSnZiU0FuTGk5d1lYSnpaU2M3WEc1Y2JtbHRjRzl5ZENCN1lYSnlZWGxGY1hWaGJDd2dZWEp5WVhsVGRHRnlkSE5YYVhSb2ZTQm1jbTl0SUNjdUxpOTFkR2xzTDJGeWNtRjVKenRjYmx4dVpYaHdiM0owSUdaMWJtTjBhVzl1SUdOaGJHTk1hVzVsUTI5MWJuUW9hSFZ1YXlrZ2UxeHVJQ0JqYjI1emRDQjdiMnhrVEdsdVpYTXNJRzVsZDB4cGJtVnpmU0E5SUdOaGJHTlBiR1JPWlhkTWFXNWxRMjkxYm5Rb2FIVnVheTVzYVc1bGN5azdYRzVjYmlBZ2FXWWdLRzlzWkV4cGJtVnpJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNCb2RXNXJMbTlzWkV4cGJtVnpJRDBnYjJ4a1RHbHVaWE03WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnWkdWc1pYUmxJR2gxYm1zdWIyeGtUR2x1WlhNN1hHNGdJSDFjYmx4dUlDQnBaaUFvYm1WM1RHbHVaWE1nSVQwOUlIVnVaR1ZtYVc1bFpDa2dlMXh1SUNBZ0lHaDFibXN1Ym1WM1RHbHVaWE1nUFNCdVpYZE1hVzVsY3p0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCa1pXeGxkR1VnYUhWdWF5NXVaWGRNYVc1bGN6dGNiaUFnZlZ4dWZWeHVYRzVsZUhCdmNuUWdablZ1WTNScGIyNGdiV1Z5WjJVb2JXbHVaU3dnZEdobGFYSnpMQ0JpWVhObEtTQjdYRzRnSUcxcGJtVWdQU0JzYjJGa1VHRjBZMmdvYldsdVpTd2dZbUZ6WlNrN1hHNGdJSFJvWldseWN5QTlJR3h2WVdSUVlYUmphQ2gwYUdWcGNuTXNJR0poYzJVcE8xeHVYRzRnSUd4bGRDQnlaWFFnUFNCN2ZUdGNibHh1SUNBdkx5QkdiM0lnYVc1a1pYZ2dkMlVnYW5WemRDQnNaWFFnYVhRZ2NHRnpjeUIwYUhKdmRXZG9JR0Z6SUdsMElHUnZaWE51SjNRZ2FHRjJaU0JoYm5rZ2JtVmpaWE56WVhKNUlHMWxZVzVwYm1jdVhHNGdJQzh2SUV4bFlYWnBibWNnYzJGdWFYUjVJR05vWldOcmN5QnZiaUIwYUdseklIUnZJSFJvWlNCQlVFa2dZMjl1YzNWdFpYSWdkR2hoZENCdFlYa2dhMjV2ZHlCdGIzSmxJR0ZpYjNWMElIUm9aVnh1SUNBdkx5QnRaV0Z1YVc1bklHbHVJSFJvWldseUlHOTNiaUJqYjI1MFpYaDBMbHh1SUNCcFppQW9iV2x1WlM1cGJtUmxlQ0I4ZkNCMGFHVnBjbk11YVc1a1pYZ3BJSHRjYmlBZ0lDQnlaWFF1YVc1a1pYZ2dQU0J0YVc1bExtbHVaR1Y0SUh4OElIUm9aV2x5Y3k1cGJtUmxlRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHRhVzVsTG01bGQwWnBiR1ZPWVcxbElIeDhJSFJvWldseWN5NXVaWGRHYVd4bFRtRnRaU2tnZTF4dUlDQWdJR2xtSUNnaFptbHNaVTVoYldWRGFHRnVaMlZrS0cxcGJtVXBLU0I3WEc0Z0lDQWdJQ0F2THlCT2J5Qm9aV0ZrWlhJZ2IzSWdibThnWTJoaGJtZGxJR2x1SUc5MWNuTXNJSFZ6WlNCMGFHVnBjbk1nS0dGdVpDQnZkWEp6SUdsbUlIUm9aV2x5Y3lCa2IyVnpJRzV2ZENCbGVHbHpkQ2xjYmlBZ0lDQWdJSEpsZEM1dmJHUkdhV3hsVG1GdFpTQTlJSFJvWldseWN5NXZiR1JHYVd4bFRtRnRaU0I4ZkNCdGFXNWxMbTlzWkVacGJHVk9ZVzFsTzF4dUlDQWdJQ0FnY21WMExtNWxkMFpwYkdWT1lXMWxJRDBnZEdobGFYSnpMbTVsZDBacGJHVk9ZVzFsSUh4OElHMXBibVV1Ym1WM1JtbHNaVTVoYldVN1hHNGdJQ0FnSUNCeVpYUXViMnhrU0dWaFpHVnlJRDBnZEdobGFYSnpMbTlzWkVobFlXUmxjaUI4ZkNCdGFXNWxMbTlzWkVobFlXUmxjanRjYmlBZ0lDQWdJSEpsZEM1dVpYZElaV0ZrWlhJZ1BTQjBhR1ZwY25NdWJtVjNTR1ZoWkdWeUlIeDhJRzFwYm1VdWJtVjNTR1ZoWkdWeU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb0lXWnBiR1ZPWVcxbFEyaGhibWRsWkNoMGFHVnBjbk1wS1NCN1hHNGdJQ0FnSUNBdkx5Qk9ieUJvWldGa1pYSWdiM0lnYm04Z1kyaGhibWRsSUdsdUlIUm9aV2x5Y3l3Z2RYTmxJRzkxY25OY2JpQWdJQ0FnSUhKbGRDNXZiR1JHYVd4bFRtRnRaU0E5SUcxcGJtVXViMnhrUm1sc1pVNWhiV1U3WEc0Z0lDQWdJQ0J5WlhRdWJtVjNSbWxzWlU1aGJXVWdQU0J0YVc1bExtNWxkMFpwYkdWT1lXMWxPMXh1SUNBZ0lDQWdjbVYwTG05c1pFaGxZV1JsY2lBOUlHMXBibVV1YjJ4a1NHVmhaR1Z5TzF4dUlDQWdJQ0FnY21WMExtNWxkMGhsWVdSbGNpQTlJRzFwYm1VdWJtVjNTR1ZoWkdWeU8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0F2THlCQ2IzUm9JR05vWVc1blpXUXVMaTRnWm1sbmRYSmxJR2wwSUc5MWRGeHVJQ0FnSUNBZ2NtVjBMbTlzWkVacGJHVk9ZVzFsSUQwZ2MyVnNaV04wUm1sbGJHUW9jbVYwTENCdGFXNWxMbTlzWkVacGJHVk9ZVzFsTENCMGFHVnBjbk11YjJ4a1JtbHNaVTVoYldVcE8xeHVJQ0FnSUNBZ2NtVjBMbTVsZDBacGJHVk9ZVzFsSUQwZ2MyVnNaV04wUm1sbGJHUW9jbVYwTENCdGFXNWxMbTVsZDBacGJHVk9ZVzFsTENCMGFHVnBjbk11Ym1WM1JtbHNaVTVoYldVcE8xeHVJQ0FnSUNBZ2NtVjBMbTlzWkVobFlXUmxjaUE5SUhObGJHVmpkRVpwWld4a0tISmxkQ3dnYldsdVpTNXZiR1JJWldGa1pYSXNJSFJvWldseWN5NXZiR1JJWldGa1pYSXBPMXh1SUNBZ0lDQWdjbVYwTG01bGQwaGxZV1JsY2lBOUlITmxiR1ZqZEVacFpXeGtLSEpsZEN3Z2JXbHVaUzV1WlhkSVpXRmtaWElzSUhSb1pXbHljeTV1WlhkSVpXRmtaWElwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRDNW9kVzVyY3lBOUlGdGRPMXh1WEc0Z0lHeGxkQ0J0YVc1bFNXNWtaWGdnUFNBd0xGeHVJQ0FnSUNBZ2RHaGxhWEp6U1c1a1pYZ2dQU0F3TEZ4dUlDQWdJQ0FnYldsdVpVOW1abk5sZENBOUlEQXNYRzRnSUNBZ0lDQjBhR1ZwY25OUFptWnpaWFFnUFNBd08xeHVYRzRnSUhkb2FXeGxJQ2h0YVc1bFNXNWtaWGdnUENCdGFXNWxMbWgxYm10ekxteGxibWQwYUNCOGZDQjBhR1ZwY25OSmJtUmxlQ0E4SUhSb1pXbHljeTVvZFc1cmN5NXNaVzVuZEdncElIdGNiaUFnSUNCc1pYUWdiV2x1WlVOMWNuSmxiblFnUFNCdGFXNWxMbWgxYm10elcyMXBibVZKYm1SbGVGMGdmSHdnZTI5c1pGTjBZWEowT2lCSmJtWnBibWwwZVgwc1hHNGdJQ0FnSUNBZ0lIUm9aV2x5YzBOMWNuSmxiblFnUFNCMGFHVnBjbk11YUhWdWEzTmJkR2hsYVhKelNXNWtaWGhkSUh4OElIdHZiR1JUZEdGeWREb2dTVzVtYVc1cGRIbDlPMXh1WEc0Z0lDQWdhV1lnS0doMWJtdENaV1p2Y21Vb2JXbHVaVU4xY25KbGJuUXNJSFJvWldseWMwTjFjbkpsYm5RcEtTQjdYRzRnSUNBZ0lDQXZMeUJVYUdseklIQmhkR05vSUdSdlpYTWdibTkwSUc5MlpYSnNZWEFnZDJsMGFDQmhibmtnYjJZZ2RHaGxJRzkwYUdWeWN5d2dlV0Y1TGx4dUlDQWdJQ0FnY21WMExtaDFibXR6TG5CMWMyZ29ZMnh2Ym1WSWRXNXJLRzFwYm1WRGRYSnlaVzUwTENCdGFXNWxUMlptYzJWMEtTazdYRzRnSUNBZ0lDQnRhVzVsU1c1a1pYZ3JLenRjYmlBZ0lDQWdJSFJvWldseWMwOW1abk5sZENBclBTQnRhVzVsUTNWeWNtVnVkQzV1WlhkTWFXNWxjeUF0SUcxcGJtVkRkWEp5Wlc1MExtOXNaRXhwYm1Wek8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FIVnVhMEpsWm05eVpTaDBhR1ZwY25ORGRYSnlaVzUwTENCdGFXNWxRM1Z5Y21WdWRDa3BJSHRjYmlBZ0lDQWdJQzh2SUZSb2FYTWdjR0YwWTJnZ1pHOWxjeUJ1YjNRZ2IzWmxjbXhoY0NCM2FYUm9JR0Z1ZVNCdlppQjBhR1VnYjNSb1pYSnpMQ0I1WVhrdVhHNGdJQ0FnSUNCeVpYUXVhSFZ1YTNNdWNIVnphQ2hqYkc5dVpVaDFibXNvZEdobGFYSnpRM1Z5Y21WdWRDd2dkR2hsYVhKelQyWm1jMlYwS1NrN1hHNGdJQ0FnSUNCMGFHVnBjbk5KYm1SbGVDc3JPMXh1SUNBZ0lDQWdiV2x1WlU5bVpuTmxkQ0FyUFNCMGFHVnBjbk5EZFhKeVpXNTBMbTVsZDB4cGJtVnpJQzBnZEdobGFYSnpRM1Z5Y21WdWRDNXZiR1JNYVc1bGN6dGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnTHk4Z1QzWmxjbXhoY0N3Z2JXVnlaMlVnWVhNZ1ltVnpkQ0IzWlNCallXNWNiaUFnSUNBZ0lHeGxkQ0J0WlhKblpXUklkVzVySUQwZ2UxeHVJQ0FnSUNBZ0lDQnZiR1JUZEdGeWREb2dUV0YwYUM1dGFXNG9iV2x1WlVOMWNuSmxiblF1YjJ4a1UzUmhjblFzSUhSb1pXbHljME4xY25KbGJuUXViMnhrVTNSaGNuUXBMRnh1SUNBZ0lDQWdJQ0J2YkdSTWFXNWxjem9nTUN4Y2JpQWdJQ0FnSUNBZ2JtVjNVM1JoY25RNklFMWhkR2d1YldsdUtHMXBibVZEZFhKeVpXNTBMbTVsZDFOMFlYSjBJQ3NnYldsdVpVOW1abk5sZEN3Z2RHaGxhWEp6UTNWeWNtVnVkQzV2YkdSVGRHRnlkQ0FySUhSb1pXbHljMDltWm5ObGRDa3NYRzRnSUNBZ0lDQWdJRzVsZDB4cGJtVnpPaUF3TEZ4dUlDQWdJQ0FnSUNCc2FXNWxjem9nVzExY2JpQWdJQ0FnSUgwN1hHNGdJQ0FnSUNCdFpYSm5aVXhwYm1WektHMWxjbWRsWkVoMWJtc3NJRzFwYm1WRGRYSnlaVzUwTG05c1pGTjBZWEowTENCdGFXNWxRM1Z5Y21WdWRDNXNhVzVsY3l3Z2RHaGxhWEp6UTNWeWNtVnVkQzV2YkdSVGRHRnlkQ3dnZEdobGFYSnpRM1Z5Y21WdWRDNXNhVzVsY3lrN1hHNGdJQ0FnSUNCMGFHVnBjbk5KYm1SbGVDc3JPMXh1SUNBZ0lDQWdiV2x1WlVsdVpHVjRLeXM3WEc1Y2JpQWdJQ0FnSUhKbGRDNW9kVzVyY3k1d2RYTm9LRzFsY21kbFpFaDFibXNwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJ5WlhRN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUd4dllXUlFZWFJqYUNod1lYSmhiU3dnWW1GelpTa2dlMXh1SUNCcFppQW9kSGx3Wlc5bUlIQmhjbUZ0SUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lHbG1JQ2dvTDE1QVFDOXRLUzUwWlhOMEtIQmhjbUZ0S1NCOGZDQW9LQzllU1c1a1pYZzZMMjBwTG5SbGMzUW9jR0Z5WVcwcEtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIQmhjbk5sVUdGMFkyZ29jR0Z5WVcwcFd6QmRPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2doWW1GelpTa2dlMXh1SUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZE5kWE4wSUhCeWIzWnBaR1VnWVNCaVlYTmxJSEpsWm1WeVpXNWpaU0J2Y2lCd1lYTnpJR2x1SUdFZ2NHRjBZMmduS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlITjBjblZqZEhWeVpXUlFZWFJqYUNoMWJtUmxabWx1WldRc0lIVnVaR1ZtYVc1bFpDd2dZbUZ6WlN3Z2NHRnlZVzBwTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhCaGNtRnRPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm1hV3hsVG1GdFpVTm9ZVzVuWldRb2NHRjBZMmdwSUh0Y2JpQWdjbVYwZFhKdUlIQmhkR05vTG01bGQwWnBiR1ZPWVcxbElDWW1JSEJoZEdOb0xtNWxkMFpwYkdWT1lXMWxJQ0U5UFNCd1lYUmphQzV2YkdSR2FXeGxUbUZ0WlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnYzJWc1pXTjBSbWxsYkdRb2FXNWtaWGdzSUcxcGJtVXNJSFJvWldseWN5a2dlMXh1SUNCcFppQW9iV2x1WlNBOVBUMGdkR2hsYVhKektTQjdYRzRnSUNBZ2NtVjBkWEp1SUcxcGJtVTdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhVzVrWlhndVkyOXVabXhwWTNRZ1BTQjBjblZsTzF4dUlDQWdJSEpsZEhWeWJpQjdiV2x1WlN3Z2RHaGxhWEp6ZlR0Y2JpQWdmVnh1ZlZ4dVhHNW1kVzVqZEdsdmJpQm9kVzVyUW1WbWIzSmxLSFJsYzNRc0lHTm9aV05yS1NCN1hHNGdJSEpsZEhWeWJpQjBaWE4wTG05c1pGTjBZWEowSUR3Z1kyaGxZMnN1YjJ4a1UzUmhjblJjYmlBZ0lDQW1KaUFvZEdWemRDNXZiR1JUZEdGeWRDQXJJSFJsYzNRdWIyeGtUR2x1WlhNcElEd2dZMmhsWTJzdWIyeGtVM1JoY25RN1hHNTlYRzVjYm1aMWJtTjBhVzl1SUdOc2IyNWxTSFZ1YXlob2RXNXJMQ0J2Wm1aelpYUXBJSHRjYmlBZ2NtVjBkWEp1SUh0Y2JpQWdJQ0J2YkdSVGRHRnlkRG9nYUhWdWF5NXZiR1JUZEdGeWRDd2diMnhrVEdsdVpYTTZJR2gxYm1zdWIyeGtUR2x1WlhNc1hHNGdJQ0FnYm1WM1UzUmhjblE2SUdoMWJtc3VibVYzVTNSaGNuUWdLeUJ2Wm1aelpYUXNJRzVsZDB4cGJtVnpPaUJvZFc1ckxtNWxkMHhwYm1WekxGeHVJQ0FnSUd4cGJtVnpPaUJvZFc1ckxteHBibVZ6WEc0Z0lIMDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHMWxjbWRsVEdsdVpYTW9hSFZ1YXl3Z2JXbHVaVTltWm5ObGRDd2diV2x1WlV4cGJtVnpMQ0IwYUdWcGNrOW1abk5sZEN3Z2RHaGxhWEpNYVc1bGN5a2dlMXh1SUNBdkx5QlVhR2x6SUhkcGJHd2daMlZ1WlhKaGJHeDVJSEpsYzNWc2RDQnBiaUJoSUdOdmJtWnNhV04wWldRZ2FIVnVheXdnWW5WMElIUm9aWEpsSUdGeVpTQmpZWE5sY3lCM2FHVnlaU0IwYUdVZ1kyOXVkR1Y0ZEZ4dUlDQXZMeUJwY3lCMGFHVWdiMjVzZVNCdmRtVnliR0Z3SUhkb1pYSmxJSGRsSUdOaGJpQnpkV05qWlhOelpuVnNiSGtnYldWeVoyVWdkR2hsSUdOdmJuUmxiblFnYUdWeVpTNWNiaUFnYkdWMElHMXBibVVnUFNCN2IyWm1jMlYwT2lCdGFXNWxUMlptYzJWMExDQnNhVzVsY3pvZ2JXbHVaVXhwYm1WekxDQnBibVJsZURvZ01IMHNYRzRnSUNBZ0lDQjBhR1ZwY2lBOUlIdHZabVp6WlhRNklIUm9aV2x5VDJabWMyVjBMQ0JzYVc1bGN6b2dkR2hsYVhKTWFXNWxjeXdnYVc1a1pYZzZJREI5TzF4dVhHNGdJQzh2SUVoaGJtUnNaU0JoYm5rZ2JHVmhaR2x1WnlCamIyNTBaVzUwWEc0Z0lHbHVjMlZ5ZEV4bFlXUnBibWNvYUhWdWF5d2diV2x1WlN3Z2RHaGxhWElwTzF4dUlDQnBibk5sY25STVpXRmthVzVuS0doMWJtc3NJSFJvWldseUxDQnRhVzVsS1R0Y2JseHVJQ0F2THlCT2IzY2dhVzRnZEdobElHOTJaWEpzWVhBZ1kyOXVkR1Z1ZEM0Z1UyTmhiaUIwYUhKdmRXZG9JR0Z1WkNCelpXeGxZM1FnZEdobElHSmxjM1FnWTJoaGJtZGxjeUJtY205dElHVmhZMmd1WEc0Z0lIZG9hV3hsSUNodGFXNWxMbWx1WkdWNElEd2diV2x1WlM1c2FXNWxjeTVzWlc1bmRHZ2dKaVlnZEdobGFYSXVhVzVrWlhnZ1BDQjBhR1ZwY2k1c2FXNWxjeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQnNaWFFnYldsdVpVTjFjbkpsYm5RZ1BTQnRhVzVsTG14cGJtVnpXMjFwYm1VdWFXNWtaWGhkTEZ4dUlDQWdJQ0FnSUNCMGFHVnBja04xY25KbGJuUWdQU0IwYUdWcGNpNXNhVzVsYzF0MGFHVnBjaTVwYm1SbGVGMDdYRzVjYmlBZ0lDQnBaaUFvS0cxcGJtVkRkWEp5Wlc1MFd6QmRJRDA5UFNBbkxTY2dmSHdnYldsdVpVTjFjbkpsYm5SYk1GMGdQVDA5SUNjckp5bGNiaUFnSUNBZ0lDQWdKaVlnS0hSb1pXbHlRM1Z5Y21WdWRGc3dYU0E5UFQwZ0p5MG5JSHg4SUhSb1pXbHlRM1Z5Y21WdWRGc3dYU0E5UFQwZ0p5c25LU2tnZTF4dUlDQWdJQ0FnTHk4Z1FtOTBhQ0J0YjJScFptbGxaQ0F1TGk1Y2JpQWdJQ0FnSUcxMWRIVmhiRU5vWVc1blpTaG9kVzVyTENCdGFXNWxMQ0IwYUdWcGNpazdYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHRhVzVsUTNWeWNtVnVkRnN3WFNBOVBUMGdKeXNuSUNZbUlIUm9aV2x5UTNWeWNtVnVkRnN3WFNBOVBUMGdKeUFuS1NCN1hHNGdJQ0FnSUNBdkx5Qk5hVzVsSUdsdWMyVnlkR1ZrWEc0Z0lDQWdJQ0JvZFc1ckxteHBibVZ6TG5CMWMyZ29MaTR1SUdOdmJHeGxZM1JEYUdGdVoyVW9iV2x1WlNrcE8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RHaGxhWEpEZFhKeVpXNTBXekJkSUQwOVBTQW5LeWNnSmlZZ2JXbHVaVU4xY25KbGJuUmJNRjBnUFQwOUlDY2dKeWtnZTF4dUlDQWdJQ0FnTHk4Z1ZHaGxhWEp6SUdsdWMyVnlkR1ZrWEc0Z0lDQWdJQ0JvZFc1ckxteHBibVZ6TG5CMWMyZ29MaTR1SUdOdmJHeGxZM1JEYUdGdVoyVW9kR2hsYVhJcEtUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tHMXBibVZEZFhKeVpXNTBXekJkSUQwOVBTQW5MU2NnSmlZZ2RHaGxhWEpEZFhKeVpXNTBXekJkSUQwOVBTQW5JQ2NwSUh0Y2JpQWdJQ0FnSUM4dklFMXBibVVnY21WdGIzWmxaQ0J2Y2lCbFpHbDBaV1JjYmlBZ0lDQWdJSEpsYlc5MllXd29hSFZ1YXl3Z2JXbHVaU3dnZEdobGFYSXBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9kR2hsYVhKRGRYSnlaVzUwV3pCZElEMDlQU0FuTFNjZ0ppWWdiV2x1WlVOMWNuSmxiblJiTUYwZ1BUMDlJQ2NnSnlrZ2UxeHVJQ0FnSUNBZ0x5OGdWR2hsYVhJZ2NtVnRiM1psWkNCdmNpQmxaR2wwWldSY2JpQWdJQ0FnSUhKbGJXOTJZV3dvYUhWdWF5d2dkR2hsYVhJc0lHMXBibVVzSUhSeWRXVXBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9iV2x1WlVOMWNuSmxiblFnUFQwOUlIUm9aV2x5UTNWeWNtVnVkQ2tnZTF4dUlDQWdJQ0FnTHk4Z1EyOXVkR1Y0ZENCcFpHVnVkR2wwZVZ4dUlDQWdJQ0FnYUhWdWF5NXNhVzVsY3k1d2RYTm9LRzFwYm1WRGRYSnlaVzUwS1R0Y2JpQWdJQ0FnSUcxcGJtVXVhVzVrWlhnckt6dGNiaUFnSUNBZ0lIUm9aV2x5TG1sdVpHVjRLeXM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDOHZJRU52Ym5SbGVIUWdiV2x6YldGMFkyaGNiaUFnSUNBZ0lHTnZibVpzYVdOMEtHaDFibXNzSUdOdmJHeGxZM1JEYUdGdVoyVW9iV2x1WlNrc0lHTnZiR3hsWTNSRGFHRnVaMlVvZEdobGFYSXBLVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0F2THlCT2IzY2djSFZ6YUNCaGJubDBhR2x1WnlCMGFHRjBJRzFoZVNCaVpTQnlaVzFoYVc1cGJtZGNiaUFnYVc1elpYSjBWSEpoYVd4cGJtY29hSFZ1YXl3Z2JXbHVaU2s3WEc0Z0lHbHVjMlZ5ZEZSeVlXbHNhVzVuS0doMWJtc3NJSFJvWldseUtUdGNibHh1SUNCallXeGpUR2x1WlVOdmRXNTBLR2gxYm1zcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCdGRYUjFZV3hEYUdGdVoyVW9hSFZ1YXl3Z2JXbHVaU3dnZEdobGFYSXBJSHRjYmlBZ2JHVjBJRzE1UTJoaGJtZGxjeUE5SUdOdmJHeGxZM1JEYUdGdVoyVW9iV2x1WlNrc1hHNGdJQ0FnSUNCMGFHVnBja05vWVc1blpYTWdQU0JqYjJ4c1pXTjBRMmhoYm1kbEtIUm9aV2x5S1R0Y2JseHVJQ0JwWmlBb1lXeHNVbVZ0YjNabGN5aHRlVU5vWVc1blpYTXBJQ1ltSUdGc2JGSmxiVzkyWlhNb2RHaGxhWEpEYUdGdVoyVnpLU2tnZTF4dUlDQWdJQzh2SUZOd1pXTnBZV3dnWTJGelpTQm1iM0lnY21WdGIzWmxJR05vWVc1blpYTWdkR2hoZENCaGNtVWdjM1Z3WlhKelpYUnpJRzltSUc5dVpTQmhibTkwYUdWeVhHNGdJQ0FnYVdZZ0tHRnljbUY1VTNSaGNuUnpWMmwwYUNodGVVTm9ZVzVuWlhNc0lIUm9aV2x5UTJoaGJtZGxjeWxjYmlBZ0lDQWdJQ0FnSmlZZ2MydHBjRkpsYlc5MlpWTjFjR1Z5YzJWMEtIUm9aV2x5TENCdGVVTm9ZVzVuWlhNc0lHMTVRMmhoYm1kbGN5NXNaVzVuZEdnZ0xTQjBhR1ZwY2tOb1lXNW5aWE11YkdWdVozUm9LU2tnZTF4dUlDQWdJQ0FnYUhWdWF5NXNhVzVsY3k1d2RYTm9LQzR1TGlCdGVVTm9ZVzVuWlhNcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDBnWld4elpTQnBaaUFvWVhKeVlYbFRkR0Z5ZEhOWGFYUm9LSFJvWldseVEyaGhibWRsY3l3Z2JYbERhR0Z1WjJWektWeHVJQ0FnSUNBZ0lDQW1KaUJ6YTJsd1VtVnRiM1psVTNWd1pYSnpaWFFvYldsdVpTd2dkR2hsYVhKRGFHRnVaMlZ6TENCMGFHVnBja05vWVc1blpYTXViR1Z1WjNSb0lDMGdiWGxEYUdGdVoyVnpMbXhsYm1kMGFDa3BJSHRjYmlBZ0lDQWdJR2gxYm1zdWJHbHVaWE11Y0hWemFDZ3VMaTRnZEdobGFYSkRhR0Z1WjJWektUdGNiaUFnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9ZWEp5WVhsRmNYVmhiQ2h0ZVVOb1lXNW5aWE1zSUhSb1pXbHlRMmhoYm1kbGN5a3BJSHRjYmlBZ0lDQm9kVzVyTG14cGJtVnpMbkIxYzJnb0xpNHVJRzE1UTJoaGJtZGxjeWs3WEc0Z0lDQWdjbVYwZFhKdU8xeHVJQ0I5WEc1Y2JpQWdZMjl1Wm14cFkzUW9hSFZ1YXl3Z2JYbERhR0Z1WjJWekxDQjBhR1ZwY2tOb1lXNW5aWE1wTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ5WlcxdmRtRnNLR2gxYm1zc0lHMXBibVVzSUhSb1pXbHlMQ0J6ZDJGd0tTQjdYRzRnSUd4bGRDQnRlVU5vWVc1blpYTWdQU0JqYjJ4c1pXTjBRMmhoYm1kbEtHMXBibVVwTEZ4dUlDQWdJQ0FnZEdobGFYSkRhR0Z1WjJWeklEMGdZMjlzYkdWamRFTnZiblJsZUhRb2RHaGxhWElzSUcxNVEyaGhibWRsY3lrN1hHNGdJR2xtSUNoMGFHVnBja05vWVc1blpYTXViV1Z5WjJWa0tTQjdYRzRnSUNBZ2FIVnVheTVzYVc1bGN5NXdkWE5vS0M0dUxpQjBhR1ZwY2tOb1lXNW5aWE11YldWeVoyVmtLVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0JqYjI1bWJHbGpkQ2hvZFc1ckxDQnpkMkZ3SUQ4Z2RHaGxhWEpEYUdGdVoyVnpJRG9nYlhsRGFHRnVaMlZ6TENCemQyRndJRDhnYlhsRGFHRnVaMlZ6SURvZ2RHaGxhWEpEYUdGdVoyVnpLVHRjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCamIyNW1iR2xqZENob2RXNXJMQ0J0YVc1bExDQjBhR1ZwY2lrZ2UxeHVJQ0JvZFc1ckxtTnZibVpzYVdOMElEMGdkSEoxWlR0Y2JpQWdhSFZ1YXk1c2FXNWxjeTV3ZFhOb0tIdGNiaUFnSUNCamIyNW1iR2xqZERvZ2RISjFaU3hjYmlBZ0lDQnRhVzVsT2lCdGFXNWxMRnh1SUNBZ0lIUm9aV2x5Y3pvZ2RHaGxhWEpjYmlBZ2ZTazdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHbHVjMlZ5ZEV4bFlXUnBibWNvYUhWdWF5d2dhVzV6WlhKMExDQjBhR1ZwY2lrZ2UxeHVJQ0IzYUdsc1pTQW9hVzV6WlhKMExtOW1abk5sZENBOElIUm9aV2x5TG05bVpuTmxkQ0FtSmlCcGJuTmxjblF1YVc1a1pYZ2dQQ0JwYm5ObGNuUXViR2x1WlhNdWJHVnVaM1JvS1NCN1hHNGdJQ0FnYkdWMElHeHBibVVnUFNCcGJuTmxjblF1YkdsdVpYTmJhVzV6WlhKMExtbHVaR1Y0S3l0ZE8xeHVJQ0FnSUdoMWJtc3ViR2x1WlhNdWNIVnphQ2hzYVc1bEtUdGNiaUFnSUNCcGJuTmxjblF1YjJabWMyVjBLeXM3WEc0Z0lIMWNibjFjYm1aMWJtTjBhVzl1SUdsdWMyVnlkRlJ5WVdsc2FXNW5LR2gxYm1zc0lHbHVjMlZ5ZENrZ2UxeHVJQ0IzYUdsc1pTQW9hVzV6WlhKMExtbHVaR1Y0SUR3Z2FXNXpaWEowTG14cGJtVnpMbXhsYm1kMGFDa2dlMXh1SUNBZ0lHeGxkQ0JzYVc1bElEMGdhVzV6WlhKMExteHBibVZ6VzJsdWMyVnlkQzVwYm1SbGVDc3JYVHRjYmlBZ0lDQm9kVzVyTG14cGJtVnpMbkIxYzJnb2JHbHVaU2s3WEc0Z0lIMWNibjFjYmx4dVpuVnVZM1JwYjI0Z1kyOXNiR1ZqZEVOb1lXNW5aU2h6ZEdGMFpTa2dlMXh1SUNCc1pYUWdjbVYwSUQwZ1cxMHNYRzRnSUNBZ0lDQnZjR1Z5WVhScGIyNGdQU0J6ZEdGMFpTNXNhVzVsYzF0emRHRjBaUzVwYm1SbGVGMWJNRjA3WEc0Z0lIZG9hV3hsSUNoemRHRjBaUzVwYm1SbGVDQThJSE4wWVhSbExteHBibVZ6TG14bGJtZDBhQ2tnZTF4dUlDQWdJR3hsZENCc2FXNWxJRDBnYzNSaGRHVXViR2x1WlhOYmMzUmhkR1V1YVc1a1pYaGRPMXh1WEc0Z0lDQWdMeThnUjNKdmRYQWdZV1JrYVhScGIyNXpJSFJvWVhRZ1lYSmxJR2x0YldWa2FXRjBaV3g1SUdGbWRHVnlJSE4xWW5SeVlXTjBhVzl1Y3lCaGJtUWdkSEpsWVhRZ2RHaGxiU0JoY3lCdmJtVWdYQ0poZEc5dGFXTmNJaUJ0YjJScFpua2dZMmhoYm1kbExseHVJQ0FnSUdsbUlDaHZjR1Z5WVhScGIyNGdQVDA5SUNjdEp5QW1KaUJzYVc1bFd6QmRJRDA5UFNBbkt5Y3BJSHRjYmlBZ0lDQWdJRzl3WlhKaGRHbHZiaUE5SUNjckp6dGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9iM0JsY21GMGFXOXVJRDA5UFNCc2FXNWxXekJkS1NCN1hHNGdJQ0FnSUNCeVpYUXVjSFZ6YUNoc2FXNWxLVHRjYmlBZ0lDQWdJSE4wWVhSbExtbHVaR1Y0S3lzN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCeVpYUTdYRzU5WEc1bWRXNWpkR2x2YmlCamIyeHNaV04wUTI5dWRHVjRkQ2h6ZEdGMFpTd2diV0YwWTJoRGFHRnVaMlZ6S1NCN1hHNGdJR3hsZENCamFHRnVaMlZ6SUQwZ1cxMHNYRzRnSUNBZ0lDQnRaWEpuWldRZ1BTQmJYU3hjYmlBZ0lDQWdJRzFoZEdOb1NXNWtaWGdnUFNBd0xGeHVJQ0FnSUNBZ1kyOXVkR1Y0ZEVOb1lXNW5aWE1nUFNCbVlXeHpaU3hjYmlBZ0lDQWdJR052Ym1ac2FXTjBaV1FnUFNCbVlXeHpaVHRjYmlBZ2QyaHBiR1VnS0cxaGRHTm9TVzVrWlhnZ1BDQnRZWFJqYUVOb1lXNW5aWE11YkdWdVozUm9YRzRnSUNBZ0lDQWdJQ1ltSUhOMFlYUmxMbWx1WkdWNElEd2djM1JoZEdVdWJHbHVaWE11YkdWdVozUm9LU0I3WEc0Z0lDQWdiR1YwSUdOb1lXNW5aU0E5SUhOMFlYUmxMbXhwYm1WelczTjBZWFJsTG1sdVpHVjRYU3hjYmlBZ0lDQWdJQ0FnYldGMFkyZ2dQU0J0WVhSamFFTm9ZVzVuWlhOYmJXRjBZMmhKYm1SbGVGMDdYRzVjYmlBZ0lDQXZMeUJQYm1ObElIZGxKM1psSUdocGRDQnZkWElnWVdSa0xDQjBhR1Z1SUhkbElHRnlaU0JrYjI1bFhHNGdJQ0FnYVdZZ0tHMWhkR05vV3pCZElEMDlQU0FuS3ljcElIdGNiaUFnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJSDFjYmx4dUlDQWdJR052Ym5SbGVIUkRhR0Z1WjJWeklEMGdZMjl1ZEdWNGRFTm9ZVzVuWlhNZ2ZId2dZMmhoYm1kbFd6QmRJQ0U5UFNBbklDYzdYRzVjYmlBZ0lDQnRaWEpuWldRdWNIVnphQ2h0WVhSamFDazdYRzRnSUNBZ2JXRjBZMmhKYm1SbGVDc3JPMXh1WEc0Z0lDQWdMeThnUTI5dWMzVnRaU0JoYm5rZ1lXUmthWFJwYjI1eklHbHVJSFJvWlNCdmRHaGxjaUJpYkc5amF5QmhjeUJoSUdOdmJtWnNhV04wSUhSdklHRjBkR1Z0Y0hSY2JpQWdJQ0F2THlCMGJ5QndkV3hzSUdsdUlIUm9aU0J5WlcxaGFXNXBibWNnWTI5dWRHVjRkQ0JoWm5SbGNpQjBhR2x6WEc0Z0lDQWdhV1lnS0dOb1lXNW5aVnN3WFNBOVBUMGdKeXNuS1NCN1hHNGdJQ0FnSUNCamIyNW1iR2xqZEdWa0lEMGdkSEoxWlR0Y2JseHVJQ0FnSUNBZ2QyaHBiR1VnS0dOb1lXNW5aVnN3WFNBOVBUMGdKeXNuS1NCN1hHNGdJQ0FnSUNBZ0lHTm9ZVzVuWlhNdWNIVnphQ2hqYUdGdVoyVXBPMXh1SUNBZ0lDQWdJQ0JqYUdGdVoyVWdQU0J6ZEdGMFpTNXNhVzVsYzFzckszTjBZWFJsTG1sdVpHVjRYVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvYldGMFkyZ3VjM1ZpYzNSeUtERXBJRDA5UFNCamFHRnVaMlV1YzNWaWMzUnlLREVwS1NCN1hHNGdJQ0FnSUNCamFHRnVaMlZ6TG5CMWMyZ29ZMmhoYm1kbEtUdGNiaUFnSUNBZ0lITjBZWFJsTG1sdVpHVjRLeXM3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lHTnZibVpzYVdOMFpXUWdQU0IwY25WbE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lHbG1JQ2dvYldGMFkyaERhR0Z1WjJWelcyMWhkR05vU1c1a1pYaGRJSHg4SUNjbktWc3dYU0E5UFQwZ0p5c25YRzRnSUNBZ0lDQW1KaUJqYjI1MFpYaDBRMmhoYm1kbGN5a2dlMXh1SUNBZ0lHTnZibVpzYVdOMFpXUWdQU0IwY25WbE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dOdmJtWnNhV04wWldRcElIdGNiaUFnSUNCeVpYUjFjbTRnWTJoaGJtZGxjenRjYmlBZ2ZWeHVYRzRnSUhkb2FXeGxJQ2h0WVhSamFFbHVaR1Y0SUR3Z2JXRjBZMmhEYUdGdVoyVnpMbXhsYm1kMGFDa2dlMXh1SUNBZ0lHMWxjbWRsWkM1d2RYTm9LRzFoZEdOb1EyaGhibWRsYzF0dFlYUmphRWx1WkdWNEt5dGRLVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUI3WEc0Z0lDQWdiV1Z5WjJWa0xGeHVJQ0FnSUdOb1lXNW5aWE5jYmlBZ2ZUdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1lXeHNVbVZ0YjNabGN5aGphR0Z1WjJWektTQjdYRzRnSUhKbGRIVnliaUJqYUdGdVoyVnpMbkpsWkhWalpTaG1kVzVqZEdsdmJpaHdjbVYyTENCamFHRnVaMlVwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdjSEpsZGlBbUppQmphR0Z1WjJWYk1GMGdQVDA5SUNjdEp6dGNiaUFnZlN3Z2RISjFaU2s3WEc1OVhHNW1kVzVqZEdsdmJpQnphMmx3VW1WdGIzWmxVM1Z3WlhKelpYUW9jM1JoZEdVc0lISmxiVzkyWlVOb1lXNW5aWE1zSUdSbGJIUmhLU0I3WEc0Z0lHWnZjaUFvYkdWMElHa2dQU0F3T3lCcElEd2daR1ZzZEdFN0lHa3JLeWtnZTF4dUlDQWdJR3hsZENCamFHRnVaMlZEYjI1MFpXNTBJRDBnY21WdGIzWmxRMmhoYm1kbGMxdHlaVzF2ZG1WRGFHRnVaMlZ6TG14bGJtZDBhQ0F0SUdSbGJIUmhJQ3NnYVYwdWMzVmljM1J5S0RFcE8xeHVJQ0FnSUdsbUlDaHpkR0YwWlM1c2FXNWxjMXR6ZEdGMFpTNXBibVJsZUNBcklHbGRJQ0U5UFNBbklDY2dLeUJqYUdGdVoyVkRiMjUwWlc1MEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnYzNSaGRHVXVhVzVrWlhnZ0t6MGdaR1ZzZEdFN1hHNGdJSEpsZEhWeWJpQjBjblZsTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJqWVd4alQyeGtUbVYzVEdsdVpVTnZkVzUwS0d4cGJtVnpLU0I3WEc0Z0lHeGxkQ0J2YkdSTWFXNWxjeUE5SURBN1hHNGdJR3hsZENCdVpYZE1hVzVsY3lBOUlEQTdYRzVjYmlBZ2JHbHVaWE11Wm05eVJXRmphQ2htZFc1amRHbHZiaWhzYVc1bEtTQjdYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQnNhVzVsSUNFOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lDQWdiR1YwSUcxNVEyOTFiblFnUFNCallXeGpUMnhrVG1WM1RHbHVaVU52ZFc1MEtHeHBibVV1YldsdVpTazdYRzRnSUNBZ0lDQnNaWFFnZEdobGFYSkRiM1Z1ZENBOUlHTmhiR05QYkdST1pYZE1hVzVsUTI5MWJuUW9iR2x1WlM1MGFHVnBjbk1wTzF4dVhHNGdJQ0FnSUNCcFppQW9iMnhrVEdsdVpYTWdJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvYlhsRGIzVnVkQzV2YkdSTWFXNWxjeUE5UFQwZ2RHaGxhWEpEYjNWdWRDNXZiR1JNYVc1bGN5a2dlMXh1SUNBZ0lDQWdJQ0FnSUc5c1pFeHBibVZ6SUNzOUlHMTVRMjkxYm5RdWIyeGtUR2x1WlhNN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdiMnhrVEdsdVpYTWdQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLRzVsZDB4cGJtVnpJQ0U5UFNCMWJtUmxabWx1WldRcElIdGNiaUFnSUNBZ0lDQWdhV1lnS0cxNVEyOTFiblF1Ym1WM1RHbHVaWE1nUFQwOUlIUm9aV2x5UTI5MWJuUXVibVYzVEdsdVpYTXBJSHRjYmlBZ0lDQWdJQ0FnSUNCdVpYZE1hVzVsY3lBclBTQnRlVU52ZFc1MExtNWxkMHhwYm1Wek8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJRzVsZDB4cGJtVnpJRDBnZFc1a1pXWnBibVZrTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJR2xtSUNodVpYZE1hVzVsY3lBaFBUMGdkVzVrWldacGJtVmtJQ1ltSUNoc2FXNWxXekJkSUQwOVBTQW5LeWNnZkh3Z2JHbHVaVnN3WFNBOVBUMGdKeUFuS1NrZ2UxeHVJQ0FnSUNBZ0lDQnVaWGRNYVc1bGN5c3JPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdhV1lnS0c5c1pFeHBibVZ6SUNFOVBTQjFibVJsWm1sdVpXUWdKaVlnS0d4cGJtVmJNRjBnUFQwOUlDY3RKeUI4ZkNCc2FXNWxXekJkSUQwOVBTQW5JQ2NwS1NCN1hHNGdJQ0FnSUNBZ0lHOXNaRXhwYm1Wekt5czdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVJQ0I5S1R0Y2JseHVJQ0J5WlhSMWNtNGdlMjlzWkV4cGJtVnpMQ0J1WlhkTWFXNWxjMzA3WEc1OVhHNGlYWDA9XG4iLCIvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VQYXRjaCA9IHBhcnNlUGF0Y2g7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuICB2YXJcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbiAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgIGRlbGltaXRlcnMgPSB1bmlEaWZmLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgIGxpc3QgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZ1bmN0aW9uIHBhcnNlSW5kZXgoKSB7XG4gICAgdmFyIGluZGV4ID0ge307XG4gICAgbGlzdC5wdXNoKGluZGV4KTsgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldOyAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuXG4gICAgICBpZiAoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIERpZmYgaW5kZXhcblxuXG4gICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvLmV4ZWMobGluZSk7XG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9IC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XG4gICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXG5cblxuICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7XG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTsgLy8gUGFyc2UgaHVua3NcblxuICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xuXG4gICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFwtXFwtXFwtfFxcK1xcK1xcKylcXHMvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgIH0gZWxzZSBpZiAoX2xpbmUgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAvLyBhcmUgY29uc3VtZWQuXG5cblxuICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcbiAgICB2YXIgZmlsZUhlYWRlciA9IC9eKC0tLXxcXCtcXCtcXCspXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xuXG4gICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgIHZhciBrZXlQcmVmaXggPSBmaWxlSGVhZGVyWzFdID09PSAnLS0tJyA/ICdvbGQnIDogJ25ldyc7XG4gICAgICB2YXIgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICBpZiAoL15cIi4qXCIkLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIH1cblxuICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIFBhcnNlcyBhIGh1bmtcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG5cblxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XG4gICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcZCspKD86LChcXGQrKSk/IFxcKyhcXGQrKSg/OiwoXFxkKykpPyBAQC8pO1xuICAgIHZhciBodW5rID0ge1xuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgIG9sZExpbmVzOiB0eXBlb2YgY2h1bmtIZWFkZXJbMl0gPT09ICd1bmRlZmluZWQnID8gMSA6ICtjaHVua0hlYWRlclsyXSxcbiAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICBuZXdMaW5lczogdHlwZW9mIGNodW5rSGVhZGVyWzRdID09PSAndW5kZWZpbmVkJyA/IDEgOiArY2h1bmtIZWFkZXJbNF0sXG4gICAgICBsaW5lczogW10sXG4gICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICB9OyAvLyBVbmlmaWVkIERpZmYgRm9ybWF0IHF1aXJrOiBJZiB0aGUgY2h1bmsgc2l6ZSBpcyAwLFxuICAgIC8vIHRoZSBmaXJzdCBudW1iZXIgaXMgb25lIGxvd2VyIHRoYW4gb25lIHdvdWxkIGV4cGVjdC5cbiAgICAvLyBodHRwczovL3d3dy5hcnRpbWEuY29tL3dlYmxvZ3Mvdmlld3Bvc3QuanNwP3RocmVhZD0xNjQyOTNcblxuICAgIGlmIChodW5rLm9sZExpbmVzID09PSAwKSB7XG4gICAgICBodW5rLm9sZFN0YXJ0ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKGh1bmsubmV3TGluZXMgPT09IDApIHtcbiAgICAgIGh1bmsubmV3U3RhcnQgKz0gMTtcbiAgICB9XG5cbiAgICB2YXIgYWRkQ291bnQgPSAwLFxuICAgICAgICByZW1vdmVDb3VudCA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXG4gICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDAgJiYgaSArIDIgPCBkaWZmc3RyLmxlbmd0aCAmJiBkaWZmc3RyW2kgKyAxXS5pbmRleE9mKCcrKysgJykgPT09IDAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZXJhdGlvbiA9IGRpZmZzdHJbaV0ubGVuZ3RoID09IDAgJiYgaSAhPSBkaWZmc3RyLmxlbmd0aCAtIDEgPyAnICcgOiBkaWZmc3RyW2ldWzBdO1xuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxuJyk7XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXG5cblxuICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICB9IC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXG5cblxuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVuaztcbiAgfVxuXG4gIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICBwYXJzZUluZGV4KCk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXdZWFJqYUM5d1lYSnpaUzVxY3lKZExDSnVZVzFsY3lJNld5SndZWEp6WlZCaGRHTm9JaXdpZFc1cFJHbG1aaUlzSW05d2RHbHZibk1pTENKa2FXWm1jM1J5SWl3aWMzQnNhWFFpTENKa1pXeHBiV2wwWlhKeklpd2liV0YwWTJnaUxDSnNhWE4wSWl3aWFTSXNJbkJoY25ObFNXNWtaWGdpTENKcGJtUmxlQ0lzSW5CMWMyZ2lMQ0pzWlc1bmRHZ2lMQ0pzYVc1bElpd2lkR1Z6ZENJc0ltaGxZV1JsY2lJc0ltVjRaV01pTENKd1lYSnpaVVpwYkdWSVpXRmtaWElpTENKb2RXNXJjeUlzSW5CaGNuTmxTSFZ1YXlJc0luTjBjbWxqZENJc0lrVnljbTl5SWl3aVNsTlBUaUlzSW5OMGNtbHVaMmxtZVNJc0ltWnBiR1ZJWldGa1pYSWlMQ0pyWlhsUWNtVm1hWGdpTENKa1lYUmhJaXdpWm1sc1pVNWhiV1VpTENKeVpYQnNZV05sSWl3aWMzVmljM1J5SWl3aWRISnBiU0lzSW1Ob2RXNXJTR1ZoWkdWeVNXNWtaWGdpTENKamFIVnVhMGhsWVdSbGNreHBibVVpTENKamFIVnVhMGhsWVdSbGNpSXNJbWgxYm1zaUxDSnZiR1JUZEdGeWRDSXNJbTlzWkV4cGJtVnpJaXdpYm1WM1UzUmhjblFpTENKdVpYZE1hVzVsY3lJc0lteHBibVZ6SWl3aWJHbHVaV1JsYkdsdGFYUmxjbk1pTENKaFpHUkRiM1Z1ZENJc0luSmxiVzkyWlVOdmRXNTBJaXdpYVc1a1pYaFBaaUlzSW05d1pYSmhkR2x2YmlKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzVlVGQlZDeERRVUZ2UWtNc1QwRkJjRUlzUlVGQk1rTTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJaRU1zUlVGQlFVRXNUMEZCWXl4MVJVRkJTaXhGUVVGSk8wRkJRMmhFTEUxQlFVbERMRTlCUVU4c1IwRkJSMFlzVDBGQlR5eERRVUZEUnl4TFFVRlNMRU5CUVdNc2NVSkJRV1FzUTBGQlpEdEJRVUZCTEUxQlEwbERMRlZCUVZVc1IwRkJSMG9zVDBGQlR5eERRVUZEU3l4TFFVRlNMRU5CUVdNc2MwSkJRV1FzUzBGQmVVTXNSVUZFTVVRN1FVRkJRU3hOUVVWSlF5eEpRVUZKTEVkQlFVY3NSVUZHV0R0QlFVRkJMRTFCUjBsRExFTkJRVU1zUjBGQlJ5eERRVWhTT3p0QlFVdEJMRmRCUVZORExGVkJRVlFzUjBGQmMwSTdRVUZEY0VJc1VVRkJTVU1zUzBGQlN5eEhRVUZITEVWQlFWbzdRVUZEUVVnc1NVRkJRVUVzU1VGQlNTeERRVUZEU1N4SlFVRk1MRU5CUVZWRUxFdEJRVllzUlVGR2IwSXNRMEZKY0VJN08wRkJRMEVzVjBGQlQwWXNRMEZCUXl4SFFVRkhUQ3hQUVVGUExFTkJRVU5UTEUxQlFXNUNMRVZCUVRKQ08wRkJRM3BDTEZWQlFVbERMRWxCUVVrc1IwRkJSMVlzVDBGQlR5eERRVUZEU3l4RFFVRkVMRU5CUVd4Q0xFTkJSSGxDTEVOQlIzcENPenRCUVVOQkxGVkJRVXNzZFVKQlFVUXNRMEZCTUVKTkxFbEJRVEZDTEVOQlFTdENSQ3hKUVVFdlFpeERRVUZLTEVWQlFUQkRPMEZCUTNoRE8wRkJRMFFzVDBGT2QwSXNRMEZSZWtJN096dEJRVU5CTEZWQlFVbEZMRTFCUVUwc1IwRkJTU3d3UTBGQlJDeERRVUUyUTBNc1NVRkJOME1zUTBGQmEwUklMRWxCUVd4RUxFTkJRV0k3TzBGQlEwRXNWVUZCU1VVc1RVRkJTaXhGUVVGWk8wRkJRMVpNTEZGQlFVRkJMRXRCUVVzc1EwRkJRMEVzUzBGQlRpeEhRVUZqU3l4TlFVRk5MRU5CUVVNc1EwRkJSQ3hEUVVGd1FqdEJRVU5FT3p0QlFVVkVVQ3hOUVVGQlFTeERRVUZETzBGQlEwWXNTMEZ3UW0xQ0xFTkJjMEp3UWp0QlFVTkJPenM3UVVGRFFWTXNTVUZCUVVFc1pVRkJaU3hEUVVGRFVDeExRVUZFTEVOQlFXWTdRVUZEUVU4c1NVRkJRVUVzWlVGQlpTeERRVUZEVUN4TFFVRkVMRU5CUVdZc1EwRjZRbTlDTEVOQk1rSndRanM3UVVGRFFVRXNTVUZCUVVFc1MwRkJTeXhEUVVGRFVTeExRVUZPTEVkQlFXTXNSVUZCWkRzN1FVRkZRU3hYUVVGUFZpeERRVUZETEVkQlFVZE1MRTlCUVU4c1EwRkJRMU1zVFVGQmJrSXNSVUZCTWtJN1FVRkRla0lzVlVGQlNVTXNTMEZCU1N4SFFVRkhWaXhQUVVGUExFTkJRVU5MTEVOQlFVUXNRMEZCYkVJN08wRkJSVUVzVlVGQlN5eG5RMEZCUkN4RFFVRnRRMDBzU1VGQmJrTXNRMEZCZDBORUxFdEJRWGhETEVOQlFVb3NSVUZCYlVRN1FVRkRha1E3UVVGRFJDeFBRVVpFTEUxQlJVOHNTVUZCU3l4TFFVRkVMRU5CUVZGRExFbEJRVklzUTBGQllVUXNTMEZCWWl4RFFVRktMRVZCUVhkQ08wRkJRemRDU0N4UlFVRkJRU3hMUVVGTExFTkJRVU5STEV0QlFVNHNRMEZCV1ZBc1NVRkJXaXhEUVVGcFFsRXNVMEZCVXl4RlFVRXhRanRCUVVORUxFOUJSazBzVFVGRlFTeEpRVUZKVGl4TFFVRkpMRWxCUVVsWUxFOUJRVThzUTBGQlEydENMRTFCUVhCQ0xFVkJRVFJDTzBGQlEycERPMEZCUTBFc1kwRkJUU3hKUVVGSlF5eExRVUZLTEVOQlFWVXNiVUpCUVcxQ1lpeERRVUZETEVkQlFVY3NRMEZCZGtJc1NVRkJORUlzUjBGQk5VSXNSMEZCYTBOakxFbEJRVWtzUTBGQlEwTXNVMEZCVEN4RFFVRmxWaXhMUVVGbUxFTkJRVFZETEVOQlFVNDdRVUZEUkN4UFFVaE5MRTFCUjBFN1FVRkRURXdzVVVGQlFVRXNRMEZCUXp0QlFVTkdPMEZCUTBZN1FVRkRSaXhIUVd4RUswTXNRMEZ2UkdoRU8wRkJRMEU3T3p0QlFVTkJMRmRCUVZOVExHVkJRVlFzUTBGQmVVSlFMRXRCUVhwQ0xFVkJRV2RETzBGQlF6bENMRkZCUVUxakxGVkJRVlVzUjBGQlNTeDFRa0ZCUkN4RFFVRXdRbElzU1VGQk1VSXNRMEZCSzBKaUxFOUJRVThzUTBGQlEwc3NRMEZCUkN4RFFVRjBReXhEUVVGdVFqczdRVUZEUVN4UlFVRkpaMElzVlVGQlNpeEZRVUZuUWp0QlFVTmtMRlZCUVVsRExGTkJRVk1zUjBGQlIwUXNWVUZCVlN4RFFVRkRMRU5CUVVRc1EwRkJWaXhMUVVGclFpeExRVUZzUWl4SFFVRXdRaXhMUVVFeFFpeEhRVUZyUXl4TFFVRnNSRHRCUVVOQkxGVkJRVTFGTEVsQlFVa3NSMEZCUjBZc1ZVRkJWU3hEUVVGRExFTkJRVVFzUTBGQlZpeERRVUZqY0VJc1MwRkJaQ3hEUVVGdlFpeEpRVUZ3UWl4RlFVRXdRaXhEUVVFeFFpeERRVUZpTzBGQlEwRXNWVUZCU1hWQ0xGRkJRVkVzUjBGQlIwUXNTVUZCU1N4RFFVRkRMRU5CUVVRc1EwRkJTaXhEUVVGUlJTeFBRVUZTTEVOQlFXZENMRTlCUVdoQ0xFVkJRWGxDTEVsQlFYcENMRU5CUVdZN08wRkJRMEVzVlVGQlN5eFJRVUZFTEVOQlFWZGtMRWxCUVZnc1EwRkJaMEpoTEZGQlFXaENMRU5CUVVvc1JVRkJLMEk3UVVGRE4wSkJMRkZCUVVGQkxGRkJRVkVzUjBGQlIwRXNVVUZCVVN4RFFVRkRSU3hOUVVGVUxFTkJRV2RDTEVOQlFXaENMRVZCUVcxQ1JpeFJRVUZSTEVOQlFVTm1MRTFCUVZRc1IwRkJhMElzUTBGQmNrTXNRMEZCV0R0QlFVTkVPenRCUVVORVJpeE5RVUZCUVN4TFFVRkxMRU5CUVVObExGTkJRVk1zUjBGQlJ5eFZRVUZpTEVOQlFVd3NSMEZCWjBORkxGRkJRV2hETzBGQlEwRnFRaXhOUVVGQlFTeExRVUZMTEVOQlFVTmxMRk5CUVZNc1IwRkJSeXhSUVVGaUxFTkJRVXdzUjBGQk9FSXNRMEZCUTBNc1NVRkJTU3hEUVVGRExFTkJRVVFzUTBGQlNpeEpRVUZYTEVWQlFWb3NSVUZCWjBKSkxFbEJRV2hDTEVWQlFUbENPMEZCUlVGMFFpeE5RVUZCUVN4RFFVRkRPMEZCUTBZN1FVRkRSaXhIUVhCRkswTXNRMEZ6UldoRU8wRkJRMEU3T3p0QlFVTkJMRmRCUVZOWExGTkJRVlFzUjBGQmNVSTdRVUZEYmtJc1VVRkJTVmtzWjBKQlFXZENMRWRCUVVkMlFpeERRVUYyUWp0QlFVRkJMRkZCUTBsM1FpeGxRVUZsTEVkQlFVYzNRaXhQUVVGUExFTkJRVU5MTEVOQlFVTXNSVUZCUml4RFFVUTNRanRCUVVGQkxGRkJSVWw1UWl4WFFVRlhMRWRCUVVkRUxHVkJRV1VzUTBGQlF6VkNMRXRCUVdoQ0xFTkJRWE5DTERSRFFVRjBRaXhEUVVac1FqdEJRVWxCTEZGQlFVazRRaXhKUVVGSkxFZEJRVWM3UVVGRFZFTXNUVUZCUVVFc1VVRkJVU3hGUVVGRkxFTkJRVU5HTEZkQlFWY3NRMEZCUXl4RFFVRkVMRU5CUkdJN1FVRkZWRWNzVFVGQlFVRXNVVUZCVVN4RlFVRkZMRTlCUVU5SUxGZEJRVmNzUTBGQlF5eERRVUZFTEVOQlFXeENMRXRCUVRCQ0xGZEJRVEZDTEVkQlFYZERMRU5CUVhoRExFZEJRVFJETEVOQlFVTkJMRmRCUVZjc1EwRkJReXhEUVVGRUxFTkJSbnBFTzBGQlIxUkpMRTFCUVVGQkxGRkJRVkVzUlVGQlJTeERRVUZEU2l4WFFVRlhMRU5CUVVNc1EwRkJSQ3hEUVVoaU8wRkJTVlJMTEUxQlFVRkJMRkZCUVZFc1JVRkJSU3hQUVVGUFRDeFhRVUZYTEVOQlFVTXNRMEZCUkN4RFFVRnNRaXhMUVVFd1FpeFhRVUV4UWl4SFFVRjNReXhEUVVGNFF5eEhRVUUwUXl4RFFVRkRRU3hYUVVGWExFTkJRVU1zUTBGQlJDeERRVXA2UkR0QlFVdFVUU3hOUVVGQlFTeExRVUZMTEVWQlFVVXNSVUZNUlR0QlFVMVVReXhOUVVGQlFTeGpRVUZqTEVWQlFVVTdRVUZPVUN4TFFVRllMRU5CVEcxQ0xFTkJZMjVDTzBGQlEwRTdRVUZEUVRzN1FVRkRRU3hSUVVGSlRpeEpRVUZKTEVOQlFVTkZMRkZCUVV3c1MwRkJhMElzUTBGQmRFSXNSVUZCZVVJN1FVRkRka0pHTEUxQlFVRkJMRWxCUVVrc1EwRkJRME1zVVVGQlRDeEpRVUZwUWl4RFFVRnFRanRCUVVORU96dEJRVU5FTEZGQlFVbEVMRWxCUVVrc1EwRkJRMGtzVVVGQlRDeExRVUZyUWl4RFFVRjBRaXhGUVVGNVFqdEJRVU4yUWtvc1RVRkJRVUVzU1VGQlNTeERRVUZEUnl4UlFVRk1MRWxCUVdsQ0xFTkJRV3BDTzBGQlEwUTdPMEZCUlVRc1VVRkJTVWtzVVVGQlVTeEhRVUZITEVOQlFXWTdRVUZCUVN4UlFVTkpReXhYUVVGWExFZEJRVWNzUTBGRWJFSTdPMEZCUlVFc1YwRkJUMnhETEVOQlFVTXNSMEZCUjB3c1QwRkJUeXhEUVVGRFV5eE5RVUZ1UWl4RlFVRXlRa29zUTBGQlF5eEZRVUUxUWl4RlFVRm5RenRCUVVNNVFqdEJRVU5CTzBGQlEwRXNWVUZCU1V3c1QwRkJUeXhEUVVGRFN5eERRVUZFTEVOQlFWQXNRMEZCVjIxRExFOUJRVmdzUTBGQmJVSXNUVUZCYmtJc1RVRkJLMElzUTBGQkwwSXNTVUZEVFc1RExFTkJRVU1zUjBGQlJ5eERRVUZLTEVkQlFWRk1MRTlCUVU4c1EwRkJRMU1zVFVGRWRFSXNTVUZGUzFRc1QwRkJUeXhEUVVGRFN5eERRVUZETEVkQlFVY3NRMEZCVEN4RFFVRlFMRU5CUVdWdFF5eFBRVUZtTEVOQlFYVkNMRTFCUVhaQ0xFMUJRVzFETEVOQlJuaERMRWxCUjB0NFF5eFBRVUZQTEVOQlFVTkxMRU5CUVVNc1IwRkJSeXhEUVVGTUxFTkJRVkFzUTBGQlpXMURMRTlCUVdZc1EwRkJkVUlzU1VGQmRrSXNUVUZCYVVNc1EwRklNVU1zUlVGSE5rTTdRVUZEZWtNN1FVRkRTRHM3UVVGRFJDeFZRVUZKUXl4VFFVRlRMRWRCUVVsNlF5eFBRVUZQTEVOQlFVTkxMRU5CUVVRc1EwRkJVQ3hEUVVGWFNTeE5RVUZZTEVsQlFYRkNMRU5CUVhKQ0xFbEJRVEJDU2l4RFFVRkRMRWxCUVV0TUxFOUJRVThzUTBGQlExTXNUVUZCVWl4SFFVRnBRaXhEUVVGc1JDeEhRVUYzUkN4SFFVRjRSQ3hIUVVFNFJGUXNUMEZCVHl4RFFVRkRTeXhEUVVGRUxFTkJRVkFzUTBGQlZ5eERRVUZZTEVOQlFUbEZPenRCUVVWQkxGVkJRVWx2UXl4VFFVRlRMRXRCUVVzc1IwRkJaQ3hKUVVGeFFrRXNVMEZCVXl4TFFVRkxMRWRCUVc1RExFbEJRVEJEUVN4VFFVRlRMRXRCUVVzc1IwRkJlRVFzU1VGQkswUkJMRk5CUVZNc1MwRkJTeXhKUVVGcVJpeEZRVUYxUmp0QlFVTnlSbFlzVVVGQlFVRXNTVUZCU1N4RFFVRkRTeXhMUVVGTUxFTkJRVmMxUWl4SlFVRllMRU5CUVdkQ1VpeFBRVUZQTEVOQlFVTkxMRU5CUVVRc1EwRkJka0k3UVVGRFFUQkNMRkZCUVVGQkxFbEJRVWtzUTBGQlEwMHNZMEZCVEN4RFFVRnZRamRDTEVsQlFYQkNMRU5CUVhsQ1RpeFZRVUZWTEVOQlFVTkhMRU5CUVVRc1EwRkJWaXhKUVVGcFFpeEpRVUV4UXpzN1FVRkZRU3haUVVGSmIwTXNVMEZCVXl4TFFVRkxMRWRCUVd4Q0xFVkJRWFZDTzBGQlEzSkNTQ3hWUVVGQlFTeFJRVUZSTzBGQlExUXNVMEZHUkN4TlFVVlBMRWxCUVVsSExGTkJRVk1zUzBGQlN5eEhRVUZzUWl4RlFVRjFRanRCUVVNMVFrWXNWVUZCUVVFc1YwRkJWenRCUVVOYUxGTkJSazBzVFVGRlFTeEpRVUZKUlN4VFFVRlRMRXRCUVVzc1IwRkJiRUlzUlVGQmRVSTdRVUZETlVKSUxGVkJRVUZCTEZGQlFWRTdRVUZEVWtNc1ZVRkJRVUVzVjBGQlZ6dEJRVU5hTzBGQlEwWXNUMEZhUkN4TlFWbFBPMEZCUTB3N1FVRkRSRHRCUVVOR0xFdEJjRVJyUWl4RFFYTkVia0k3T3p0QlFVTkJMRkZCUVVrc1EwRkJRMFFzVVVGQlJDeEpRVUZoVUN4SlFVRkpMRU5CUVVOSkxGRkJRVXdzUzBGQmEwSXNRMEZCYmtNc1JVRkJjME03UVVGRGNFTktMRTFCUVVGQkxFbEJRVWtzUTBGQlEwa3NVVUZCVEN4SFFVRm5RaXhEUVVGb1FqdEJRVU5FT3p0QlFVTkVMRkZCUVVrc1EwRkJRMGtzVjBGQlJDeEpRVUZuUWxJc1NVRkJTU3hEUVVGRFJTeFJRVUZNTEV0QlFXdENMRU5CUVhSRExFVkJRWGxETzBGQlEzWkRSaXhOUVVGQlFTeEpRVUZKTEVOQlFVTkZMRkZCUVV3c1IwRkJaMElzUTBGQmFFSTdRVUZEUkN4TFFUVkVhMElzUTBFNFJHNUNPenM3UVVGRFFTeFJRVUZKYkVNc1QwRkJUeXhEUVVGRGEwSXNUVUZCV2l4RlFVRnZRanRCUVVOc1FpeFZRVUZKY1VJc1VVRkJVU3hMUVVGTFVDeEpRVUZKTEVOQlFVTkpMRkZCUVhSQ0xFVkJRV2RETzBGQlF6bENMR05CUVUwc1NVRkJTV3BDTEV0QlFVb3NRMEZCVlN4elJFRkJjMFJWTEdkQ1FVRm5RaXhIUVVGSExFTkJRWHBGTEVOQlFWWXNRMEZCVGp0QlFVTkVPenRCUVVORUxGVkJRVWxYTEZkQlFWY3NTMEZCUzFJc1NVRkJTU3hEUVVGRFJTeFJRVUY2UWl4RlFVRnRRenRCUVVOcVF5eGpRVUZOTEVsQlFVbG1MRXRCUVVvc1EwRkJWU3gzUkVGQmQwUlZMR2RDUVVGblFpeEhRVUZITEVOQlFUTkZMRU5CUVZZc1EwRkJUanRCUVVORU8wRkJRMFk3TzBGQlJVUXNWMEZCVDBjc1NVRkJVRHRCUVVORU96dEJRVVZFTEZOQlFVOHhRaXhEUVVGRExFZEJRVWRNTEU5QlFVOHNRMEZCUTFNc1RVRkJia0lzUlVGQk1rSTdRVUZEZWtKSUxFbEJRVUZCTEZWQlFWVTdRVUZEV0RzN1FVRkZSQ3hUUVVGUFJpeEpRVUZRTzBGQlEwUWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdablZ1WTNScGIyNGdjR0Z5YzJWUVlYUmphQ2gxYm1sRWFXWm1MQ0J2Y0hScGIyNXpJRDBnZTMwcElIdGNiaUFnYkdWMElHUnBabVp6ZEhJZ1BTQjFibWxFYVdabUxuTndiR2wwS0M5Y1hISmNYRzU4VzF4Y2JseGNkbHhjWmx4Y2NseGNlRGcxWFM4cExGeHVJQ0FnSUNBZ1pHVnNhVzFwZEdWeWN5QTlJSFZ1YVVScFptWXViV0YwWTJnb0wxeGNjbHhjYm54YlhGeHVYRngyWEZ4bVhGeHlYRng0T0RWZEwyY3BJSHg4SUZ0ZExGeHVJQ0FnSUNBZ2JHbHpkQ0E5SUZ0ZExGeHVJQ0FnSUNBZ2FTQTlJREE3WEc1Y2JpQWdablZ1WTNScGIyNGdjR0Z5YzJWSmJtUmxlQ2dwSUh0Y2JpQWdJQ0JzWlhRZ2FXNWtaWGdnUFNCN2ZUdGNiaUFnSUNCc2FYTjBMbkIxYzJnb2FXNWtaWGdwTzF4dVhHNGdJQ0FnTHk4Z1VHRnljMlVnWkdsbVppQnRaWFJoWkdGMFlWeHVJQ0FnSUhkb2FXeGxJQ2hwSUR3Z1pHbG1abk4wY2k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUd4bGRDQnNhVzVsSUQwZ1pHbG1abk4wY2x0cFhUdGNibHh1SUNBZ0lDQWdMeThnUm1sc1pTQm9aV0ZrWlhJZ1ptOTFibVFzSUdWdVpDQndZWEp6YVc1bklHUnBabVlnYldWMFlXUmhkR0ZjYmlBZ0lDQWdJR2xtSUNnb0wxNG9YRnd0WEZ3dFhGd3RmRnhjSzF4Y0sxeGNLM3hBUUNsY1hITXZLUzUwWlhOMEtHeHBibVVwS1NCN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QkVhV1ptSUdsdVpHVjRYRzRnSUNBZ0lDQnNaWFFnYUdWaFpHVnlJRDBnS0M5ZUtEODZTVzVrWlhnNmZHUnBabVlvUHpvZ0xYSWdYRngzS3lrcktWeGNjeXNvTGlzL0tWeGNjeW9rTHlrdVpYaGxZeWhzYVc1bEtUdGNiaUFnSUNBZ0lHbG1JQ2hvWldGa1pYSXBJSHRjYmlBZ0lDQWdJQ0FnYVc1a1pYZ3VhVzVrWlhnZ1BTQm9aV0ZrWlhKYk1WMDdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCUVlYSnpaU0JtYVd4bElHaGxZV1JsY25NZ2FXWWdkR2hsZVNCaGNtVWdaR1ZtYVc1bFpDNGdWVzVwWm1sbFpDQmthV1ptSUhKbGNYVnBjbVZ6SUhSb1pXMHNJR0oxZEZ4dUlDQWdJQzh2SUhSb1pYSmxKM01nYm04Z2RHVmphRzVwWTJGc0lHbHpjM1ZsY3lCMGJ5Qm9ZWFpsSUdGdUlHbHpiMnhoZEdWa0lHaDFibXNnZDJsMGFHOTFkQ0JtYVd4bElHaGxZV1JsY2x4dUlDQWdJSEJoY25ObFJtbHNaVWhsWVdSbGNpaHBibVJsZUNrN1hHNGdJQ0FnY0dGeWMyVkdhV3hsU0dWaFpHVnlLR2x1WkdWNEtUdGNibHh1SUNBZ0lDOHZJRkJoY25ObElHaDFibXR6WEc0Z0lDQWdhVzVrWlhndWFIVnVhM01nUFNCYlhUdGNibHh1SUNBZ0lIZG9hV3hsSUNocElEd2daR2xtWm5OMGNpNXNaVzVuZEdncElIdGNiaUFnSUNBZ0lHeGxkQ0JzYVc1bElEMGdaR2xtWm5OMGNsdHBYVHRjYmx4dUlDQWdJQ0FnYVdZZ0tDZ3ZYaWhKYm1SbGVEcDhaR2xtWm54Y1hDMWNYQzFjWEMxOFhGd3JYRndyWEZ3cktWeGNjeThwTG5SbGMzUW9iR2x1WlNrcElIdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tDZ3ZYa0JBTHlrdWRHVnpkQ2hzYVc1bEtTa2dlMXh1SUNBZ0lDQWdJQ0JwYm1SbGVDNW9kVzVyY3k1d2RYTm9LSEJoY25ObFNIVnVheWdwS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2JHbHVaU0FtSmlCdmNIUnBiMjV6TG5OMGNtbGpkQ2tnZTF4dUlDQWdJQ0FnSUNBdkx5QkpaMjV2Y21VZ2RXNWxlSEJsWTNSbFpDQmpiMjUwWlc1MElIVnViR1Z6Y3lCcGJpQnpkSEpwWTNRZ2JXOWtaVnh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KMVZ1YTI1dmQyNGdiR2x1WlNBbklDc2dLR2tnS3lBeEtTQXJJQ2NnSnlBcklFcFRUMDR1YzNSeWFXNW5hV1o1S0d4cGJtVXBLVHRjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR2tyS3p0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNBdkx5QlFZWEp6WlhNZ2RHaGxJQzB0TFNCaGJtUWdLeXNySUdobFlXUmxjbk1zSUdsbUlHNXZibVVnWVhKbElHWnZkVzVrTENCdWJ5QnNhVzVsYzF4dUlDQXZMeUJoY21VZ1kyOXVjM1Z0WldRdVhHNGdJR1oxYm1OMGFXOXVJSEJoY25ObFJtbHNaVWhsWVdSbGNpaHBibVJsZUNrZ2UxeHVJQ0FnSUdOdmJuTjBJR1pwYkdWSVpXRmtaWElnUFNBb0wxNG9MUzB0ZkZ4Y0sxeGNLMXhjS3lsY1hITXJLQzRxS1NRdktTNWxlR1ZqS0dScFptWnpkSEpiYVYwcE8xeHVJQ0FnSUdsbUlDaG1hV3hsU0dWaFpHVnlLU0I3WEc0Z0lDQWdJQ0JzWlhRZ2EyVjVVSEpsWm1sNElEMGdabWxzWlVobFlXUmxjbHN4WFNBOVBUMGdKeTB0TFNjZ1B5QW5iMnhrSnlBNklDZHVaWGNuTzF4dUlDQWdJQ0FnWTI5dWMzUWdaR0YwWVNBOUlHWnBiR1ZJWldGa1pYSmJNbDB1YzNCc2FYUW9KMXhjZENjc0lESXBPMXh1SUNBZ0lDQWdiR1YwSUdacGJHVk9ZVzFsSUQwZ1pHRjBZVnN3WFM1eVpYQnNZV05sS0M5Y1hGeGNYRnhjWEM5bkxDQW5YRnhjWENjcE8xeHVJQ0FnSUNBZ2FXWWdLQ2d2WGx3aUxpcGNJaVF2S1M1MFpYTjBLR1pwYkdWT1lXMWxLU2tnZTF4dUlDQWdJQ0FnSUNCbWFXeGxUbUZ0WlNBOUlHWnBiR1ZPWVcxbExuTjFZbk4wY2lneExDQm1hV3hsVG1GdFpTNXNaVzVuZEdnZ0xTQXlLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR2x1WkdWNFcydGxlVkJ5WldacGVDQXJJQ2RHYVd4bFRtRnRaU2RkSUQwZ1ptbHNaVTVoYldVN1hHNGdJQ0FnSUNCcGJtUmxlRnRyWlhsUWNtVm1hWGdnS3lBblNHVmhaR1Z5SjEwZ1BTQW9aR0YwWVZzeFhTQjhmQ0FuSnlrdWRISnBiU2dwTzF4dVhHNGdJQ0FnSUNCcEt5czdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeThnVUdGeWMyVnpJR0VnYUhWdWExeHVJQ0F2THlCVWFHbHpJR0Z6YzNWdFpYTWdkR2hoZENCM1pTQmhjbVVnWVhRZ2RHaGxJSE4wWVhKMElHOW1JR0VnYUhWdWF5NWNiaUFnWm5WdVkzUnBiMjRnY0dGeWMyVklkVzVyS0NrZ2UxeHVJQ0FnSUd4bGRDQmphSFZ1YTBobFlXUmxja2x1WkdWNElEMGdhU3hjYmlBZ0lDQWdJQ0FnWTJoMWJtdElaV0ZrWlhKTWFXNWxJRDBnWkdsbVpuTjBjbHRwS3l0ZExGeHVJQ0FnSUNBZ0lDQmphSFZ1YTBobFlXUmxjaUE5SUdOb2RXNXJTR1ZoWkdWeVRHbHVaUzV6Y0d4cGRDZ3ZRRUFnTFNoY1hHUXJLU2cvT2l3b1hGeGtLeWtwUHlCY1hDc29YRnhrS3lrb1B6b3NLRnhjWkNzcEtUOGdRRUF2S1R0Y2JseHVJQ0FnSUd4bGRDQm9kVzVySUQwZ2UxeHVJQ0FnSUNBZ2IyeGtVM1JoY25RNklDdGphSFZ1YTBobFlXUmxjbHN4WFN4Y2JpQWdJQ0FnSUc5c1pFeHBibVZ6T2lCMGVYQmxiMllnWTJoMWJtdElaV0ZrWlhKYk1sMGdQVDA5SUNkMWJtUmxabWx1WldRbklEOGdNU0E2SUN0amFIVnVhMGhsWVdSbGNsc3lYU3hjYmlBZ0lDQWdJRzVsZDFOMFlYSjBPaUFyWTJoMWJtdElaV0ZrWlhKYk0xMHNYRzRnSUNBZ0lDQnVaWGRNYVc1bGN6b2dkSGx3Wlc5bUlHTm9kVzVyU0dWaFpHVnlXelJkSUQwOVBTQW5kVzVrWldacGJtVmtKeUEvSURFZ09pQXJZMmgxYm10SVpXRmtaWEpiTkYwc1hHNGdJQ0FnSUNCc2FXNWxjem9nVzEwc1hHNGdJQ0FnSUNCc2FXNWxaR1ZzYVcxcGRHVnljem9nVzExY2JpQWdJQ0I5TzF4dVhHNGdJQ0FnTHk4Z1ZXNXBabWxsWkNCRWFXWm1JRVp2Y20xaGRDQnhkV2x5YXpvZ1NXWWdkR2hsSUdOb2RXNXJJSE5wZW1VZ2FYTWdNQ3hjYmlBZ0lDQXZMeUIwYUdVZ1ptbHljM1FnYm5WdFltVnlJR2x6SUc5dVpTQnNiM2RsY2lCMGFHRnVJRzl1WlNCM2IzVnNaQ0JsZUhCbFkzUXVYRzRnSUNBZ0x5OGdhSFIwY0hNNkx5OTNkM2N1WVhKMGFXMWhMbU52YlM5M1pXSnNiMmR6TDNacFpYZHdiM04wTG1wemNEOTBhSEpsWVdROU1UWTBNamt6WEc0Z0lDQWdhV1lnS0doMWJtc3ViMnhrVEdsdVpYTWdQVDA5SURBcElIdGNiaUFnSUNBZ0lHaDFibXN1YjJ4a1UzUmhjblFnS3owZ01UdGNiaUFnSUNCOVhHNGdJQ0FnYVdZZ0tHaDFibXN1Ym1WM1RHbHVaWE1nUFQwOUlEQXBJSHRjYmlBZ0lDQWdJR2gxYm1zdWJtVjNVM1JoY25RZ0t6MGdNVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnNaWFFnWVdSa1EyOTFiblFnUFNBd0xGeHVJQ0FnSUNBZ0lDQnlaVzF2ZG1WRGIzVnVkQ0E5SURBN1hHNGdJQ0FnWm05eUlDZzdJR2tnUENCa2FXWm1jM1J5TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQXZMeUJNYVc1bGN5QnpkR0Z5ZEdsdVp5QjNhWFJvSUNjdExTMG5JR052ZFd4a0lHSmxJRzFwYzNSaGEyVnVJR1p2Y2lCMGFHVWdYQ0p5WlcxdmRtVWdiR2x1WlZ3aUlHOXdaWEpoZEdsdmJseHVJQ0FnSUNBZ0x5OGdRblYwSUhSb1pYa2dZMjkxYkdRZ1ltVWdkR2hsSUdobFlXUmxjaUJtYjNJZ2RHaGxJRzVsZUhRZ1ptbHNaUzRnVkdobGNtVm1iM0psSUhCeWRXNWxJSE4xWTJnZ1kyRnpaWE1nYjNWMExseHVJQ0FnSUNBZ2FXWWdLR1JwWm1aemRISmJhVjB1YVc1a1pYaFBaaWduTFMwdElDY3BJRDA5UFNBd1hHNGdJQ0FnSUNBZ0lDQWdJQ0FtSmlBb2FTQXJJRElnUENCa2FXWm1jM1J5TG14bGJtZDBhQ2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDWW1JR1JwWm1aemRISmJhU0FySURGZExtbHVaR1Y0VDJZb0p5c3JLeUFuS1NBOVBUMGdNRnh1SUNBZ0lDQWdJQ0FnSUNBZ0ppWWdaR2xtWm5OMGNsdHBJQ3NnTWwwdWFXNWtaWGhQWmlnblFFQW5LU0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdiR1YwSUc5d1pYSmhkR2x2YmlBOUlDaGthV1ptYzNSeVcybGRMbXhsYm1kMGFDQTlQU0F3SUNZbUlHa2dJVDBnS0dScFptWnpkSEl1YkdWdVozUm9JQzBnTVNrcElEOGdKeUFuSURvZ1pHbG1abk4wY2x0cFhWc3dYVHRjYmx4dUlDQWdJQ0FnYVdZZ0tHOXdaWEpoZEdsdmJpQTlQVDBnSnlzbklIeDhJRzl3WlhKaGRHbHZiaUE5UFQwZ0p5MG5JSHg4SUc5d1pYSmhkR2x2YmlBOVBUMGdKeUFuSUh4OElHOXdaWEpoZEdsdmJpQTlQVDBnSjF4Y1hGd25LU0I3WEc0Z0lDQWdJQ0FnSUdoMWJtc3ViR2x1WlhNdWNIVnphQ2hrYVdabWMzUnlXMmxkS1R0Y2JpQWdJQ0FnSUNBZ2FIVnVheTVzYVc1bFpHVnNhVzFwZEdWeWN5NXdkWE5vS0dSbGJHbHRhWFJsY25OYmFWMGdmSHdnSjF4Y2JpY3BPMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaHZjR1Z5WVhScGIyNGdQVDA5SUNjckp5a2dlMXh1SUNBZ0lDQWdJQ0FnSUdGa1pFTnZkVzUwS3lzN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9iM0JsY21GMGFXOXVJRDA5UFNBbkxTY3BJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZEYjNWdWRDc3JPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0c5d1pYSmhkR2x2YmlBOVBUMGdKeUFuS1NCN1hHNGdJQ0FnSUNBZ0lDQWdZV1JrUTI5MWJuUXJLenRjYmlBZ0lDQWdJQ0FnSUNCeVpXMXZkbVZEYjNWdWRDc3JPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0JpY21WaGF6dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QklZVzVrYkdVZ2RHaGxJR1Z0Y0hSNUlHSnNiMk5ySUdOdmRXNTBJR05oYzJWY2JpQWdJQ0JwWmlBb0lXRmtaRU52ZFc1MElDWW1JR2gxYm1zdWJtVjNUR2x1WlhNZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUdoMWJtc3VibVYzVEdsdVpYTWdQU0F3TzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvSVhKbGJXOTJaVU52ZFc1MElDWW1JR2gxYm1zdWIyeGtUR2x1WlhNZ1BUMDlJREVwSUh0Y2JpQWdJQ0FnSUdoMWJtc3ViMnhrVEdsdVpYTWdQU0F3TzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUZCbGNtWnZjbTBnYjNCMGFXOXVZV3dnYzJGdWFYUjVJR05vWldOcmFXNW5YRzRnSUNBZ2FXWWdLRzl3ZEdsdmJuTXVjM1J5YVdOMEtTQjdYRzRnSUNBZ0lDQnBaaUFvWVdSa1EyOTFiblFnSVQwOUlHaDFibXN1Ym1WM1RHbHVaWE1wSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0NkQlpHUmxaQ0JzYVc1bElHTnZkVzUwSUdScFpDQnViM1FnYldGMFkyZ2dabTl5SUdoMWJtc2dZWFFnYkdsdVpTQW5JQ3NnS0dOb2RXNXJTR1ZoWkdWeVNXNWtaWGdnS3lBeEtTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaUFvY21WdGIzWmxRMjkxYm5RZ0lUMDlJR2gxYm1zdWIyeGtUR2x1WlhNcElIdGNiaUFnSUNBZ0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZFNaVzF2ZG1Wa0lHeHBibVVnWTI5MWJuUWdaR2xrSUc1dmRDQnRZWFJqYUNCbWIzSWdhSFZ1YXlCaGRDQnNhVzVsSUNjZ0t5QW9ZMmgxYm10SVpXRmtaWEpKYm1SbGVDQXJJREVwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdhSFZ1YXp0Y2JpQWdmVnh1WEc0Z0lIZG9hV3hsSUNocElEd2daR2xtWm5OMGNpNXNaVzVuZEdncElIdGNiaUFnSUNCd1lYSnpaVWx1WkdWNEtDazdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdiR2x6ZER0Y2JuMWNiaUpkZlE9PVxuIiwiLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFycmF5RXF1YWwgPSBhcnJheUVxdWFsO1xuZXhwb3J0cy5hcnJheVN0YXJ0c1dpdGggPSBhcnJheVN0YXJ0c1dpdGg7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc0wyRnljbUY1TG1weklsMHNJbTVoYldWeklqcGJJbUZ5Y21GNVJYRjFZV3dpTENKaElpd2lZaUlzSW14bGJtZDBhQ0lzSW1GeWNtRjVVM1JoY25SelYybDBhQ0lzSW1GeWNtRjVJaXdpYzNSaGNuUWlMQ0pwSWwwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzVlVGQlZDeERRVUZ2UWtNc1EwRkJjRUlzUlVGQmRVSkRMRU5CUVhaQ0xFVkJRVEJDTzBGQlF5OUNMRTFCUVVsRUxFTkJRVU1zUTBGQlEwVXNUVUZCUml4TFFVRmhSQ3hEUVVGRExFTkJRVU5ETEUxQlFXNUNMRVZCUVRKQ08wRkJRM3BDTEZkQlFVOHNTMEZCVUR0QlFVTkVPenRCUVVWRUxGTkJRVTlETEdWQlFXVXNRMEZCUTBnc1EwRkJSQ3hGUVVGSlF5eERRVUZLTEVOQlFYUkNPMEZCUTBRN08wRkJSVTBzVTBGQlUwVXNaVUZCVkN4RFFVRjVRa01zUzBGQmVrSXNSVUZCWjBORExFdEJRV2hETEVWQlFYVkRPMEZCUXpWRExFMUJRVWxCTEV0QlFVc3NRMEZCUTBnc1RVRkJUaXhIUVVGbFJTeExRVUZMTEVOQlFVTkdMRTFCUVhwQ0xFVkJRV2xETzBGQlF5OUNMRmRCUVU4c1MwRkJVRHRCUVVORU96dEJRVVZFTEU5QlFVc3NTVUZCU1Vrc1EwRkJReXhIUVVGSExFTkJRV0lzUlVGQlowSkJMRU5CUVVNc1IwRkJSMFFzUzBGQlN5eERRVUZEU0N4TlFVRXhRaXhGUVVGclEwa3NRMEZCUXl4RlFVRnVReXhGUVVGMVF6dEJRVU55UXl4UlFVRkpSQ3hMUVVGTExFTkJRVU5ETEVOQlFVUXNRMEZCVEN4TFFVRmhSaXhMUVVGTExFTkJRVU5GTEVOQlFVUXNRMEZCZEVJc1JVRkJNa0k3UVVGRGVrSXNZVUZCVHl4TFFVRlFPMEZCUTBRN1FVRkRSanM3UVVGRlJDeFRRVUZQTEVsQlFWQTdRVUZEUkNJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltVjRjRzl5ZENCbWRXNWpkR2x2YmlCaGNuSmhlVVZ4ZFdGc0tHRXNJR0lwSUh0Y2JpQWdhV1lnS0dFdWJHVnVaM1JvSUNFOVBTQmlMbXhsYm1kMGFDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUJoY25KaGVWTjBZWEowYzFkcGRHZ29ZU3dnWWlrN1hHNTlYRzVjYm1WNGNHOXlkQ0JtZFc1amRHbHZiaUJoY25KaGVWTjBZWEowYzFkcGRHZ29ZWEp5WVhrc0lITjBZWEowS1NCN1hHNGdJR2xtSUNoemRHRnlkQzVzWlc1bmRHZ2dQaUJoY25KaGVTNXNaVzVuZEdncElIdGNiaUFnSUNCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUgxY2JseHVJQ0JtYjNJZ0tHeGxkQ0JwSUQwZ01Ec2dhU0E4SUhOMFlYSjBMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnYVdZZ0tITjBZWEowVzJsZElDRTlQU0JoY25KaGVWdHBYU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCMGNuVmxPMXh1ZlZ4dUlsMTlcbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cbi8vIEl0ZXJhdG9yIHRoYXQgdHJhdmVyc2VzIGluIHRoZSByYW5nZSBvZiBbbWluLCBtYXhdLCBzdGVwcGluZ1xuLy8gYnkgZGlzdGFuY2UgZnJvbSBhIGdpdmVuIHN0YXJ0IHBvc2l0aW9uLiBJLmUuIGZvciBbMCwgNF0sIHdpdGhcbi8vIHN0YXJ0IG9mIDIsIHRoaXMgd2lsbCBpdGVyYXRlIDIsIDMsIDEsIDQsIDAuXG5mdW5jdGlvblxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xuX2RlZmF1bHRcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG4oc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcbiAgdmFyIHdhbnRGb3J3YXJkID0gdHJ1ZSxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICBsb2NhbE9mZnNldCA9IDE7XG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmIChiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FudEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG5cblxuICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgIGlmICghZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XG4gICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXG5cblxuICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xuICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpdGVyYXRvcigpO1xuICAgIH0gLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cbiAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxuXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc0wyUnBjM1JoYm1ObExXbDBaWEpoZEc5eUxtcHpJbDBzSW01aGJXVnpJanBiSW5OMFlYSjBJaXdpYldsdVRHbHVaU0lzSW0xaGVFeHBibVVpTENKM1lXNTBSbTl5ZDJGeVpDSXNJbUpoWTJ0M1lYSmtSWGhvWVhWemRHVmtJaXdpWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0lzSW14dlkyRnNUMlptYzJWMElpd2lhWFJsY21GMGIzSWlYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3p0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVObE8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNRMEZCVTBFc1MwRkJWQ3hGUVVGblFrTXNUMEZCYUVJc1JVRkJlVUpETEU5QlFYcENMRVZCUVd0RE8wRkJReTlETEUxQlFVbERMRmRCUVZjc1IwRkJSeXhKUVVGc1FqdEJRVUZCTEUxQlEwbERMR2xDUVVGcFFpeEhRVUZITEV0QlJIaENPMEZCUVVFc1RVRkZTVU1zWjBKQlFXZENMRWRCUVVjc1MwRkdka0k3UVVGQlFTeE5RVWRKUXl4WFFVRlhMRWRCUVVjc1EwRkliRUk3UVVGTFFTeFRRVUZQTEZOQlFWTkRMRkZCUVZRc1IwRkJiMEk3UVVGRGVrSXNVVUZCU1Vvc1YwRkJWeXhKUVVGSkxFTkJRVU5GTEdkQ1FVRndRaXhGUVVGelF6dEJRVU53UXl4VlFVRkpSQ3hwUWtGQlNpeEZRVUYxUWp0QlFVTnlRa1VzVVVGQlFVRXNWMEZCVnp0QlFVTmFMRTlCUmtRc1RVRkZUenRCUVVOTVNDeFJRVUZCUVN4WFFVRlhMRWRCUVVjc1MwRkJaRHRCUVVORUxFOUJURzFETEVOQlQzQkRPMEZCUTBFN096dEJRVU5CTEZWQlFVbElMRXRCUVVzc1IwRkJSMDBzVjBGQlVpeEpRVUYxUWtvc1QwRkJNMElzUlVGQmIwTTdRVUZEYkVNc1pVRkJUMGtzVjBGQlVEdEJRVU5FT3p0QlFVVkVSQ3hOUVVGQlFTeG5Ra0ZCWjBJc1IwRkJSeXhKUVVGdVFqdEJRVU5FT3p0QlFVVkVMRkZCUVVrc1EwRkJRMFFzYVVKQlFVd3NSVUZCZDBJN1FVRkRkRUlzVlVGQlNTeERRVUZEUXl4blFrRkJUQ3hGUVVGMVFqdEJRVU55UWtZc1VVRkJRVUVzVjBGQlZ5eEhRVUZITEVsQlFXUTdRVUZEUkN4UFFVaHhRaXhEUVV0MFFqdEJRVU5CT3pzN1FVRkRRU3hWUVVGSlJpeFBRVUZQTEVsQlFVbEVMRXRCUVVzc1IwRkJSMDBzVjBGQmRrSXNSVUZCYjBNN1FVRkRiRU1zWlVGQlR5eERRVUZEUVN4WFFVRlhMRVZCUVc1Q08wRkJRMFE3TzBGQlJVUkdMRTFCUVVGQkxHbENRVUZwUWl4SFFVRkhMRWxCUVhCQ08wRkJRMEVzWVVGQlQwY3NVVUZCVVN4RlFVRm1PMEZCUTBRc1MwRTVRbmRDTEVOQlowTjZRanRCUVVOQk96dEJRVU5FTEVkQmJFTkVPMEZCYlVORUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnU1hSbGNtRjBiM0lnZEdoaGRDQjBjbUYyWlhKelpYTWdhVzRnZEdobElISmhibWRsSUc5bUlGdHRhVzRzSUcxaGVGMHNJSE4wWlhCd2FXNW5YRzR2THlCaWVTQmthWE4wWVc1alpTQm1jbTl0SUdFZ1oybDJaVzRnYzNSaGNuUWdjRzl6YVhScGIyNHVJRWt1WlM0Z1ptOXlJRnN3TENBMFhTd2dkMmwwYUZ4dUx5OGdjM1JoY25RZ2IyWWdNaXdnZEdocGN5QjNhV3hzSUdsMFpYSmhkR1VnTWl3Z015d2dNU3dnTkN3Z01DNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHWjFibU4wYVc5dUtITjBZWEowTENCdGFXNU1hVzVsTENCdFlYaE1hVzVsS1NCN1hHNGdJR3hsZENCM1lXNTBSbTl5ZDJGeVpDQTlJSFJ5ZFdVc1hHNGdJQ0FnSUNCaVlXTnJkMkZ5WkVWNGFHRjFjM1JsWkNBOUlHWmhiSE5sTEZ4dUlDQWdJQ0FnWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0E5SUdaaGJITmxMRnh1SUNBZ0lDQWdiRzlqWVd4UFptWnpaWFFnUFNBeE8xeHVYRzRnSUhKbGRIVnliaUJtZFc1amRHbHZiaUJwZEdWeVlYUnZjaWdwSUh0Y2JpQWdJQ0JwWmlBb2QyRnVkRVp2Y25kaGNtUWdKaVlnSVdadmNuZGhjbVJGZUdoaGRYTjBaV1FwSUh0Y2JpQWdJQ0FnSUdsbUlDaGlZV05yZDJGeVpFVjRhR0YxYzNSbFpDa2dlMXh1SUNBZ0lDQWdJQ0JzYjJOaGJFOW1abk5sZENzck8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2QyRnVkRVp2Y25kaGNtUWdQU0JtWVd4elpUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdMeThnUTJobFkyc2dhV1lnZEhKNWFXNW5JSFJ2SUdacGRDQmlaWGx2Ym1RZ2RHVjRkQ0JzWlc1bmRHZ3NJR0Z1WkNCcFppQnViM1FzSUdOb1pXTnJJR2wwSUdacGRITmNiaUFnSUNBZ0lDOHZJR0ZtZEdWeUlHOW1abk5sZENCc2IyTmhkR2x2YmlBb2IzSWdaR1Z6YVhKbFpDQnNiMk5oZEdsdmJpQnZiaUJtYVhKemRDQnBkR1Z5WVhScGIyNHBYRzRnSUNBZ0lDQnBaaUFvYzNSaGNuUWdLeUJzYjJOaGJFOW1abk5sZENBOFBTQnRZWGhNYVc1bEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnNiMk5oYkU5bVpuTmxkRHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnWm05eWQyRnlaRVY0YUdGMWMzUmxaQ0E5SUhSeWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLQ0ZpWVdOcmQyRnlaRVY0YUdGMWMzUmxaQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tDRm1iM0ozWVhKa1JYaG9ZWFZ6ZEdWa0tTQjdYRzRnSUNBZ0lDQWdJSGRoYm5SR2IzSjNZWEprSUQwZ2RISjFaVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1EyaGxZMnNnYVdZZ2RISjVhVzVuSUhSdklHWnBkQ0JpWldadmNtVWdkR1Y0ZENCaVpXZHBibTVwYm1jc0lHRnVaQ0JwWmlCdWIzUXNJR05vWldOcklHbDBJR1pwZEhOY2JpQWdJQ0FnSUM4dklHSmxabTl5WlNCdlptWnpaWFFnYkc5allYUnBiMjVjYmlBZ0lDQWdJR2xtSUNodGFXNU1hVzVsSUR3OUlITjBZWEowSUMwZ2JHOWpZV3hQWm1aelpYUXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJQzFzYjJOaGJFOW1abk5sZENzck8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQmlZV05yZDJGeVpFVjRhR0YxYzNSbFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYVhSbGNtRjBiM0lvS1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCWFpTQjBjbWxsWkNCMGJ5Qm1hWFFnYUhWdWF5QmlaV1p2Y21VZ2RHVjRkQ0JpWldkcGJtNXBibWNnWVc1a0lHSmxlVzl1WkNCMFpYaDBJR3hsYm1kMGFDd2dkR2hsYmx4dUlDQWdJQzh2SUdoMWJtc2dZMkZ1SjNRZ1ptbDBJRzl1SUhSb1pTQjBaWGgwTGlCU1pYUjFjbTRnZFc1a1pXWnBibVZrWEc0Z0lIMDdYRzU5WEc0aVhYMD1cbiIsIi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZW5lcmF0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnM7XG5cbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXG5mdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkZWZhdWx0c1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MWRHbHNMM0JoY21GdGN5NXFjeUpkTENKdVlXMWxjeUk2V3lKblpXNWxjbUYwWlU5d2RHbHZibk1pTENKdmNIUnBiMjV6SWl3aVpHVm1ZWFZzZEhNaUxDSmpZV3hzWW1GamF5SXNJbTVoYldVaUxDSm9ZWE5QZDI1UWNtOXdaWEowZVNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPMEZCUVU4c1UwRkJVMEVzWlVGQlZDeERRVUY1UWtNc1QwRkJla0lzUlVGQmEwTkRMRkZCUVd4RExFVkJRVFJETzBGQlEycEVMRTFCUVVrc1QwRkJUMFFzVDBGQlVDeExRVUZ0UWl4VlFVRjJRaXhGUVVGdFF6dEJRVU5xUTBNc1NVRkJRVUVzVVVGQlVTeERRVUZEUXl4UlFVRlVMRWRCUVc5Q1JpeFBRVUZ3UWp0QlFVTkVMRWRCUmtRc1RVRkZUeXhKUVVGSlFTeFBRVUZLTEVWQlFXRTdRVUZEYkVJc1UwRkJTeXhKUVVGSlJ5eEpRVUZVTEVsQlFXbENTQ3hQUVVGcVFpeEZRVUV3UWp0QlFVTjRRanRCUVVOQkxGVkJRVWxCTEU5QlFVOHNRMEZCUTBrc1kwRkJVaXhEUVVGMVFrUXNTVUZCZGtJc1EwRkJTaXhGUVVGclF6dEJRVU5vUTBZc1VVRkJRVUVzVVVGQlVTeERRVUZEUlN4SlFVRkVMRU5CUVZJc1IwRkJhVUpJTEU5QlFVOHNRMEZCUTBjc1NVRkJSQ3hEUVVGNFFqdEJRVU5FTzBGQlEwWTdRVUZEUmpzN1FVRkRSQ3hUUVVGUFJpeFJRVUZRTzBGQlEwUWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpsZUhCdmNuUWdablZ1WTNScGIyNGdaMlZ1WlhKaGRHVlBjSFJwYjI1ektHOXdkR2x2Ym5Nc0lHUmxabUYxYkhSektTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ2IzQjBhVzl1Y3lBOVBUMGdKMloxYm1OMGFXOXVKeWtnZTF4dUlDQWdJR1JsWm1GMWJIUnpMbU5oYkd4aVlXTnJJRDBnYjNCMGFXOXVjenRjYmlBZ2ZTQmxiSE5sSUdsbUlDaHZjSFJwYjI1ektTQjdYRzRnSUNBZ1ptOXlJQ2hzWlhRZ2JtRnRaU0JwYmlCdmNIUnBiMjV6S1NCN1hHNGdJQ0FnSUNBdktpQnBjM1JoYm1KMWJDQnBaMjV2Y21VZ1pXeHpaU0FxTDF4dUlDQWdJQ0FnYVdZZ0tHOXdkR2x2Ym5NdWFHRnpUM2R1VUhKdmNHVnlkSGtvYm1GdFpTa3BJSHRjYmlBZ0lDQWdJQ0FnWkdWbVlYVnNkSE5iYm1GdFpWMGdQU0J2Y0hScGIyNXpXMjVoYldWZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdmVnh1SUNCeVpYUjFjbTRnWkdWbVlYVnNkSE03WEc1OVhHNGlYWDA9XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nID0+IHtcblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nIGVpdGhlciBpbnNpZGUgb3Igb3V0c2lkZSBjaGFyYWN0ZXIgc2V0cy5cblx0Ly8gVXNlIGEgc2ltcGxlIGJhY2tzbGFzaCBlc2NhcGUgd2hlbiBpdOKAmXMgYWx3YXlzIHZhbGlkLCBhbmQgYSBcXHVubm5uIGVzY2FwZSB3aGVuIHRoZSBzaW1wbGVyIGZvcm0gd291bGQgYmUgZGlzYWxsb3dlZCBieSBVbmljb2RlIHBhdHRlcm5z4oCZIHN0cmljdGVyIGdyYW1tYXIuXG5cdHJldHVybiBzdHJpbmdcblx0XHQucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy5dL2csICdcXFxcJCYnKVxuXHRcdC5yZXBsYWNlKC8tL2csICdcXFxceDJkJyk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qKlxyXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxyXG4gKiBDb3B5cmlnaHQgMjAxOSBGSU5PUyBGREMzIGNvbnRyaWJ1dG9ycyAtIHNlZSBOT1RJQ0UgZmlsZVxyXG4gKi9cbnZhciBPcGVuRXJyb3I7XG5cbihmdW5jdGlvbiAoT3BlbkVycm9yKSB7XG4gIE9wZW5FcnJvcltcIkFwcE5vdEZvdW5kXCJdID0gXCJBcHBOb3RGb3VuZFwiO1xuICBPcGVuRXJyb3JbXCJFcnJvck9uTGF1bmNoXCJdID0gXCJFcnJvck9uTGF1bmNoXCI7XG4gIE9wZW5FcnJvcltcIkFwcFRpbWVvdXRcIl0gPSBcIkFwcFRpbWVvdXRcIjtcbiAgT3BlbkVycm9yW1wiUmVzb2x2ZXJVbmF2YWlsYWJsZVwiXSA9IFwiUmVzb2x2ZXJVbmF2YWlsYWJsZVwiO1xufSkoT3BlbkVycm9yIHx8IChPcGVuRXJyb3IgPSB7fSkpO1xuXG52YXIgUmVzb2x2ZUVycm9yO1xuXG4oZnVuY3Rpb24gKFJlc29sdmVFcnJvcikge1xuICBSZXNvbHZlRXJyb3JbXCJOb0FwcHNGb3VuZFwiXSA9IFwiTm9BcHBzRm91bmRcIjtcbiAgUmVzb2x2ZUVycm9yW1wiUmVzb2x2ZXJVbmF2YWlsYWJsZVwiXSA9IFwiUmVzb2x2ZXJVbmF2YWlsYWJsZVwiO1xuICBSZXNvbHZlRXJyb3JbXCJSZXNvbHZlclRpbWVvdXRcIl0gPSBcIlJlc29sdmVyVGltZW91dFwiO1xufSkoUmVzb2x2ZUVycm9yIHx8IChSZXNvbHZlRXJyb3IgPSB7fSkpO1xuXG52YXIgQ2hhbm5lbEVycm9yO1xuXG4oZnVuY3Rpb24gKENoYW5uZWxFcnJvcikge1xuICBDaGFubmVsRXJyb3JbXCJOb0NoYW5uZWxGb3VuZFwiXSA9IFwiTm9DaGFubmVsRm91bmRcIjtcbiAgQ2hhbm5lbEVycm9yW1wiQWNjZXNzRGVuaWVkXCJdID0gXCJBY2Nlc3NEZW5pZWRcIjtcbiAgQ2hhbm5lbEVycm9yW1wiQ3JlYXRpb25GYWlsZWRcIl0gPSBcIkNyZWF0aW9uRmFpbGVkXCI7XG59KShDaGFubmVsRXJyb3IgfHwgKENoYW5uZWxFcnJvciA9IHt9KSk7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIHJ1bnRpbWVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQkMTsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQkMSkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQkMSwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQkMTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICAgbW9kdWxlLmV4cG9ydHMgXG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG59KTtcblxudmFyIERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG52YXIgVW5hdmFpbGFibGVFcnJvciA9IC8qI19fUFVSRV9fKi9uZXcgRXJyb3IoJ0ZEQzMgRGVza3RvcEFnZW50IG5vdCBhdmFpbGFibGUgYXQgYHdpbmRvdy5mZGMzYC4nKTtcbnZhciBUaW1lb3V0RXJyb3IgPSAvKiNfX1BVUkVfXyovbmV3IEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYGZkYzNSZWFkeWAgZXZlbnQuJyk7XG52YXIgVW5leHBlY3RlZEVycm9yID0gLyojX19QVVJFX18qL25ldyBFcnJvcignYGZkYzNSZWFkeWAgZXZlbnQgZmlyZWQsIGJ1dCBgd2luZG93LmZkYzNgIG5vdCBzZXQgdG8gRGVza3RvcEFnZW50LicpO1xuXG5mdW5jdGlvbiByZWplY3RJZk5vR2xvYmFsKGYpIHtcbiAgcmV0dXJuIHdpbmRvdy5mZGMzID8gZigpIDogUHJvbWlzZS5yZWplY3QoVW5hdmFpbGFibGVFcnJvcik7XG59XG5cbmZ1bmN0aW9uIHRocm93SWZOb0dsb2JhbChmKSB7XG4gIGlmICghd2luZG93LmZkYzMpIHtcbiAgICB0aHJvdyBVbmF2YWlsYWJsZUVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGYoKTtcbn1cblxudmFyIGZkYzNSZWFkeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcnVudGltZV8xLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh3YWl0Rm9yTXMpIHtcbiAgICByZXR1cm4gcnVudGltZV8xLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAod2FpdEZvck1zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgd2FpdEZvck1zID0gREVGQVVMVF9USU1FT1VUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGdsb2JhbCBpcyBhbHJlYWR5IGF2YWlsYWJsZSByZXNvbHZlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGlmICh3aW5kb3cuZmRjMykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdHMgbm90IGF2YWlsYWJsZSBzZXR1cCBhIHRpbWVvdXQgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmZkYzMgPyByZXNvbHZlKCkgOiByZWplY3QoVGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB3YWl0Rm9yTXMpOyAvLyBsaXN0ZW4gZm9yIHRoZSBmZGMzUmVhZHkgZXZlbnRcblxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmZGMzUmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuZmRjMyA/IHJlc29sdmUoKSA6IHJlamVjdChVbmV4cGVjdGVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBmZGMzUmVhZHkoX3gpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gb3BlbihhcHAsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5vcGVuKGFwcCwgY29udGV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZEludGVudChpbnRlbnQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5maW5kSW50ZW50KGludGVudCwgY29udGV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZEludGVudHNCeUNvbnRleHQoY29udGV4dCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmZpbmRJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJyb2FkY2FzdChjb250ZXh0KSB7XG4gIHRocm93SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmJyb2FkY2FzdChjb250ZXh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByYWlzZUludGVudChpbnRlbnQsIGNvbnRleHQsIGFwcCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLnJhaXNlSW50ZW50KGludGVudCwgY29udGV4dCwgYXBwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByYWlzZUludGVudEZvckNvbnRleHQoY29udGV4dCwgYXBwKSB7XG4gIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmZkYzMucmFpc2VJbnRlbnRGb3JDb250ZXh0KGNvbnRleHQsIGFwcCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkSW50ZW50TGlzdGVuZXIoaW50ZW50LCBoYW5kbGVyKSB7XG4gIHJldHVybiB0aHJvd0lmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5hZGRJbnRlbnRMaXN0ZW5lcihpbnRlbnQsIGhhbmRsZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZU9ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlT3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRocm93SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmZkYzMuYWRkQ29udGV4dExpc3RlbmVyKGNvbnRleHRUeXBlT3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhyb3dJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIoY29udGV4dFR5cGVPckhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTeXN0ZW1DaGFubmVscygpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5nZXRTeXN0ZW1DaGFubmVscygpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGpvaW5DaGFubmVsKGNoYW5uZWxJZCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmpvaW5DaGFubmVsKGNoYW5uZWxJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDaGFubmVsKGNoYW5uZWxJZCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChjaGFubmVsSWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRDaGFubmVsKCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmdldEN1cnJlbnRDaGFubmVsKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbGVhdmVDdXJyZW50Q2hhbm5lbCgpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW5mbygpIHtcbiAgcmV0dXJuIHRocm93SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmdldEluZm8oKTtcbiAgfSk7XG59XG4vKipcclxuICogQ29tcGFyZSBudW1lcmljIHNlbXZlciB2ZXJzaW9uIG51bWJlciBzdHJpbmdzIChpbiB0aGUgZm9ybSBgMS4yLjNgKS5cclxuICpcclxuICogUmV0dXJucyBgLTFgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGxvd2VyIHZlcnNpb24gbnVtYmVyIHRoYW4gdGhlIHNlY29uZCxcclxuICogYDFgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCwgMCBpZiB0aGUgYXJndW1lbnRzIGFyZVxyXG4gKiBlcXVhbCBhbmQgYG51bGxgIGlmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgY29tcGFyaXNvbi5cclxuICpcclxuICogQHBhcmFtIGFcclxuICogQHBhcmFtIGJcclxuICovXG5cbnZhciBjb21wYXJlVmVyc2lvbk51bWJlcnMgPSBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbk51bWJlcnMoYSwgYikge1xuICB0cnkge1xuICAgIHZhciBhVmVyQXJyID0gYS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICAgIHZhciBiVmVyQXJyID0gYi5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IE1hdGgubWF4KGFWZXJBcnIubGVuZ3RoLCBiVmVyQXJyLmxlbmd0aCk7IGluZGV4KyspIHtcbiAgICAgIC8qIElmIG9uZSB2ZXJzaW9uIG51bWJlciBoYXMgbW9yZSBkaWdpdHMgYW5kIHRoZSBvdGhlciBkb2VzIG5vdCwgYW5kIHRoZXkgYXJlIG90aGVyd2lzZSBlcXVhbCxcclxuICAgICAgICAgYXNzdW1lIHRoZSBsb25nZXIgaXMgZ3JlYXRlci4gRS5nLiAxLjEuMSA+IDEuMSAqL1xuICAgICAgaWYgKGluZGV4ID09PSBhVmVyQXJyLmxlbmd0aCB8fCBhVmVyQXJyW2luZGV4XSA8IGJWZXJBcnJbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGJWZXJBcnIubGVuZ3RoIHx8IGFWZXJBcnJbaW5kZXhdID4gYlZlckFycltpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29tcGFyZSB2ZXJzaW9uIHN0cmluZ3MnLCBlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgRkRDMyB2ZXJzaW9uIGluIGFuIEltcGxlbWVudGF0aW9uTWV0YWRhdGEgb2JqZWN0IGlzIGdyZWF0ZXIgdGhhblxyXG4gKiBvciBlcXVhbCB0byB0aGUgc3VwcGxpZWQgbnVtZXJpYyBzZW12ZXIgdmVyc2lvbiBudW1iZXIgc3RyaW5nIChpbiB0aGUgZm9ybSBgMS4yLjNgKS5cclxuICpcclxuICogUmV0dXJucyBhIGJvb2xlYW4gb3IgbnVsbCBpZiBhbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjb21wYXJpbmcgdGhlIHZlcnNpb24gbnVtYmVycy5cclxuICpcclxuICogQHBhcmFtIG1ldGFkYXRhXHJcbiAqIEBwYXJhbSB2ZXJzaW9uXHJcbiAqL1xuXG52YXIgdmVyc2lvbklzQXRMZWFzdCA9IGZ1bmN0aW9uIHZlcnNpb25Jc0F0TGVhc3QobWV0YWRhdGEsIHZlcnNpb24pIHtcbiAgdmFyIGNvbXBhcmlzb24gPSBjb21wYXJlVmVyc2lvbk51bWJlcnMobWV0YWRhdGEuZmRjM1ZlcnNpb24sIHZlcnNpb24pO1xuICByZXR1cm4gY29tcGFyaXNvbiA9PT0gbnVsbCA/IG51bGwgOiBjb21wYXJpc29uID49IDAgPyB0cnVlIDogZmFsc2U7XG59O1xuXG52YXIgQ29udGV4dFR5cGVzO1xuXG4oZnVuY3Rpb24gKENvbnRleHRUeXBlcykge1xuICBDb250ZXh0VHlwZXNbXCJDb250YWN0XCJdID0gXCJmZGMzLmNvbnRhY3RcIjtcbiAgQ29udGV4dFR5cGVzW1wiQ29udGFjdExpc3RcIl0gPSBcImZkYzMuY29udGFjdExpc3RcIjtcbiAgQ29udGV4dFR5cGVzW1wiQ291bnRyeVwiXSA9IFwiZmRjMy5jb3VudHJ5XCI7XG4gIENvbnRleHRUeXBlc1tcIkluc3RydW1lbnRcIl0gPSBcImZkYzMuaW5zdHJ1bWVudFwiO1xuICBDb250ZXh0VHlwZXNbXCJPcmdhbml6YXRpb25cIl0gPSBcImZkYzMub3JnYW5pemF0aW9uXCI7XG4gIENvbnRleHRUeXBlc1tcIlBvcnRmb2xpb1wiXSA9IFwiZmRjMy5wb3J0Zm9saW9cIjtcbiAgQ29udGV4dFR5cGVzW1wiUG9zaXRpb25cIl0gPSBcImZkYzMucG9zaXRpb25cIjtcbn0pKENvbnRleHRUeXBlcyB8fCAoQ29udGV4dFR5cGVzID0ge30pKTtcblxuLy8gVG8gcGFyc2UgdGhpcyBkYXRhOlxuLy9cbi8vICAgaW1wb3J0IHsgQ29udmVydCwgQ29udGV4dCwgQ29udGFjdCwgQ29udGFjdExpc3QsIEluc3RydW1lbnQsIEluc3RydW1lbnRMaXN0LCBDb3VudHJ5LCBPcmdhbml6YXRpb24sIFBvcnRmb2xpbywgUG9zaXRpb24gfSBmcm9tIFwiLi9maWxlXCI7XG4vL1xuLy8gICBjb25zdCBjb250ZXh0ID0gQ29udmVydC50b0NvbnRleHQoanNvbik7XG4vLyAgIGNvbnN0IGNvbnRhY3QgPSBDb252ZXJ0LnRvQ29udGFjdChqc29uKTtcbi8vICAgY29uc3QgY29udGFjdExpc3QgPSBDb252ZXJ0LnRvQ29udGFjdExpc3QoanNvbik7XG4vLyAgIGNvbnN0IGluc3RydW1lbnQgPSBDb252ZXJ0LnRvSW5zdHJ1bWVudChqc29uKTtcbi8vICAgY29uc3QgaW5zdHJ1bWVudExpc3QgPSBDb252ZXJ0LnRvSW5zdHJ1bWVudExpc3QoanNvbik7XG4vLyAgIGNvbnN0IGNvdW50cnkgPSBDb252ZXJ0LnRvQ291bnRyeShqc29uKTtcbi8vICAgY29uc3Qgb3JnYW5pemF0aW9uID0gQ29udmVydC50b09yZ2FuaXphdGlvbihqc29uKTtcbi8vICAgY29uc3QgcG9ydGZvbGlvID0gQ29udmVydC50b1BvcnRmb2xpbyhqc29uKTtcbi8vICAgY29uc3QgcG9zaXRpb24gPSBDb252ZXJ0LnRvUG9zaXRpb24oanNvbik7XG4vL1xuLy8gVGhlc2UgZnVuY3Rpb25zIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIEpTT04gZG9lc24ndFxuLy8gbWF0Y2ggdGhlIGV4cGVjdGVkIGludGVyZmFjZSwgZXZlbiBpZiB0aGUgSlNPTiBpcyB2YWxpZC5cbi8vIENvbnZlcnRzIEpTT04gc3RyaW5ncyB0by9mcm9tIHlvdXIgdHlwZXNcbi8vIGFuZCBhc3NlcnRzIHRoZSByZXN1bHRzIG9mIEpTT04ucGFyc2UgYXQgcnVudGltZVxudmFyIENvbnZlcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb252ZXJ0KCkge31cblxuICBDb252ZXJ0LnRvQ29udGV4dCA9IGZ1bmN0aW9uIHRvQ29udGV4dChqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignQ29udGV4dCcpKTtcbiAgfTtcblxuICBDb252ZXJ0LmNvbnRleHRUb0pzb24gPSBmdW5jdGlvbiBjb250ZXh0VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignQ29udGV4dCcpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b0NvbnRhY3QgPSBmdW5jdGlvbiB0b0NvbnRhY3QoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NvbnRhY3QnKSk7XG4gIH07XG5cbiAgQ29udmVydC5jb250YWN0VG9Kc29uID0gZnVuY3Rpb24gY29udGFjdFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NvbnRhY3QnKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Db250YWN0TGlzdCA9IGZ1bmN0aW9uIHRvQ29udGFjdExpc3QoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NvbnRhY3RMaXN0JykpO1xuICB9O1xuXG4gIENvbnZlcnQuY29udGFjdExpc3RUb0pzb24gPSBmdW5jdGlvbiBjb250YWN0TGlzdFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NvbnRhY3RMaXN0JykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvSW5zdHJ1bWVudCA9IGZ1bmN0aW9uIHRvSW5zdHJ1bWVudChqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignSW5zdHJ1bWVudCcpKTtcbiAgfTtcblxuICBDb252ZXJ0Lmluc3RydW1lbnRUb0pzb24gPSBmdW5jdGlvbiBpbnN0cnVtZW50VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignSW5zdHJ1bWVudCcpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b0luc3RydW1lbnRMaXN0ID0gZnVuY3Rpb24gdG9JbnN0cnVtZW50TGlzdChqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignSW5zdHJ1bWVudExpc3QnKSk7XG4gIH07XG5cbiAgQ29udmVydC5pbnN0cnVtZW50TGlzdFRvSnNvbiA9IGZ1bmN0aW9uIGluc3RydW1lbnRMaXN0VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignSW5zdHJ1bWVudExpc3QnKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Db3VudHJ5ID0gZnVuY3Rpb24gdG9Db3VudHJ5KGpzb24pIHtcbiAgICByZXR1cm4gY2FzdChKU09OLnBhcnNlKGpzb24pLCByKCdDb3VudHJ5JykpO1xuICB9O1xuXG4gIENvbnZlcnQuY291bnRyeVRvSnNvbiA9IGZ1bmN0aW9uIGNvdW50cnlUb0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodW5jYXN0KHZhbHVlLCByKCdDb3VudHJ5JykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvT3JnYW5pemF0aW9uID0gZnVuY3Rpb24gdG9Pcmdhbml6YXRpb24oanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ09yZ2FuaXphdGlvbicpKTtcbiAgfTtcblxuICBDb252ZXJ0Lm9yZ2FuaXphdGlvblRvSnNvbiA9IGZ1bmN0aW9uIG9yZ2FuaXphdGlvblRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ09yZ2FuaXphdGlvbicpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b1BvcnRmb2xpbyA9IGZ1bmN0aW9uIHRvUG9ydGZvbGlvKGpzb24pIHtcbiAgICByZXR1cm4gY2FzdChKU09OLnBhcnNlKGpzb24pLCByKCdQb3J0Zm9saW8nKSk7XG4gIH07XG5cbiAgQ29udmVydC5wb3J0Zm9saW9Ub0pzb24gPSBmdW5jdGlvbiBwb3J0Zm9saW9Ub0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodW5jYXN0KHZhbHVlLCByKCdQb3J0Zm9saW8nKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIHRvUG9zaXRpb24oanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ1Bvc2l0aW9uJykpO1xuICB9O1xuXG4gIENvbnZlcnQucG9zaXRpb25Ub0pzb24gPSBmdW5jdGlvbiBwb3NpdGlvblRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ1Bvc2l0aW9uJykpLCBudWxsLCAyKTtcbiAgfTtcblxuICByZXR1cm4gQ29udmVydDtcbn0oKTtcblxuZnVuY3Rpb24gaW52YWxpZFZhbHVlKHR5cCwgdmFsLCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAga2V5ID0gJyc7XG4gIH1cblxuICBpZiAoa2V5KSB7XG4gICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBFeHBlY3RlZCB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwKSArIFwiIGJ1dCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkgKyBcIiBmb3IgdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cCkpO1xufVxuXG5mdW5jdGlvbiBqc29uVG9KU1Byb3BzKHR5cCkge1xuICBpZiAodHlwLmpzb25Ub0pTID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgdHlwLnByb3BzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBtYXBbcC5qc29uXSA9IHtcbiAgICAgICAga2V5OiBwLmpzLFxuICAgICAgICB0eXA6IHAudHlwXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHR5cC5qc29uVG9KUyA9IG1hcDtcbiAgfVxuXG4gIHJldHVybiB0eXAuanNvblRvSlM7XG59XG5cbmZ1bmN0aW9uIGpzVG9KU09OUHJvcHModHlwKSB7XG4gIGlmICh0eXAuanNUb0pTT04gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICB0eXAucHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1hcFtwLmpzXSA9IHtcbiAgICAgICAga2V5OiBwLmpzb24sXG4gICAgICAgIHR5cDogcC50eXBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdHlwLmpzVG9KU09OID0gbWFwO1xuICB9XG5cbiAgcmV0dXJuIHR5cC5qc1RvSlNPTjtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtKHZhbCwgdHlwLCBnZXRQcm9wcywga2V5KSB7XG4gIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgIGtleSA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUHJpbWl0aXZlKHR5cCwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiB0eXAgPT09IHR5cGVvZiB2YWwpIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXAsIHZhbCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVVuaW9uKHR5cHMsIHZhbCkge1xuICAgIC8vIHZhbCBtdXN0IHZhbGlkYXRlIGFnYWluc3Qgb25lIHR5cCBpbiB0eXBzXG4gICAgdmFyIGwgPSB0eXBzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgX3R5cCA9IHR5cHNbaV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCBfdHlwLCBnZXRQcm9wcyk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkVmFsdWUodHlwcywgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUVudW0oY2FzZXMsIHZhbCkge1xuICAgIGlmIChjYXNlcy5pbmRleE9mKHZhbCkgIT09IC0xKSByZXR1cm4gdmFsO1xuICAgIHJldHVybiBpbnZhbGlkVmFsdWUoY2FzZXMsIHZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1BcnJheSh0eXAsIHZhbCkge1xuICAgIC8vIHZhbCBtdXN0IGJlIGFuIGFycmF5IHdpdGggbm8gaW52YWxpZCBlbGVtZW50c1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm4gaW52YWxpZFZhbHVlKCdhcnJheScsIHZhbCk7XG4gICAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGVsLCB0eXAsIGdldFByb3BzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybURhdGUodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBuZXcgRGF0ZSh2YWwpO1xuXG4gICAgaWYgKGlzTmFOKGQudmFsdWVPZigpKSkge1xuICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZSgnRGF0ZScsIHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1PYmplY3QocHJvcHMsIGFkZGl0aW9uYWwsIHZhbCkge1xuICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gaW52YWxpZFZhbHVlKCdvYmplY3QnLCB2YWwpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2tleV07XG4gICAgICB2YXIgdiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSkgPyB2YWxba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIHJlc3VsdFtwcm9wLmtleV0gPSB0cmFuc2Zvcm0odiwgcHJvcC50eXAsIGdldFByb3BzLCBwcm9wLmtleSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJhbnNmb3JtKHZhbFtrZXldLCBhZGRpdGlvbmFsLCBnZXRQcm9wcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHR5cCA9PT0gJ2FueScpIHJldHVybiB2YWw7XG5cbiAgaWYgKHR5cCA9PT0gbnVsbCkge1xuICAgIGlmICh2YWwgPT09IG51bGwpIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXAsIHZhbCk7XG4gIH1cblxuICBpZiAodHlwID09PSBmYWxzZSkgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXAsIHZhbCk7XG5cbiAgd2hpbGUgKHR5cGVvZiB0eXAgPT09ICdvYmplY3QnICYmIHR5cC5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHR5cCA9IHR5cGVNYXBbdHlwLnJlZl07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXApKSByZXR1cm4gdHJhbnNmb3JtRW51bSh0eXAsIHZhbCk7XG5cbiAgaWYgKHR5cGVvZiB0eXAgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cC5oYXNPd25Qcm9wZXJ0eSgndW5pb25NZW1iZXJzJykgPyB0cmFuc2Zvcm1Vbmlvbih0eXAudW5pb25NZW1iZXJzLCB2YWwpIDogdHlwLmhhc093blByb3BlcnR5KCdhcnJheUl0ZW1zJykgPyB0cmFuc2Zvcm1BcnJheSh0eXAuYXJyYXlJdGVtcywgdmFsKSA6IHR5cC5oYXNPd25Qcm9wZXJ0eSgncHJvcHMnKSA/IHRyYW5zZm9ybU9iamVjdChnZXRQcm9wcyh0eXApLCB0eXAuYWRkaXRpb25hbCwgdmFsKSA6IGludmFsaWRWYWx1ZSh0eXAsIHZhbCk7XG4gIH0gLy8gTnVtYmVycyBjYW4gYmUgcGFyc2VkIGJ5IERhdGUgYnV0IHNob3VsZG4ndCBiZS5cblxuXG4gIGlmICh0eXAgPT09IERhdGUgJiYgdHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHJldHVybiB0cmFuc2Zvcm1EYXRlKHZhbCk7XG4gIHJldHVybiB0cmFuc2Zvcm1QcmltaXRpdmUodHlwLCB2YWwpO1xufVxuXG5mdW5jdGlvbiBjYXN0KHZhbCwgdHlwKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0odmFsLCB0eXAsIGpzb25Ub0pTUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1bmNhc3QodmFsLCB0eXApIHtcbiAgcmV0dXJuIHRyYW5zZm9ybSh2YWwsIHR5cCwganNUb0pTT05Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGEodHlwKSB7XG4gIHJldHVybiB7XG4gICAgYXJyYXlJdGVtczogdHlwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHR5cHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVuaW9uTWVtYmVyczogdHlwc1xuICB9O1xufVxuXG5mdW5jdGlvbiBvKHByb3BzLCBhZGRpdGlvbmFsKSB7XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGFkZGl0aW9uYWw6IGFkZGl0aW9uYWxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbShhZGRpdGlvbmFsKSB7XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IFtdLFxuICAgIGFkZGl0aW9uYWw6IGFkZGl0aW9uYWxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcihuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgcmVmOiBuYW1lXG4gIH07XG59XG5cbnZhciB0eXBlTWFwID0ge1xuICBDb250ZXh0OiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfV0sICdhbnknKSxcbiAgQ29udGFjdExpc3Q6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2NvbnRhY3RzJyxcbiAgICBqczogJ2NvbnRhY3RzJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9hKCAvKiNfX1BVUkVfXyovcignQ29udGFjdCcpKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL20oJycpKVxuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJ2FueScpLFxuICBDb250YWN0OiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovcignQ29udGFjdElEJylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgQ29udGFjdElEOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdlbWFpbCcsXG4gICAganM6ICdlbWFpbCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0ZEU19JRCcsXG4gICAganM6ICdGRFNfSUQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICcnKSxcbiAgSW5zdHJ1bWVudExpc3Q6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2luc3RydW1lbnRzJyxcbiAgICBqczogJ2luc3RydW1lbnRzJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9hKCAvKiNfX1BVUkVfXyovcignSW5zdHJ1bWVudCcpKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL20oJycpKVxuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJ2FueScpLFxuICBJbnN0cnVtZW50OiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovcignSW5zdHJ1bWVudElEJylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgSW5zdHJ1bWVudElEOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdCQkcnLFxuICAgIGpzOiAnQkJHJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnQ1VTSVAnLFxuICAgIGpzOiAnQ1VTSVAnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICdGRFNfSUQnLFxuICAgIGpzOiAnRkRTX0lEJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnRklHSScsXG4gICAganM6ICdGSUdJJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnSVNJTicsXG4gICAganM6ICdJU0lOJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnUEVSTUlEJyxcbiAgICBqczogJ1BFUk1JRCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ1JJQycsXG4gICAganM6ICdSSUMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICdTRURPTCcsXG4gICAganM6ICdTRURPTCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ3RpY2tlcicsXG4gICAganM6ICd0aWNrZXInLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICcnKSxcbiAgQ291bnRyeTogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3IoJ0NvdW50cnlJRCcpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIENvdW50cnlJRDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnSVNPQUxQSEEyJyxcbiAgICBqczogJ0lTT0FMUEhBMicsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0lTT0FMUEhBMycsXG4gICAganM6ICdJU09BTFBIQTMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICcnKSxcbiAgT3JnYW5pemF0aW9uOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovcignT3JnYW5pemF0aW9uSUQnKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJ2FueScpLFxuICBPcmdhbml6YXRpb25JRDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnRkRTX0lEJyxcbiAgICBqczogJ0ZEU19JRCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0xFSScsXG4gICAganM6ICdMRUknLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICdQRVJNSUQnLFxuICAgIGpzOiAnUEVSTUlEJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnJyksXG4gIFBvcnRmb2xpbzogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAncG9zaXRpb25zJyxcbiAgICBqczogJ3Bvc2l0aW9ucycsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovYSggLyojX19QVVJFX18qL3IoJ1Bvc2l0aW9uJykpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnJykpXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIFBvc2l0aW9uOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdob2xkaW5nJyxcbiAgICBqczogJ2hvbGRpbmcnLFxuICAgIHR5cDogMy4xNFxuICB9LCB7XG4gICAganNvbjogJ2luc3RydW1lbnQnLFxuICAgIGpzOiAnaW5zdHJ1bWVudCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovcignSW5zdHJ1bWVudCcpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnJykpXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55Jylcbn07XG5cbnZhciBJbnRlbnRzO1xuXG4oZnVuY3Rpb24gKEludGVudHMpIHtcbiAgSW50ZW50c1tcIlN0YXJ0Q2FsbFwiXSA9IFwiU3RhcnRDYWxsXCI7XG4gIEludGVudHNbXCJTdGFydENoYXRcIl0gPSBcIlN0YXJ0Q2hhdFwiO1xuICBJbnRlbnRzW1wiVmlld0NoYXJ0XCJdID0gXCJWaWV3Q2hhcnRcIjtcbiAgSW50ZW50c1tcIlZpZXdDb250YWN0XCJdID0gXCJWaWV3Q29udGFjdFwiO1xuICBJbnRlbnRzW1wiVmlld1F1b3RlXCJdID0gXCJWaWV3UXVvdGVcIjtcbiAgSW50ZW50c1tcIlZpZXdOZXdzXCJdID0gXCJWaWV3TmV3c1wiO1xuICBJbnRlbnRzW1wiVmlld0luc3RydW1lbnRcIl0gPSBcIlZpZXdJbnN0cnVtZW50XCI7XG4gIEludGVudHNbXCJWaWV3QW5hbHlzaXNcIl0gPSBcIlZpZXdBbmFseXNpc1wiO1xufSkoSW50ZW50cyB8fCAoSW50ZW50cyA9IHt9KSk7XG5cbmV4cG9ydCB7IENoYW5uZWxFcnJvciwgQ29udGV4dFR5cGVzLCBDb252ZXJ0LCBJbnRlbnRzLCBPcGVuRXJyb3IsIFJlc29sdmVFcnJvciwgYWRkQ29udGV4dExpc3RlbmVyLCBhZGRJbnRlbnRMaXN0ZW5lciwgYnJvYWRjYXN0LCBjb21wYXJlVmVyc2lvbk51bWJlcnMsIGZkYzNSZWFkeSwgZmluZEludGVudCwgZmluZEludGVudHNCeUNvbnRleHQsIGdldEN1cnJlbnRDaGFubmVsLCBnZXRJbmZvLCBnZXRPckNyZWF0ZUNoYW5uZWwsIGdldFN5c3RlbUNoYW5uZWxzLCBqb2luQ2hhbm5lbCwgbGVhdmVDdXJyZW50Q2hhbm5lbCwgb3BlbiwgcmFpc2VJbnRlbnQsIHJhaXNlSW50ZW50Rm9yQ29udGV4dCwgdmVyc2lvbklzQXRMZWFzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmRjMy5lc20uanMubWFwXG4iLCIvKipcclxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcclxuICogQ29weXJpZ2h0IEZJTk9TIEZEQzMgY29udHJpYnV0b3JzIC0gc2VlIE5PVElDRSBmaWxlXHJcbiAqL1xuXG4vKiogQ29uc3RhbnRzIHJlcHJlc2VudGluZyB0aGUgZXJyb3JzIHRoYXQgY2FuIGJlIGVuY291bnRlcmVkIHdoZW4gY2FsbGluZyB0aGUgYG9wZW5gIG1ldGhvZCBvbiB0aGUgRGVza3RvcEFnZW50IG9iamVjdCAoYGZkYzNgKS4gKi9cbnZhciBPcGVuRXJyb3I7XG5cbihmdW5jdGlvbiAoT3BlbkVycm9yKSB7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGlzIG5vdCBmb3VuZC4qL1xuICBPcGVuRXJyb3JbXCJBcHBOb3RGb3VuZFwiXSA9IFwiQXBwTm90Rm91bmRcIjtcbiAgLyoqIFJldHVybmVkIGlmIHRoZSBzcGVjaWZpZWQgYXBwbGljYXRpb24gZmFpbHMgdG8gbGF1bmNoIGNvcnJlY3RseS4qL1xuXG4gIE9wZW5FcnJvcltcIkVycm9yT25MYXVuY2hcIl0gPSBcIkVycm9yT25MYXVuY2hcIjtcbiAgLyoqIFJldHVybmVkIGlmIHRoZSBzcGVjaWZpZWQgYXBwbGljYXRpb24gbGF1bmNoZXMgYnV0IGZhaWxzIHRvIGFkZCBhIGNvbnRleHQgbGlzdGVuZXIgaW4gb3JkZXIgdG8gcmVjZWl2ZSB0aGUgY29udGV4dCBwYXNzZWQgdG8gdGhlIGBmZGMzLm9wZW5gIGNhbGwuKi9cblxuICBPcGVuRXJyb3JbXCJBcHBUaW1lb3V0XCJdID0gXCJBcHBUaW1lb3V0XCI7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgRkRDMyBkZXNrdG9wIGFnZW50IGltcGxlbWVudGF0aW9uIGlzIG5vdCBjdXJyZW50bHkgYWJsZSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuKi9cblxuICBPcGVuRXJyb3JbXCJSZXNvbHZlclVuYXZhaWxhYmxlXCJdID0gXCJSZXNvbHZlclVuYXZhaWxhYmxlXCI7XG59KShPcGVuRXJyb3IgfHwgKE9wZW5FcnJvciA9IHt9KSk7XG4vKiogQ29uc3RhbnRzIHJlcHJlc2VudGluZyB0aGUgZXJyb3JzIHRoYXQgY2FuIGJlIGVuY291bnRlcmVkIHdoZW4gY2FsbGluZyB0aGUgYGZpbmRJbnRlbnRgLCBgZmluZEludGVudHNCeUNvbnRleHRgLCBgcmFpc2VJbnRlbnRgIG9yIGByYWlzZUludGVudEZvckNvbnRleHRgIG1ldGhvZHMgb24gdGhlIERlc2t0b3BBZ2VudCAoYGZkYzNgKS4gKi9cblxuXG52YXIgUmVzb2x2ZUVycm9yO1xuXG4oZnVuY3Rpb24gKFJlc29sdmVFcnJvcikge1xuICAvKiogU0hPVUxEIGJlIHJldHVybmVkIGlmIG5vIGFwcHMgYXJlIGF2YWlsYWJsZSB0aGF0IGNhbiByZXNvbHZlIHRoZSBpbnRlbnQgYW5kIGNvbnRleHQgY29tYmluYXRpb24uKi9cbiAgUmVzb2x2ZUVycm9yW1wiTm9BcHBzRm91bmRcIl0gPSBcIk5vQXBwc0ZvdW5kXCI7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgRkRDMyBkZXNrdG9wIGFnZW50IGltcGxlbWVudGF0aW9uIGlzIG5vdCBjdXJyZW50bHkgYWJsZSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuKi9cblxuICBSZXNvbHZlRXJyb3JbXCJSZXNvbHZlclVuYXZhaWxhYmxlXCJdID0gXCJSZXNvbHZlclVuYXZhaWxhYmxlXCI7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgdXNlciBjYW5jZWxsZWQgdGhlIHJlc29sdXRpb24gcmVxdWVzdCwgZm9yIGV4YW1wbGUgYnkgY2xvc2luZyBvciBjYW5jZWxsaW5nIGEgcmVzb2x2ZXIgVUkuKi9cblxuICBSZXNvbHZlRXJyb3JbXCJVc2VyQ2FuY2VsbGVkXCJdID0gXCJVc2VyQ2FuY2VsbGVkUmVzb2x1dGlvblwiO1xuICAvKiogU0hPVUxEIGJlIHJldHVybmVkIGlmIGEgdGltZW91dCBjYW5jZWxzIGFuIGludGVudCByZXNvbHV0aW9uIHRoYXQgcmVxdWlyZWQgdXNlciBpbnRlcmFjdGlvbi4gUGxlYXNlIHVzZSBgUmVzb2x2ZXJVbmF2YWlsYWJsZWAgaW5zdGVhZCBmb3Igc2l0dWF0aW9ucyB3aGVyZSBhIHJlc29sdmVyIFVJIG9yIHNpbWlsYXIgZmFpbHMuKi9cblxuICBSZXNvbHZlRXJyb3JbXCJSZXNvbHZlclRpbWVvdXRcIl0gPSBcIlJlc29sdmVyVGltZW91dFwiO1xuICAvKiogUmV0dXJuZWQgaWYgYSBzcGVjaWZpZWQgdGFyZ2V0IGFwcGxpY2F0aW9uIGlzIG5vdCBhdmFpbGFibGUgb3IgYSBuZXcgaW5zdGFuY2Ugb2YgaXQgY2Fubm90IGJlIG9wZW5lZC4gKi9cblxuICBSZXNvbHZlRXJyb3JbXCJUYXJnZXRBcHBVbmF2YWlsYWJsZVwiXSA9IFwiVGFyZ2V0QXBwVW5hdmFpbGFibGVcIjtcbiAgLyoqIFJldHVybmVkIGlmIGEgc3BlY2lmaWVkIHRhcmdldCBhcHBsaWNhdGlvbiBpbnN0YW5jZSBpcyBub3QgYXZhaWxhYmxlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGhhcyBiZWVuIGNsb3NlZC4gKi9cblxuICBSZXNvbHZlRXJyb3JbXCJUYXJnZXRJbnN0YW5jZVVuYXZhaWxhYmxlXCJdID0gXCJUYXJnZXRJbnN0YW5jZVVuYXZhaWxhYmxlXCI7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgaW50ZW50IGFuZCBjb250ZXh0IGNvdWxkIG5vdCBiZSBkZWxpdmVyZWQgdG8gdGhlIHNlbGVjdGVkIGFwcGxpY2F0aW9uIG9yIGluc3RhbmNlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGhhcyBub3QgYWRkZWQgYW4gaW50ZW50IGhhbmRsZXIgd2l0aGluIGEgdGltZW91dC4qL1xuXG4gIFJlc29sdmVFcnJvcltcIkludGVudERlbGl2ZXJ5RmFpbGVkXCJdID0gXCJJbnRlbnREZWxpdmVyeUZhaWxlZFwiO1xufSkoUmVzb2x2ZUVycm9yIHx8IChSZXNvbHZlRXJyb3IgPSB7fSkpO1xuXG52YXIgUmVzdWx0RXJyb3I7XG5cbihmdW5jdGlvbiAoUmVzdWx0RXJyb3IpIHtcbiAgLyoqIFJldHVybmVkIGlmIHRoZSBpbnRlbnQgaGFuZGxlciBleGl0ZWQgd2l0aG91dCByZXR1cm5pbmcgYSBQcm9taXNlIG9yIHRoYXQgUHJvbWlzZSB3YXMgbm90IHJlc29sdmVkIHdpdGggYSBDb250ZXh0IG9yIENoYW5uZWwgb2JqZWN0LiAqL1xuICBSZXN1bHRFcnJvcltcIk5vUmVzdWx0UmV0dXJuZWRcIl0gPSBcIk5vUmVzdWx0UmV0dXJuZWRcIjtcbiAgLyoqIFJldHVybmVkIGlmIHRoZSBJbnRlbnQgaGFuZGxlciBmdW5jdGlvbiBwcm9jZXNzaW5nIHRoZSByYWlzZWQgaW50ZW50IHRocm93cyBhbiBlcnJvciBvciByZWplY3RzIHRoZSBQcm9taXNlIGl0IHJldHVybmVkLiAqL1xuXG4gIFJlc3VsdEVycm9yW1wiSW50ZW50SGFuZGxlclJlamVjdGVkXCJdID0gXCJJbnRlbnRIYW5kbGVyUmVqZWN0ZWRcIjtcbn0pKFJlc3VsdEVycm9yIHx8IChSZXN1bHRFcnJvciA9IHt9KSk7XG5cbnZhciBDaGFubmVsRXJyb3I7XG5cbihmdW5jdGlvbiAoQ2hhbm5lbEVycm9yKSB7XG4gIC8qKiBSZXR1cm5lZCBpZiB0aGUgc3BlY2lmaWVkIGNoYW5uZWwgaXMgbm90IGZvdW5kIHdoZW4gYXR0ZW1wdGluZyB0byBqb2luIGEgY2hhbm5lbCB2aWEgdGhlIGBqb2luVXNlckNoYW5uZWxgIGZ1bmN0aW9uICBvZiB0aGUgRGVza3RvcEFnZW50IChgZmRjM2ApLiovXG4gIENoYW5uZWxFcnJvcltcIk5vQ2hhbm5lbEZvdW5kXCJdID0gXCJOb0NoYW5uZWxGb3VuZFwiO1xuICAvKiogU0hPVUxEIGJlIHJldHVybmVkIHdoZW4gYSByZXF1ZXN0IHRvIGpvaW4gYSB1c2VyIGNoYW5uZWwgb3IgdG8gYSByZXRyaWV2ZSBhIENoYW5uZWwgb2JqZWN0IHZpYSB0aGUgYGpvaW5Vc2VyQ2hhbm5lbGAgb3IgYGdldE9yQ3JlYXRlQ2hhbm5lbGAgbWV0aG9kcyBvZiB0aGUgRGVza3RvcEFnZW50IChgZmRjM2ApIG9iamVjdCBpcyBkZW5pZWQuICovXG5cbiAgQ2hhbm5lbEVycm9yW1wiQWNjZXNzRGVuaWVkXCJdID0gXCJBY2Nlc3NEZW5pZWRcIjtcbiAgLyoqIFNIT1VMRCBiZSByZXR1cm5lZCB3aGVuIGEgY2hhbm5lbCBjYW5ub3QgYmUgY3JlYXRlZCBvciByZXRyaWV2ZWQgdmlhIHRoZSBgZ2V0T3JDcmVhdGVDaGFubmVsYCBtZXRob2Qgb2YgdGhlIERlc2t0b3BBZ2VudCAoYGZkYzNgKS4qL1xuXG4gIENoYW5uZWxFcnJvcltcIkNyZWF0aW9uRmFpbGVkXCJdID0gXCJDcmVhdGlvbkZhaWxlZFwiO1xufSkoQ2hhbm5lbEVycm9yIHx8IChDaGFubmVsRXJyb3IgPSB7fSkpO1xuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG5cbiAgX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IHt9LFxuICAgICAgT3AgPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSksIG9ialtrZXldO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgICBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksXG4gICAgICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5faW52b2tlID0gZnVuY3Rpb24gKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuXG4gICAgICAgIGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkge1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgICBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KGlubmVyRm4sIHNlbGYsIGNvbnRleHQpLCBnZW5lcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7XG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnLFxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWx1ZSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkge1xuICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSkgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgIHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuICAgIDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiAhMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbiksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7XG4gIH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjtcbiAgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogYXJnXG4gICAgfTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpO1xuXG4gICAgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgZm9yICg7IGtleXMubGVuZ3RoOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gITA7XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sXG4gICAgICAgICAgICByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7XG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiAoZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2F0Y2g6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9LCBleHBvcnRzO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG52YXIgVW5hdmFpbGFibGVFcnJvciA9IC8qI19fUFVSRV9fKi9uZXcgRXJyb3IoJ0ZEQzMgRGVza3RvcEFnZW50IG5vdCBhdmFpbGFibGUgYXQgYHdpbmRvdy5mZGMzYC4nKTtcbnZhciBUaW1lb3V0RXJyb3IgPSAvKiNfX1BVUkVfXyovbmV3IEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgYGZkYzNSZWFkeWAgZXZlbnQuJyk7XG52YXIgVW5leHBlY3RlZEVycm9yID0gLyojX19QVVJFX18qL25ldyBFcnJvcignYGZkYzNSZWFkeWAgZXZlbnQgZmlyZWQsIGJ1dCBgd2luZG93LmZkYzNgIG5vdCBzZXQgdG8gRGVza3RvcEFnZW50LicpO1xuXG5mdW5jdGlvbiByZWplY3RJZk5vR2xvYmFsKGYpIHtcbiAgcmV0dXJuIHdpbmRvdy5mZGMzID8gZigpIDogUHJvbWlzZS5yZWplY3QoVW5hdmFpbGFibGVFcnJvcik7XG59XG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGltbWVhZGlhdGVseVxyXG4gKiBpZiB0aGUgZGVza3RvcCBhZ2VudCBBUEkgaXMgZm91bmQgYXQgYHdpbmRvdy5mZGMzYC4gSWYgdGhlIEFQSSBpcyBmb3VuZCxcclxuICogdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gdGhlIGBmZGMzUmVhZHlgIGV2ZW50IGlzIHJlY2VpdmVkIG9yIGlmIGl0XHJcbiAqIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCB0aW1lb3V0LiBJZiB0aGUgQVBJIGlzIG5vdCBmb3VuZCwgaXRcclxuICogd2lsbCByZWplY3Qgd2l0aCBhbiBlcnJvci5cclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBhd2FpdCBmZGMzUmVhZHkoKTtcclxuICogY29uc3QgaW50ZW50TGlzdGVuZXIgPSBhd2FpdCBhZGRJbnRlbnRMaXN0ZW5lcihcIlZpZXdDaGFydFwiLCBpbnRlbnRIYW5kbGVyRm4pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHdhaXRGb3JNcyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgRkRDMyBBUEkgdG8gYmVcclxuICogcmVhZHkuIERlZmF1bHRzIHRvIDUgc2Vjb25kcy5cclxuICovXG5cblxudmFyIGZkYzNSZWFkeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh3YWl0Rm9yTXMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAod2FpdEZvck1zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgd2FpdEZvck1zID0gREVGQVVMVF9USU1FT1VUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGdsb2JhbCBpcyBhbHJlYWR5IGF2YWlsYWJsZSByZXNvbHZlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGlmICh3aW5kb3cuZmRjMykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdHMgbm90IGF2YWlsYWJsZSBzZXR1cCBhIHRpbWVvdXQgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmZkYzMgPyByZXNvbHZlKCkgOiByZWplY3QoVGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB3YWl0Rm9yTXMpOyAvLyBsaXN0ZW4gZm9yIHRoZSBmZGMzUmVhZHkgZXZlbnRcblxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmZGMzUmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuZmRjMyA/IHJlc29sdmUoKSA6IHJlamVjdChVbmV4cGVjdGVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBmZGMzUmVhZHkoX3gpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcHApIHtcbiAgcmV0dXJuIHR5cGVvZiBhcHAgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBvcGVuKGFwcCwgY29udGV4dCkge1xuICBpZiAoaXNTdHJpbmcoYXBwKSkge1xuICAgIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZmRjMy5vcGVuKGFwcCwgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5mZGMzLm9wZW4oYXBwLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZEludGVudChpbnRlbnQsIGNvbnRleHQsIHJlc3VsdFR5cGUpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5maW5kSW50ZW50KGludGVudCwgY29udGV4dCwgcmVzdWx0VHlwZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZEludGVudHNCeUNvbnRleHQoY29udGV4dCwgcmVzdWx0VHlwZSkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmZpbmRJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQsIHJlc3VsdFR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJyb2FkY2FzdChjb250ZXh0KSB7XG4gIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmZkYzMuYnJvYWRjYXN0KGNvbnRleHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJhaXNlSW50ZW50KGludGVudCwgY29udGV4dCwgYXBwKSB7XG4gIGlmIChhcHAgJiYgaXNTdHJpbmcoYXBwKSkge1xuICAgIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZmRjMy5yYWlzZUludGVudChpbnRlbnQsIGNvbnRleHQsIGFwcCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5mZGMzLnJhaXNlSW50ZW50KGludGVudCwgY29udGV4dCwgYXBwKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcmFpc2VJbnRlbnRGb3JDb250ZXh0KGNvbnRleHQsIGFwcCkge1xuICBpZiAoYXBwICYmIGlzU3RyaW5nKGFwcCkpIHtcbiAgICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmZkYzMucmFpc2VJbnRlbnRGb3JDb250ZXh0KGNvbnRleHQsIGFwcCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5mZGMzLnJhaXNlSW50ZW50Rm9yQ29udGV4dChjb250ZXh0LCBhcHApO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhZGRJbnRlbnRMaXN0ZW5lcihpbnRlbnQsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5hZGRJbnRlbnRMaXN0ZW5lcihpbnRlbnQsIGhhbmRsZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZU9ySGFuZGxlciwgaGFuZGxlcikge1xuICAvL0hhbmRsZSAoZGVwcmVjYXRlZCkgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYWxsb3dlZCBjb250ZXh0VHlwZSBhcmd1bWVudCB0byBiZSBvbWl0dGVkXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGVPckhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmZkYzMuYWRkQ29udGV4dExpc3RlbmVyKGNvbnRleHRUeXBlT3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmZkYzMuYWRkQ29udGV4dExpc3RlbmVyKG51bGwsIGNvbnRleHRUeXBlT3JIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VXNlckNoYW5uZWxzKCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgLy9mYWxsYmFjayB0byBnZXRTeXN0ZW1DaGFubmVscyBmb3IgRkRDMyA8Mi4wIGltcGxlbWVudGF0aW9uc1xuICAgIGlmICh3aW5kb3cuZmRjMy5nZXRVc2VyQ2hhbm5lbHMpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZmRjMy5nZXRVc2VyQ2hhbm5lbHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdy5mZGMzLmdldFN5c3RlbUNoYW5uZWxzKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN5c3RlbUNoYW5uZWxzKCkge1xuICAvL2ZhbGxmb3J3YXJkIHRvIGdldFVzZXJDaGFubmVscyBmb3IgRkRDMyAyLjArIGltcGxlbWVudGF0aW9uc1xuICByZXR1cm4gZ2V0VXNlckNoYW5uZWxzKCk7XG59XG5mdW5jdGlvbiBqb2luVXNlckNoYW5uZWwoY2hhbm5lbElkKSB7XG4gIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZhbGxiYWNrIHRvIGpvaW5DaGFubmVsIGZvciBGREMzIDwyLjAgaW1wbGVtZW50YXRpb25zXG4gICAgaWYgKHdpbmRvdy5mZGMzLmpvaW5Vc2VyQ2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5mZGMzLmpvaW5Vc2VyQ2hhbm5lbChjaGFubmVsSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93LmZkYzMuam9pbkNoYW5uZWwoY2hhbm5lbElkKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gam9pbkNoYW5uZWwoY2hhbm5lbElkKSB7XG4gIC8vZmFsbGZvcndhcmQgdG8gam9pblVzZXJDaGFubmVsIGZvciBGREMzIDIuMCsgaW1wbGVtZW50YXRpb25zXG4gIHJldHVybiBqb2luVXNlckNoYW5uZWwoY2hhbm5lbElkKTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ2hhbm5lbChjaGFubmVsSWQpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoY2hhbm5lbElkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50Q2hhbm5lbCgpIHtcbiAgcmV0dXJuIHJlamVjdElmTm9HbG9iYWwoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuZmRjMy5nZXRDdXJyZW50Q2hhbm5lbCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGxlYXZlQ3VycmVudENoYW5uZWwoKSB7XG4gIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmZkYzMubGVhdmVDdXJyZW50Q2hhbm5lbCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEluZm8oKSB7XG4gIHJldHVybiByZWplY3RJZk5vR2xvYmFsKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmZkYzMuZ2V0SW5mbygpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFwcE1ldGFkYXRhKGFwcCkge1xuICByZXR1cm4gcmVqZWN0SWZOb0dsb2JhbChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZGMzLmdldEFwcE1ldGFkYXRhKGFwcCk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIENvbXBhcmUgbnVtZXJpYyBzZW12ZXIgdmVyc2lvbiBudW1iZXIgc3RyaW5ncyAoaW4gdGhlIGZvcm0gYDEuMi4zYCkuXHJcbiAqXHJcbiAqIFJldHVybnMgYC0xYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBsb3dlciB2ZXJzaW9uIG51bWJlciB0aGFuIHRoZSBzZWNvbmQsXHJcbiAqIGAxYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQsIDAgaWYgdGhlIGFyZ3VtZW50cyBhcmVcclxuICogZXF1YWwgYW5kIGBudWxsYCBpZiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGNvbXBhcmlzb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBhXHJcbiAqIEBwYXJhbSBiXHJcbiAqL1xuXG52YXIgY29tcGFyZVZlcnNpb25OdW1iZXJzID0gZnVuY3Rpb24gY29tcGFyZVZlcnNpb25OdW1iZXJzKGEsIGIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYVZlckFyciA9IGEuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgICB2YXIgYlZlckFyciA9IGIuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBNYXRoLm1heChhVmVyQXJyLmxlbmd0aCwgYlZlckFyci5sZW5ndGgpOyBpbmRleCsrKSB7XG4gICAgICAvKiBJZiBvbmUgdmVyc2lvbiBudW1iZXIgaGFzIG1vcmUgZGlnaXRzIGFuZCB0aGUgb3RoZXIgZG9lcyBub3QsIGFuZCB0aGV5IGFyZSBvdGhlcndpc2UgZXF1YWwsXHJcbiAgICAgICAgIGFzc3VtZSB0aGUgbG9uZ2VyIGlzIGdyZWF0ZXIuIEUuZy4gMS4xLjEgPiAxLjEgKi9cbiAgICAgIGlmIChpbmRleCA9PT0gYVZlckFyci5sZW5ndGggfHwgYVZlckFycltpbmRleF0gPCBiVmVyQXJyW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBiVmVyQXJyLmxlbmd0aCB8fCBhVmVyQXJyW2luZGV4XSA+IGJWZXJBcnJbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvbXBhcmUgdmVyc2lvbiBzdHJpbmdzJywgZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIEZEQzMgdmVyc2lvbiBpbiBhbiBJbXBsZW1lbnRhdGlvbk1ldGFkYXRhIG9iamVjdCBpcyBncmVhdGVyIHRoYW5cclxuICogb3IgZXF1YWwgdG8gdGhlIHN1cHBsaWVkIG51bWVyaWMgc2VtdmVyIHZlcnNpb24gbnVtYmVyIHN0cmluZyAoaW4gdGhlIGZvcm0gYDEuMi4zYCkuXHJcbiAqXHJcbiAqIFJldHVybnMgYSBib29sZWFuIG9yIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY29tcGFyaW5nIHRoZSB2ZXJzaW9uIG51bWJlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXRhZGF0YVxyXG4gKiBAcGFyYW0gdmVyc2lvblxyXG4gKi9cblxudmFyIHZlcnNpb25Jc0F0TGVhc3QgPSBmdW5jdGlvbiB2ZXJzaW9uSXNBdExlYXN0KG1ldGFkYXRhLCB2ZXJzaW9uKSB7XG4gIHZhciBjb21wYXJpc29uID0gY29tcGFyZVZlcnNpb25OdW1iZXJzKG1ldGFkYXRhLmZkYzNWZXJzaW9uLCB2ZXJzaW9uKTtcbiAgcmV0dXJuIGNvbXBhcmlzb24gPT09IG51bGwgPyBudWxsIDogY29tcGFyaXNvbiA+PSAwID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxudmFyIENvbnRleHRUeXBlcztcblxuKGZ1bmN0aW9uIChDb250ZXh0VHlwZXMpIHtcbiAgQ29udGV4dFR5cGVzW1wiQ2hhcnRcIl0gPSBcImZkYzMuY2hhcnRcIjtcbiAgQ29udGV4dFR5cGVzW1wiQ2hhdEluaXRTZXR0aW5nc1wiXSA9IFwiZmRjMy5jaGF0LmluaXRTZXR0aW5nc1wiO1xuICBDb250ZXh0VHlwZXNbXCJDb250YWN0XCJdID0gXCJmZGMzLmNvbnRhY3RcIjtcbiAgQ29udGV4dFR5cGVzW1wiQ29udGFjdExpc3RcIl0gPSBcImZkYzMuY29udGFjdExpc3RcIjtcbiAgQ29udGV4dFR5cGVzW1wiQ291bnRyeVwiXSA9IFwiZmRjMy5jb3VudHJ5XCI7XG4gIENvbnRleHRUeXBlc1tcIkN1cnJlbmN5XCJdID0gXCJmZGMzLmN1cnJlbmN5XCI7XG4gIENvbnRleHRUeXBlc1tcIkVtYWlsXCJdID0gXCJmZGMzLmVtYWlsXCI7XG4gIENvbnRleHRUeXBlc1tcIkluc3RydW1lbnRcIl0gPSBcImZkYzMuaW5zdHJ1bWVudFwiO1xuICBDb250ZXh0VHlwZXNbXCJJbnN0cnVtZW50TGlzdFwiXSA9IFwiZmRjMy5pbnN0cnVtZW50TGlzdFwiO1xuICBDb250ZXh0VHlwZXNbXCJPcmdhbml6YXRpb25cIl0gPSBcImZkYzMub3JnYW5pemF0aW9uXCI7XG4gIENvbnRleHRUeXBlc1tcIlBvcnRmb2xpb1wiXSA9IFwiZmRjMy5wb3J0Zm9saW9cIjtcbiAgQ29udGV4dFR5cGVzW1wiUG9zaXRpb25cIl0gPSBcImZkYzMucG9zaXRpb25cIjtcbiAgQ29udGV4dFR5cGVzW1wiTm90aGluZ1wiXSA9IFwiZmRjMy5ub3RoaW5nXCI7XG4gIENvbnRleHRUeXBlc1tcIlRpbWVSYW5nZVwiXSA9IFwiZmRjMy50aW1lcmFuZ2VcIjtcbiAgQ29udGV4dFR5cGVzW1wiVmFsdWF0aW9uXCJdID0gXCJmZGMzLnZhbHVhdGlvblwiO1xufSkoQ29udGV4dFR5cGVzIHx8IChDb250ZXh0VHlwZXMgPSB7fSkpO1xuXG4vLyBUbyBwYXJzZSB0aGlzIGRhdGE6XG4vL1xuLy8gICBpbXBvcnQgeyBDb252ZXJ0LCBDb250ZXh0LCBDaGFydCwgQ2hhdEluaXRTZXR0aW5ncywgQ29udGFjdCwgQ29udGFjdExpc3QsIENvdW50cnksIEN1cnJlbmN5LCBFbWFpbCwgSW5zdHJ1bWVudCwgSW5zdHJ1bWVudExpc3QsIE5vdGhpbmcsIE9yZ2FuaXphdGlvbiwgUG9ydGZvbGlvLCBQb3NpdGlvbiwgVGltZVJhbmdlLCBWYWx1YXRpb24gfSBmcm9tIFwiLi9maWxlXCI7XG4vL1xuLy8gICBjb25zdCBjb250ZXh0ID0gQ29udmVydC50b0NvbnRleHQoanNvbik7XG4vLyAgIGNvbnN0IGNoYXJ0ID0gQ29udmVydC50b0NoYXJ0KGpzb24pO1xuLy8gICBjb25zdCBjaGF0SW5pdFNldHRpbmdzID0gQ29udmVydC50b0NoYXRJbml0U2V0dGluZ3MoanNvbik7XG4vLyAgIGNvbnN0IGNvbnRhY3QgPSBDb252ZXJ0LnRvQ29udGFjdChqc29uKTtcbi8vICAgY29uc3QgY29udGFjdExpc3QgPSBDb252ZXJ0LnRvQ29udGFjdExpc3QoanNvbik7XG4vLyAgIGNvbnN0IGNvdW50cnkgPSBDb252ZXJ0LnRvQ291bnRyeShqc29uKTtcbi8vICAgY29uc3QgY3VycmVuY3kgPSBDb252ZXJ0LnRvQ3VycmVuY3koanNvbik7XG4vLyAgIGNvbnN0IGVtYWlsID0gQ29udmVydC50b0VtYWlsKGpzb24pO1xuLy8gICBjb25zdCBpbnN0cnVtZW50ID0gQ29udmVydC50b0luc3RydW1lbnQoanNvbik7XG4vLyAgIGNvbnN0IGluc3RydW1lbnRMaXN0ID0gQ29udmVydC50b0luc3RydW1lbnRMaXN0KGpzb24pO1xuLy8gICBjb25zdCBub3RoaW5nID0gQ29udmVydC50b05vdGhpbmcoanNvbik7XG4vLyAgIGNvbnN0IG9yZ2FuaXphdGlvbiA9IENvbnZlcnQudG9Pcmdhbml6YXRpb24oanNvbik7XG4vLyAgIGNvbnN0IHBvcnRmb2xpbyA9IENvbnZlcnQudG9Qb3J0Zm9saW8oanNvbik7XG4vLyAgIGNvbnN0IHBvc2l0aW9uID0gQ29udmVydC50b1Bvc2l0aW9uKGpzb24pO1xuLy8gICBjb25zdCB0aW1lUmFuZ2UgPSBDb252ZXJ0LnRvVGltZVJhbmdlKGpzb24pO1xuLy8gICBjb25zdCB2YWx1YXRpb24gPSBDb252ZXJ0LnRvVmFsdWF0aW9uKGpzb24pO1xuLy9cbi8vIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBKU09OIGRvZXNuJ3Rcbi8vIG1hdGNoIHRoZSBleHBlY3RlZCBpbnRlcmZhY2UsIGV2ZW4gaWYgdGhlIEpTT04gaXMgdmFsaWQuXG52YXIgU3R5bGU7XG5cbihmdW5jdGlvbiAoU3R5bGUpIHtcbiAgU3R5bGVbXCJCYXJcIl0gPSBcImJhclwiO1xuICBTdHlsZVtcIkNhbmRsZVwiXSA9IFwiY2FuZGxlXCI7XG4gIFN0eWxlW1wiQ3VzdG9tXCJdID0gXCJjdXN0b21cIjtcbiAgU3R5bGVbXCJIZWF0bWFwXCJdID0gXCJoZWF0bWFwXCI7XG4gIFN0eWxlW1wiSGlzdG9ncmFtXCJdID0gXCJoaXN0b2dyYW1cIjtcbiAgU3R5bGVbXCJMaW5lXCJdID0gXCJsaW5lXCI7XG4gIFN0eWxlW1wiTW91bnRhaW5cIl0gPSBcIm1vdW50YWluXCI7XG4gIFN0eWxlW1wiUGllXCJdID0gXCJwaWVcIjtcbiAgU3R5bGVbXCJTY2F0dGVyXCJdID0gXCJzY2F0dGVyXCI7XG4gIFN0eWxlW1wiU3RhY2tlZEJhclwiXSA9IFwic3RhY2tlZC1iYXJcIjtcbn0pKFN0eWxlIHx8IChTdHlsZSA9IHt9KSk7IC8vIENvbnZlcnRzIEpTT04gc3RyaW5ncyB0by9mcm9tIHlvdXIgdHlwZXNcbi8vIGFuZCBhc3NlcnRzIHRoZSByZXN1bHRzIG9mIEpTT04ucGFyc2UgYXQgcnVudGltZVxuXG5cbnZhciBDb252ZXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udmVydCgpIHt9XG5cbiAgQ29udmVydC50b0NvbnRleHQgPSBmdW5jdGlvbiB0b0NvbnRleHQoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NvbnRleHQnKSk7XG4gIH07XG5cbiAgQ29udmVydC5jb250ZXh0VG9Kc29uID0gZnVuY3Rpb24gY29udGV4dFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NvbnRleHQnKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9DaGFydCA9IGZ1bmN0aW9uIHRvQ2hhcnQoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NoYXJ0JykpO1xuICB9O1xuXG4gIENvbnZlcnQuY2hhcnRUb0pzb24gPSBmdW5jdGlvbiBjaGFydFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NoYXJ0JykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvQ2hhdEluaXRTZXR0aW5ncyA9IGZ1bmN0aW9uIHRvQ2hhdEluaXRTZXR0aW5ncyhqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignQ2hhdEluaXRTZXR0aW5ncycpKTtcbiAgfTtcblxuICBDb252ZXJ0LmNoYXRJbml0U2V0dGluZ3NUb0pzb24gPSBmdW5jdGlvbiBjaGF0SW5pdFNldHRpbmdzVG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignQ2hhdEluaXRTZXR0aW5ncycpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b0NvbnRhY3QgPSBmdW5jdGlvbiB0b0NvbnRhY3QoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NvbnRhY3QnKSk7XG4gIH07XG5cbiAgQ29udmVydC5jb250YWN0VG9Kc29uID0gZnVuY3Rpb24gY29udGFjdFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NvbnRhY3QnKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Db250YWN0TGlzdCA9IGZ1bmN0aW9uIHRvQ29udGFjdExpc3QoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0NvbnRhY3RMaXN0JykpO1xuICB9O1xuXG4gIENvbnZlcnQuY29udGFjdExpc3RUb0pzb24gPSBmdW5jdGlvbiBjb250YWN0TGlzdFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0NvbnRhY3RMaXN0JykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvQ291bnRyeSA9IGZ1bmN0aW9uIHRvQ291bnRyeShqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignQ291bnRyeScpKTtcbiAgfTtcblxuICBDb252ZXJ0LmNvdW50cnlUb0pzb24gPSBmdW5jdGlvbiBjb3VudHJ5VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignQ291bnRyeScpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b0N1cnJlbmN5ID0gZnVuY3Rpb24gdG9DdXJyZW5jeShqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignQ3VycmVuY3knKSk7XG4gIH07XG5cbiAgQ29udmVydC5jdXJyZW5jeVRvSnNvbiA9IGZ1bmN0aW9uIGN1cnJlbmN5VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignQ3VycmVuY3knKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9FbWFpbCA9IGZ1bmN0aW9uIHRvRW1haWwoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ0VtYWlsJykpO1xuICB9O1xuXG4gIENvbnZlcnQuZW1haWxUb0pzb24gPSBmdW5jdGlvbiBlbWFpbFRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ0VtYWlsJykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvSW5zdHJ1bWVudCA9IGZ1bmN0aW9uIHRvSW5zdHJ1bWVudChqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignSW5zdHJ1bWVudCcpKTtcbiAgfTtcblxuICBDb252ZXJ0Lmluc3RydW1lbnRUb0pzb24gPSBmdW5jdGlvbiBpbnN0cnVtZW50VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignSW5zdHJ1bWVudCcpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b0luc3RydW1lbnRMaXN0ID0gZnVuY3Rpb24gdG9JbnN0cnVtZW50TGlzdChqc29uKSB7XG4gICAgcmV0dXJuIGNhc3QoSlNPTi5wYXJzZShqc29uKSwgcignSW5zdHJ1bWVudExpc3QnKSk7XG4gIH07XG5cbiAgQ29udmVydC5pbnN0cnVtZW50TGlzdFRvSnNvbiA9IGZ1bmN0aW9uIGluc3RydW1lbnRMaXN0VG9Kc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHVuY2FzdCh2YWx1ZSwgcignSW5zdHJ1bWVudExpc3QnKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Ob3RoaW5nID0gZnVuY3Rpb24gdG9Ob3RoaW5nKGpzb24pIHtcbiAgICByZXR1cm4gY2FzdChKU09OLnBhcnNlKGpzb24pLCByKCdOb3RoaW5nJykpO1xuICB9O1xuXG4gIENvbnZlcnQubm90aGluZ1RvSnNvbiA9IGZ1bmN0aW9uIG5vdGhpbmdUb0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodW5jYXN0KHZhbHVlLCByKCdOb3RoaW5nJykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvT3JnYW5pemF0aW9uID0gZnVuY3Rpb24gdG9Pcmdhbml6YXRpb24oanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ09yZ2FuaXphdGlvbicpKTtcbiAgfTtcblxuICBDb252ZXJ0Lm9yZ2FuaXphdGlvblRvSnNvbiA9IGZ1bmN0aW9uIG9yZ2FuaXphdGlvblRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ09yZ2FuaXphdGlvbicpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b1BvcnRmb2xpbyA9IGZ1bmN0aW9uIHRvUG9ydGZvbGlvKGpzb24pIHtcbiAgICByZXR1cm4gY2FzdChKU09OLnBhcnNlKGpzb24pLCByKCdQb3J0Zm9saW8nKSk7XG4gIH07XG5cbiAgQ29udmVydC5wb3J0Zm9saW9Ub0pzb24gPSBmdW5jdGlvbiBwb3J0Zm9saW9Ub0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodW5jYXN0KHZhbHVlLCByKCdQb3J0Zm9saW8nKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIENvbnZlcnQudG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIHRvUG9zaXRpb24oanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ1Bvc2l0aW9uJykpO1xuICB9O1xuXG4gIENvbnZlcnQucG9zaXRpb25Ub0pzb24gPSBmdW5jdGlvbiBwb3NpdGlvblRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ1Bvc2l0aW9uJykpLCBudWxsLCAyKTtcbiAgfTtcblxuICBDb252ZXJ0LnRvVGltZVJhbmdlID0gZnVuY3Rpb24gdG9UaW1lUmFuZ2UoanNvbikge1xuICAgIHJldHVybiBjYXN0KEpTT04ucGFyc2UoanNvbiksIHIoJ1RpbWVSYW5nZScpKTtcbiAgfTtcblxuICBDb252ZXJ0LnRpbWVSYW5nZVRvSnNvbiA9IGZ1bmN0aW9uIHRpbWVSYW5nZVRvSnNvbih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh1bmNhc3QodmFsdWUsIHIoJ1RpbWVSYW5nZScpKSwgbnVsbCwgMik7XG4gIH07XG5cbiAgQ29udmVydC50b1ZhbHVhdGlvbiA9IGZ1bmN0aW9uIHRvVmFsdWF0aW9uKGpzb24pIHtcbiAgICByZXR1cm4gY2FzdChKU09OLnBhcnNlKGpzb24pLCByKCdWYWx1YXRpb24nKSk7XG4gIH07XG5cbiAgQ29udmVydC52YWx1YXRpb25Ub0pzb24gPSBmdW5jdGlvbiB2YWx1YXRpb25Ub0pzb24odmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodW5jYXN0KHZhbHVlLCByKCdWYWx1YXRpb24nKSksIG51bGwsIDIpO1xuICB9O1xuXG4gIHJldHVybiBDb252ZXJ0O1xufSgpO1xuXG5mdW5jdGlvbiBpbnZhbGlkVmFsdWUodHlwLCB2YWwsIGtleSkge1xuICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICBrZXkgPSAnJztcbiAgfVxuXG4gIGlmIChrZXkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIEV4cGVjdGVkIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXApICsgXCIgYnV0IGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICB9XG5cbiAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsKSArIFwiIGZvciB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwKSk7XG59XG5cbmZ1bmN0aW9uIGpzb25Ub0pTUHJvcHModHlwKSB7XG4gIGlmICh0eXAuanNvblRvSlMgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICB0eXAucHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1hcFtwLmpzb25dID0ge1xuICAgICAgICBrZXk6IHAuanMsXG4gICAgICAgIHR5cDogcC50eXBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdHlwLmpzb25Ub0pTID0gbWFwO1xuICB9XG5cbiAgcmV0dXJuIHR5cC5qc29uVG9KUztcbn1cblxuZnVuY3Rpb24ganNUb0pTT05Qcm9wcyh0eXApIHtcbiAgaWYgKHR5cC5qc1RvSlNPTiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHR5cC5wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbWFwW3AuanNdID0ge1xuICAgICAgICBrZXk6IHAuanNvbixcbiAgICAgICAgdHlwOiBwLnR5cFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0eXAuanNUb0pTT04gPSBtYXA7XG4gIH1cblxuICByZXR1cm4gdHlwLmpzVG9KU09OO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0odmFsLCB0eXAsIGdldFByb3BzLCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAga2V5ID0gJyc7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1QcmltaXRpdmUodHlwLCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIHR5cCA9PT0gdHlwZW9mIHZhbCkgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gaW52YWxpZFZhbHVlKHR5cCwgdmFsLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtVW5pb24odHlwcywgdmFsKSB7XG4gICAgLy8gdmFsIG11c3QgdmFsaWRhdGUgYWdhaW5zdCBvbmUgdHlwIGluIHR5cHNcbiAgICB2YXIgbCA9IHR5cHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBfdHlwID0gdHlwc1tpXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybSh2YWwsIF90eXAsIGdldFByb3BzKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXBzLCB2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtRW51bShjYXNlcywgdmFsKSB7XG4gICAgaWYgKGNhc2VzLmluZGV4T2YodmFsKSAhPT0gLTEpIHJldHVybiB2YWw7XG4gICAgcmV0dXJuIGludmFsaWRWYWx1ZShjYXNlcywgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUFycmF5KHR5cCwgdmFsKSB7XG4gICAgLy8gdmFsIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBubyBpbnZhbGlkIGVsZW1lbnRzXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiBpbnZhbGlkVmFsdWUoJ2FycmF5JywgdmFsKTtcbiAgICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oZWwsIHR5cCwgZ2V0UHJvcHMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtRGF0ZSh2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZCA9IG5ldyBEYXRlKHZhbCk7XG5cbiAgICBpZiAoaXNOYU4oZC52YWx1ZU9mKCkpKSB7XG4gICAgICByZXR1cm4gaW52YWxpZFZhbHVlKCdEYXRlJywgdmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU9iamVjdChwcm9wcywgYWRkaXRpb25hbCwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHJldHVybiBpbnZhbGlkVmFsdWUoJ29iamVjdCcsIHZhbCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNba2V5XTtcbiAgICAgIHZhciB2ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KSA/IHZhbFtrZXldIDogdW5kZWZpbmVkO1xuICAgICAgcmVzdWx0W3Byb3Aua2V5XSA9IHRyYW5zZm9ybSh2LCBwcm9wLnR5cCwgZ2V0UHJvcHMsIHByb3Aua2V5KTtcbiAgICB9KTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWwpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cmFuc2Zvcm0odmFsW2tleV0sIGFkZGl0aW9uYWwsIGdldFByb3BzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAodHlwID09PSAnYW55JykgcmV0dXJuIHZhbDtcblxuICBpZiAodHlwID09PSBudWxsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gaW52YWxpZFZhbHVlKHR5cCwgdmFsKTtcbiAgfVxuXG4gIGlmICh0eXAgPT09IGZhbHNlKSByZXR1cm4gaW52YWxpZFZhbHVlKHR5cCwgdmFsKTtcblxuICB3aGlsZSAodHlwZW9mIHR5cCA9PT0gJ29iamVjdCcgJiYgdHlwLnJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHlwID0gdHlwZU1hcFt0eXAucmVmXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cCkpIHJldHVybiB0cmFuc2Zvcm1FbnVtKHR5cCwgdmFsKTtcblxuICBpZiAodHlwZW9mIHR5cCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwLmhhc093blByb3BlcnR5KCd1bmlvbk1lbWJlcnMnKSA/IHRyYW5zZm9ybVVuaW9uKHR5cC51bmlvbk1lbWJlcnMsIHZhbCkgOiB0eXAuaGFzT3duUHJvcGVydHkoJ2FycmF5SXRlbXMnKSA/IHRyYW5zZm9ybUFycmF5KHR5cC5hcnJheUl0ZW1zLCB2YWwpIDogdHlwLmhhc093blByb3BlcnR5KCdwcm9wcycpID8gdHJhbnNmb3JtT2JqZWN0KGdldFByb3BzKHR5cCksIHR5cC5hZGRpdGlvbmFsLCB2YWwpIDogaW52YWxpZFZhbHVlKHR5cCwgdmFsKTtcbiAgfSAvLyBOdW1iZXJzIGNhbiBiZSBwYXJzZWQgYnkgRGF0ZSBidXQgc2hvdWxkbid0IGJlLlxuXG5cbiAgaWYgKHR5cCA9PT0gRGF0ZSAmJiB0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykgcmV0dXJuIHRyYW5zZm9ybURhdGUodmFsKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByaW1pdGl2ZSh0eXAsIHZhbCk7XG59XG5cbmZ1bmN0aW9uIGNhc3QodmFsLCB0eXApIHtcbiAgcmV0dXJuIHRyYW5zZm9ybSh2YWwsIHR5cCwganNvblRvSlNQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVuY2FzdCh2YWwsIHR5cCkge1xuICByZXR1cm4gdHJhbnNmb3JtKHZhbCwgdHlwLCBqc1RvSlNPTlByb3BzKTtcbn1cblxuZnVuY3Rpb24gYSh0eXApIHtcbiAgcmV0dXJuIHtcbiAgICBhcnJheUl0ZW1zOiB0eXBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdHlwc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdW5pb25NZW1iZXJzOiB0eXBzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG8ocHJvcHMsIGFkZGl0aW9uYWwpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgYWRkaXRpb25hbDogYWRkaXRpb25hbFxuICB9O1xufVxuXG5mdW5jdGlvbiBtKGFkZGl0aW9uYWwpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wczogW10sXG4gICAgYWRkaXRpb25hbDogYWRkaXRpb25hbFxuICB9O1xufVxuXG5mdW5jdGlvbiByKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICByZWY6IG5hbWVcbiAgfTtcbn1cblxudmFyIHR5cGVNYXAgPSB7XG4gIENvbnRleHQ6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL20oJycpKVxuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9XSwgJ2FueScpLFxuICBDaGFydDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnaW5zdHJ1bWVudHMnLFxuICAgIGpzOiAnaW5zdHJ1bWVudHMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL2EoIC8qI19fUFVSRV9fKi9yKCdJbnN0cnVtZW50JykpXG4gIH0sIHtcbiAgICBqc29uOiAnb3RoZXJDb25maWcnLFxuICAgIGpzOiAnb3RoZXJDb25maWcnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnYW55JykpXG4gIH0sIHtcbiAgICBqc29uOiAncmFuZ2UnLFxuICAgIGpzOiAncmFuZ2UnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovcignVGltZVJhbmdlJykpXG4gIH0sIHtcbiAgICBqc29uOiAnc3R5bGUnLFxuICAgIGpzOiAnc3R5bGUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovcignU3R5bGUnKSlcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgSW5zdHJ1bWVudDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3IoJ0luc3RydW1lbnRJRCcpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIEluc3RydW1lbnRJRDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnQkJHJyxcbiAgICBqczogJ0JCRycsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0NVU0lQJyxcbiAgICBqczogJ0NVU0lQJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnRkRTX0lEJyxcbiAgICBqczogJ0ZEU19JRCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0ZJR0knLFxuICAgIGpzOiAnRklHSScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0lTSU4nLFxuICAgIGpzOiAnSVNJTicsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ1BFUk1JRCcsXG4gICAganM6ICdQRVJNSUQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICdSSUMnLFxuICAgIGpzOiAnUklDJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnU0VET0wnLFxuICAgIGpzOiAnU0VET0wnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICd0aWNrZXInLFxuICAgIGpzOiAndGlja2VyJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnJyksXG4gIFRpbWVSYW5nZTogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnZW5kVGltZScsXG4gICAganM6ICdlbmRUaW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgRGF0ZSlcbiAgfSwge1xuICAgIGpzb246ICdzdGFydFRpbWUnLFxuICAgIGpzOiAnc3RhcnRUaW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgRGF0ZSlcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgQ2hhdEluaXRTZXR0aW5nczogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnY2hhdE5hbWUnLFxuICAgIGpzOiAnY2hhdE5hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICdpbml0TWVzc2FnZScsXG4gICAganM6ICdpbml0TWVzc2FnZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ21lbWJlcnMnLFxuICAgIGpzOiAnbWVtYmVycycsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9yKCdDb250YWN0TGlzdCcpKVxuICB9LCB7XG4gICAganNvbjogJ29wdGlvbnMnLFxuICAgIGpzOiAnb3B0aW9ucycsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICdhbnknKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnYW55J1xuICB9XSwgJ2FueScpLFxuICBDb250YWN0TGlzdDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnY29udGFjdHMnLFxuICAgIGpzOiAnY29udGFjdHMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL2EoIC8qI19fUFVSRV9fKi9yKCdDb250YWN0JykpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnJykpXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIENvbnRhY3Q6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9yKCdDb250YWN0SUQnKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJ2FueScpLFxuICBDb250YWN0SUQ6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2VtYWlsJyxcbiAgICBqczogJ2VtYWlsJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnRkRTX0lEJyxcbiAgICBqczogJ0ZEU19JRCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJycpLFxuICBDb3VudHJ5OiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovcignQ291bnRyeUlEJylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgQ291bnRyeUlEOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdDT1VOVFJZX0lTT0FMUEhBMicsXG4gICAganM6ICdDT1VOVFJZX0lTT0FMUEhBMicsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0NPVU5UUllfSVNPQUxQSEEzJyxcbiAgICBqczogJ0NPVU5UUllfSVNPQUxQSEEzJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnSVNPQUxQSEEyJyxcbiAgICBqczogJ0lTT0FMUEhBMicsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ0lTT0FMUEhBMycsXG4gICAganM6ICdJU09BTFBIQTMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICcnKSxcbiAgQ3VycmVuY3k6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9yKCdDdXJyZW5jeUlEJylcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfV0sICdhbnknKSxcbiAgQ3VycmVuY3lJRDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnQ1VSUkVOQ1lfSVNPQ09ERScsXG4gICAganM6ICdDVVJSRU5DWV9JU09DT0RFJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnJyksXG4gIEVtYWlsOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdyZWNpcGllbnRzJyxcbiAgICBqczogJ3JlY2lwaWVudHMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3IoJ1JlY2lwaWVudHNPYmplY3QnKVxuICB9LCB7XG4gICAganNvbjogJ3N1YmplY3QnLFxuICAgIGpzOiAnc3ViamVjdCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ3RleHRCb2R5JyxcbiAgICBqczogJ3RleHRCb2R5JyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnJykpXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIFJlY2lwaWVudHNPYmplY3Q6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL3IoJ1JlY2lwaWVudHNJRCcpKVxuICB9LCB7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ2NvbnRhY3RzJyxcbiAgICBqczogJ2NvbnRhY3RzJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL2EoIC8qI19fUFVSRV9fKi9yKCdDb250YWN0JykpKVxuICB9XSwgJ2FueScpLFxuICBSZWNpcGllbnRzSUQ6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2VtYWlsJyxcbiAgICBqczogJ2VtYWlsJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnRkRTX0lEJyxcbiAgICBqczogJ0ZEU19JRCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJycpLFxuICBJbnN0cnVtZW50TGlzdDogLyojX19QVVJFX18qL28oW3tcbiAgICBqc29uOiAnaW5zdHJ1bWVudHMnLFxuICAgIGpzOiAnaW5zdHJ1bWVudHMnLFxuICAgIHR5cDogLyojX19QVVJFX18qL2EoIC8qI19fUFVSRV9fKi9yKCdJbnN0cnVtZW50JykpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnaWQnLFxuICAgIGpzOiAnaWQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAvKiNfX1BVUkVfXyovbSgnJykpXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIE5vdGhpbmc6IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ3R5cGUnLFxuICAgIGpzOiAndHlwZScsXG4gICAgdHlwOiAnJ1xuICB9LCB7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgLyojX19QVVJFX18qL20oJycpKVxuICB9LCB7XG4gICAganNvbjogJ25hbWUnLFxuICAgIGpzOiAnbmFtZScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9XSwgJ2FueScpLFxuICBPcmdhbml6YXRpb246IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2lkJyxcbiAgICBqczogJ2lkJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9yKCdPcmdhbml6YXRpb25JRCcpXG4gIH0sIHtcbiAgICBqc29uOiAndHlwZScsXG4gICAganM6ICd0eXBlJyxcbiAgICB0eXA6ICcnXG4gIH0sIHtcbiAgICBqc29uOiAnbmFtZScsXG4gICAganM6ICduYW1lJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH1dLCAnYW55JyksXG4gIE9yZ2FuaXphdGlvbklEOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdGRFNfSUQnLFxuICAgIGpzOiAnRkRTX0lEJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgJycpXG4gIH0sIHtcbiAgICBqc29uOiAnTEVJJyxcbiAgICBqczogJ0xFSScsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsICcnKVxuICB9LCB7XG4gICAganNvbjogJ1BFUk1JRCcsXG4gICAganM6ICdQRVJNSUQnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICcnKSxcbiAgUG9ydGZvbGlvOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdwb3NpdGlvbnMnLFxuICAgIGpzOiAncG9zaXRpb25zJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9hKCAvKiNfX1BVUkVfXyovcignUG9zaXRpb24nKSlcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgUG9zaXRpb246IC8qI19fUFVSRV9fKi9vKFt7XG4gICAganNvbjogJ2hvbGRpbmcnLFxuICAgIGpzOiAnaG9sZGluZycsXG4gICAgdHlwOiAzLjE0XG4gIH0sIHtcbiAgICBqc29uOiAnaW5zdHJ1bWVudCcsXG4gICAganM6ICdpbnN0cnVtZW50JyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi9yKCdJbnN0cnVtZW50JylcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgVmFsdWF0aW9uOiAvKiNfX1BVUkVfXyovbyhbe1xuICAgIGpzb246ICdDVVJSRU5DWV9JU09DT0RFJyxcbiAgICBqczogJ0NVUlJFTkNZX0lTT0NPREUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICdleHBpcnlUaW1lJyxcbiAgICBqczogJ2V4cGlyeVRpbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCBEYXRlKVxuICB9LCB7XG4gICAganNvbjogJ3ByaWNlJyxcbiAgICBqczogJ3ByaWNlJyxcbiAgICB0eXA6IC8qI19fUFVSRV9fKi91KHVuZGVmaW5lZCwgMy4xNClcbiAgfSwge1xuICAgIGpzb246ICd0eXBlJyxcbiAgICBqczogJ3R5cGUnLFxuICAgIHR5cDogJydcbiAgfSwge1xuICAgIGpzb246ICd2YWx1YXRpb25UaW1lJyxcbiAgICBqczogJ3ZhbHVhdGlvblRpbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCBEYXRlKVxuICB9LCB7XG4gICAganNvbjogJ3ZhbHVlJyxcbiAgICBqczogJ3ZhbHVlJyxcbiAgICB0eXA6IDMuMTRcbiAgfSwge1xuICAgIGpzb246ICdpZCcsXG4gICAganM6ICdpZCcsXG4gICAgdHlwOiAvKiNfX1BVUkVfXyovdSh1bmRlZmluZWQsIC8qI19fUFVSRV9fKi9tKCcnKSlcbiAgfSwge1xuICAgIGpzb246ICduYW1lJyxcbiAgICBqczogJ25hbWUnLFxuICAgIHR5cDogLyojX19QVVJFX18qL3UodW5kZWZpbmVkLCAnJylcbiAgfV0sICdhbnknKSxcbiAgU3R5bGU6IFsnYmFyJywgJ2NhbmRsZScsICdjdXN0b20nLCAnaGVhdG1hcCcsICdoaXN0b2dyYW0nLCAnbGluZScsICdtb3VudGFpbicsICdwaWUnLCAnc2NhdHRlcicsICdzdGFja2VkLWJhciddXG59O1xuXG52YXIgSW50ZW50cztcblxuKGZ1bmN0aW9uIChJbnRlbnRzKSB7XG4gIEludGVudHNbXCJTdGFydENhbGxcIl0gPSBcIlN0YXJ0Q2FsbFwiO1xuICBJbnRlbnRzW1wiU3RhcnRDaGF0XCJdID0gXCJTdGFydENoYXRcIjtcbiAgSW50ZW50c1tcIlN0YXJ0RW1haWxcIl0gPSBcIlN0YXJ0RW1haWxcIjtcbiAgSW50ZW50c1tcIlZpZXdBbmFseXNpc1wiXSA9IFwiVmlld0FuYWx5c2lzXCI7XG4gIEludGVudHNbXCJWaWV3Q2hhcnRcIl0gPSBcIlZpZXdDaGFydFwiO1xuICBJbnRlbnRzW1wiVmlld0NvbnRhY3RcIl0gPSBcIlZpZXdDb250YWN0XCI7XG4gIEludGVudHNbXCJWaWV3SG9sZGluZ3NcIl0gPSBcIlZpZXdIb2xkaW5nc1wiO1xuICBJbnRlbnRzW1wiVmlld0luc3RydW1lbnRcIl0gPSBcIlZpZXdJbnN0cnVtZW50XCI7XG4gIEludGVudHNbXCJWaWV3SW50ZXJhY3Rpb25zXCJdID0gXCJWaWV3SW50ZXJhY3Rpb25zXCI7XG4gIEludGVudHNbXCJWaWV3TmV3c1wiXSA9IFwiVmlld05ld3NcIjtcbiAgSW50ZW50c1tcIlZpZXdPcmRlcnNcIl0gPSBcIlZpZXdPcmRlcnNcIjtcbiAgSW50ZW50c1tcIlZpZXdQcm9maWxlXCJdID0gXCJWaWV3UHJvZmlsZVwiO1xuICBJbnRlbnRzW1wiVmlld1F1b3RlXCJdID0gXCJWaWV3UXVvdGVcIjtcbiAgSW50ZW50c1tcIlZpZXdSZXNlYXJjaFwiXSA9IFwiVmlld1Jlc2VhcmNoXCI7XG59KShJbnRlbnRzIHx8IChJbnRlbnRzID0ge30pKTtcblxuZXhwb3J0IHsgQ2hhbm5lbEVycm9yLCBDb250ZXh0VHlwZXMsIENvbnZlcnQsIEludGVudHMsIE9wZW5FcnJvciwgUmVzb2x2ZUVycm9yLCBSZXN1bHRFcnJvciwgU3R5bGUsIGFkZENvbnRleHRMaXN0ZW5lciwgYWRkSW50ZW50TGlzdGVuZXIsIGJyb2FkY2FzdCwgY29tcGFyZVZlcnNpb25OdW1iZXJzLCBmZGMzUmVhZHksIGZpbmRJbnRlbnQsIGZpbmRJbnRlbnRzQnlDb250ZXh0LCBnZXRBcHBNZXRhZGF0YSwgZ2V0Q3VycmVudENoYW5uZWwsIGdldEluZm8sIGdldE9yQ3JlYXRlQ2hhbm5lbCwgZ2V0U3lzdGVtQ2hhbm5lbHMsIGdldFVzZXJDaGFubmVscywgam9pbkNoYW5uZWwsIGpvaW5Vc2VyQ2hhbm5lbCwgbGVhdmVDdXJyZW50Q2hhbm5lbCwgb3BlbiwgcmFpc2VJbnRlbnQsIHJhaXNlSW50ZW50Rm9yQ29udGV4dCwgdmVyc2lvbklzQXRMZWFzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmRjMy5lc20uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiBDaGFpIC0gZ2V0RnVuY05hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRGdW5jTmFtZShjb25zdHJ1Y3RvckZuKVxuICpcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbiAqIFdoZW4gYSBub24tZnVuY3Rpb24gaW5zdGFuY2UgaXMgcGFzc2VkLCByZXR1cm5zIGBudWxsYC5cbiAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBhRnVuYy5uYW1lYCBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAbmFtZSBnZXRGdW5jTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uTmFtZU1hdGNoID0gL1xccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqW14oPzoqXFwvKV0rXFwqXFwvXFxzKikqKFteXFxzXFwoXFwvXSspLztcbmZ1bmN0aW9uIGdldEZ1bmNOYW1lKGFGdW5jKSB7XG4gIGlmICh0eXBlb2YgYUZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBuYW1lID0gJyc7XG4gIGlmICh0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhRnVuYy5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgRnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5IGFuZCBpZiBhRnVuYy5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIG1hdGNoID0gdG9TdHJpbmcuY2FsbChhRnVuYykubWF0Y2goZnVuY3Rpb25OYW1lTWF0Y2gpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBgbmFtZWAgcHJvcGVydHkgd2UganVzdCB1c2UgaXRcbiAgICBuYW1lID0gYUZ1bmMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZ1bmNOYW1lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIi8qISBodHRwczovL210aHMuYmUvaGUgdjEuMi4wIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2AuXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGAuXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0Ly8gQWxsIGFzdHJhbCBzeW1ib2xzLlxuXHR2YXIgcmVnZXhBc3RyYWxTeW1ib2xzID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcblx0Ly8gQWxsIEFTQ0lJIHN5bWJvbHMgKG5vdCBqdXN0IHByaW50YWJsZSBBU0NJSSkgZXhjZXB0IHRob3NlIGxpc3RlZCBpbiB0aGVcblx0Ly8gZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUuXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzXG5cdHZhciByZWdleEFzY2lpV2hpdGVsaXN0ID0gL1tcXHgwMS1cXHg3Rl0vZztcblx0Ly8gQWxsIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBBU0NJSSBuZXdsaW5lcywgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHMsIG9yXG5cdC8vIGNvZGUgcG9pbnRzIGxpc3RlZCBpbiB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUgb25cblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXMuXG5cdHZhciByZWdleEJtcFdoaXRlbGlzdCA9IC9bXFx4MDEtXFx0XFx4MEJcXGZcXHgwRS1cXHgxRlxceDdGXFx4ODFcXHg4RFxceDhGXFx4OTBcXHg5RFxceEEwLVxcdUZGRkZdL2c7XG5cblx0dmFyIHJlZ2V4RW5jb2RlTm9uQXNjaWkgPSAvPFxcdTIwRDJ8PVxcdTIwRTV8PlxcdTIwRDJ8XFx1MjA1RlxcdTIwMEF8XFx1MjE5RFxcdTAzMzh8XFx1MjIwMlxcdTAzMzh8XFx1MjIyMFxcdTIwRDJ8XFx1MjIyOVxcdUZFMDB8XFx1MjIyQVxcdUZFMDB8XFx1MjIzQ1xcdTIwRDJ8XFx1MjIzRFxcdTAzMzF8XFx1MjIzRVxcdTAzMzN8XFx1MjI0MlxcdTAzMzh8XFx1MjI0QlxcdTAzMzh8XFx1MjI0RFxcdTIwRDJ8XFx1MjI0RVxcdTAzMzh8XFx1MjI0RlxcdTAzMzh8XFx1MjI1MFxcdTAzMzh8XFx1MjI2MVxcdTIwRTV8XFx1MjI2NFxcdTIwRDJ8XFx1MjI2NVxcdTIwRDJ8XFx1MjI2NlxcdTAzMzh8XFx1MjI2N1xcdTAzMzh8XFx1MjI2OFxcdUZFMDB8XFx1MjI2OVxcdUZFMDB8XFx1MjI2QVxcdTAzMzh8XFx1MjI2QVxcdTIwRDJ8XFx1MjI2QlxcdTAzMzh8XFx1MjI2QlxcdTIwRDJ8XFx1MjI3RlxcdTAzMzh8XFx1MjI4MlxcdTIwRDJ8XFx1MjI4M1xcdTIwRDJ8XFx1MjI4QVxcdUZFMDB8XFx1MjI4QlxcdUZFMDB8XFx1MjI4RlxcdTAzMzh8XFx1MjI5MFxcdTAzMzh8XFx1MjI5M1xcdUZFMDB8XFx1MjI5NFxcdUZFMDB8XFx1MjJCNFxcdTIwRDJ8XFx1MjJCNVxcdTIwRDJ8XFx1MjJEOFxcdTAzMzh8XFx1MjJEOVxcdTAzMzh8XFx1MjJEQVxcdUZFMDB8XFx1MjJEQlxcdUZFMDB8XFx1MjJGNVxcdTAzMzh8XFx1MjJGOVxcdTAzMzh8XFx1MjkzM1xcdTAzMzh8XFx1MjlDRlxcdTAzMzh8XFx1MjlEMFxcdTAzMzh8XFx1MkE2RFxcdTAzMzh8XFx1MkE3MFxcdTAzMzh8XFx1MkE3RFxcdTAzMzh8XFx1MkE3RVxcdTAzMzh8XFx1MkFBMVxcdTAzMzh8XFx1MkFBMlxcdTAzMzh8XFx1MkFBQ1xcdUZFMDB8XFx1MkFBRFxcdUZFMDB8XFx1MkFBRlxcdTAzMzh8XFx1MkFCMFxcdTAzMzh8XFx1MkFDNVxcdTAzMzh8XFx1MkFDNlxcdTAzMzh8XFx1MkFDQlxcdUZFMDB8XFx1MkFDQ1xcdUZFMDB8XFx1MkFGRFxcdTIwRTV8W1xceEEwLVxcdTAxMTNcXHUwMTE2LVxcdTAxMjJcXHUwMTI0LVxcdTAxMkJcXHUwMTJFLVxcdTAxNERcXHUwMTUwLVxcdTAxN0VcXHUwMTkyXFx1MDFCNVxcdTAxRjVcXHUwMjM3XFx1MDJDNlxcdTAyQzdcXHUwMkQ4LVxcdTAyRERcXHUwMzExXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0E5XFx1MDNCMS1cXHUwM0M5XFx1MDNEMVxcdTAzRDJcXHUwM0Q1XFx1MDNENlxcdTAzRENcXHUwM0REXFx1MDNGMFxcdTAzRjFcXHUwM0Y1XFx1MDNGNlxcdTA0MDEtXFx1MDQwQ1xcdTA0MEUtXFx1MDQ0RlxcdTA0NTEtXFx1MDQ1Q1xcdTA0NUVcXHUwNDVGXFx1MjAwMi1cXHUyMDA1XFx1MjAwNy1cXHUyMDEwXFx1MjAxMy1cXHUyMDE2XFx1MjAxOC1cXHUyMDFBXFx1MjAxQy1cXHUyMDFFXFx1MjAyMC1cXHUyMDIyXFx1MjAyNVxcdTIwMjZcXHUyMDMwLVxcdTIwMzVcXHUyMDM5XFx1MjAzQVxcdTIwM0VcXHUyMDQxXFx1MjA0M1xcdTIwNDRcXHUyMDRGXFx1MjA1N1xcdTIwNUYtXFx1MjA2M1xcdTIwQUNcXHUyMERCXFx1MjBEQ1xcdTIxMDJcXHUyMTA1XFx1MjEwQS1cXHUyMTEzXFx1MjExNS1cXHUyMTFFXFx1MjEyMlxcdTIxMjRcXHUyMTI3LVxcdTIxMjlcXHUyMTJDXFx1MjEyRFxcdTIxMkYtXFx1MjEzMVxcdTIxMzMtXFx1MjEzOFxcdTIxNDUtXFx1MjE0OFxcdTIxNTMtXFx1MjE1RVxcdTIxOTAtXFx1MjE5QlxcdTIxOUQtXFx1MjFBN1xcdTIxQTktXFx1MjFBRVxcdTIxQjAtXFx1MjFCM1xcdTIxQjUtXFx1MjFCN1xcdTIxQkEtXFx1MjFEQlxcdTIxRERcXHUyMUU0XFx1MjFFNVxcdTIxRjVcXHUyMUZELVxcdTIyMDVcXHUyMjA3LVxcdTIyMDlcXHUyMjBCXFx1MjIwQ1xcdTIyMEYtXFx1MjIxNFxcdTIyMTYtXFx1MjIxOFxcdTIyMUFcXHUyMjFELVxcdTIyMzhcXHUyMjNBLVxcdTIyNTdcXHUyMjU5XFx1MjI1QVxcdTIyNUNcXHUyMjVGLVxcdTIyNjJcXHUyMjY0LVxcdTIyOEJcXHUyMjhELVxcdTIyOUJcXHUyMjlELVxcdTIyQTVcXHUyMkE3LVxcdTIyQjBcXHUyMkIyLVxcdTIyQkJcXHUyMkJELVxcdTIyREJcXHUyMkRFLVxcdTIyRTNcXHUyMkU2LVxcdTIyRjdcXHUyMkY5LVxcdTIyRkVcXHUyMzA1XFx1MjMwNlxcdTIzMDgtXFx1MjMxMFxcdTIzMTJcXHUyMzEzXFx1MjMxNVxcdTIzMTZcXHUyMzFDLVxcdTIzMUZcXHUyMzIyXFx1MjMyM1xcdTIzMkRcXHUyMzJFXFx1MjMzNlxcdTIzM0RcXHUyMzNGXFx1MjM3Q1xcdTIzQjBcXHUyM0IxXFx1MjNCNC1cXHUyM0I2XFx1MjNEQy1cXHUyM0RGXFx1MjNFMlxcdTIzRTdcXHUyNDIzXFx1MjRDOFxcdTI1MDBcXHUyNTAyXFx1MjUwQ1xcdTI1MTBcXHUyNTE0XFx1MjUxOFxcdTI1MUNcXHUyNTI0XFx1MjUyQ1xcdTI1MzRcXHUyNTNDXFx1MjU1MC1cXHUyNTZDXFx1MjU4MFxcdTI1ODRcXHUyNTg4XFx1MjU5MS1cXHUyNTkzXFx1MjVBMVxcdTI1QUFcXHUyNUFCXFx1MjVBRFxcdTI1QUVcXHUyNUIxXFx1MjVCMy1cXHUyNUI1XFx1MjVCOFxcdTI1QjlcXHUyNUJELVxcdTI1QkZcXHUyNUMyXFx1MjVDM1xcdTI1Q0FcXHUyNUNCXFx1MjVFQ1xcdTI1RUZcXHUyNUY4LVxcdTI1RkNcXHUyNjA1XFx1MjYwNlxcdTI2MEVcXHUyNjQwXFx1MjY0MlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjZBXFx1MjY2RC1cXHUyNjZGXFx1MjcxM1xcdTI3MTdcXHUyNzIwXFx1MjczNlxcdTI3NThcXHUyNzcyXFx1Mjc3M1xcdTI3QzhcXHUyN0M5XFx1MjdFNi1cXHUyN0VEXFx1MjdGNS1cXHUyN0ZBXFx1MjdGQ1xcdTI3RkZcXHUyOTAyLVxcdTI5MDVcXHUyOTBDLVxcdTI5MTNcXHUyOTE2XFx1MjkxOS1cXHUyOTIwXFx1MjkyMy1cXHUyOTJBXFx1MjkzM1xcdTI5MzUtXFx1MjkzOVxcdTI5M0NcXHUyOTNEXFx1Mjk0NVxcdTI5NDgtXFx1Mjk0QlxcdTI5NEUtXFx1Mjk3NlxcdTI5NzhcXHUyOTc5XFx1Mjk3Qi1cXHUyOTdGXFx1Mjk4NVxcdTI5ODZcXHUyOThCLVxcdTI5OTZcXHUyOTlBXFx1Mjk5Q1xcdTI5OURcXHUyOUE0LVxcdTI5QjdcXHUyOUI5XFx1MjlCQlxcdTI5QkNcXHUyOUJFLVxcdTI5QzVcXHUyOUM5XFx1MjlDRC1cXHUyOUQwXFx1MjlEQy1cXHUyOURFXFx1MjlFMy1cXHUyOUU1XFx1MjlFQlxcdTI5RjRcXHUyOUY2XFx1MkEwMC1cXHUyQTAyXFx1MkEwNFxcdTJBMDZcXHUyQTBDXFx1MkEwRFxcdTJBMTAtXFx1MkExN1xcdTJBMjItXFx1MkEyN1xcdTJBMjlcXHUyQTJBXFx1MkEyRC1cXHUyQTMxXFx1MkEzMy1cXHUyQTNDXFx1MkEzRlxcdTJBNDBcXHUyQTQyLVxcdTJBNERcXHUyQTUwXFx1MkE1My1cXHUyQTU4XFx1MkE1QS1cXHUyQTVEXFx1MkE1RlxcdTJBNjZcXHUyQTZBXFx1MkE2RC1cXHUyQTc1XFx1MkE3Ny1cXHUyQTlBXFx1MkE5RC1cXHUyQUEyXFx1MkFBNC1cXHUyQUIwXFx1MkFCMy1cXHUyQUM4XFx1MkFDQlxcdTJBQ0NcXHUyQUNGLVxcdTJBREJcXHUyQUU0XFx1MkFFNi1cXHUyQUU5XFx1MkFFQi1cXHUyQUYzXFx1MkFGRFxcdUZCMDAtXFx1RkIwNF18XFx1RDgzNVtcXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVEQ0NGXFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERDZCXS9nO1xuXHR2YXIgZW5jb2RlTWFwID0geydcXHhBRCc6J3NoeScsJ1xcdTIwMEMnOid6d25qJywnXFx1MjAwRCc6J3p3aicsJ1xcdTIwMEUnOidscm0nLCdcXHUyMDYzJzonaWMnLCdcXHUyMDYyJzonaXQnLCdcXHUyMDYxJzonYWYnLCdcXHUyMDBGJzoncmxtJywnXFx1MjAwQic6J1plcm9XaWR0aFNwYWNlJywnXFx1MjA2MCc6J05vQnJlYWsnLCdcXHUwMzExJzonRG93bkJyZXZlJywnXFx1MjBEQic6J3Rkb3QnLCdcXHUyMERDJzonRG90RG90JywnXFx0JzonVGFiJywnXFxuJzonTmV3TGluZScsJ1xcdTIwMDgnOidwdW5jc3AnLCdcXHUyMDVGJzonTWVkaXVtU3BhY2UnLCdcXHUyMDA5JzondGhpbnNwJywnXFx1MjAwQSc6J2hhaXJzcCcsJ1xcdTIwMDQnOidlbXNwMTMnLCdcXHUyMDAyJzonZW5zcCcsJ1xcdTIwMDUnOidlbXNwMTQnLCdcXHUyMDAzJzonZW1zcCcsJ1xcdTIwMDcnOidudW1zcCcsJ1xceEEwJzonbmJzcCcsJ1xcdTIwNUZcXHUyMDBBJzonVGhpY2tTcGFjZScsJ1xcdTIwM0UnOidvbGluZScsJ18nOidsb3diYXInLCdcXHUyMDEwJzonZGFzaCcsJ1xcdTIwMTMnOiduZGFzaCcsJ1xcdTIwMTQnOidtZGFzaCcsJ1xcdTIwMTUnOidob3JiYXInLCcsJzonY29tbWEnLCc7Jzonc2VtaScsJ1xcdTIwNEYnOidic2VtaScsJzonOidjb2xvbicsJ1xcdTJBNzQnOidDb2xvbmUnLCchJzonZXhjbCcsJ1xceEExJzonaWV4Y2wnLCc/JzoncXVlc3QnLCdcXHhCRic6J2lxdWVzdCcsJy4nOidwZXJpb2QnLCdcXHUyMDI1JzonbmxkcicsJ1xcdTIwMjYnOidtbGRyJywnXFx4QjcnOidtaWRkb3QnLCdcXCcnOidhcG9zJywnXFx1MjAxOCc6J2xzcXVvJywnXFx1MjAxOSc6J3JzcXVvJywnXFx1MjAxQSc6J3NicXVvJywnXFx1MjAzOSc6J2xzYXF1bycsJ1xcdTIwM0EnOidyc2FxdW8nLCdcIic6J3F1b3QnLCdcXHUyMDFDJzonbGRxdW8nLCdcXHUyMDFEJzoncmRxdW8nLCdcXHUyMDFFJzonYmRxdW8nLCdcXHhBQic6J2xhcXVvJywnXFx4QkInOidyYXF1bycsJygnOidscGFyJywnKSc6J3JwYXInLCdbJzonbHNxYicsJ10nOidyc3FiJywneyc6J2xjdWInLCd9JzoncmN1YicsJ1xcdTIzMDgnOidsY2VpbCcsJ1xcdTIzMDknOidyY2VpbCcsJ1xcdTIzMEEnOidsZmxvb3InLCdcXHUyMzBCJzoncmZsb29yJywnXFx1Mjk4NSc6J2xvcGFyJywnXFx1Mjk4Nic6J3JvcGFyJywnXFx1Mjk4Qic6J2xicmtlJywnXFx1Mjk4Qyc6J3JicmtlJywnXFx1Mjk4RCc6J2xicmtzbHUnLCdcXHUyOThFJzoncmJya3NsZCcsJ1xcdTI5OEYnOidsYnJrc2xkJywnXFx1Mjk5MCc6J3JicmtzbHUnLCdcXHUyOTkxJzonbGFuZ2QnLCdcXHUyOTkyJzoncmFuZ2QnLCdcXHUyOTkzJzonbHBhcmx0JywnXFx1Mjk5NCc6J3JwYXJndCcsJ1xcdTI5OTUnOidndGxQYXInLCdcXHUyOTk2JzonbHRyUGFyJywnXFx1MjdFNic6J2xvYnJrJywnXFx1MjdFNyc6J3JvYnJrJywnXFx1MjdFOCc6J2xhbmcnLCdcXHUyN0U5JzoncmFuZycsJ1xcdTI3RUEnOidMYW5nJywnXFx1MjdFQic6J1JhbmcnLCdcXHUyN0VDJzonbG9hbmcnLCdcXHUyN0VEJzoncm9hbmcnLCdcXHUyNzcyJzonbGJicmsnLCdcXHUyNzczJzoncmJicmsnLCdcXHUyMDE2JzonVmVydCcsJ1xceEE3Jzonc2VjdCcsJ1xceEI2JzoncGFyYScsJ0AnOidjb21tYXQnLCcqJzonYXN0JywnLyc6J3NvbCcsJ3VuZGVmaW5lZCc6bnVsbCwnJic6J2FtcCcsJyMnOidudW0nLCclJzoncGVyY250JywnXFx1MjAzMCc6J3Blcm1pbCcsJ1xcdTIwMzEnOidwZXJ0ZW5rJywnXFx1MjAyMCc6J2RhZ2dlcicsJ1xcdTIwMjEnOidEYWdnZXInLCdcXHUyMDIyJzonYnVsbCcsJ1xcdTIwNDMnOidoeWJ1bGwnLCdcXHUyMDMyJzoncHJpbWUnLCdcXHUyMDMzJzonUHJpbWUnLCdcXHUyMDM0JzondHByaW1lJywnXFx1MjA1Nyc6J3FwcmltZScsJ1xcdTIwMzUnOidicHJpbWUnLCdcXHUyMDQxJzonY2FyZXQnLCdgJzonZ3JhdmUnLCdcXHhCNCc6J2FjdXRlJywnXFx1MDJEQyc6J3RpbGRlJywnXic6J0hhdCcsJ1xceEFGJzonbWFjcicsJ1xcdTAyRDgnOidicmV2ZScsJ1xcdTAyRDknOidkb3QnLCdcXHhBOCc6J2RpZScsJ1xcdTAyREEnOidyaW5nJywnXFx1MDJERCc6J2RibGFjJywnXFx4QjgnOidjZWRpbCcsJ1xcdTAyREInOidvZ29uJywnXFx1MDJDNic6J2NpcmMnLCdcXHUwMkM3JzonY2Fyb24nLCdcXHhCMCc6J2RlZycsJ1xceEE5JzonY29weScsJ1xceEFFJzoncmVnJywnXFx1MjExNyc6J2NvcHlzcicsJ1xcdTIxMTgnOid3cCcsJ1xcdTIxMUUnOidyeCcsJ1xcdTIxMjcnOidtaG8nLCdcXHUyMTI5JzonaWlvdGEnLCdcXHUyMTkwJzonbGFycicsJ1xcdTIxOUEnOidubGFycicsJ1xcdTIxOTInOidyYXJyJywnXFx1MjE5Qic6J25yYXJyJywnXFx1MjE5MSc6J3VhcnInLCdcXHUyMTkzJzonZGFycicsJ1xcdTIxOTQnOidoYXJyJywnXFx1MjFBRSc6J25oYXJyJywnXFx1MjE5NSc6J3ZhcnInLCdcXHUyMTk2JzonbndhcnInLCdcXHUyMTk3JzonbmVhcnInLCdcXHUyMTk4Jzonc2VhcnInLCdcXHUyMTk5Jzonc3dhcnInLCdcXHUyMTlEJzoncmFycncnLCdcXHUyMTlEXFx1MDMzOCc6J25yYXJydycsJ1xcdTIxOUUnOidMYXJyJywnXFx1MjE5Ric6J1VhcnInLCdcXHUyMUEwJzonUmFycicsJ1xcdTIxQTEnOidEYXJyJywnXFx1MjFBMic6J2xhcnJ0bCcsJ1xcdTIxQTMnOidyYXJydGwnLCdcXHUyMUE0JzonbWFwc3RvbGVmdCcsJ1xcdTIxQTUnOidtYXBzdG91cCcsJ1xcdTIxQTYnOidtYXAnLCdcXHUyMUE3JzonbWFwc3RvZG93bicsJ1xcdTIxQTknOidsYXJyaGsnLCdcXHUyMUFBJzoncmFycmhrJywnXFx1MjFBQic6J2xhcnJscCcsJ1xcdTIxQUMnOidyYXJybHAnLCdcXHUyMUFEJzonaGFycncnLCdcXHUyMUIwJzonbHNoJywnXFx1MjFCMSc6J3JzaCcsJ1xcdTIxQjInOidsZHNoJywnXFx1MjFCMyc6J3Jkc2gnLCdcXHUyMUI1JzonY3JhcnInLCdcXHUyMUI2JzonY3VsYXJyJywnXFx1MjFCNyc6J2N1cmFycicsJ1xcdTIxQkEnOidvbGFycicsJ1xcdTIxQkInOidvcmFycicsJ1xcdTIxQkMnOidsaGFydScsJ1xcdTIxQkQnOidsaGFyZCcsJ1xcdTIxQkUnOid1aGFycicsJ1xcdTIxQkYnOid1aGFybCcsJ1xcdTIxQzAnOidyaGFydScsJ1xcdTIxQzEnOidyaGFyZCcsJ1xcdTIxQzInOidkaGFycicsJ1xcdTIxQzMnOidkaGFybCcsJ1xcdTIxQzQnOidybGFycicsJ1xcdTIxQzUnOid1ZGFycicsJ1xcdTIxQzYnOidscmFycicsJ1xcdTIxQzcnOidsbGFycicsJ1xcdTIxQzgnOid1dWFycicsJ1xcdTIxQzknOidycmFycicsJ1xcdTIxQ0EnOidkZGFycicsJ1xcdTIxQ0InOidscmhhcicsJ1xcdTIxQ0MnOidybGhhcicsJ1xcdTIxRDAnOidsQXJyJywnXFx1MjFDRCc6J25sQXJyJywnXFx1MjFEMSc6J3VBcnInLCdcXHUyMUQyJzonckFycicsJ1xcdTIxQ0YnOiduckFycicsJ1xcdTIxRDMnOidkQXJyJywnXFx1MjFENCc6J2lmZicsJ1xcdTIxQ0UnOiduaEFycicsJ1xcdTIxRDUnOid2QXJyJywnXFx1MjFENic6J253QXJyJywnXFx1MjFENyc6J25lQXJyJywnXFx1MjFEOCc6J3NlQXJyJywnXFx1MjFEOSc6J3N3QXJyJywnXFx1MjFEQSc6J2xBYXJyJywnXFx1MjFEQic6J3JBYXJyJywnXFx1MjFERCc6J3ppZ3JhcnInLCdcXHUyMUU0JzonbGFycmInLCdcXHUyMUU1JzoncmFycmInLCdcXHUyMUY1JzonZHVhcnInLCdcXHUyMUZEJzonbG9hcnInLCdcXHUyMUZFJzoncm9hcnInLCdcXHUyMUZGJzonaG9hcnInLCdcXHUyMjAwJzonZm9yYWxsJywnXFx1MjIwMSc6J2NvbXAnLCdcXHUyMjAyJzoncGFydCcsJ1xcdTIyMDJcXHUwMzM4JzonbnBhcnQnLCdcXHUyMjAzJzonZXhpc3QnLCdcXHUyMjA0JzonbmV4aXN0JywnXFx1MjIwNSc6J2VtcHR5JywnXFx1MjIwNyc6J0RlbCcsJ1xcdTIyMDgnOidpbicsJ1xcdTIyMDknOidub3RpbicsJ1xcdTIyMEInOiduaScsJ1xcdTIyMEMnOidub3RuaScsJ1xcdTAzRjYnOidiZXBzaScsJ1xcdTIyMEYnOidwcm9kJywnXFx1MjIxMCc6J2NvcHJvZCcsJ1xcdTIyMTEnOidzdW0nLCcrJzoncGx1cycsJ1xceEIxJzoncG0nLCdcXHhGNyc6J2RpdicsJ1xceEQ3JzondGltZXMnLCc8JzonbHQnLCdcXHUyMjZFJzonbmx0JywnPFxcdTIwRDInOidudmx0JywnPSc6J2VxdWFscycsJ1xcdTIyNjAnOiduZScsJz1cXHUyMEU1JzonYm5lJywnXFx1MkE3NSc6J0VxdWFsJywnPic6J2d0JywnXFx1MjI2Ric6J25ndCcsJz5cXHUyMEQyJzonbnZndCcsJ1xceEFDJzonbm90JywnfCc6J3ZlcnQnLCdcXHhBNic6J2JydmJhcicsJ1xcdTIyMTInOidtaW51cycsJ1xcdTIyMTMnOidtcCcsJ1xcdTIyMTQnOidwbHVzZG8nLCdcXHUyMDQ0JzonZnJhc2wnLCdcXHUyMjE2Jzonc2V0bW4nLCdcXHUyMjE3JzonbG93YXN0JywnXFx1MjIxOCc6J2NvbXBmbicsJ1xcdTIyMUEnOidTcXJ0JywnXFx1MjIxRCc6J3Byb3AnLCdcXHUyMjFFJzonaW5maW4nLCdcXHUyMjFGJzonYW5ncnQnLCdcXHUyMjIwJzonYW5nJywnXFx1MjIyMFxcdTIwRDInOiduYW5nJywnXFx1MjIyMSc6J2FuZ21zZCcsJ1xcdTIyMjInOidhbmdzcGgnLCdcXHUyMjIzJzonbWlkJywnXFx1MjIyNCc6J25taWQnLCdcXHUyMjI1JzoncGFyJywnXFx1MjIyNic6J25wYXInLCdcXHUyMjI3JzonYW5kJywnXFx1MjIyOCc6J29yJywnXFx1MjIyOSc6J2NhcCcsJ1xcdTIyMjlcXHVGRTAwJzonY2FwcycsJ1xcdTIyMkEnOidjdXAnLCdcXHUyMjJBXFx1RkUwMCc6J2N1cHMnLCdcXHUyMjJCJzonaW50JywnXFx1MjIyQyc6J0ludCcsJ1xcdTIyMkQnOid0aW50JywnXFx1MkEwQyc6J3FpbnQnLCdcXHUyMjJFJzonb2ludCcsJ1xcdTIyMkYnOidDb25pbnQnLCdcXHUyMjMwJzonQ2NvbmludCcsJ1xcdTIyMzEnOidjd2ludCcsJ1xcdTIyMzInOidjd2NvbmludCcsJ1xcdTIyMzMnOidhd2NvbmludCcsJ1xcdTIyMzQnOid0aGVyZTQnLCdcXHUyMjM1JzonYmVjYXVzJywnXFx1MjIzNic6J3JhdGlvJywnXFx1MjIzNyc6J0NvbG9uJywnXFx1MjIzOCc6J21pbnVzZCcsJ1xcdTIyM0EnOidtRERvdCcsJ1xcdTIyM0InOidob210aHQnLCdcXHUyMjNDJzonc2ltJywnXFx1MjI0MSc6J25zaW0nLCdcXHUyMjNDXFx1MjBEMic6J252c2ltJywnXFx1MjIzRCc6J2JzaW0nLCdcXHUyMjNEXFx1MDMzMSc6J3JhY2UnLCdcXHUyMjNFJzonYWMnLCdcXHUyMjNFXFx1MDMzMyc6J2FjRScsJ1xcdTIyM0YnOidhY2QnLCdcXHUyMjQwJzond3InLCdcXHUyMjQyJzonZXNpbScsJ1xcdTIyNDJcXHUwMzM4JzonbmVzaW0nLCdcXHUyMjQzJzonc2ltZScsJ1xcdTIyNDQnOiduc2ltZScsJ1xcdTIyNDUnOidjb25nJywnXFx1MjI0Nyc6J25jb25nJywnXFx1MjI0Nic6J3NpbW5lJywnXFx1MjI0OCc6J2FwJywnXFx1MjI0OSc6J25hcCcsJ1xcdTIyNEEnOidhcGUnLCdcXHUyMjRCJzonYXBpZCcsJ1xcdTIyNEJcXHUwMzM4JzonbmFwaWQnLCdcXHUyMjRDJzonYmNvbmcnLCdcXHUyMjREJzonQ3VwQ2FwJywnXFx1MjI2RCc6J05vdEN1cENhcCcsJ1xcdTIyNERcXHUyMEQyJzonbnZhcCcsJ1xcdTIyNEUnOididW1wJywnXFx1MjI0RVxcdTAzMzgnOiduYnVtcCcsJ1xcdTIyNEYnOididW1wZScsJ1xcdTIyNEZcXHUwMzM4JzonbmJ1bXBlJywnXFx1MjI1MCc6J2RvdGVxJywnXFx1MjI1MFxcdTAzMzgnOiduZWRvdCcsJ1xcdTIyNTEnOidlRG90JywnXFx1MjI1Mic6J2VmRG90JywnXFx1MjI1Myc6J2VyRG90JywnXFx1MjI1NCc6J2NvbG9uZScsJ1xcdTIyNTUnOidlY29sb24nLCdcXHUyMjU2JzonZWNpcicsJ1xcdTIyNTcnOidjaXJlJywnXFx1MjI1OSc6J3dlZGdlcScsJ1xcdTIyNUEnOid2ZWVlcScsJ1xcdTIyNUMnOid0cmllJywnXFx1MjI1Ric6J2VxdWVzdCcsJ1xcdTIyNjEnOidlcXVpdicsJ1xcdTIyNjInOiduZXF1aXYnLCdcXHUyMjYxXFx1MjBFNSc6J2JuZXF1aXYnLCdcXHUyMjY0JzonbGUnLCdcXHUyMjcwJzonbmxlJywnXFx1MjI2NFxcdTIwRDInOidudmxlJywnXFx1MjI2NSc6J2dlJywnXFx1MjI3MSc6J25nZScsJ1xcdTIyNjVcXHUyMEQyJzonbnZnZScsJ1xcdTIyNjYnOidsRScsJ1xcdTIyNjZcXHUwMzM4JzonbmxFJywnXFx1MjI2Nyc6J2dFJywnXFx1MjI2N1xcdTAzMzgnOiduZ0UnLCdcXHUyMjY4XFx1RkUwMCc6J2x2bkUnLCdcXHUyMjY4JzonbG5FJywnXFx1MjI2OSc6J2duRScsJ1xcdTIyNjlcXHVGRTAwJzonZ3ZuRScsJ1xcdTIyNkEnOidsbCcsJ1xcdTIyNkFcXHUwMzM4Jzonbkx0dicsJ1xcdTIyNkFcXHUyMEQyJzonbkx0JywnXFx1MjI2Qic6J2dnJywnXFx1MjI2QlxcdTAzMzgnOiduR3R2JywnXFx1MjI2QlxcdTIwRDInOiduR3QnLCdcXHUyMjZDJzondHdpeHQnLCdcXHUyMjcyJzonbHNpbScsJ1xcdTIyNzQnOidubHNpbScsJ1xcdTIyNzMnOidnc2ltJywnXFx1MjI3NSc6J25nc2ltJywnXFx1MjI3Nic6J2xnJywnXFx1MjI3OCc6J250bGcnLCdcXHUyMjc3JzonZ2wnLCdcXHUyMjc5JzonbnRnbCcsJ1xcdTIyN0EnOidwcicsJ1xcdTIyODAnOiducHInLCdcXHUyMjdCJzonc2MnLCdcXHUyMjgxJzonbnNjJywnXFx1MjI3Qyc6J3ByY3VlJywnXFx1MjJFMCc6J25wcmN1ZScsJ1xcdTIyN0QnOidzY2N1ZScsJ1xcdTIyRTEnOiduc2NjdWUnLCdcXHUyMjdFJzoncHJzaW0nLCdcXHUyMjdGJzonc2NzaW0nLCdcXHUyMjdGXFx1MDMzOCc6J05vdFN1Y2NlZWRzVGlsZGUnLCdcXHUyMjgyJzonc3ViJywnXFx1MjI4NCc6J25zdWInLCdcXHUyMjgyXFx1MjBEMic6J3Zuc3ViJywnXFx1MjI4Myc6J3N1cCcsJ1xcdTIyODUnOiduc3VwJywnXFx1MjI4M1xcdTIwRDInOid2bnN1cCcsJ1xcdTIyODYnOidzdWJlJywnXFx1MjI4OCc6J25zdWJlJywnXFx1MjI4Nyc6J3N1cGUnLCdcXHUyMjg5JzonbnN1cGUnLCdcXHUyMjhBXFx1RkUwMCc6J3ZzdWJuZScsJ1xcdTIyOEEnOidzdWJuZScsJ1xcdTIyOEJcXHVGRTAwJzondnN1cG5lJywnXFx1MjI4Qic6J3N1cG5lJywnXFx1MjI4RCc6J2N1cGRvdCcsJ1xcdTIyOEUnOid1cGx1cycsJ1xcdTIyOEYnOidzcXN1YicsJ1xcdTIyOEZcXHUwMzM4JzonTm90U3F1YXJlU3Vic2V0JywnXFx1MjI5MCc6J3Nxc3VwJywnXFx1MjI5MFxcdTAzMzgnOidOb3RTcXVhcmVTdXBlcnNldCcsJ1xcdTIyOTEnOidzcXN1YmUnLCdcXHUyMkUyJzonbnNxc3ViZScsJ1xcdTIyOTInOidzcXN1cGUnLCdcXHUyMkUzJzonbnNxc3VwZScsJ1xcdTIyOTMnOidzcWNhcCcsJ1xcdTIyOTNcXHVGRTAwJzonc3FjYXBzJywnXFx1MjI5NCc6J3NxY3VwJywnXFx1MjI5NFxcdUZFMDAnOidzcWN1cHMnLCdcXHUyMjk1Jzonb3BsdXMnLCdcXHUyMjk2Jzonb21pbnVzJywnXFx1MjI5Nyc6J290aW1lcycsJ1xcdTIyOTgnOidvc29sJywnXFx1MjI5OSc6J29kb3QnLCdcXHUyMjlBJzonb2NpcicsJ1xcdTIyOUInOidvYXN0JywnXFx1MjI5RCc6J29kYXNoJywnXFx1MjI5RSc6J3BsdXNiJywnXFx1MjI5Ric6J21pbnVzYicsJ1xcdTIyQTAnOid0aW1lc2InLCdcXHUyMkExJzonc2RvdGInLCdcXHUyMkEyJzondmRhc2gnLCdcXHUyMkFDJzonbnZkYXNoJywnXFx1MjJBMyc6J2Rhc2h2JywnXFx1MjJBNCc6J3RvcCcsJ1xcdTIyQTUnOidib3QnLCdcXHUyMkE3JzonbW9kZWxzJywnXFx1MjJBOCc6J3ZEYXNoJywnXFx1MjJBRCc6J252RGFzaCcsJ1xcdTIyQTknOidWZGFzaCcsJ1xcdTIyQUUnOiduVmRhc2gnLCdcXHUyMkFBJzonVnZkYXNoJywnXFx1MjJBQic6J1ZEYXNoJywnXFx1MjJBRic6J25WRGFzaCcsJ1xcdTIyQjAnOidwcnVyZWwnLCdcXHUyMkIyJzondmx0cmknLCdcXHUyMkVBJzonbmx0cmknLCdcXHUyMkIzJzondnJ0cmknLCdcXHUyMkVCJzonbnJ0cmknLCdcXHUyMkI0JzonbHRyaWUnLCdcXHUyMkVDJzonbmx0cmllJywnXFx1MjJCNFxcdTIwRDInOidudmx0cmllJywnXFx1MjJCNSc6J3J0cmllJywnXFx1MjJFRCc6J25ydHJpZScsJ1xcdTIyQjVcXHUyMEQyJzonbnZydHJpZScsJ1xcdTIyQjYnOidvcmlnb2YnLCdcXHUyMkI3JzonaW1vZicsJ1xcdTIyQjgnOidtdW1hcCcsJ1xcdTIyQjknOidoZXJjb24nLCdcXHUyMkJBJzonaW50Y2FsJywnXFx1MjJCQic6J3ZlZWJhcicsJ1xcdTIyQkQnOidiYXJ2ZWUnLCdcXHUyMkJFJzonYW5ncnR2YicsJ1xcdTIyQkYnOidscnRyaScsJ1xcdTIyQzAnOidXZWRnZScsJ1xcdTIyQzEnOidWZWUnLCdcXHUyMkMyJzoneGNhcCcsJ1xcdTIyQzMnOid4Y3VwJywnXFx1MjJDNCc6J2RpYW0nLCdcXHUyMkM1Jzonc2RvdCcsJ1xcdTIyQzYnOidTdGFyJywnXFx1MjJDNyc6J2Rpdm9ueCcsJ1xcdTIyQzgnOidib3d0aWUnLCdcXHUyMkM5JzonbHRpbWVzJywnXFx1MjJDQSc6J3J0aW1lcycsJ1xcdTIyQ0InOidsdGhyZWUnLCdcXHUyMkNDJzoncnRocmVlJywnXFx1MjJDRCc6J2JzaW1lJywnXFx1MjJDRSc6J2N1dmVlJywnXFx1MjJDRic6J2N1d2VkJywnXFx1MjJEMCc6J1N1YicsJ1xcdTIyRDEnOidTdXAnLCdcXHUyMkQyJzonQ2FwJywnXFx1MjJEMyc6J0N1cCcsJ1xcdTIyRDQnOidmb3JrJywnXFx1MjJENSc6J2VwYXInLCdcXHUyMkQ2JzonbHRkb3QnLCdcXHUyMkQ3JzonZ3Rkb3QnLCdcXHUyMkQ4JzonTGwnLCdcXHUyMkQ4XFx1MDMzOCc6J25MbCcsJ1xcdTIyRDknOidHZycsJ1xcdTIyRDlcXHUwMzM4JzonbkdnJywnXFx1MjJEQVxcdUZFMDAnOidsZXNnJywnXFx1MjJEQSc6J2xlZycsJ1xcdTIyREInOidnZWwnLCdcXHUyMkRCXFx1RkUwMCc6J2dlc2wnLCdcXHUyMkRFJzonY3VlcHInLCdcXHUyMkRGJzonY3Vlc2MnLCdcXHUyMkU2JzonbG5zaW0nLCdcXHUyMkU3JzonZ25zaW0nLCdcXHUyMkU4JzoncHJuc2ltJywnXFx1MjJFOSc6J3NjbnNpbScsJ1xcdTIyRUUnOid2ZWxsaXAnLCdcXHUyMkVGJzonY3Rkb3QnLCdcXHUyMkYwJzondXRkb3QnLCdcXHUyMkYxJzonZHRkb3QnLCdcXHUyMkYyJzonZGlzaW4nLCdcXHUyMkYzJzonaXNpbnN2JywnXFx1MjJGNCc6J2lzaW5zJywnXFx1MjJGNSc6J2lzaW5kb3QnLCdcXHUyMkY1XFx1MDMzOCc6J25vdGluZG90JywnXFx1MjJGNic6J25vdGludmMnLCdcXHUyMkY3Jzonbm90aW52YicsJ1xcdTIyRjknOidpc2luRScsJ1xcdTIyRjlcXHUwMzM4Jzonbm90aW5FJywnXFx1MjJGQSc6J25pc2QnLCdcXHUyMkZCJzoneG5pcycsJ1xcdTIyRkMnOiduaXMnLCdcXHUyMkZEJzonbm90bml2YycsJ1xcdTIyRkUnOidub3RuaXZiJywnXFx1MjMwNSc6J2JhcndlZCcsJ1xcdTIzMDYnOidCYXJ3ZWQnLCdcXHUyMzBDJzonZHJjcm9wJywnXFx1MjMwRCc6J2RsY3JvcCcsJ1xcdTIzMEUnOid1cmNyb3AnLCdcXHUyMzBGJzondWxjcm9wJywnXFx1MjMxMCc6J2Jub3QnLCdcXHUyMzEyJzoncHJvZmxpbmUnLCdcXHUyMzEzJzoncHJvZnN1cmYnLCdcXHUyMzE1JzondGVscmVjJywnXFx1MjMxNic6J3RhcmdldCcsJ1xcdTIzMUMnOid1bGNvcm4nLCdcXHUyMzFEJzondXJjb3JuJywnXFx1MjMxRSc6J2RsY29ybicsJ1xcdTIzMUYnOidkcmNvcm4nLCdcXHUyMzIyJzonZnJvd24nLCdcXHUyMzIzJzonc21pbGUnLCdcXHUyMzJEJzonY3lsY3R5JywnXFx1MjMyRSc6J3Byb2ZhbGFyJywnXFx1MjMzNic6J3RvcGJvdCcsJ1xcdTIzM0QnOidvdmJhcicsJ1xcdTIzM0YnOidzb2xiYXInLCdcXHUyMzdDJzonYW5nemFycicsJ1xcdTIzQjAnOidsbW91c3QnLCdcXHUyM0IxJzoncm1vdXN0JywnXFx1MjNCNCc6J3RicmsnLCdcXHUyM0I1JzonYmJyaycsJ1xcdTIzQjYnOidiYnJrdGJyaycsJ1xcdTIzREMnOidPdmVyUGFyZW50aGVzaXMnLCdcXHUyM0REJzonVW5kZXJQYXJlbnRoZXNpcycsJ1xcdTIzREUnOidPdmVyQnJhY2UnLCdcXHUyM0RGJzonVW5kZXJCcmFjZScsJ1xcdTIzRTInOid0cnBleml1bScsJ1xcdTIzRTcnOidlbGludGVycycsJ1xcdTI0MjMnOidibGFuaycsJ1xcdTI1MDAnOidib3hoJywnXFx1MjUwMic6J2JveHYnLCdcXHUyNTBDJzonYm94ZHInLCdcXHUyNTEwJzonYm94ZGwnLCdcXHUyNTE0JzonYm94dXInLCdcXHUyNTE4JzonYm94dWwnLCdcXHUyNTFDJzonYm94dnInLCdcXHUyNTI0JzonYm94dmwnLCdcXHUyNTJDJzonYm94aGQnLCdcXHUyNTM0JzonYm94aHUnLCdcXHUyNTNDJzonYm94dmgnLCdcXHUyNTUwJzonYm94SCcsJ1xcdTI1NTEnOidib3hWJywnXFx1MjU1Mic6J2JveGRSJywnXFx1MjU1Myc6J2JveERyJywnXFx1MjU1NCc6J2JveERSJywnXFx1MjU1NSc6J2JveGRMJywnXFx1MjU1Nic6J2JveERsJywnXFx1MjU1Nyc6J2JveERMJywnXFx1MjU1OCc6J2JveHVSJywnXFx1MjU1OSc6J2JveFVyJywnXFx1MjU1QSc6J2JveFVSJywnXFx1MjU1Qic6J2JveHVMJywnXFx1MjU1Qyc6J2JveFVsJywnXFx1MjU1RCc6J2JveFVMJywnXFx1MjU1RSc6J2JveHZSJywnXFx1MjU1Ric6J2JveFZyJywnXFx1MjU2MCc6J2JveFZSJywnXFx1MjU2MSc6J2JveHZMJywnXFx1MjU2Mic6J2JveFZsJywnXFx1MjU2Myc6J2JveFZMJywnXFx1MjU2NCc6J2JveEhkJywnXFx1MjU2NSc6J2JveGhEJywnXFx1MjU2Nic6J2JveEhEJywnXFx1MjU2Nyc6J2JveEh1JywnXFx1MjU2OCc6J2JveGhVJywnXFx1MjU2OSc6J2JveEhVJywnXFx1MjU2QSc6J2JveHZIJywnXFx1MjU2Qic6J2JveFZoJywnXFx1MjU2Qyc6J2JveFZIJywnXFx1MjU4MCc6J3VoYmxrJywnXFx1MjU4NCc6J2xoYmxrJywnXFx1MjU4OCc6J2Jsb2NrJywnXFx1MjU5MSc6J2JsazE0JywnXFx1MjU5Mic6J2JsazEyJywnXFx1MjU5Myc6J2JsazM0JywnXFx1MjVBMSc6J3NxdScsJ1xcdTI1QUEnOidzcXVmJywnXFx1MjVBQic6J0VtcHR5VmVyeVNtYWxsU3F1YXJlJywnXFx1MjVBRCc6J3JlY3QnLCdcXHUyNUFFJzonbWFya2VyJywnXFx1MjVCMSc6J2ZsdG5zJywnXFx1MjVCMyc6J3h1dHJpJywnXFx1MjVCNCc6J3V0cmlmJywnXFx1MjVCNSc6J3V0cmknLCdcXHUyNUI4JzoncnRyaWYnLCdcXHUyNUI5JzoncnRyaScsJ1xcdTI1QkQnOid4ZHRyaScsJ1xcdTI1QkUnOidkdHJpZicsJ1xcdTI1QkYnOidkdHJpJywnXFx1MjVDMic6J2x0cmlmJywnXFx1MjVDMyc6J2x0cmknLCdcXHUyNUNBJzonbG96JywnXFx1MjVDQic6J2NpcicsJ1xcdTI1RUMnOid0cmlkb3QnLCdcXHUyNUVGJzoneGNpcmMnLCdcXHUyNUY4JzondWx0cmknLCdcXHUyNUY5JzondXJ0cmknLCdcXHUyNUZBJzonbGx0cmknLCdcXHUyNUZCJzonRW1wdHlTbWFsbFNxdWFyZScsJ1xcdTI1RkMnOidGaWxsZWRTbWFsbFNxdWFyZScsJ1xcdTI2MDUnOidzdGFyZicsJ1xcdTI2MDYnOidzdGFyJywnXFx1MjYwRSc6J3Bob25lJywnXFx1MjY0MCc6J2ZlbWFsZScsJ1xcdTI2NDInOidtYWxlJywnXFx1MjY2MCc6J3NwYWRlcycsJ1xcdTI2NjMnOidjbHVicycsJ1xcdTI2NjUnOidoZWFydHMnLCdcXHUyNjY2JzonZGlhbXMnLCdcXHUyNjZBJzonc3VuZycsJ1xcdTI3MTMnOidjaGVjaycsJ1xcdTI3MTcnOidjcm9zcycsJ1xcdTI3MjAnOidtYWx0JywnXFx1MjczNic6J3NleHQnLCdcXHUyNzU4JzonVmVydGljYWxTZXBhcmF0b3InLCdcXHUyN0M4JzonYnNvbGhzdWInLCdcXHUyN0M5Jzonc3VwaHNvbCcsJ1xcdTI3RjUnOid4bGFycicsJ1xcdTI3RjYnOid4cmFycicsJ1xcdTI3RjcnOid4aGFycicsJ1xcdTI3RjgnOid4bEFycicsJ1xcdTI3RjknOid4ckFycicsJ1xcdTI3RkEnOid4aEFycicsJ1xcdTI3RkMnOid4bWFwJywnXFx1MjdGRic6J2R6aWdyYXJyJywnXFx1MjkwMic6J252bEFycicsJ1xcdTI5MDMnOidudnJBcnInLCdcXHUyOTA0JzonbnZIYXJyJywnXFx1MjkwNSc6J01hcCcsJ1xcdTI5MEMnOidsYmFycicsJ1xcdTI5MEQnOidyYmFycicsJ1xcdTI5MEUnOidsQmFycicsJ1xcdTI5MEYnOidyQmFycicsJ1xcdTI5MTAnOidSQmFycicsJ1xcdTI5MTEnOidERG90cmFoZCcsJ1xcdTI5MTInOidVcEFycm93QmFyJywnXFx1MjkxMyc6J0Rvd25BcnJvd0JhcicsJ1xcdTI5MTYnOidSYXJydGwnLCdcXHUyOTE5JzonbGF0YWlsJywnXFx1MjkxQSc6J3JhdGFpbCcsJ1xcdTI5MUInOidsQXRhaWwnLCdcXHUyOTFDJzonckF0YWlsJywnXFx1MjkxRCc6J2xhcnJmcycsJ1xcdTI5MUUnOidyYXJyZnMnLCdcXHUyOTFGJzonbGFycmJmcycsJ1xcdTI5MjAnOidyYXJyYmZzJywnXFx1MjkyMyc6J253YXJoaycsJ1xcdTI5MjQnOiduZWFyaGsnLCdcXHUyOTI1Jzonc2VhcmhrJywnXFx1MjkyNic6J3N3YXJoaycsJ1xcdTI5MjcnOidud25lYXInLCdcXHUyOTI4JzondG9lYScsJ1xcdTI5MjknOid0b3NhJywnXFx1MjkyQSc6J3N3bndhcicsJ1xcdTI5MzMnOidyYXJyYycsJ1xcdTI5MzNcXHUwMzM4JzonbnJhcnJjJywnXFx1MjkzNSc6J2N1ZGFycnInLCdcXHUyOTM2JzonbGRjYScsJ1xcdTI5MzcnOidyZGNhJywnXFx1MjkzOCc6J2N1ZGFycmwnLCdcXHUyOTM5JzonbGFycnBsJywnXFx1MjkzQyc6J2N1cmFycm0nLCdcXHUyOTNEJzonY3VsYXJycCcsJ1xcdTI5NDUnOidyYXJycGwnLCdcXHUyOTQ4JzonaGFycmNpcicsJ1xcdTI5NDknOidVYXJyb2NpcicsJ1xcdTI5NEEnOidsdXJkc2hhcicsJ1xcdTI5NEInOidsZHJ1c2hhcicsJ1xcdTI5NEUnOidMZWZ0UmlnaHRWZWN0b3InLCdcXHUyOTRGJzonUmlnaHRVcERvd25WZWN0b3InLCdcXHUyOTUwJzonRG93bkxlZnRSaWdodFZlY3RvcicsJ1xcdTI5NTEnOidMZWZ0VXBEb3duVmVjdG9yJywnXFx1Mjk1Mic6J0xlZnRWZWN0b3JCYXInLCdcXHUyOTUzJzonUmlnaHRWZWN0b3JCYXInLCdcXHUyOTU0JzonUmlnaHRVcFZlY3RvckJhcicsJ1xcdTI5NTUnOidSaWdodERvd25WZWN0b3JCYXInLCdcXHUyOTU2JzonRG93bkxlZnRWZWN0b3JCYXInLCdcXHUyOTU3JzonRG93blJpZ2h0VmVjdG9yQmFyJywnXFx1Mjk1OCc6J0xlZnRVcFZlY3RvckJhcicsJ1xcdTI5NTknOidMZWZ0RG93blZlY3RvckJhcicsJ1xcdTI5NUEnOidMZWZ0VGVlVmVjdG9yJywnXFx1Mjk1Qic6J1JpZ2h0VGVlVmVjdG9yJywnXFx1Mjk1Qyc6J1JpZ2h0VXBUZWVWZWN0b3InLCdcXHUyOTVEJzonUmlnaHREb3duVGVlVmVjdG9yJywnXFx1Mjk1RSc6J0Rvd25MZWZ0VGVlVmVjdG9yJywnXFx1Mjk1Ric6J0Rvd25SaWdodFRlZVZlY3RvcicsJ1xcdTI5NjAnOidMZWZ0VXBUZWVWZWN0b3InLCdcXHUyOTYxJzonTGVmdERvd25UZWVWZWN0b3InLCdcXHUyOTYyJzonbEhhcicsJ1xcdTI5NjMnOid1SGFyJywnXFx1Mjk2NCc6J3JIYXInLCdcXHUyOTY1JzonZEhhcicsJ1xcdTI5NjYnOidsdXJ1aGFyJywnXFx1Mjk2Nyc6J2xkcmRoYXInLCdcXHUyOTY4JzoncnVsdWhhcicsJ1xcdTI5NjknOidyZGxkaGFyJywnXFx1Mjk2QSc6J2xoYXJ1bCcsJ1xcdTI5NkInOidsbGhhcmQnLCdcXHUyOTZDJzoncmhhcnVsJywnXFx1Mjk2RCc6J2xyaGFyZCcsJ1xcdTI5NkUnOid1ZGhhcicsJ1xcdTI5NkYnOidkdWhhcicsJ1xcdTI5NzAnOidSb3VuZEltcGxpZXMnLCdcXHUyOTcxJzonZXJhcnInLCdcXHUyOTcyJzonc2ltcmFycicsJ1xcdTI5NzMnOidsYXJyc2ltJywnXFx1Mjk3NCc6J3JhcnJzaW0nLCdcXHUyOTc1JzoncmFycmFwJywnXFx1Mjk3Nic6J2x0bGFycicsJ1xcdTI5NzgnOidndHJhcnInLCdcXHUyOTc5Jzonc3VicmFycicsJ1xcdTI5N0InOidzdXBsYXJyJywnXFx1Mjk3Qyc6J2xmaXNodCcsJ1xcdTI5N0QnOidyZmlzaHQnLCdcXHUyOTdFJzondWZpc2h0JywnXFx1Mjk3Ric6J2RmaXNodCcsJ1xcdTI5OUEnOid2emlnemFnJywnXFx1Mjk5Qyc6J3ZhbmdydCcsJ1xcdTI5OUQnOidhbmdydHZiZCcsJ1xcdTI5QTQnOidhbmdlJywnXFx1MjlBNSc6J3JhbmdlJywnXFx1MjlBNic6J2R3YW5nbGUnLCdcXHUyOUE3JzondXdhbmdsZScsJ1xcdTI5QTgnOidhbmdtc2RhYScsJ1xcdTI5QTknOidhbmdtc2RhYicsJ1xcdTI5QUEnOidhbmdtc2RhYycsJ1xcdTI5QUInOidhbmdtc2RhZCcsJ1xcdTI5QUMnOidhbmdtc2RhZScsJ1xcdTI5QUQnOidhbmdtc2RhZicsJ1xcdTI5QUUnOidhbmdtc2RhZycsJ1xcdTI5QUYnOidhbmdtc2RhaCcsJ1xcdTI5QjAnOidiZW1wdHl2JywnXFx1MjlCMSc6J2RlbXB0eXYnLCdcXHUyOUIyJzonY2VtcHR5dicsJ1xcdTI5QjMnOidyYWVtcHR5dicsJ1xcdTI5QjQnOidsYWVtcHR5dicsJ1xcdTI5QjUnOidvaGJhcicsJ1xcdTI5QjYnOidvbWlkJywnXFx1MjlCNyc6J29wYXInLCdcXHUyOUI5Jzonb3BlcnAnLCdcXHUyOUJCJzonb2xjcm9zcycsJ1xcdTI5QkMnOidvZHNvbGQnLCdcXHUyOUJFJzonb2xjaXInLCdcXHUyOUJGJzonb2ZjaXInLCdcXHUyOUMwJzonb2x0JywnXFx1MjlDMSc6J29ndCcsJ1xcdTI5QzInOidjaXJzY2lyJywnXFx1MjlDMyc6J2NpckUnLCdcXHUyOUM0Jzonc29sYicsJ1xcdTI5QzUnOidic29sYicsJ1xcdTI5QzknOidib3hib3gnLCdcXHUyOUNEJzondHJpc2InLCdcXHUyOUNFJzoncnRyaWx0cmknLCdcXHUyOUNGJzonTGVmdFRyaWFuZ2xlQmFyJywnXFx1MjlDRlxcdTAzMzgnOidOb3RMZWZ0VHJpYW5nbGVCYXInLCdcXHUyOUQwJzonUmlnaHRUcmlhbmdsZUJhcicsJ1xcdTI5RDBcXHUwMzM4JzonTm90UmlnaHRUcmlhbmdsZUJhcicsJ1xcdTI5REMnOidpaW5maW4nLCdcXHUyOUREJzonaW5maW50aWUnLCdcXHUyOURFJzonbnZpbmZpbicsJ1xcdTI5RTMnOidlcGFyc2wnLCdcXHUyOUU0Jzonc21lcGFyc2wnLCdcXHUyOUU1JzonZXF2cGFyc2wnLCdcXHUyOUVCJzonbG96ZicsJ1xcdTI5RjQnOidSdWxlRGVsYXllZCcsJ1xcdTI5RjYnOidkc29sJywnXFx1MkEwMCc6J3hvZG90JywnXFx1MkEwMSc6J3hvcGx1cycsJ1xcdTJBMDInOid4b3RpbWUnLCdcXHUyQTA0JzoneHVwbHVzJywnXFx1MkEwNic6J3hzcWN1cCcsJ1xcdTJBMEQnOidmcGFydGludCcsJ1xcdTJBMTAnOidjaXJmbmludCcsJ1xcdTJBMTEnOidhd2ludCcsJ1xcdTJBMTInOidycHBvbGludCcsJ1xcdTJBMTMnOidzY3BvbGludCcsJ1xcdTJBMTQnOiducG9saW50JywnXFx1MkExNSc6J3BvaW50aW50JywnXFx1MkExNic6J3F1YXRpbnQnLCdcXHUyQTE3JzonaW50bGFyaGsnLCdcXHUyQTIyJzoncGx1c2NpcicsJ1xcdTJBMjMnOidwbHVzYWNpcicsJ1xcdTJBMjQnOidzaW1wbHVzJywnXFx1MkEyNSc6J3BsdXNkdScsJ1xcdTJBMjYnOidwbHVzc2ltJywnXFx1MkEyNyc6J3BsdXN0d28nLCdcXHUyQTI5JzonbWNvbW1hJywnXFx1MkEyQSc6J21pbnVzZHUnLCdcXHUyQTJEJzonbG9wbHVzJywnXFx1MkEyRSc6J3JvcGx1cycsJ1xcdTJBMkYnOidDcm9zcycsJ1xcdTJBMzAnOid0aW1lc2QnLCdcXHUyQTMxJzondGltZXNiYXInLCdcXHUyQTMzJzonc21hc2hwJywnXFx1MkEzNCc6J2xvdGltZXMnLCdcXHUyQTM1Jzoncm90aW1lcycsJ1xcdTJBMzYnOidvdGltZXNhcycsJ1xcdTJBMzcnOidPdGltZXMnLCdcXHUyQTM4Jzonb2RpdicsJ1xcdTJBMzknOid0cmlwbHVzJywnXFx1MkEzQSc6J3RyaW1pbnVzJywnXFx1MkEzQic6J3RyaXRpbWUnLCdcXHUyQTNDJzonaXByb2QnLCdcXHUyQTNGJzonYW1hbGcnLCdcXHUyQTQwJzonY2FwZG90JywnXFx1MkE0Mic6J25jdXAnLCdcXHUyQTQzJzonbmNhcCcsJ1xcdTJBNDQnOidjYXBhbmQnLCdcXHUyQTQ1JzonY3Vwb3InLCdcXHUyQTQ2JzonY3VwY2FwJywnXFx1MkE0Nyc6J2NhcGN1cCcsJ1xcdTJBNDgnOidjdXBicmNhcCcsJ1xcdTJBNDknOidjYXBicmN1cCcsJ1xcdTJBNEEnOidjdXBjdXAnLCdcXHUyQTRCJzonY2FwY2FwJywnXFx1MkE0Qyc6J2NjdXBzJywnXFx1MkE0RCc6J2NjYXBzJywnXFx1MkE1MCc6J2NjdXBzc20nLCdcXHUyQTUzJzonQW5kJywnXFx1MkE1NCc6J09yJywnXFx1MkE1NSc6J2FuZGFuZCcsJ1xcdTJBNTYnOidvcm9yJywnXFx1MkE1Nyc6J29yc2xvcGUnLCdcXHUyQTU4JzonYW5kc2xvcGUnLCdcXHUyQTVBJzonYW5kdicsJ1xcdTJBNUInOidvcnYnLCdcXHUyQTVDJzonYW5kZCcsJ1xcdTJBNUQnOidvcmQnLCdcXHUyQTVGJzond2VkYmFyJywnXFx1MkE2Nic6J3Nkb3RlJywnXFx1MkE2QSc6J3NpbWRvdCcsJ1xcdTJBNkQnOidjb25nZG90JywnXFx1MkE2RFxcdTAzMzgnOiduY29uZ2RvdCcsJ1xcdTJBNkUnOidlYXN0ZXInLCdcXHUyQTZGJzonYXBhY2lyJywnXFx1MkE3MCc6J2FwRScsJ1xcdTJBNzBcXHUwMzM4JzonbmFwRScsJ1xcdTJBNzEnOidlcGx1cycsJ1xcdTJBNzInOidwbHVzZScsJ1xcdTJBNzMnOidFc2ltJywnXFx1MkE3Nyc6J2VERG90JywnXFx1MkE3OCc6J2VxdWl2REQnLCdcXHUyQTc5JzonbHRjaXInLCdcXHUyQTdBJzonZ3RjaXInLCdcXHUyQTdCJzonbHRxdWVzdCcsJ1xcdTJBN0MnOidndHF1ZXN0JywnXFx1MkE3RCc6J2xlcycsJ1xcdTJBN0RcXHUwMzM4JzonbmxlcycsJ1xcdTJBN0UnOidnZXMnLCdcXHUyQTdFXFx1MDMzOCc6J25nZXMnLCdcXHUyQTdGJzonbGVzZG90JywnXFx1MkE4MCc6J2dlc2RvdCcsJ1xcdTJBODEnOidsZXNkb3RvJywnXFx1MkE4Mic6J2dlc2RvdG8nLCdcXHUyQTgzJzonbGVzZG90b3InLCdcXHUyQTg0JzonZ2VzZG90b2wnLCdcXHUyQTg1JzonbGFwJywnXFx1MkE4Nic6J2dhcCcsJ1xcdTJBODcnOidsbmUnLCdcXHUyQTg4JzonZ25lJywnXFx1MkE4OSc6J2xuYXAnLCdcXHUyQThBJzonZ25hcCcsJ1xcdTJBOEInOidsRWcnLCdcXHUyQThDJzonZ0VsJywnXFx1MkE4RCc6J2xzaW1lJywnXFx1MkE4RSc6J2dzaW1lJywnXFx1MkE4Ric6J2xzaW1nJywnXFx1MkE5MCc6J2dzaW1sJywnXFx1MkE5MSc6J2xnRScsJ1xcdTJBOTInOidnbEUnLCdcXHUyQTkzJzonbGVzZ2VzJywnXFx1MkE5NCc6J2dlc2xlcycsJ1xcdTJBOTUnOidlbHMnLCdcXHUyQTk2JzonZWdzJywnXFx1MkE5Nyc6J2Vsc2RvdCcsJ1xcdTJBOTgnOidlZ3Nkb3QnLCdcXHUyQTk5JzonZWwnLCdcXHUyQTlBJzonZWcnLCdcXHUyQTlEJzonc2ltbCcsJ1xcdTJBOUUnOidzaW1nJywnXFx1MkE5Ric6J3NpbWxFJywnXFx1MkFBMCc6J3NpbWdFJywnXFx1MkFBMSc6J0xlc3NMZXNzJywnXFx1MkFBMVxcdTAzMzgnOidOb3ROZXN0ZWRMZXNzTGVzcycsJ1xcdTJBQTInOidHcmVhdGVyR3JlYXRlcicsJ1xcdTJBQTJcXHUwMzM4JzonTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCdcXHUyQUE0JzonZ2xqJywnXFx1MkFBNSc6J2dsYScsJ1xcdTJBQTYnOidsdGNjJywnXFx1MkFBNyc6J2d0Y2MnLCdcXHUyQUE4JzonbGVzY2MnLCdcXHUyQUE5JzonZ2VzY2MnLCdcXHUyQUFBJzonc210JywnXFx1MkFBQic6J2xhdCcsJ1xcdTJBQUMnOidzbXRlJywnXFx1MkFBQ1xcdUZFMDAnOidzbXRlcycsJ1xcdTJBQUQnOidsYXRlJywnXFx1MkFBRFxcdUZFMDAnOidsYXRlcycsJ1xcdTJBQUUnOididW1wRScsJ1xcdTJBQUYnOidwcmUnLCdcXHUyQUFGXFx1MDMzOCc6J25wcmUnLCdcXHUyQUIwJzonc2NlJywnXFx1MkFCMFxcdTAzMzgnOiduc2NlJywnXFx1MkFCMyc6J3ByRScsJ1xcdTJBQjQnOidzY0UnLCdcXHUyQUI1JzoncHJuRScsJ1xcdTJBQjYnOidzY25FJywnXFx1MkFCNyc6J3ByYXAnLCdcXHUyQUI4Jzonc2NhcCcsJ1xcdTJBQjknOidwcm5hcCcsJ1xcdTJBQkEnOidzY25hcCcsJ1xcdTJBQkInOidQcicsJ1xcdTJBQkMnOidTYycsJ1xcdTJBQkQnOidzdWJkb3QnLCdcXHUyQUJFJzonc3VwZG90JywnXFx1MkFCRic6J3N1YnBsdXMnLCdcXHUyQUMwJzonc3VwcGx1cycsJ1xcdTJBQzEnOidzdWJtdWx0JywnXFx1MkFDMic6J3N1cG11bHQnLCdcXHUyQUMzJzonc3ViZWRvdCcsJ1xcdTJBQzQnOidzdXBlZG90JywnXFx1MkFDNSc6J3N1YkUnLCdcXHUyQUM1XFx1MDMzOCc6J25zdWJFJywnXFx1MkFDNic6J3N1cEUnLCdcXHUyQUM2XFx1MDMzOCc6J25zdXBFJywnXFx1MkFDNyc6J3N1YnNpbScsJ1xcdTJBQzgnOidzdXBzaW0nLCdcXHUyQUNCXFx1RkUwMCc6J3ZzdWJuRScsJ1xcdTJBQ0InOidzdWJuRScsJ1xcdTJBQ0NcXHVGRTAwJzondnN1cG5FJywnXFx1MkFDQyc6J3N1cG5FJywnXFx1MkFDRic6J2NzdWInLCdcXHUyQUQwJzonY3N1cCcsJ1xcdTJBRDEnOidjc3ViZScsJ1xcdTJBRDInOidjc3VwZScsJ1xcdTJBRDMnOidzdWJzdXAnLCdcXHUyQUQ0Jzonc3Vwc3ViJywnXFx1MkFENSc6J3N1YnN1YicsJ1xcdTJBRDYnOidzdXBzdXAnLCdcXHUyQUQ3Jzonc3VwaHN1YicsJ1xcdTJBRDgnOidzdXBkc3ViJywnXFx1MkFEOSc6J2Zvcmt2JywnXFx1MkFEQSc6J3RvcGZvcmsnLCdcXHUyQURCJzonbWxjcCcsJ1xcdTJBRTQnOidEYXNodicsJ1xcdTJBRTYnOidWZGFzaGwnLCdcXHUyQUU3JzonQmFydicsJ1xcdTJBRTgnOid2QmFyJywnXFx1MkFFOSc6J3ZCYXJ2JywnXFx1MkFFQic6J1ZiYXInLCdcXHUyQUVDJzonTm90JywnXFx1MkFFRCc6J2JOb3QnLCdcXHUyQUVFJzoncm5taWQnLCdcXHUyQUVGJzonY2lybWlkJywnXFx1MkFGMCc6J21pZGNpcicsJ1xcdTJBRjEnOid0b3BjaXInLCdcXHUyQUYyJzonbmhwYXInLCdcXHUyQUYzJzoncGFyc2ltJywnXFx1MkFGRCc6J3BhcnNsJywnXFx1MkFGRFxcdTIwRTUnOiducGFyc2wnLCdcXHUyNjZEJzonZmxhdCcsJ1xcdTI2NkUnOiduYXR1cicsJ1xcdTI2NkYnOidzaGFycCcsJ1xceEE0JzonY3VycmVuJywnXFx4QTInOidjZW50JywnJCc6J2RvbGxhcicsJ1xceEEzJzoncG91bmQnLCdcXHhBNSc6J3llbicsJ1xcdTIwQUMnOidldXJvJywnXFx4QjknOidzdXAxJywnXFx4QkQnOidoYWxmJywnXFx1MjE1Myc6J2ZyYWMxMycsJ1xceEJDJzonZnJhYzE0JywnXFx1MjE1NSc6J2ZyYWMxNScsJ1xcdTIxNTknOidmcmFjMTYnLCdcXHUyMTVCJzonZnJhYzE4JywnXFx4QjInOidzdXAyJywnXFx1MjE1NCc6J2ZyYWMyMycsJ1xcdTIxNTYnOidmcmFjMjUnLCdcXHhCMyc6J3N1cDMnLCdcXHhCRSc6J2ZyYWMzNCcsJ1xcdTIxNTcnOidmcmFjMzUnLCdcXHUyMTVDJzonZnJhYzM4JywnXFx1MjE1OCc6J2ZyYWM0NScsJ1xcdTIxNUEnOidmcmFjNTYnLCdcXHUyMTVEJzonZnJhYzU4JywnXFx1MjE1RSc6J2ZyYWM3OCcsJ1xcdUQ4MzVcXHVEQ0I2JzonYXNjcicsJ1xcdUQ4MzVcXHVERDUyJzonYW9wZicsJ1xcdUQ4MzVcXHVERDFFJzonYWZyJywnXFx1RDgzNVxcdUREMzgnOidBb3BmJywnXFx1RDgzNVxcdUREMDQnOidBZnInLCdcXHVEODM1XFx1REM5Qyc6J0FzY3InLCdcXHhBQSc6J29yZGYnLCdcXHhFMSc6J2FhY3V0ZScsJ1xceEMxJzonQWFjdXRlJywnXFx4RTAnOidhZ3JhdmUnLCdcXHhDMCc6J0FncmF2ZScsJ1xcdTAxMDMnOidhYnJldmUnLCdcXHUwMTAyJzonQWJyZXZlJywnXFx4RTInOidhY2lyYycsJ1xceEMyJzonQWNpcmMnLCdcXHhFNSc6J2FyaW5nJywnXFx4QzUnOidhbmdzdCcsJ1xceEU0JzonYXVtbCcsJ1xceEM0JzonQXVtbCcsJ1xceEUzJzonYXRpbGRlJywnXFx4QzMnOidBdGlsZGUnLCdcXHUwMTA1JzonYW9nb24nLCdcXHUwMTA0JzonQW9nb24nLCdcXHUwMTAxJzonYW1hY3InLCdcXHUwMTAwJzonQW1hY3InLCdcXHhFNic6J2FlbGlnJywnXFx4QzYnOidBRWxpZycsJ1xcdUQ4MzVcXHVEQ0I3JzonYnNjcicsJ1xcdUQ4MzVcXHVERDUzJzonYm9wZicsJ1xcdUQ4MzVcXHVERDFGJzonYmZyJywnXFx1RDgzNVxcdUREMzknOidCb3BmJywnXFx1MjEyQyc6J0JzY3InLCdcXHVEODM1XFx1REQwNSc6J0JmcicsJ1xcdUQ4MzVcXHVERDIwJzonY2ZyJywnXFx1RDgzNVxcdURDQjgnOidjc2NyJywnXFx1RDgzNVxcdURENTQnOidjb3BmJywnXFx1MjEyRCc6J0NmcicsJ1xcdUQ4MzVcXHVEQzlFJzonQ3NjcicsJ1xcdTIxMDInOidDb3BmJywnXFx1MDEwNyc6J2NhY3V0ZScsJ1xcdTAxMDYnOidDYWN1dGUnLCdcXHUwMTA5JzonY2NpcmMnLCdcXHUwMTA4JzonQ2NpcmMnLCdcXHUwMTBEJzonY2Nhcm9uJywnXFx1MDEwQyc6J0NjYXJvbicsJ1xcdTAxMEInOidjZG90JywnXFx1MDEwQSc6J0Nkb3QnLCdcXHhFNyc6J2NjZWRpbCcsJ1xceEM3JzonQ2NlZGlsJywnXFx1MjEwNSc6J2luY2FyZScsJ1xcdUQ4MzVcXHVERDIxJzonZGZyJywnXFx1MjE0Nic6J2RkJywnXFx1RDgzNVxcdURENTUnOidkb3BmJywnXFx1RDgzNVxcdURDQjknOidkc2NyJywnXFx1RDgzNVxcdURDOUYnOidEc2NyJywnXFx1RDgzNVxcdUREMDcnOidEZnInLCdcXHUyMTQ1JzonREQnLCdcXHVEODM1XFx1REQzQic6J0RvcGYnLCdcXHUwMTBGJzonZGNhcm9uJywnXFx1MDEwRSc6J0RjYXJvbicsJ1xcdTAxMTEnOidkc3Ryb2snLCdcXHUwMTEwJzonRHN0cm9rJywnXFx4RjAnOidldGgnLCdcXHhEMCc6J0VUSCcsJ1xcdTIxNDcnOidlZScsJ1xcdTIxMkYnOidlc2NyJywnXFx1RDgzNVxcdUREMjInOidlZnInLCdcXHVEODM1XFx1REQ1Nic6J2VvcGYnLCdcXHUyMTMwJzonRXNjcicsJ1xcdUQ4MzVcXHVERDA4JzonRWZyJywnXFx1RDgzNVxcdUREM0MnOidFb3BmJywnXFx4RTknOidlYWN1dGUnLCdcXHhDOSc6J0VhY3V0ZScsJ1xceEU4JzonZWdyYXZlJywnXFx4QzgnOidFZ3JhdmUnLCdcXHhFQSc6J2VjaXJjJywnXFx4Q0EnOidFY2lyYycsJ1xcdTAxMUInOidlY2Fyb24nLCdcXHUwMTFBJzonRWNhcm9uJywnXFx4RUInOidldW1sJywnXFx4Q0InOidFdW1sJywnXFx1MDExNyc6J2Vkb3QnLCdcXHUwMTE2JzonRWRvdCcsJ1xcdTAxMTknOidlb2dvbicsJ1xcdTAxMTgnOidFb2dvbicsJ1xcdTAxMTMnOidlbWFjcicsJ1xcdTAxMTInOidFbWFjcicsJ1xcdUQ4MzVcXHVERDIzJzonZmZyJywnXFx1RDgzNVxcdURENTcnOidmb3BmJywnXFx1RDgzNVxcdURDQkInOidmc2NyJywnXFx1RDgzNVxcdUREMDknOidGZnInLCdcXHVEODM1XFx1REQzRCc6J0ZvcGYnLCdcXHUyMTMxJzonRnNjcicsJ1xcdUZCMDAnOidmZmxpZycsJ1xcdUZCMDMnOidmZmlsaWcnLCdcXHVGQjA0JzonZmZsbGlnJywnXFx1RkIwMSc6J2ZpbGlnJywnZmonOidmamxpZycsJ1xcdUZCMDInOidmbGxpZycsJ1xcdTAxOTInOidmbm9mJywnXFx1MjEwQSc6J2dzY3InLCdcXHVEODM1XFx1REQ1OCc6J2dvcGYnLCdcXHVEODM1XFx1REQyNCc6J2dmcicsJ1xcdUQ4MzVcXHVEQ0EyJzonR3NjcicsJ1xcdUQ4MzVcXHVERDNFJzonR29wZicsJ1xcdUQ4MzVcXHVERDBBJzonR2ZyJywnXFx1MDFGNSc6J2dhY3V0ZScsJ1xcdTAxMUYnOidnYnJldmUnLCdcXHUwMTFFJzonR2JyZXZlJywnXFx1MDExRCc6J2djaXJjJywnXFx1MDExQyc6J0djaXJjJywnXFx1MDEyMSc6J2dkb3QnLCdcXHUwMTIwJzonR2RvdCcsJ1xcdTAxMjInOidHY2VkaWwnLCdcXHVEODM1XFx1REQyNSc6J2hmcicsJ1xcdTIxMEUnOidwbGFuY2toJywnXFx1RDgzNVxcdURDQkQnOidoc2NyJywnXFx1RDgzNVxcdURENTknOidob3BmJywnXFx1MjEwQic6J0hzY3InLCdcXHUyMTBDJzonSGZyJywnXFx1MjEwRCc6J0hvcGYnLCdcXHUwMTI1JzonaGNpcmMnLCdcXHUwMTI0JzonSGNpcmMnLCdcXHUyMTBGJzonaGJhcicsJ1xcdTAxMjcnOidoc3Ryb2snLCdcXHUwMTI2JzonSHN0cm9rJywnXFx1RDgzNVxcdURENUEnOidpb3BmJywnXFx1RDgzNVxcdUREMjYnOidpZnInLCdcXHVEODM1XFx1RENCRSc6J2lzY3InLCdcXHUyMTQ4JzonaWknLCdcXHVEODM1XFx1REQ0MCc6J0lvcGYnLCdcXHUyMTEwJzonSXNjcicsJ1xcdTIxMTEnOidJbScsJ1xceEVEJzonaWFjdXRlJywnXFx4Q0QnOidJYWN1dGUnLCdcXHhFQyc6J2lncmF2ZScsJ1xceENDJzonSWdyYXZlJywnXFx4RUUnOidpY2lyYycsJ1xceENFJzonSWNpcmMnLCdcXHhFRic6J2l1bWwnLCdcXHhDRic6J0l1bWwnLCdcXHUwMTI5JzonaXRpbGRlJywnXFx1MDEyOCc6J0l0aWxkZScsJ1xcdTAxMzAnOidJZG90JywnXFx1MDEyRic6J2lvZ29uJywnXFx1MDEyRSc6J0lvZ29uJywnXFx1MDEyQic6J2ltYWNyJywnXFx1MDEyQSc6J0ltYWNyJywnXFx1MDEzMyc6J2lqbGlnJywnXFx1MDEzMic6J0lKbGlnJywnXFx1MDEzMSc6J2ltYXRoJywnXFx1RDgzNVxcdURDQkYnOidqc2NyJywnXFx1RDgzNVxcdURENUInOidqb3BmJywnXFx1RDgzNVxcdUREMjcnOidqZnInLCdcXHVEODM1XFx1RENBNSc6J0pzY3InLCdcXHVEODM1XFx1REQwRCc6J0pmcicsJ1xcdUQ4MzVcXHVERDQxJzonSm9wZicsJ1xcdTAxMzUnOidqY2lyYycsJ1xcdTAxMzQnOidKY2lyYycsJ1xcdTAyMzcnOidqbWF0aCcsJ1xcdUQ4MzVcXHVERDVDJzona29wZicsJ1xcdUQ4MzVcXHVEQ0MwJzona3NjcicsJ1xcdUQ4MzVcXHVERDI4Jzona2ZyJywnXFx1RDgzNVxcdURDQTYnOidLc2NyJywnXFx1RDgzNVxcdURENDInOidLb3BmJywnXFx1RDgzNVxcdUREMEUnOidLZnInLCdcXHUwMTM3Jzona2NlZGlsJywnXFx1MDEzNic6J0tjZWRpbCcsJ1xcdUQ4MzVcXHVERDI5JzonbGZyJywnXFx1RDgzNVxcdURDQzEnOidsc2NyJywnXFx1MjExMyc6J2VsbCcsJ1xcdUQ4MzVcXHVERDVEJzonbG9wZicsJ1xcdTIxMTInOidMc2NyJywnXFx1RDgzNVxcdUREMEYnOidMZnInLCdcXHVEODM1XFx1REQ0Myc6J0xvcGYnLCdcXHUwMTNBJzonbGFjdXRlJywnXFx1MDEzOSc6J0xhY3V0ZScsJ1xcdTAxM0UnOidsY2Fyb24nLCdcXHUwMTNEJzonTGNhcm9uJywnXFx1MDEzQyc6J2xjZWRpbCcsJ1xcdTAxM0InOidMY2VkaWwnLCdcXHUwMTQyJzonbHN0cm9rJywnXFx1MDE0MSc6J0xzdHJvaycsJ1xcdTAxNDAnOidsbWlkb3QnLCdcXHUwMTNGJzonTG1pZG90JywnXFx1RDgzNVxcdUREMkEnOidtZnInLCdcXHVEODM1XFx1REQ1RSc6J21vcGYnLCdcXHVEODM1XFx1RENDMic6J21zY3InLCdcXHVEODM1XFx1REQxMCc6J01mcicsJ1xcdUQ4MzVcXHVERDQ0JzonTW9wZicsJ1xcdTIxMzMnOidNc2NyJywnXFx1RDgzNVxcdUREMkInOiduZnInLCdcXHVEODM1XFx1REQ1Ric6J25vcGYnLCdcXHVEODM1XFx1RENDMyc6J25zY3InLCdcXHUyMTE1JzonTm9wZicsJ1xcdUQ4MzVcXHVEQ0E5JzonTnNjcicsJ1xcdUQ4MzVcXHVERDExJzonTmZyJywnXFx1MDE0NCc6J25hY3V0ZScsJ1xcdTAxNDMnOidOYWN1dGUnLCdcXHUwMTQ4JzonbmNhcm9uJywnXFx1MDE0Nyc6J05jYXJvbicsJ1xceEYxJzonbnRpbGRlJywnXFx4RDEnOidOdGlsZGUnLCdcXHUwMTQ2JzonbmNlZGlsJywnXFx1MDE0NSc6J05jZWRpbCcsJ1xcdTIxMTYnOidudW1lcm8nLCdcXHUwMTRCJzonZW5nJywnXFx1MDE0QSc6J0VORycsJ1xcdUQ4MzVcXHVERDYwJzonb29wZicsJ1xcdUQ4MzVcXHVERDJDJzonb2ZyJywnXFx1MjEzNCc6J29zY3InLCdcXHVEODM1XFx1RENBQSc6J09zY3InLCdcXHVEODM1XFx1REQxMic6J09mcicsJ1xcdUQ4MzVcXHVERDQ2JzonT29wZicsJ1xceEJBJzonb3JkbScsJ1xceEYzJzonb2FjdXRlJywnXFx4RDMnOidPYWN1dGUnLCdcXHhGMic6J29ncmF2ZScsJ1xceEQyJzonT2dyYXZlJywnXFx4RjQnOidvY2lyYycsJ1xceEQ0JzonT2NpcmMnLCdcXHhGNic6J291bWwnLCdcXHhENic6J091bWwnLCdcXHUwMTUxJzonb2RibGFjJywnXFx1MDE1MCc6J09kYmxhYycsJ1xceEY1Jzonb3RpbGRlJywnXFx4RDUnOidPdGlsZGUnLCdcXHhGOCc6J29zbGFzaCcsJ1xceEQ4JzonT3NsYXNoJywnXFx1MDE0RCc6J29tYWNyJywnXFx1MDE0Qyc6J09tYWNyJywnXFx1MDE1Myc6J29lbGlnJywnXFx1MDE1Mic6J09FbGlnJywnXFx1RDgzNVxcdUREMkQnOidwZnInLCdcXHVEODM1XFx1RENDNSc6J3BzY3InLCdcXHVEODM1XFx1REQ2MSc6J3BvcGYnLCdcXHUyMTE5JzonUG9wZicsJ1xcdUQ4MzVcXHVERDEzJzonUGZyJywnXFx1RDgzNVxcdURDQUInOidQc2NyJywnXFx1RDgzNVxcdURENjInOidxb3BmJywnXFx1RDgzNVxcdUREMkUnOidxZnInLCdcXHVEODM1XFx1RENDNic6J3FzY3InLCdcXHVEODM1XFx1RENBQyc6J1FzY3InLCdcXHVEODM1XFx1REQxNCc6J1FmcicsJ1xcdTIxMUEnOidRb3BmJywnXFx1MDEzOCc6J2tncmVlbicsJ1xcdUQ4MzVcXHVERDJGJzoncmZyJywnXFx1RDgzNVxcdURENjMnOidyb3BmJywnXFx1RDgzNVxcdURDQzcnOidyc2NyJywnXFx1MjExQic6J1JzY3InLCdcXHUyMTFDJzonUmUnLCdcXHUyMTFEJzonUm9wZicsJ1xcdTAxNTUnOidyYWN1dGUnLCdcXHUwMTU0JzonUmFjdXRlJywnXFx1MDE1OSc6J3JjYXJvbicsJ1xcdTAxNTgnOidSY2Fyb24nLCdcXHUwMTU3JzoncmNlZGlsJywnXFx1MDE1Nic6J1JjZWRpbCcsJ1xcdUQ4MzVcXHVERDY0Jzonc29wZicsJ1xcdUQ4MzVcXHVEQ0M4Jzonc3NjcicsJ1xcdUQ4MzVcXHVERDMwJzonc2ZyJywnXFx1RDgzNVxcdURENEEnOidTb3BmJywnXFx1RDgzNVxcdUREMTYnOidTZnInLCdcXHVEODM1XFx1RENBRSc6J1NzY3InLCdcXHUyNEM4Jzonb1MnLCdcXHUwMTVCJzonc2FjdXRlJywnXFx1MDE1QSc6J1NhY3V0ZScsJ1xcdTAxNUQnOidzY2lyYycsJ1xcdTAxNUMnOidTY2lyYycsJ1xcdTAxNjEnOidzY2Fyb24nLCdcXHUwMTYwJzonU2Nhcm9uJywnXFx1MDE1Ric6J3NjZWRpbCcsJ1xcdTAxNUUnOidTY2VkaWwnLCdcXHhERic6J3N6bGlnJywnXFx1RDgzNVxcdUREMzEnOid0ZnInLCdcXHVEODM1XFx1RENDOSc6J3RzY3InLCdcXHVEODM1XFx1REQ2NSc6J3RvcGYnLCdcXHVEODM1XFx1RENBRic6J1RzY3InLCdcXHVEODM1XFx1REQxNyc6J1RmcicsJ1xcdUQ4MzVcXHVERDRCJzonVG9wZicsJ1xcdTAxNjUnOid0Y2Fyb24nLCdcXHUwMTY0JzonVGNhcm9uJywnXFx1MDE2Myc6J3RjZWRpbCcsJ1xcdTAxNjInOidUY2VkaWwnLCdcXHUyMTIyJzondHJhZGUnLCdcXHUwMTY3JzondHN0cm9rJywnXFx1MDE2Nic6J1RzdHJvaycsJ1xcdUQ4MzVcXHVEQ0NBJzondXNjcicsJ1xcdUQ4MzVcXHVERDY2JzondW9wZicsJ1xcdUQ4MzVcXHVERDMyJzondWZyJywnXFx1RDgzNVxcdURENEMnOidVb3BmJywnXFx1RDgzNVxcdUREMTgnOidVZnInLCdcXHVEODM1XFx1RENCMCc6J1VzY3InLCdcXHhGQSc6J3VhY3V0ZScsJ1xceERBJzonVWFjdXRlJywnXFx4RjknOid1Z3JhdmUnLCdcXHhEOSc6J1VncmF2ZScsJ1xcdTAxNkQnOid1YnJldmUnLCdcXHUwMTZDJzonVWJyZXZlJywnXFx4RkInOid1Y2lyYycsJ1xceERCJzonVWNpcmMnLCdcXHUwMTZGJzondXJpbmcnLCdcXHUwMTZFJzonVXJpbmcnLCdcXHhGQyc6J3V1bWwnLCdcXHhEQyc6J1V1bWwnLCdcXHUwMTcxJzondWRibGFjJywnXFx1MDE3MCc6J1VkYmxhYycsJ1xcdTAxNjknOid1dGlsZGUnLCdcXHUwMTY4JzonVXRpbGRlJywnXFx1MDE3Myc6J3VvZ29uJywnXFx1MDE3Mic6J1VvZ29uJywnXFx1MDE2Qic6J3VtYWNyJywnXFx1MDE2QSc6J1VtYWNyJywnXFx1RDgzNVxcdUREMzMnOid2ZnInLCdcXHVEODM1XFx1REQ2Nyc6J3ZvcGYnLCdcXHVEODM1XFx1RENDQic6J3ZzY3InLCdcXHVEODM1XFx1REQxOSc6J1ZmcicsJ1xcdUQ4MzVcXHVERDREJzonVm9wZicsJ1xcdUQ4MzVcXHVEQ0IxJzonVnNjcicsJ1xcdUQ4MzVcXHVERDY4Jzond29wZicsJ1xcdUQ4MzVcXHVEQ0NDJzond3NjcicsJ1xcdUQ4MzVcXHVERDM0Jzond2ZyJywnXFx1RDgzNVxcdURDQjInOidXc2NyJywnXFx1RDgzNVxcdURENEUnOidXb3BmJywnXFx1RDgzNVxcdUREMUEnOidXZnInLCdcXHUwMTc1Jzond2NpcmMnLCdcXHUwMTc0JzonV2NpcmMnLCdcXHVEODM1XFx1REQzNSc6J3hmcicsJ1xcdUQ4MzVcXHVEQ0NEJzoneHNjcicsJ1xcdUQ4MzVcXHVERDY5JzoneG9wZicsJ1xcdUQ4MzVcXHVERDRGJzonWG9wZicsJ1xcdUQ4MzVcXHVERDFCJzonWGZyJywnXFx1RDgzNVxcdURDQjMnOidYc2NyJywnXFx1RDgzNVxcdUREMzYnOid5ZnInLCdcXHVEODM1XFx1RENDRSc6J3lzY3InLCdcXHVEODM1XFx1REQ2QSc6J3lvcGYnLCdcXHVEODM1XFx1RENCNCc6J1lzY3InLCdcXHVEODM1XFx1REQxQyc6J1lmcicsJ1xcdUQ4MzVcXHVERDUwJzonWW9wZicsJ1xceEZEJzoneWFjdXRlJywnXFx4REQnOidZYWN1dGUnLCdcXHUwMTc3JzoneWNpcmMnLCdcXHUwMTc2JzonWWNpcmMnLCdcXHhGRic6J3l1bWwnLCdcXHUwMTc4JzonWXVtbCcsJ1xcdUQ4MzVcXHVEQ0NGJzonenNjcicsJ1xcdUQ4MzVcXHVERDM3JzonemZyJywnXFx1RDgzNVxcdURENkInOid6b3BmJywnXFx1MjEyOCc6J1pmcicsJ1xcdTIxMjQnOidab3BmJywnXFx1RDgzNVxcdURDQjUnOidac2NyJywnXFx1MDE3QSc6J3phY3V0ZScsJ1xcdTAxNzknOidaYWN1dGUnLCdcXHUwMTdFJzonemNhcm9uJywnXFx1MDE3RCc6J1pjYXJvbicsJ1xcdTAxN0MnOid6ZG90JywnXFx1MDE3Qic6J1pkb3QnLCdcXHUwMUI1JzonaW1wZWQnLCdcXHhGRSc6J3Rob3JuJywnXFx4REUnOidUSE9STicsJ1xcdTAxNDknOiduYXBvcycsJ1xcdTAzQjEnOidhbHBoYScsJ1xcdTAzOTEnOidBbHBoYScsJ1xcdTAzQjInOidiZXRhJywnXFx1MDM5Mic6J0JldGEnLCdcXHUwM0IzJzonZ2FtbWEnLCdcXHUwMzkzJzonR2FtbWEnLCdcXHUwM0I0JzonZGVsdGEnLCdcXHUwMzk0JzonRGVsdGEnLCdcXHUwM0I1JzonZXBzaScsJ1xcdTAzRjUnOidlcHNpdicsJ1xcdTAzOTUnOidFcHNpbG9uJywnXFx1MDNERCc6J2dhbW1hZCcsJ1xcdTAzREMnOidHYW1tYWQnLCdcXHUwM0I2JzonemV0YScsJ1xcdTAzOTYnOidaZXRhJywnXFx1MDNCNyc6J2V0YScsJ1xcdTAzOTcnOidFdGEnLCdcXHUwM0I4JzondGhldGEnLCdcXHUwM0QxJzondGhldGF2JywnXFx1MDM5OCc6J1RoZXRhJywnXFx1MDNCOSc6J2lvdGEnLCdcXHUwMzk5JzonSW90YScsJ1xcdTAzQkEnOidrYXBwYScsJ1xcdTAzRjAnOidrYXBwYXYnLCdcXHUwMzlBJzonS2FwcGEnLCdcXHUwM0JCJzonbGFtYmRhJywnXFx1MDM5Qic6J0xhbWJkYScsJ1xcdTAzQkMnOidtdScsJ1xceEI1JzonbWljcm8nLCdcXHUwMzlDJzonTXUnLCdcXHUwM0JEJzonbnUnLCdcXHUwMzlEJzonTnUnLCdcXHUwM0JFJzoneGknLCdcXHUwMzlFJzonWGknLCdcXHUwM0JGJzonb21pY3JvbicsJ1xcdTAzOUYnOidPbWljcm9uJywnXFx1MDNDMCc6J3BpJywnXFx1MDNENic6J3BpdicsJ1xcdTAzQTAnOidQaScsJ1xcdTAzQzEnOidyaG8nLCdcXHUwM0YxJzoncmhvdicsJ1xcdTAzQTEnOidSaG8nLCdcXHUwM0MzJzonc2lnbWEnLCdcXHUwM0EzJzonU2lnbWEnLCdcXHUwM0MyJzonc2lnbWFmJywnXFx1MDNDNCc6J3RhdScsJ1xcdTAzQTQnOidUYXUnLCdcXHUwM0M1JzondXBzaScsJ1xcdTAzQTUnOidVcHNpbG9uJywnXFx1MDNEMic6J1Vwc2knLCdcXHUwM0M2JzoncGhpJywnXFx1MDNENSc6J3BoaXYnLCdcXHUwM0E2JzonUGhpJywnXFx1MDNDNyc6J2NoaScsJ1xcdTAzQTcnOidDaGknLCdcXHUwM0M4JzoncHNpJywnXFx1MDNBOCc6J1BzaScsJ1xcdTAzQzknOidvbWVnYScsJ1xcdTAzQTknOidvaG0nLCdcXHUwNDMwJzonYWN5JywnXFx1MDQxMCc6J0FjeScsJ1xcdTA0MzEnOidiY3knLCdcXHUwNDExJzonQmN5JywnXFx1MDQzMic6J3ZjeScsJ1xcdTA0MTInOidWY3knLCdcXHUwNDMzJzonZ2N5JywnXFx1MDQxMyc6J0djeScsJ1xcdTA0NTMnOidnamN5JywnXFx1MDQwMyc6J0dKY3knLCdcXHUwNDM0JzonZGN5JywnXFx1MDQxNCc6J0RjeScsJ1xcdTA0NTInOidkamN5JywnXFx1MDQwMic6J0RKY3knLCdcXHUwNDM1JzonaWVjeScsJ1xcdTA0MTUnOidJRWN5JywnXFx1MDQ1MSc6J2lvY3knLCdcXHUwNDAxJzonSU9jeScsJ1xcdTA0NTQnOidqdWtjeScsJ1xcdTA0MDQnOidKdWtjeScsJ1xcdTA0MzYnOid6aGN5JywnXFx1MDQxNic6J1pIY3knLCdcXHUwNDM3JzonemN5JywnXFx1MDQxNyc6J1pjeScsJ1xcdTA0NTUnOidkc2N5JywnXFx1MDQwNSc6J0RTY3knLCdcXHUwNDM4JzonaWN5JywnXFx1MDQxOCc6J0ljeScsJ1xcdTA0NTYnOidpdWtjeScsJ1xcdTA0MDYnOidJdWtjeScsJ1xcdTA0NTcnOid5aWN5JywnXFx1MDQwNyc6J1lJY3knLCdcXHUwNDM5JzonamN5JywnXFx1MDQxOSc6J0pjeScsJ1xcdTA0NTgnOidqc2VyY3knLCdcXHUwNDA4JzonSnNlcmN5JywnXFx1MDQzQSc6J2tjeScsJ1xcdTA0MUEnOidLY3knLCdcXHUwNDVDJzona2pjeScsJ1xcdTA0MEMnOidLSmN5JywnXFx1MDQzQic6J2xjeScsJ1xcdTA0MUInOidMY3knLCdcXHUwNDU5JzonbGpjeScsJ1xcdTA0MDknOidMSmN5JywnXFx1MDQzQyc6J21jeScsJ1xcdTA0MUMnOidNY3knLCdcXHUwNDNEJzonbmN5JywnXFx1MDQxRCc6J05jeScsJ1xcdTA0NUEnOiduamN5JywnXFx1MDQwQSc6J05KY3knLCdcXHUwNDNFJzonb2N5JywnXFx1MDQxRSc6J09jeScsJ1xcdTA0M0YnOidwY3knLCdcXHUwNDFGJzonUGN5JywnXFx1MDQ0MCc6J3JjeScsJ1xcdTA0MjAnOidSY3knLCdcXHUwNDQxJzonc2N5JywnXFx1MDQyMSc6J1NjeScsJ1xcdTA0NDInOid0Y3knLCdcXHUwNDIyJzonVGN5JywnXFx1MDQ1Qic6J3RzaGN5JywnXFx1MDQwQic6J1RTSGN5JywnXFx1MDQ0Myc6J3VjeScsJ1xcdTA0MjMnOidVY3knLCdcXHUwNDVFJzondWJyY3knLCdcXHUwNDBFJzonVWJyY3knLCdcXHUwNDQ0JzonZmN5JywnXFx1MDQyNCc6J0ZjeScsJ1xcdTA0NDUnOidraGN5JywnXFx1MDQyNSc6J0tIY3knLCdcXHUwNDQ2JzondHNjeScsJ1xcdTA0MjYnOidUU2N5JywnXFx1MDQ0Nyc6J2NoY3knLCdcXHUwNDI3JzonQ0hjeScsJ1xcdTA0NUYnOidkemN5JywnXFx1MDQwRic6J0RaY3knLCdcXHUwNDQ4Jzonc2hjeScsJ1xcdTA0MjgnOidTSGN5JywnXFx1MDQ0OSc6J3NoY2hjeScsJ1xcdTA0MjknOidTSENIY3knLCdcXHUwNDRBJzonaGFyZGN5JywnXFx1MDQyQSc6J0hBUkRjeScsJ1xcdTA0NEInOid5Y3knLCdcXHUwNDJCJzonWWN5JywnXFx1MDQ0Qyc6J3NvZnRjeScsJ1xcdTA0MkMnOidTT0ZUY3knLCdcXHUwNDREJzonZWN5JywnXFx1MDQyRCc6J0VjeScsJ1xcdTA0NEUnOid5dWN5JywnXFx1MDQyRSc6J1lVY3knLCdcXHUwNDRGJzoneWFjeScsJ1xcdTA0MkYnOidZQWN5JywnXFx1MjEzNSc6J2FsZXBoJywnXFx1MjEzNic6J2JldGgnLCdcXHUyMTM3JzonZ2ltZWwnLCdcXHUyMTM4JzonZGFsZXRoJ307XG5cblx0dmFyIHJlZ2V4RXNjYXBlID0gL1tcIiYnPD5gXS9nO1xuXHR2YXIgZXNjYXBlTWFwID0ge1xuXHRcdCdcIic6ICcmcXVvdDsnLFxuXHRcdCcmJzogJyZhbXA7Jyxcblx0XHQnXFwnJzogJyYjeDI3OycsXG5cdFx0JzwnOiAnJmx0OycsXG5cdFx0Ly8gU2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kczogaW4gSFRNTCwgdGhlXG5cdFx0Ly8gZm9sbG93aW5nIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgdW5sZXNzIGl04oCZcyBwYXJ0IG9mIGEgdGFnIG9yIGFuXG5cdFx0Ly8gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBXZeKAmXJlIG9ubHkgZXNjYXBpbmcgaXQgdG8gc3VwcG9ydCB0aG9zZVxuXHRcdC8vIHNpdHVhdGlvbnMsIGFuZCBmb3IgWE1MIHN1cHBvcnQuXG5cdFx0Jz4nOiAnJmd0OycsXG5cdFx0Ly8gSW4gSW50ZXJuZXQgRXhwbG9yZXIg4omkIDgsIHRoZSBiYWNrdGljayBjaGFyYWN0ZXIgY2FuIGJlIHVzZWRcblx0XHQvLyB0byBicmVhayBvdXQgb2YgKHVuKXF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuXG5cdFx0Ly8gU2VlIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwMiwgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTA4LCBhbmRcblx0XHQvLyBodHRwOi8vaHRtbDVzZWMub3JnLyMxMzMuXG5cdFx0J2AnOiAnJiN4NjA7J1xuXHR9O1xuXG5cdHZhciByZWdleEludmFsaWRFbnRpdHkgPSAvJiMoPzpbeFhdW15hLWZBLUYwLTldfFteMC05eFhdKS87XG5cdHZhciByZWdleEludmFsaWRSYXdDb2RlUG9pbnQgPSAvW1xcMC1cXHgwOFxceDBCXFx4MEUtXFx4MUZcXHg3Ri1cXHg5RlxcdUZERDAtXFx1RkRFRlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgzRlxcdUQ4N0ZcXHVEOEJGXFx1RDhGRlxcdUQ5M0ZcXHVEOTdGXFx1RDlCRlxcdUQ5RkZcXHVEQTNGXFx1REE3RlxcdURBQkZcXHVEQUZGXFx1REIzRlxcdURCN0ZcXHVEQkJGXFx1REJGRl1bXFx1REZGRVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcblx0dmFyIHJlZ2V4RGVjb2RlID0gLyYoQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbHxEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3d8Q2xvY2t3aXNlQ29udG91ckludGVncmFsfE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyfE5vdFNxdWFyZVN1cGVyc2V0RXF1YWx8RGlhY3JpdGljYWxEb3VibGVBY3V0ZXxOb3RSaWdodFRyaWFuZ2xlRXF1YWx8Tm90U3VjY2VlZHNTbGFudEVxdWFsfE5vdFByZWNlZGVzU2xhbnRFcXVhbHxDbG9zZUN1cmx5RG91YmxlUXVvdGV8TmVnYXRpdmVWZXJ5VGhpblNwYWNlfERvdWJsZUNvbnRvdXJJbnRlZ3JhbHxGaWxsZWRWZXJ5U21hbGxTcXVhcmV8Q2FwaXRhbERpZmZlcmVudGlhbER8T3BlbkN1cmx5RG91YmxlUXVvdGV8RW1wdHlWZXJ5U21hbGxTcXVhcmV8TmVzdGVkR3JlYXRlckdyZWF0ZXJ8RG91YmxlTG9uZ1JpZ2h0QXJyb3d8Tm90TGVmdFRyaWFuZ2xlRXF1YWx8Tm90R3JlYXRlclNsYW50RXF1YWx8UmV2ZXJzZVVwRXF1aWxpYnJpdW18RG91YmxlTGVmdFJpZ2h0QXJyb3d8Tm90U3F1YXJlU3Vic2V0RXF1YWx8Tm90RG91YmxlVmVydGljYWxCYXJ8UmlnaHRBcnJvd0xlZnRBcnJvd3xOb3RHcmVhdGVyRnVsbEVxdWFsfE5vdFJpZ2h0VHJpYW5nbGVCYXJ8U3F1YXJlU3VwZXJzZXRFcXVhbHxEb3duTGVmdFJpZ2h0VmVjdG9yfERvdWJsZUxvbmdMZWZ0QXJyb3d8bGVmdHJpZ2h0c3F1aWdhcnJvd3xMZWZ0QXJyb3dSaWdodEFycm93fE5lZ2F0aXZlTWVkaXVtU3BhY2V8YmxhY2t0cmlhbmdsZXJpZ2h0fFJpZ2h0RG93blZlY3RvckJhcnxQcmVjZWRlc1NsYW50RXF1YWx8UmlnaHREb3VibGVCcmFja2V0fFN1Y2NlZWRzU2xhbnRFcXVhbHxOb3RMZWZ0VHJpYW5nbGVCYXJ8UmlnaHRUcmlhbmdsZUVxdWFsfFNxdWFyZUludGVyc2VjdGlvbnxSaWdodERvd25UZWVWZWN0b3J8UmV2ZXJzZUVxdWlsaWJyaXVtfE5lZ2F0aXZlVGhpY2tTcGFjZXxsb25nbGVmdHJpZ2h0YXJyb3d8TG9uZ2xlZnRyaWdodGFycm93fExvbmdMZWZ0UmlnaHRBcnJvd3xEb3duUmlnaHRUZWVWZWN0b3J8RG93blJpZ2h0VmVjdG9yQmFyfEdyZWF0ZXJTbGFudEVxdWFsfFNxdWFyZVN1YnNldEVxdWFsfExlZnREb3duVmVjdG9yQmFyfExlZnREb3VibGVCcmFja2V0fFZlcnRpY2FsU2VwYXJhdG9yfHJpZ2h0bGVmdGhhcnBvb25zfE5vdEdyZWF0ZXJHcmVhdGVyfE5vdFNxdWFyZVN1cGVyc2V0fGJsYWNrdHJpYW5nbGVsZWZ0fGJsYWNrdHJpYW5nbGVkb3dufE5lZ2F0aXZlVGhpblNwYWNlfExlZnREb3duVGVlVmVjdG9yfE5vdExlc3NTbGFudEVxdWFsfGxlZnRyaWdodGhhcnBvb25zfERvdWJsZVVwRG93bkFycm93fERvdWJsZVZlcnRpY2FsQmFyfExlZnRUcmlhbmdsZUVxdWFsfEZpbGxlZFNtYWxsU3F1YXJlfHR3b2hlYWRyaWdodGFycm93fE5vdE5lc3RlZExlc3NMZXNzfERvd25MZWZ0VGVlVmVjdG9yfERvd25MZWZ0VmVjdG9yQmFyfFJpZ2h0QW5nbGVCcmFja2V0fE5vdFRpbGRlRnVsbEVxdWFsfE5vdFJldmVyc2VFbGVtZW50fFJpZ2h0VXBEb3duVmVjdG9yfERpYWNyaXRpY2FsVGlsZGV8Tm90U3VjY2VlZHNUaWxkZXxjaXJjbGVhcnJvd3JpZ2h0fE5vdFByZWNlZGVzRXF1YWx8cmlnaHRoYXJwb29uZG93bnxEb3VibGVSaWdodEFycm93fE5vdFN1Y2NlZWRzRXF1YWx8Tm9uQnJlYWtpbmdTcGFjZXxOb3RSaWdodFRyaWFuZ2xlfExlc3NFcXVhbEdyZWF0ZXJ8UmlnaHRVcFRlZVZlY3RvcnxMZWZ0QW5nbGVCcmFja2V0fEdyZWF0ZXJGdWxsRXF1YWx8RG93bkFycm93VXBBcnJvd3xSaWdodFVwVmVjdG9yQmFyfHR3b2hlYWRsZWZ0YXJyb3d8R3JlYXRlckVxdWFsTGVzc3xkb3duaGFycG9vbnJpZ2h0fFJpZ2h0VHJpYW5nbGVCYXJ8bnRyaWFuZ2xlcmlnaHRlcXxOb3RTdXBlcnNldEVxdWFsfExlZnRVcERvd25WZWN0b3J8RGlhY3JpdGljYWxBY3V0ZXxyaWdodHJpZ2h0YXJyb3dzfHZhcnRyaWFuZ2xlcmlnaHR8VXBBcnJvd0Rvd25BcnJvd3xEaWFjcml0aWNhbEdyYXZlfFVuZGVyUGFyZW50aGVzaXN8RW1wdHlTbWFsbFNxdWFyZXxMZWZ0VXBWZWN0b3JCYXJ8bGVmdHJpZ2h0YXJyb3dzfERvd25SaWdodFZlY3Rvcnxkb3duaGFycG9vbmxlZnR8dHJpYW5nbGVyaWdodGVxfFNob3J0UmlnaHRBcnJvd3xPdmVyUGFyZW50aGVzaXN8RG91YmxlTGVmdEFycm93fERvdWJsZURvd25BcnJvd3xOb3RTcXVhcmVTdWJzZXR8YmlndHJpYW5nbGVkb3dufG50cmlhbmdsZWxlZnRlcXxVcHBlclJpZ2h0QXJyb3d8Y3VydmVhcnJvd3JpZ2h0fHZhcnRyaWFuZ2xlbGVmdHxOb3RMZWZ0VHJpYW5nbGV8bmxlZnRyaWdodGFycm93fExvd2VyUmlnaHRBcnJvd3xOb3RIdW1wRG93bkh1bXB8Tm90R3JlYXRlclRpbGRlfHJpZ2h0dGhyZWV0aW1lc3xMZWZ0VXBUZWVWZWN0b3J8Tm90R3JlYXRlckVxdWFsfHN0cmFpZ2h0ZXBzaWxvbnxMZWZ0VHJpYW5nbGVCYXJ8cmlnaHRzcXVpZ2Fycm93fENvbnRvdXJJbnRlZ3JhbHxyaWdodGxlZnRhcnJvd3N8Q2xvc2VDdXJseVF1b3RlfFJpZ2h0RG93blZlY3RvcnxMZWZ0UmlnaHRWZWN0b3J8bkxlZnRyaWdodGFycm93fGxlZnRoYXJwb29uZG93bnxjaXJjbGVhcnJvd2xlZnR8U3F1YXJlU3VwZXJzZXR8T3BlbkN1cmx5UXVvdGV8aG9va3JpZ2h0YXJyb3d8SG9yaXpvbnRhbExpbmV8RGlhY3JpdGljYWxEb3R8Tm90TGVzc0dyZWF0ZXJ8bnRyaWFuZ2xlcmlnaHR8RG91YmxlUmlnaHRUZWV8SW52aXNpYmxlQ29tbWF8SW52aXNpYmxlVGltZXN8TG93ZXJMZWZ0QXJyb3d8RG93bkxlZnRWZWN0b3J8Tm90U3Vic2V0RXF1YWx8Y3VydmVhcnJvd2xlZnR8dHJpYW5nbGVsZWZ0ZXF8Tm90VmVydGljYWxCYXJ8VGlsZGVGdWxsRXF1YWx8ZG93bmRvd25hcnJvd3N8Tm90R3JlYXRlckxlc3N8UmlnaHRUZWVWZWN0b3J8WmVyb1dpZHRoU3BhY2V8bG9vcGFycm93cmlnaHR8TG9uZ1JpZ2h0QXJyb3d8ZG91YmxlYmFyd2VkZ2V8U2hvcnRMZWZ0QXJyb3d8U2hvcnREb3duQXJyb3d8UmlnaHRWZWN0b3JCYXJ8R3JlYXRlckdyZWF0ZXJ8UmV2ZXJzZUVsZW1lbnR8cmlnaHRoYXJwb29udXB8TGVzc1NsYW50RXF1YWx8bGVmdHRocmVldGltZXN8dXBoYXJwb29ucmlnaHR8cmlnaHRhcnJvd3RhaWx8TGVmdERvd25WZWN0b3J8TG9uZ3JpZ2h0YXJyb3d8TmVzdGVkTGVzc0xlc3N8VXBwZXJMZWZ0QXJyb3d8bnNob3J0cGFyYWxsZWx8bGVmdGxlZnRhcnJvd3N8bGVmdHJpZ2h0YXJyb3d8TGVmdHJpZ2h0YXJyb3d8TGVmdFJpZ2h0QXJyb3d8bG9uZ3JpZ2h0YXJyb3d8dXBoYXJwb29ubGVmdHxSaWdodEFycm93QmFyfEFwcGx5RnVuY3Rpb258TGVmdFRlZVZlY3RvcnxsZWZ0YXJyb3d0YWlsfE5vdEVxdWFsVGlsZGV8dmFyc3Vic2V0bmVxcXx2YXJzdXBzZXRuZXFxfFJpZ2h0VGVlQXJyb3d8U3VjY2VlZHNFcXVhbHxTdWNjZWVkc1RpbGRlfExlZnRWZWN0b3JCYXJ8U3VwZXJzZXRFcXVhbHxob29rbGVmdGFycm93fERpZmZlcmVudGlhbER8VmVydGljYWxUaWxkZXxWZXJ5VGhpblNwYWNlfGJsYWNrdHJpYW5nbGV8YmlndHJpYW5nbGV1cHxMZXNzRnVsbEVxdWFsfGRpdmlkZW9udGltZXN8bGVmdGhhcnBvb251cHxVcEVxdWlsaWJyaXVtfG50cmlhbmdsZWxlZnR8UmlnaHRUcmlhbmdsZXxtZWFzdXJlZGFuZ2xlfHNob3J0cGFyYWxsZWx8bG9uZ2xlZnRhcnJvd3xMb25nbGVmdGFycm93fExvbmdMZWZ0QXJyb3d8RG91YmxlTGVmdFRlZXxQb2luY2FyZXBsYW5lfFByZWNlZGVzRXF1YWx8dHJpYW5nbGVyaWdodHxEb3VibGVVcEFycm93fFJpZ2h0VXBWZWN0b3J8ZmFsbGluZ2RvdHNlcXxsb29wYXJyb3dsZWZ0fFByZWNlZGVzVGlsZGV8Tm90VGlsZGVFcXVhbHxOb3RUaWxkZVRpbGRlfHNtYWxsc2V0bWludXN8UHJvcG9ydGlvbmFsfHRyaWFuZ2xlbGVmdHx0cmlhbmdsZWRvd258VW5kZXJCcmFja2V0fE5vdEh1bXBFcXVhbHxleHBvbmVudGlhbGV8RXhwb25lbnRpYWxFfE5vdExlc3NUaWxkZXxIaWxiZXJ0U3BhY2V8UmlnaHRDZWlsaW5nfGJsYWNrbG96ZW5nZXx2YXJzdXBzZXRuZXF8SHVtcERvd25IdW1wfEdyZWF0ZXJFcXVhbHxWZXJ0aWNhbExpbmV8TGVmdFRlZUFycm93fE5vdExlc3NFcXVhbHxEb3duVGVlQXJyb3d8TGVmdFRyaWFuZ2xlfHZhcnN1YnNldG5lcXxJbnRlcnNlY3Rpb258Tm90Q29uZ3J1ZW50fERvd25BcnJvd0JhcnxMZWZ0VXBWZWN0b3J8TGVmdEFycm93QmFyfHJpc2luZ2RvdHNlcXxHcmVhdGVyVGlsZGV8Um91bmRJbXBsaWVzfFNxdWFyZVN1YnNldHxTaG9ydFVwQXJyb3d8Tm90U3VwZXJzZXR8cXVhdGVybmlvbnN8cHJlY25hcHByb3h8YmFja2Vwc2lsb258cHJlY2N1cmx5ZXF8T3ZlckJyYWNrZXR8YmxhY2tzcXVhcmV8TWVkaXVtU3BhY2V8VmVydGljYWxCYXJ8Y2lyY2xlZGNpcmN8Y2lyY2xlZGRhc2h8Q2lyY2xlTWludXN8Q2lyY2xlVGltZXN8TGVzc0dyZWF0ZXJ8Y3VybHllcXByZWN8Y3VybHllcXN1Y2N8ZGlhbW9uZHN1aXR8VXBEb3duQXJyb3d8VXBkb3duYXJyb3d8UnVsZURlbGF5ZWR8UnJpZ2h0YXJyb3d8dXBkb3duYXJyb3d8UmlnaHRWZWN0b3J8blJpZ2h0YXJyb3d8bnJpZ2h0YXJyb3d8ZXFzbGFudGxlc3N8TGVmdENlaWxpbmd8RXF1aWxpYnJpdW18U21hbGxDaXJjbGV8ZXhwZWN0YXRpb258Tm90U3VjY2VlZHN8dGhpY2thcHByb3h8R3JlYXRlckxlc3N8U3F1YXJlVW5pb258Tm90UHJlY2VkZXN8Tm90TGVzc0xlc3N8c3RyYWlnaHRwaGl8c3VjY25hcHByb3h8c3VjY2N1cmx5ZXF8U3Vic2V0RXF1YWx8c3FzdXBzZXRlcXxQcm9wb3J0aW9ufExhcGxhY2V0cmZ8SW1hZ2luYXJ5SXxzdXBzZXRuZXFxfE5vdEdyZWF0ZXJ8Z3RyZXFxbGVzc3xOb3RFbGVtZW50fFRoaWNrU3BhY2V8VGlsZGVFcXVhbHxUaWxkZVRpbGRlfEZvdXJpZXJ0cmZ8cm1vdXN0YWNoZXxFcXVhbFRpbGRlfGVxc2xhbnRndHJ8VW5kZXJCcmFjZXxMZWZ0VmVjdG9yfFVwQXJyb3dCYXJ8bkxlZnRhcnJvd3xuc3Vic2V0ZXFxfHN1YnNldG5lcXF8bnN1cHNldGVxcXxubGVmdGFycm93fHN1Y2NhcHByb3h8bGVzc2FwcHJveHxVcFRlZUFycm93fHVwdXBhcnJvd3N8Y3VybHl3ZWRnZXxsZXNzZXFxZ3RyfHZhcmVwc2lsb258dmFybm90aGluZ3xSaWdodEZsb29yfGNvbXBsZW1lbnR8Q2lyY2xlUGx1c3xzcXN1YnNldGVxfExsZWZ0YXJyb3d8Y2lyY2xlZGFzdHxSaWdodEFycm93fFJpZ2h0YXJyb3d8cmlnaHRhcnJvd3xsbW91c3RhY2hlfEJlcm5vdWxsaXN8cHJlY2FwcHJveHxtYXBzdG9sZWZ0fG1hcHN0b2Rvd258bG9uZ21hcHN0b3xkb3RzcXVhcmV8ZG93bmFycm93fERvdWJsZURvdHxuc3Vic2V0ZXF8c3Vwc2V0bmVxfGxlZnRhcnJvd3xuc3Vwc2V0ZXF8c3Vic2V0bmVxfFRoaW5TcGFjZXxuZ2Vxc2xhbnR8c3Vic2V0ZXFxfEh1bXBFcXVhbHxOb3RTdWJzZXR8dHJpYW5nbGVxfE5vdEN1cENhcHxsZXNzZXFndHJ8aGVhcnRzdWl0fFRyaXBsZURvdHxMZWZ0YXJyb3d8Q29wcm9kdWN0fENvbmdydWVudHx2YXJwcm9wdG98Y29tcGxleGVzfGd2ZXJ0bmVxcXxMZWZ0QXJyb3d8TGVzc1RpbGRlfHN1cHNldGVxcXxNaW51c1BsdXN8Q2lyY2xlRG90fG5sZXFzbGFudHxOb3RFeGlzdHN8Z3RyZXFsZXNzfG5wYXJhbGxlbHxVbmlvblBsdXN8TGVmdEZsb29yfGNoZWNrbWFya3xDZW50ZXJEb3R8Y2VudGVyZG90fE1lbGxpbnRyZnxndHJhcHByb3h8Ymlnb3RpbWVzfE92ZXJCcmFjZXxzcGFkZXN1aXR8dGhlcmVmb3JlfHBpdGNoZm9ya3xyYXRpb25hbHN8UGx1c01pbnVzfEJhY2tzbGFzaHxUaGVyZWZvcmV8RG93bkJyZXZlfGJhY2tzaW1lcXxiYWNrcHJpbWV8RG93bkFycm93fG5zaG9ydG1pZHxEb3duYXJyb3d8bHZlcnRuZXFxfGVxdnBhcnNsfGltYWdsaW5lfGltYWdwYXJ0fGluZmludGllfGludGVnZXJzfEludGVncmFsfGludGVyY2FsfExlc3NMZXNzfFVhcnJvY2lyfGludGxhcmhrfHNxc3Vwc2V0fGFuZ21zZGFmfHNxc3Vic2V0fGxsY29ybmVyfHZhcnRoZXRhfGN1cGJyY2FwfGxuYXBwcm94fFN1cGVyc2V0fFN1Y2hUaGF0fHN1Y2Nuc2ltfHN1Y2NuZXFxfGFuZ21zZGFnfGJpZ3VwbHVzfGN1cmx5dmVlfHRycGV6aXVtfFN1Y2NlZWRzfE5vdFRpbGRlfGJpZ3dlZGdlfGFuZ21zZGFofGFuZ3J0dmJkfHRyaW1pbnVzfGN3Y29uaW50fGZwYXJ0aW50fGxyY29ybmVyfHNtZXBhcnNsfHN1YnNldGVxfHVyY29ybmVyfGx1cmRzaGFyfGxhZW1wdHl2fEREb3RyYWhkfGFwcHJveGVxfGxkcnVzaGFyfGF3Y29uaW50fG1hcHN0b3VwfGJhY2tjb25nfHNob3J0bWlkfHRyaWFuZ2xlfGdlcXNsYW50fGdlc2RvdG9sfHRpbWVzYmFyfGNpcmNsZWRSfGNpcmNsZWRTfHNldG1pbnVzfG11bHRpbWFwfG5hdHVyYWxzfHNjcG9saW50fG5jb25nZG90fFJpZ2h0VGVlfGJveG1pbnVzfGduYXBwcm94fGJveHRpbWVzfGFuZHNsb3BlfHRoaWNrc2ltfGFuZ21zZGFhfHZhcnNpZ21hfGNpcmZuaW50fHJ0cmlsdHJpfGFuZ21zZGFifHJwcG9saW50fGFuZ21zZGFjfGJhcndlZGdlfGRyYmthcm93fGNsdWJzdWl0fHRoZXRhc3ltfGJzb2xoc3VifGNhcGJyY3VwfGR6aWdyYXJyfGRvdGVxZG90fERvdEVxdWFsfGRvdG1pbnVzfFVuZGVyQmFyfE5vdEVxdWFsfHJlYWxwYXJ0fG90aW1lc2FzfHVsY29ybmVyfGhrc2Vhcm93fGhrc3dhcm93fHBhcmFsbGVsfFBhcnRpYWxEfGVsaW50ZXJzfGVtcHR5c2V0fHBsdXNhY2lyfGJicmt0YnJrfGFuZ21zZGFkfHBvaW50aW50fGJpZ29wbHVzfGFuZ21zZGFlfFByZWNlZGVzfGJpZ3NxY3VwfHZhcmthcHBhfG5vdGluZG90fHN1cHNldGVxfHByZWNuZXFxfHByZWNuc2ltfHByb2ZhbGFyfHByb2ZsaW5lfHByb2ZzdXJmfGxlcXNsYW50fGxlc2RvdG9yfHJhZW1wdHl2fHN1YnBsdXN8bm90bml2Ynxub3RuaXZjfHN1YnJhcnJ8emlncmFycnx2emlnemFnfHN1Ym11bHR8c3ViZWRvdHxFbGVtZW50fGJldHdlZW58Y2lyc2NpcnxsYXJyYmZzfGxhcnJzaW18bG90aW1lc3xsYnJrc2xkfGxicmtzbHV8bG96ZW5nZXxsZHJkaGFyfGRia2Fyb3d8YmlnY2lyY3xlcHNpbG9ufHNpbXJhcnJ8c2ltcGx1c3xsdHF1ZXN0fEVwc2lsb258bHVydWhhcnxndHF1ZXN0fG1hbHRlc2V8bnBvbGludHxlcWNvbG9ufG5wcmVjZXF8Ymlnb2RvdHxkZGFnZ2VyfGd0cmxlc3N8Ym5lcXVpdnxoYXJyY2lyfGRkb3RzZXF8ZXF1aXZERHxiYWNrc2ltfGRlbXB0eXZ8bnNxc3ViZXxuc3FzdXBlfFVwc2lsb258bnN1YnNldHx1cHNpbG9ufG1pbnVzZHV8bnN1Y2NlcXxzd2Fycm93fG5zdXBzZXR8Y29sb25lcXxzZWFycm93fGJveHBsdXN8bmFwcHJveHxuYXR1cmFsfGFzeW1wZXF8YWxlZnN5bXxjb25nZG90fG5lYXJyb3d8Ymlnc3RhcnxkaWFtb25kfHN1cHBsdXN8dHJpdGltZXxMZWZ0VGVlfG52aW5maW58dHJpcGx1c3xOZXdMaW5lfG52bHRyaWV8bnZydHJpZXxud2Fycm93fG5leGlzdHN8RGlhbW9uZHxydWx1aGFyfEltcGxpZXN8c3VwbXVsdHxhbmd6YXJyfHN1cGxhcnJ8c3VwaHN1YnxxdWVzdGVxfGJlY2F1c2V8ZGlnYW1tYXxCZWNhdXNlfG9sY3Jvc3N8YmVtcHR5dnxvbWljcm9ufE9taWNyb258cm90aW1lc3xOb0JyZWFrfGludHByb2R8YW5ncnR2YnxvcmRlcm9mfHV3YW5nbGV8c3VwaHNvbHxsZXNkb3RvfG9yc2xvcGV8RG93blRlZXxyZWFsaW5lfGN1ZGFycmx8cmRsZGhhcnxPdmVyQmFyfHN1cGVkb3R8bGVzc2RvdHxzdXBkc3VifHRvcGZvcmt8c3VjY3NpbXxyYnJrc2x1fHJicmtzbGR8cGVydGVua3xjdWRhcnJyfGlzaW5kb3R8cGxhbmNraHxsZXNzZ3RyfHBsdXNjaXJ8Z2VzZG90b3xwbHVzc2ltfHBsdXN0d298bGVzc3NpbXxjdWxhcnJwfHJhcnJzaW18Q2F5bGV5c3xub3RpbnZhfG5vdGludmJ8bm90aW52Y3xVcEFycm93fFVwYXJyb3d8dXBhcnJvd3xOb3RMZXNzfGR3YW5nbGV8cHJlY3NpbXxQcm9kdWN0fGN1cmFycm18Q2NvbmludHxkb3RwbHVzfHJhcnJiZnN8Y2N1cHNzbXxDZWRpbGxhfGNlbXB0eXZ8bm90bml2YXxxdWF0aW50fGZyYWMzNXxmcmFjMzh8ZnJhYzQ1fGZyYWM1NnxmcmFjNTh8ZnJhYzc4fHRyaWRvdHx4b3BsdXN8Z2FjdXRlfGdhbW1hZHxHYW1tYWR8bGZpc2h0fGxmbG9vcnxiaWdjdXB8c3FzdXBlfGdicmV2ZXxHYnJldmV8bGhhcnVsfHNxc3ViZXxzcWN1cHN8R2NlZGlsfGFwYWNpcnxsbGhhcmR8bG1pZG90fExtaWRvdHxsbW91c3R8YW5kYW5kfHNxY2Fwc3xhcHByb3h8QWJyZXZlfHNwYWRlc3xjaXJjZXF8dHByaW1lfGRpdmlkZXx0b3BjaXJ8QXNzaWdufHRvcGJvdHxnZXNkb3R8ZGl2b254fHh1cGx1c3x0aW1lc2R8Z2VzbGVzfGF0aWxkZXxzb2xiYXJ8U09GVGN5fGxvcGx1c3x0aW1lc2J8bG93YXN0fGxvd2JhcnxkbGNvcm58ZGxjcm9wfHNvZnRjeXxkb2xsYXJ8bHBhcmx0fHRoa3NpbXxscmhhcmR8QXRpbGRlfGxzYXF1b3xzbWFzaHB8YmlndmVlfHRoaW5zcHx3cmVhdGh8Ymthcm93fGxzcXVvcnxsc3Ryb2t8THN0cm9rfGx0aHJlZXxsdGltZXN8bHRsYXJyfERvdERvdHxzaW1kb3R8bHRyUGFyfHdlaWVycHx4c3FjdXB8YW5nbXNkfHNpZ21hdnxzaWdtYWZ8emVldHJmfFpjYXJvbnx6Y2Fyb258bWFwc3RvfHZzdXBuZXx0aGV0YXZ8Y2lybWlkfG1hcmtlcnxtY29tbWF8WmFjdXRlfHZzdWJuRXx0aGVyZTR8Z3RsUGFyfHZzdWJuZXxib3R0b218Z3RyYXJyfFNIQ0hjeXxzaGNoY3l8bWlkYXN0fG1pZGNpcnxtaWRkb3R8bWludXNifG1pbnVzZHxndHJkb3R8Ym93dGllfHNmcm93bnxtbnBsdXN8bW9kZWxzfGNvbG9uZXxzZXN3YXJ8Q29sb25lfG1zdHBvc3xzZWFyaGt8Z3Ryc2ltfG5hY3V0ZXxOYWN1dGV8Ym94Ym94fHRlbHJlY3xoYWlyc3B8VGNlZGlsfG5idW1wZXxzY25zaW18bmNhcm9ufE5jYXJvbnxuY2VkaWx8TmNlZGlsfGhhbWlsdHxTY2VkaWx8bmVhcmhrfGhhcmRjeXxIQVJEY3l8dGNlZGlsfFRjYXJvbnxjb21tYXR8bmVxdWl2fG5lc2Vhcnx0Y2Fyb258dGFyZ2V0fGhlYXJ0c3xuZXhpc3R8dmFycmhvfHNjZWRpbHxTY2Fyb258c2Nhcm9ufGhlbGxpcHxTYWN1dGV8c2FjdXRlfGhlcmNvbnxzd253YXJ8Y29tcGZufHJ0aW1lc3xydGhyZWV8cnNxdW9yfHJzYXF1b3x6YWN1dGV8d2VkZ2VxfGhvbXRodHxiYXJ2ZWV8YmFyd2VkfEJhcndlZHxycGFyZ3R8aG9yYmFyfGNvbmludHxzd2FyaGt8cm9wbHVzfG5sdHJpZXxoc2xhc2h8aHN0cm9rfEhzdHJva3xybW91c3R8Q29uaW50fGJwcmltZXxoeWJ1bGx8aHlwaGVufGlhY3V0ZXxJYWN1dGV8c3Vwc3VwfHN1cHN1YnxzdXBzaW18dmFycGhpfGNvcHJvZHxicnZiYXJ8YWdyYXZlfFN1cHNldHxzdXBzZXR8aWdyYXZlfElncmF2ZXxub3RpbkV8QWdyYXZlfGlpaWludHxpaW5maW58Y29weXNyfHdlZGJhcnxWZXJiYXJ8dmFuZ3J0fGJlY2F1c3xpbmNhcmV8dmVyYmFyfGlub2RvdHxidWxsZXR8ZHJjb3JufGludGNhbHxkcmNyb3B8Y3VsYXJyfHZlbGxpcHxVdGlsZGV8YnVtcGVxfGN1cGNhcHxkc3Ryb2t8RHN0cm9rfEN1cENhcHxjdXBjdXB8Y3VwZG90fGVhY3V0ZXxFYWN1dGV8c3VwZG90fGlxdWVzdHxlYXN0ZXJ8ZWNhcm9ufEVjYXJvbnxlY29sb258aXNpbnN2fHV0aWxkZXxpdGlsZGV8SXRpbGRlfGN1cmFycnxzdWNjZXF8QnVtcGVxfGNhY3V0ZXx1bGNyb3B8bnBhcnNsfENhY3V0ZXxucHJjdWV8ZWdyYXZlfEVncmF2ZXxucmFycmN8bnJhcnJ3fHN1YnN1cHxzdWJzdWJ8bnJ0cmllfGpzZXJjeXxuc2NjdWV8SnNlcmN5fGthcHBhdnxrY2VkaWx8S2NlZGlsfHN1YnNpbXx1bGNvcm58bnNpbWVxfGVnc2RvdHx2ZWViYXJ8a2dyZWVufGNhcGFuZHxlbHNkb3R8U3Vic2V0fHN1YnNldHxjdXJyZW58YWFjdXRlfGxhY3V0ZXxMYWN1dGV8ZW1wdHl2fG50aWxkZXxOdGlsZGV8bGFncmFufGxhbWJkYXxMYW1iZGF8Y2FwY2FwfFVncmF2ZXxsYW5nbGV8c3ViZG90fGVtc3AxM3xudW1lcm98ZW1zcDE0fG52ZGFzaHxudkRhc2h8blZkYXNofG5WRGFzaHx1Z3JhdmV8dWZpc2h0fG52SGFycnxsYXJyZnN8bnZsQXJyfGxhcnJoa3xsYXJybHB8bGFycnBsfG52ckFycnxVZGJsYWN8bndhcmhrfGxhcnJ0bHxud25lYXJ8b2FjdXRlfE9hY3V0ZXxsYXRhaWx8bEF0YWlsfHNzdGFyZnxsYnJhY2V8b2RibGFjfE9kYmxhY3xsYnJhY2t8dWRibGFjfG9kc29sZHxlcGFyc2x8bGNhcm9ufExjYXJvbnxvZ3JhdmV8T2dyYXZlfGxjZWRpbHxMY2VkaWx8QWFjdXRlfHNzbWlsZXxzc2V0bW58c3F1YXJmfGxkcXVvcnxjYXBjdXB8b21pbnVzfGN5bGN0eXxyaGFydWx8ZXFjaXJjfGRhZ2dlcnxyZmxvb3J8cmZpc2h0fERhZ2dlcnxkYWxldGh8ZXF1YWxzfG9yaWdvZnxjYXBkb3R8ZXF1ZXN0fGRjYXJvbnxEY2Fyb258cmRxdW9yfG9zbGFzaHxPc2xhc2h8b3RpbGRlfE90aWxkZXxvdGltZXN8T3RpbWVzfHVyY3JvcHxVYnJldmV8dWJyZXZlfFlhY3V0ZXxVYWN1dGV8dWFjdXRlfFJjZWRpbHxyY2VkaWx8dXJjb3JufHBhcnNpbXxSY2Fyb258VmRhc2hsfHJjYXJvbnxUc3Ryb2t8cGVyY250fHBlcmlvZHxwZXJtaWx8RXhpc3RzfHlhY3V0ZXxyYnJhY2t8cmJyYWNlfHBobW1hdHxjY2Fyb258Q2Nhcm9ufHBsYW5ja3xjY2VkaWx8cGxhbmt2fHRzdHJva3xmZW1hbGV8cGx1c2RvfHBsdXNkdXxmZmlsaWd8cGx1c21ufGZmbGxpZ3xDY2VkaWx8ckF0YWlsfGRmaXNodHxiZXJub3V8cmF0YWlsfFJhcnJ0bHxyYXJydGx8YW5nc3BofHJhcnJwbHxyYXJybHB8cmFycmhrfHh3ZWRnZXx4b3RpbWV8Zm9yYWxsfEZvckFsbHxWdmRhc2h8dnN1cG5FfHByZWNlcXxiaWdjYXB8ZnJhYzEyfGZyYWMxM3xmcmFjMTR8cHJpbWVzfHJhcnJmc3xwcm5zaW18ZnJhYzE1fFNxdWFyZXxmcmFjMTZ8c3F1YXJlfGxlc2RvdHxmcmFjMTh8ZnJhYzIzfHByb3B0b3xwcnVyZWx8cmFycmFwfHJhbmdsZXxwdW5jc3B8ZnJhYzI1fFJhY3V0ZXxxcHJpbWV8cmFjdXRlfGxlc2dlc3xmcmFjMzR8YWJyZXZlfEFFbGlnfGVxc2ltfHV0ZG90fHNldG1ufHVydHJpfEVxdWFsfFVyaW5nfHNlQXJyfHVyaW5nfHNlYXJyfGRhc2h2fERhc2h2fG11bWFwfG5hYmxhfGlvZ29ufElvZ29ufHNkb3RlfHNkb3RifHNjc2ltfG5hcGlkfG5hcG9zfGVxdWl2fG5hdHVyfEFjaXJjfGRibGFjfGVyYXJyfG5idW1wfGlwcm9kfGVyRG90fHVjaXJjfGF3aW50fGVzZG90fGFuZ3J0fG5jb25nfGlzaW5FfHNjbmFwfFNjaXJjfHNjaXJjfG5kYXNofGlzaW5zfFVicmN5fG5lYXJyfG5lQXJyfGlzaW52fG5lZG90fHVicmN5fGFjdXRlfFljaXJjfGl1a2N5fEl1a2N5fHh1dHJpfG5lc2ltfGNhcmV0fGpjaXJjfEpjaXJjfGNhcm9ufHR3aXh0fGRkYXJyfHNjY3VlfGV4aXN0fGptYXRofHNicXVvfG5nZXFxfGFuZ3N0fGNjYXBzfGxjZWlsfG5nc2ltfFVwVGVlfGRlbHRhfERlbHRhfHJ0cmlmfG5oYXJyfG5oQXJyfG5ocGFyfHJ0cmllfGp1a2N5fEp1a2N5fGthcHBhfHJzcXVvfEthcHBhfG5sYXJyfG5sQXJyfFRTSGN5fHJyYXJyfGFvZ29ufEFvZ29ufGZmbGlnfHhyYXJyfHRzaGN5fGNjaXJjfG5sZXFxfGZpbGlnfHVwc2lofG5sZXNzfGRoYXJsfG5sc2ltfGZqbGlnfHJvcGFyfG5sdHJpfGRoYXJyfHJvYnJrfHJvYXJyfGZsbGlnfGZsdG5zfHJvYW5nfHJubWlkfHN1Ym5FfHN1Ym5lfGxBYXJyfHRyaXNifENjaXJjfGFjaXJjfGNjdXBzfGJsYW5rfFZEYXNofGZvcmt2fFZkYXNofGxhbmdkfGNlZGlsfGJsazEyfGJsazE0fGxhcXVvfHN0cm5zfGRpYW1zfG5vdGlufHZEYXNofGxhcnJifGJsazM0fGJsb2NrfGRpc2lufHVwbHVzfHZkYXNofHZCYXJ2fGFlbGlnfHN0YXJmfFdlZGdlfGNoZWNrfHhyQXJyfGxhdGVzfGxiYXJyfGxCYXJyfG5vdG5pfGxiYnJrfGJjb25nfGZyYXNsfGxicmtlfGZyb3dufHZydHJpfHZwcm9wfHZuc3VwfGdhbW1hfEdhbW1hfHdlZGdlfHhvZG90fGJkcXVvfHNyYXJyfGRvdGVxfGxkcXVvfGJveGRsfGJveGRMfGdjaXJjfEdjaXJjfGJveERsfGJveERMfGJveGRyfGJveGRSfGJveERyfFRSQURFfHRyYWRlfHJsaGFyfGJveERSfHZuc3VifG5wYXJ0fHZsdHJpfHJsYXJyfGJveGhkfGJveGhEfG5wcmVjfGdlc2NjfG5yYXJyfG5yQXJyfGJveEhkfGJveEhEfGJveGh1fGJveGhVfG5ydHJpfGJveEh1fGNsdWJzfGJveEhVfHRpbWVzfGNvbG9ufENvbG9ufGdpbWVsfHhsQXJyfFRpbGRlfG5zaW1lfHRpbGRlfG5zbWlkfG5zcGFyfFRIT1JOfHRob3JufHhsYXJyfG5zdWJlfG5zdWJFfHRoa2FwfHhoQXJyfGNvbW1hfG5zdWNjfGJveHVsfGJveHVMfG5zdXBlfG5zdXBFfGduZXFxfGduc2ltfGJveFVsfGJveFVMfGdyYXZlfGJveHVyfGJveHVSfGJveFVyfGJveFVSfGxlc2NjfGFuZ2xlfGJlcHNpfGJveHZofHZhcnBpfGJveHZIfG51bXNwfFRoZXRhfGdzaW1lfGdzaW1sfHRoZXRhfGJveFZofGJveFZIfGJveHZsfGd0Y2lyfGd0ZG90fGJveHZMfGJveFZsfGJveFZMfGNyYXJyfGNyb3NzfENyb3NzfG52c2ltfGJveHZyfG53YXJyfG53QXJyfHNxc3VwfGR0ZG90fFVvZ29ufGxoYXJkfGxoYXJ1fGR0cmlmfG9jaXJjfE9jaXJjfGxoYmxrfGR1YXJyfG9kYXNofHNxc3VifEhhY2VrfHNxY3VwfGxsYXJyfGR1aGFyfG9lbGlnfE9FbGlnfG9mY2lyfGJveHZSfHVvZ29ufGxsdHJpfGJveFZyfGNzdWJlfHV1YXJyfG9oYmFyfGNzdXBlfGN0ZG90fG9sYXJyfG9sY2lyfGhhcnJ3fG9saW5lfHNxY2FwfG9tYWNyfE9tYWNyfG9tZWdhfE9tZWdhfGJveFZSfGFsZXBofGxuZXFxfGxuc2ltfGxvYW5nfGxvYXJyfHJoYXJ1fGxvYnJrfGhjaXJjfG9wZXJwfG9wbHVzfHJoYXJkfEhjaXJjfG9yYXJyfFVuaW9ufG9yZGVyfGVjaXJjfEVjaXJjfGN1ZXByfHN6bGlnfGN1ZXNjfGJyZXZlfHJlYWxzfGVERG90fEJyZXZlfGhvYXJyfGxvcGFyfHV0cmlmfHJkcXVvfFVtYWNyfHVtYWNyfGVmRG90fHN3QXJyfHVsdHJpfGFscGhhfHJjZWlsfG92YmFyfHN3YXJyfFdjaXJjfHdjaXJjfHNtdGVzfHNtaWxlfGJzZW1pfGxyYXJyfGFyaW5nfHBhcnNsfGxyaGFyfGJzaW1lfHVoYmxrfGxydHJpfGN1cG9yfEFyaW5nfHVoYXJyfHVoYXJsfHNsYXJyfHJicmtlfGJzb2xifGxzaW1lfHJiYnJrfFJCYXJyfGxzaW1nfHBob25lfHJCYXJyfHJiYXJyfGljaXJjfGxzcXVvfEljaXJjfGVtYWNyfEVtYWNyfHJhdGlvfHNpbW5lfHBsdXNifHNpbWxFfHNpbWdFfHNpbWVxfHBsdXNlfGx0Y2lyfGx0ZG90fGVtcHR5fHhoYXJyfHhkdHJpfGlleGNsfEFscGhhfGx0cmllfHJhcnJ3fHBvdW5kfGx0cmlmfHhjaXJjfGJ1bXBlfHByY3VlfGJ1bXBFfGFzeW1wfGFtYWNyfGN1dmVlfFNpZ21hfHNpZ21hfGlpaW50fHVkaGFyfGlpb3RhfGlqbGlnfElKbGlnfHN1cG5FfGltYWNyfEltYWNyfHByaW1lfFByaW1lfGltYWdlfHBybmFwfGVvZ29ufEVvZ29ufHJhcnJjfG1kYXNofG1ERG90fGN1d2VkfGltYXRofHN1cG5lfGltcGVkfEFtYWNyfHVkYXJyfHByc2ltfG1pY3JvfHJhcnJifGN3aW50fHJhcXVvfGluZmlufGVwbHVzfHJhbmdlfHJhbmdkfFVjaXJjfHJhZGljfG1pbnVzfGFtYWxnfHZlZWVxfHJBYXJyfGVwc2l2fHljaXJjfHF1ZXN0fHNoYXJwfHF1b3R8enduanxRc2NyfHJhY2V8cXNjcnxRb3BmfHFvcGZ8cWludHxyYW5nfFJhbmd8WnNjcnx6c2NyfFpvcGZ8em9wZnxyYXJyfHJBcnJ8UmFycnxQc2NyfHBzY3J8cHJvcHxwcm9kfHBybkV8cHJlY3xaSGN5fHpoY3l8cHJhcHxaZXRhfHpldGF8UG9wZnxwb3BmfFpkb3R8cGx1c3x6ZG90fFl1bWx8eXVtbHxwaGl2fFlVY3l8eXVjeXxZc2NyfHlzY3J8cGVycHxZb3BmfHlvcGZ8cGFydHxwYXJhfFlJY3l8T3VtbHxyY3VifHlpY3l8WUFjeXxyZGNhfG91bWx8b3NvbHxPc2NyfHJkc2h8eWFjeXxyZWFsfG9zY3J8eHZlZXxhbmRkfHJlY3R8YW5kdnxYc2NyfG9yb3J8b3JkbXxvcmRmfHhzY3J8YW5nZXxhb3BmfEFvcGZ8ckhhcnxYb3BmfG9wYXJ8T29wZnx4b3BmfHhuaXN8cmhvdnxvb3BmfG9taWR8eG1hcHxvaW50fGFwaWR8YXBvc3xvZ29ufGFzY3J8QXNjcnxvZG90fG9kaXZ8eGN1cHx4Y2FwfG9jaXJ8b2FzdHxudmx0fG52bGV8bnZndHxudmdlfG52YXB8V3Njcnx3c2NyfGF1bWx8bnRsZ3xudGdsfG5zdXB8bnN1Ynxuc2ltfE5zY3J8bnNjcnxuc2NlfFdvcGZ8cmluZ3xucHJlfHdvcGZ8bnBhcnxBdW1sfEJhcnZ8YmJya3xOb3BmfG5vcGZ8bm1pZHxuTHR2fGJldGF8cm9wZnxSb3BmfEJldGF8YmV0aHxubGVzfHJwYXJ8bmxlcXxibm90fGJOb3R8bmxkcnxOSmN5fHJzY3J8UnNjcnxWc2NyfHZzY3J8cnNxYnxuamN5fGJvcGZ8bmlzZHxCb3BmfHJ0cml8Vm9wZnxuR3R2fG5ndHJ8dm9wZnxib3hofGJveEh8Ym94dnxuZ2VzfG5nZXF8Ym94Vnxic2NyfHNjYXB8QnNjcnxic2ltfFZlcnR8dmVydHxic29sfGJ1bGx8YnVtcHxjYXBzfGNkb3R8bmN1cHxzY25FfG5jYXB8bmJzcHxuYXBFfENkb3R8Y2VudHxzZG90fFZiYXJ8bmFuZ3x2QmFyfGNoY3l8TXNjcnxtc2NyfHNlY3R8c2VtaXxDSGN5fE1vcGZ8bW9wZnxzZXh0fGNpcmN8Y2lyZXxtbGRyfG1sY3B8Y2lyRXxjb21wfHNoY3l8U0hjeXx2QXJyfHZhcnJ8Y29uZ3xjb3BmfENvcGZ8Y29weXxDT1BZfG1hbHR8bWFsZXxtYWNyfGx2bkV8Y3NjcnxsdHJpfHNpbWV8bHRjY3xzaW1nfENzY3J8c2ltbHxjc3VifFV1bWx8bHNxYnxsc2ltfHV1bWx8Y3N1cHxMc2NyfGxzY3J8dXRyaXxzbWlkfGxwYXJ8Y3Vwc3xzbXRlfGxvemZ8ZGFycnxMb3BmfFVzY3J8c29sYnxsb3BmfHNvcGZ8U29wZnxsbmVxfHVzY3J8c3BhcnxkQXJyfGxuYXB8RGFycnxkYXNofFNxcnR8TEpjeXxsamN5fGxIYXJ8ZEhhcnxVcHNpfHVwc2l8ZGlhbXxsZXNnfGRqY3l8REpjeXxsZXFxfGRvcGZ8RG9wZnxkc2NyfERzY3J8ZHNjeXxsZHNofGxkY2F8c3F1ZnxEU2N5fHNzY3J8U3Njcnxkc29sfGxjdWJ8bGF0ZXxzdGFyfFN0YXJ8VW9wZnxMYXJyfGxBcnJ8bGFycnx1b3BmfGR0cml8ZHpjeXxzdWJlfHN1YkV8TGFuZ3xsYW5nfEtzY3J8a3NjcnxLb3BmfGtvcGZ8S0pjeXxramN5fEtIY3l8a2hjeXxEWmN5fGVjaXJ8ZWRvdHxlRG90fEpzY3J8anNjcnxzdWNjfEpvcGZ8am9wZnxFZG90fHVIYXJ8ZW1zcHxlbnNwfEl1bWx8aXVtbHxlb3BmfGlzaW58SXNjcnxpc2NyfEVvcGZ8ZXBhcnxzdW5nfGVwc2l8ZXNjcnxzdXAxfHN1cDJ8c3VwM3xJb3RhfGlvdGF8c3VwZXxzdXBFfElvcGZ8aW9wZnxJT2N5fGlvY3l8RXNjcnxlc2ltfEVzaW18aW1vZnxVYXJyfFFVT1R8dUFycnx1YXJyfGV1bWx8SUVjeXxpZWN5fElkb3R8RXVtbHxldXJvfGV4Y2x8SHNjcnxoc2NyfEhvcGZ8aG9wZnxUU2N5fHRzY3l8VHNjcnxoYmFyfHRzY3J8ZmxhdHx0YnJrfGZub2Z8aEFycnxoYXJyfGhhbGZ8Zm9wZnxGb3BmfHRkb3R8Z3ZuRXxmb3JrfHRyaWV8Z3RjY3xmc2NyfEZzY3J8Z2RvdHxnc2ltfEdzY3J8Z3NjcnxHb3BmfGdvcGZ8Z25lcXxHZG90fHRvc2F8Z25hcHxUb3BmfHRvcGZ8Z2VxcXx0b2VhfEdKY3l8Z2pjeXx0aW50fGdlc2x8bWlkfFNmcnxnZ2d8dG9wfGdlc3xnbGF8Z2xFfGdsanxnZXF8Z25lfGdFbHxnZWx8Z25FfEdjeXxnY3l8Z2FwfFRmcnx0ZnJ8VGN5fHRjeXxIYXR8VGF1fEZmcnx0YXV8VGFifGhmcnxIZnJ8ZmZyfEZjeXxmY3l8aWN5fEljeXxpZmZ8RVRIfGV0aHxpZnJ8SWZyfEV0YXxldGF8aW50fEludHxTdXB8c3VwfHVjeXxVY3l8U3VtfHN1bXxqY3l8RU5HfHVmcnxVZnJ8ZW5nfEpjeXxqZnJ8ZWxzfGVsbHxlZ3N8RWZyfGVmcnxKZnJ8dW1sfGtjeXxLY3l8RWN5fGVjeXxrZnJ8S2ZyfGxhcHxTdWJ8c3VifGxhdHxsY3l8TGN5fGxlZ3xEb3R8ZG90fGxFZ3xsZXF8bGVzfHNxdXxkaXZ8ZGllfGxmcnxMZnJ8bGdFfERmcnxkZnJ8RGVsfGRlZ3xEY3l8ZGN5fGxuZXxsbkV8c29sfGxvenxzbXR8Q3VwfGxybXxjdXB8bHNofExzaHxzaW18c2h5fG1hcHxNYXB8bWN5fE1jeXxtZnJ8TWZyfG1ob3xnZnJ8R2ZyfHNmcnxjaXJ8Q2hpfGNoaXxuYXB8Q2ZyfHZjeXxWY3l8Y2ZyfFNjeXxzY3l8bmN5fE5jeXx2ZWV8VmVlfENhcHxjYXB8bmZyfHNjRXxzY2V8TmZyfG5nZXxuZ0V8bkdnfHZmcnxWZnJ8bmd0fGJvdHxuR3R8bmlzfG5pdnxSc2h8cnNofG5sZXxubEV8Ym5lfEJmcnxiZnJ8bkxsfG5sdHxuTHR8QmN5fGJjeXxub3R8Tm90fHJsbXx3ZnJ8V2ZyfG5wcnxuc2N8bnVtfG9jeXxhc3R8T2N5fG9mcnx4ZnJ8WGZyfE9mcnxvZ3R8b2htfGFwRXxvbHR8UmhvfGFwZXxyaG98UmZyfHJmcnxvcmR8UkVHfGFuZ3xyZWd8b3J2fEFuZHxhbmR8QU1QfFJjeXxhbXB8QWZyfHljeXxZY3l8eWVufHlmcnxZZnJ8cmN5fHBhcnxwY3l8UGN5fHBmcnxQZnJ8cGhpfFBoaXxhZnJ8QWN5fGFjeXx6Y3l8WmN5fHBpdnxhY0V8YWNkfHpmcnxaZnJ8cHJlfHByRXxwc2l8UHNpfHFmcnxRZnJ8endqfE9yfGdlfEdnfGd0fGdnfGVsfG9TfGx0fEx0fExUfFJlfGxnfGdsfGVnfG5lfEltfGl0fGxlfEREfHdwfHdyfG51fE51fGRkfGxFfFNjfHNjfHBpfFBpfGVlfGFmfGxsfExsfHJ4fGdFfHhpfHBtfFhpfGljfHByfFByfGlufG5pfG1wfG11fGFjfE11fG9yfGFwfEd0fEdUfGlpKTt8JihBYWN1dGV8QWdyYXZlfEF0aWxkZXxDY2VkaWx8RWFjdXRlfEVncmF2ZXxJYWN1dGV8SWdyYXZlfE50aWxkZXxPYWN1dGV8T2dyYXZlfE9zbGFzaHxPdGlsZGV8VWFjdXRlfFVncmF2ZXxZYWN1dGV8YWFjdXRlfGFncmF2ZXxhdGlsZGV8YnJ2YmFyfGNjZWRpbHxjdXJyZW58ZGl2aWRlfGVhY3V0ZXxlZ3JhdmV8ZnJhYzEyfGZyYWMxNHxmcmFjMzR8aWFjdXRlfGlncmF2ZXxpcXVlc3R8bWlkZG90fG50aWxkZXxvYWN1dGV8b2dyYXZlfG9zbGFzaHxvdGlsZGV8cGx1c21ufHVhY3V0ZXx1Z3JhdmV8eWFjdXRlfEFFbGlnfEFjaXJjfEFyaW5nfEVjaXJjfEljaXJjfE9jaXJjfFRIT1JOfFVjaXJjfGFjaXJjfGFjdXRlfGFlbGlnfGFyaW5nfGNlZGlsfGVjaXJjfGljaXJjfGlleGNsfGxhcXVvfG1pY3JvfG9jaXJjfHBvdW5kfHJhcXVvfHN6bGlnfHRob3JufHRpbWVzfHVjaXJjfEF1bWx8Q09QWXxFdW1sfEl1bWx8T3VtbHxRVU9UfFV1bWx8YXVtbHxjZW50fGNvcHl8ZXVtbHxpdW1sfG1hY3J8bmJzcHxvcmRmfG9yZG18b3VtbHxwYXJhfHF1b3R8c2VjdHxzdXAxfHN1cDJ8c3VwM3x1dW1sfHl1bWx8QU1QfEVUSHxSRUd8YW1wfGRlZ3xldGh8bm90fHJlZ3xzaHl8dW1sfHllbnxHVHxMVHxndHxsdCkoPyE7KShbPWEtekEtWjAtOV0/KXwmIyhbMC05XSspKDs/KXwmI1t4WF0oW2EtZkEtRjAtOV0rKSg7Pyl8JihbMC05YS16QS1aXSspL2c7XG5cdHZhciBkZWNvZGVNYXAgPSB7J2FhY3V0ZSc6J1xceEUxJywnQWFjdXRlJzonXFx4QzEnLCdhYnJldmUnOidcXHUwMTAzJywnQWJyZXZlJzonXFx1MDEwMicsJ2FjJzonXFx1MjIzRScsJ2FjZCc6J1xcdTIyM0YnLCdhY0UnOidcXHUyMjNFXFx1MDMzMycsJ2FjaXJjJzonXFx4RTInLCdBY2lyYyc6J1xceEMyJywnYWN1dGUnOidcXHhCNCcsJ2FjeSc6J1xcdTA0MzAnLCdBY3knOidcXHUwNDEwJywnYWVsaWcnOidcXHhFNicsJ0FFbGlnJzonXFx4QzYnLCdhZic6J1xcdTIwNjEnLCdhZnInOidcXHVEODM1XFx1REQxRScsJ0Fmcic6J1xcdUQ4MzVcXHVERDA0JywnYWdyYXZlJzonXFx4RTAnLCdBZ3JhdmUnOidcXHhDMCcsJ2FsZWZzeW0nOidcXHUyMTM1JywnYWxlcGgnOidcXHUyMTM1JywnYWxwaGEnOidcXHUwM0IxJywnQWxwaGEnOidcXHUwMzkxJywnYW1hY3InOidcXHUwMTAxJywnQW1hY3InOidcXHUwMTAwJywnYW1hbGcnOidcXHUyQTNGJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhbmQnOidcXHUyMjI3JywnQW5kJzonXFx1MkE1MycsJ2FuZGFuZCc6J1xcdTJBNTUnLCdhbmRkJzonXFx1MkE1QycsJ2FuZHNsb3BlJzonXFx1MkE1OCcsJ2FuZHYnOidcXHUyQTVBJywnYW5nJzonXFx1MjIyMCcsJ2FuZ2UnOidcXHUyOUE0JywnYW5nbGUnOidcXHUyMjIwJywnYW5nbXNkJzonXFx1MjIyMScsJ2FuZ21zZGFhJzonXFx1MjlBOCcsJ2FuZ21zZGFiJzonXFx1MjlBOScsJ2FuZ21zZGFjJzonXFx1MjlBQScsJ2FuZ21zZGFkJzonXFx1MjlBQicsJ2FuZ21zZGFlJzonXFx1MjlBQycsJ2FuZ21zZGFmJzonXFx1MjlBRCcsJ2FuZ21zZGFnJzonXFx1MjlBRScsJ2FuZ21zZGFoJzonXFx1MjlBRicsJ2FuZ3J0JzonXFx1MjIxRicsJ2FuZ3J0dmInOidcXHUyMkJFJywnYW5ncnR2YmQnOidcXHUyOTlEJywnYW5nc3BoJzonXFx1MjIyMicsJ2FuZ3N0JzonXFx4QzUnLCdhbmd6YXJyJzonXFx1MjM3QycsJ2FvZ29uJzonXFx1MDEwNScsJ0FvZ29uJzonXFx1MDEwNCcsJ2FvcGYnOidcXHVEODM1XFx1REQ1MicsJ0FvcGYnOidcXHVEODM1XFx1REQzOCcsJ2FwJzonXFx1MjI0OCcsJ2FwYWNpcic6J1xcdTJBNkYnLCdhcGUnOidcXHUyMjRBJywnYXBFJzonXFx1MkE3MCcsJ2FwaWQnOidcXHUyMjRCJywnYXBvcyc6J1xcJycsJ0FwcGx5RnVuY3Rpb24nOidcXHUyMDYxJywnYXBwcm94JzonXFx1MjI0OCcsJ2FwcHJveGVxJzonXFx1MjI0QScsJ2FyaW5nJzonXFx4RTUnLCdBcmluZyc6J1xceEM1JywnYXNjcic6J1xcdUQ4MzVcXHVEQ0I2JywnQXNjcic6J1xcdUQ4MzVcXHVEQzlDJywnQXNzaWduJzonXFx1MjI1NCcsJ2FzdCc6JyonLCdhc3ltcCc6J1xcdTIyNDgnLCdhc3ltcGVxJzonXFx1MjI0RCcsJ2F0aWxkZSc6J1xceEUzJywnQXRpbGRlJzonXFx4QzMnLCdhdW1sJzonXFx4RTQnLCdBdW1sJzonXFx4QzQnLCdhd2NvbmludCc6J1xcdTIyMzMnLCdhd2ludCc6J1xcdTJBMTEnLCdiYWNrY29uZyc6J1xcdTIyNEMnLCdiYWNrZXBzaWxvbic6J1xcdTAzRjYnLCdiYWNrcHJpbWUnOidcXHUyMDM1JywnYmFja3NpbSc6J1xcdTIyM0QnLCdiYWNrc2ltZXEnOidcXHUyMkNEJywnQmFja3NsYXNoJzonXFx1MjIxNicsJ0JhcnYnOidcXHUyQUU3JywnYmFydmVlJzonXFx1MjJCRCcsJ2JhcndlZCc6J1xcdTIzMDUnLCdCYXJ3ZWQnOidcXHUyMzA2JywnYmFyd2VkZ2UnOidcXHUyMzA1JywnYmJyayc6J1xcdTIzQjUnLCdiYnJrdGJyayc6J1xcdTIzQjYnLCdiY29uZyc6J1xcdTIyNEMnLCdiY3knOidcXHUwNDMxJywnQmN5JzonXFx1MDQxMScsJ2JkcXVvJzonXFx1MjAxRScsJ2JlY2F1cyc6J1xcdTIyMzUnLCdiZWNhdXNlJzonXFx1MjIzNScsJ0JlY2F1c2UnOidcXHUyMjM1JywnYmVtcHR5dic6J1xcdTI5QjAnLCdiZXBzaSc6J1xcdTAzRjYnLCdiZXJub3UnOidcXHUyMTJDJywnQmVybm91bGxpcyc6J1xcdTIxMkMnLCdiZXRhJzonXFx1MDNCMicsJ0JldGEnOidcXHUwMzkyJywnYmV0aCc6J1xcdTIxMzYnLCdiZXR3ZWVuJzonXFx1MjI2QycsJ2Jmcic6J1xcdUQ4MzVcXHVERDFGJywnQmZyJzonXFx1RDgzNVxcdUREMDUnLCdiaWdjYXAnOidcXHUyMkMyJywnYmlnY2lyYyc6J1xcdTI1RUYnLCdiaWdjdXAnOidcXHUyMkMzJywnYmlnb2RvdCc6J1xcdTJBMDAnLCdiaWdvcGx1cyc6J1xcdTJBMDEnLCdiaWdvdGltZXMnOidcXHUyQTAyJywnYmlnc3FjdXAnOidcXHUyQTA2JywnYmlnc3Rhcic6J1xcdTI2MDUnLCdiaWd0cmlhbmdsZWRvd24nOidcXHUyNUJEJywnYmlndHJpYW5nbGV1cCc6J1xcdTI1QjMnLCdiaWd1cGx1cyc6J1xcdTJBMDQnLCdiaWd2ZWUnOidcXHUyMkMxJywnYmlnd2VkZ2UnOidcXHUyMkMwJywnYmthcm93JzonXFx1MjkwRCcsJ2JsYWNrbG96ZW5nZSc6J1xcdTI5RUInLCdibGFja3NxdWFyZSc6J1xcdTI1QUEnLCdibGFja3RyaWFuZ2xlJzonXFx1MjVCNCcsJ2JsYWNrdHJpYW5nbGVkb3duJzonXFx1MjVCRScsJ2JsYWNrdHJpYW5nbGVsZWZ0JzonXFx1MjVDMicsJ2JsYWNrdHJpYW5nbGVyaWdodCc6J1xcdTI1QjgnLCdibGFuayc6J1xcdTI0MjMnLCdibGsxMic6J1xcdTI1OTInLCdibGsxNCc6J1xcdTI1OTEnLCdibGszNCc6J1xcdTI1OTMnLCdibG9jayc6J1xcdTI1ODgnLCdibmUnOic9XFx1MjBFNScsJ2JuZXF1aXYnOidcXHUyMjYxXFx1MjBFNScsJ2Jub3QnOidcXHUyMzEwJywnYk5vdCc6J1xcdTJBRUQnLCdib3BmJzonXFx1RDgzNVxcdURENTMnLCdCb3BmJzonXFx1RDgzNVxcdUREMzknLCdib3QnOidcXHUyMkE1JywnYm90dG9tJzonXFx1MjJBNScsJ2Jvd3RpZSc6J1xcdTIyQzgnLCdib3hib3gnOidcXHUyOUM5JywnYm94ZGwnOidcXHUyNTEwJywnYm94ZEwnOidcXHUyNTU1JywnYm94RGwnOidcXHUyNTU2JywnYm94REwnOidcXHUyNTU3JywnYm94ZHInOidcXHUyNTBDJywnYm94ZFInOidcXHUyNTUyJywnYm94RHInOidcXHUyNTUzJywnYm94RFInOidcXHUyNTU0JywnYm94aCc6J1xcdTI1MDAnLCdib3hIJzonXFx1MjU1MCcsJ2JveGhkJzonXFx1MjUyQycsJ2JveGhEJzonXFx1MjU2NScsJ2JveEhkJzonXFx1MjU2NCcsJ2JveEhEJzonXFx1MjU2NicsJ2JveGh1JzonXFx1MjUzNCcsJ2JveGhVJzonXFx1MjU2OCcsJ2JveEh1JzonXFx1MjU2NycsJ2JveEhVJzonXFx1MjU2OScsJ2JveG1pbnVzJzonXFx1MjI5RicsJ2JveHBsdXMnOidcXHUyMjlFJywnYm94dGltZXMnOidcXHUyMkEwJywnYm94dWwnOidcXHUyNTE4JywnYm94dUwnOidcXHUyNTVCJywnYm94VWwnOidcXHUyNTVDJywnYm94VUwnOidcXHUyNTVEJywnYm94dXInOidcXHUyNTE0JywnYm94dVInOidcXHUyNTU4JywnYm94VXInOidcXHUyNTU5JywnYm94VVInOidcXHUyNTVBJywnYm94dic6J1xcdTI1MDInLCdib3hWJzonXFx1MjU1MScsJ2JveHZoJzonXFx1MjUzQycsJ2JveHZIJzonXFx1MjU2QScsJ2JveFZoJzonXFx1MjU2QicsJ2JveFZIJzonXFx1MjU2QycsJ2JveHZsJzonXFx1MjUyNCcsJ2JveHZMJzonXFx1MjU2MScsJ2JveFZsJzonXFx1MjU2MicsJ2JveFZMJzonXFx1MjU2MycsJ2JveHZyJzonXFx1MjUxQycsJ2JveHZSJzonXFx1MjU1RScsJ2JveFZyJzonXFx1MjU1RicsJ2JveFZSJzonXFx1MjU2MCcsJ2JwcmltZSc6J1xcdTIwMzUnLCdicmV2ZSc6J1xcdTAyRDgnLCdCcmV2ZSc6J1xcdTAyRDgnLCdicnZiYXInOidcXHhBNicsJ2JzY3InOidcXHVEODM1XFx1RENCNycsJ0JzY3InOidcXHUyMTJDJywnYnNlbWknOidcXHUyMDRGJywnYnNpbSc6J1xcdTIyM0QnLCdic2ltZSc6J1xcdTIyQ0QnLCdic29sJzonXFxcXCcsJ2Jzb2xiJzonXFx1MjlDNScsJ2Jzb2xoc3ViJzonXFx1MjdDOCcsJ2J1bGwnOidcXHUyMDIyJywnYnVsbGV0JzonXFx1MjAyMicsJ2J1bXAnOidcXHUyMjRFJywnYnVtcGUnOidcXHUyMjRGJywnYnVtcEUnOidcXHUyQUFFJywnYnVtcGVxJzonXFx1MjI0RicsJ0J1bXBlcSc6J1xcdTIyNEUnLCdjYWN1dGUnOidcXHUwMTA3JywnQ2FjdXRlJzonXFx1MDEwNicsJ2NhcCc6J1xcdTIyMjknLCdDYXAnOidcXHUyMkQyJywnY2FwYW5kJzonXFx1MkE0NCcsJ2NhcGJyY3VwJzonXFx1MkE0OScsJ2NhcGNhcCc6J1xcdTJBNEInLCdjYXBjdXAnOidcXHUyQTQ3JywnY2FwZG90JzonXFx1MkE0MCcsJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJzonXFx1MjE0NScsJ2NhcHMnOidcXHUyMjI5XFx1RkUwMCcsJ2NhcmV0JzonXFx1MjA0MScsJ2Nhcm9uJzonXFx1MDJDNycsJ0NheWxleXMnOidcXHUyMTJEJywnY2NhcHMnOidcXHUyQTREJywnY2Nhcm9uJzonXFx1MDEwRCcsJ0NjYXJvbic6J1xcdTAxMEMnLCdjY2VkaWwnOidcXHhFNycsJ0NjZWRpbCc6J1xceEM3JywnY2NpcmMnOidcXHUwMTA5JywnQ2NpcmMnOidcXHUwMTA4JywnQ2NvbmludCc6J1xcdTIyMzAnLCdjY3Vwcyc6J1xcdTJBNEMnLCdjY3Vwc3NtJzonXFx1MkE1MCcsJ2Nkb3QnOidcXHUwMTBCJywnQ2RvdCc6J1xcdTAxMEEnLCdjZWRpbCc6J1xceEI4JywnQ2VkaWxsYSc6J1xceEI4JywnY2VtcHR5dic6J1xcdTI5QjInLCdjZW50JzonXFx4QTInLCdjZW50ZXJkb3QnOidcXHhCNycsJ0NlbnRlckRvdCc6J1xceEI3JywnY2ZyJzonXFx1RDgzNVxcdUREMjAnLCdDZnInOidcXHUyMTJEJywnY2hjeSc6J1xcdTA0NDcnLCdDSGN5JzonXFx1MDQyNycsJ2NoZWNrJzonXFx1MjcxMycsJ2NoZWNrbWFyayc6J1xcdTI3MTMnLCdjaGknOidcXHUwM0M3JywnQ2hpJzonXFx1MDNBNycsJ2Npcic6J1xcdTI1Q0InLCdjaXJjJzonXFx1MDJDNicsJ2NpcmNlcSc6J1xcdTIyNTcnLCdjaXJjbGVhcnJvd2xlZnQnOidcXHUyMUJBJywnY2lyY2xlYXJyb3dyaWdodCc6J1xcdTIxQkInLCdjaXJjbGVkYXN0JzonXFx1MjI5QicsJ2NpcmNsZWRjaXJjJzonXFx1MjI5QScsJ2NpcmNsZWRkYXNoJzonXFx1MjI5RCcsJ0NpcmNsZURvdCc6J1xcdTIyOTknLCdjaXJjbGVkUic6J1xceEFFJywnY2lyY2xlZFMnOidcXHUyNEM4JywnQ2lyY2xlTWludXMnOidcXHUyMjk2JywnQ2lyY2xlUGx1cyc6J1xcdTIyOTUnLCdDaXJjbGVUaW1lcyc6J1xcdTIyOTcnLCdjaXJlJzonXFx1MjI1NycsJ2NpckUnOidcXHUyOUMzJywnY2lyZm5pbnQnOidcXHUyQTEwJywnY2lybWlkJzonXFx1MkFFRicsJ2NpcnNjaXInOidcXHUyOUMyJywnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFx1MjIzMicsJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZSc6J1xcdTIwMUQnLCdDbG9zZUN1cmx5UXVvdGUnOidcXHUyMDE5JywnY2x1YnMnOidcXHUyNjYzJywnY2x1YnN1aXQnOidcXHUyNjYzJywnY29sb24nOic6JywnQ29sb24nOidcXHUyMjM3JywnY29sb25lJzonXFx1MjI1NCcsJ0NvbG9uZSc6J1xcdTJBNzQnLCdjb2xvbmVxJzonXFx1MjI1NCcsJ2NvbW1hJzonLCcsJ2NvbW1hdCc6J0AnLCdjb21wJzonXFx1MjIwMScsJ2NvbXBmbic6J1xcdTIyMTgnLCdjb21wbGVtZW50JzonXFx1MjIwMScsJ2NvbXBsZXhlcyc6J1xcdTIxMDInLCdjb25nJzonXFx1MjI0NScsJ2Nvbmdkb3QnOidcXHUyQTZEJywnQ29uZ3J1ZW50JzonXFx1MjI2MScsJ2NvbmludCc6J1xcdTIyMkUnLCdDb25pbnQnOidcXHUyMjJGJywnQ29udG91ckludGVncmFsJzonXFx1MjIyRScsJ2NvcGYnOidcXHVEODM1XFx1REQ1NCcsJ0NvcGYnOidcXHUyMTAyJywnY29wcm9kJzonXFx1MjIxMCcsJ0NvcHJvZHVjdCc6J1xcdTIyMTAnLCdjb3B5JzonXFx4QTknLCdDT1BZJzonXFx4QTknLCdjb3B5c3InOidcXHUyMTE3JywnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMzMnLCdjcmFycic6J1xcdTIxQjUnLCdjcm9zcyc6J1xcdTI3MTcnLCdDcm9zcyc6J1xcdTJBMkYnLCdjc2NyJzonXFx1RDgzNVxcdURDQjgnLCdDc2NyJzonXFx1RDgzNVxcdURDOUUnLCdjc3ViJzonXFx1MkFDRicsJ2NzdWJlJzonXFx1MkFEMScsJ2NzdXAnOidcXHUyQUQwJywnY3N1cGUnOidcXHUyQUQyJywnY3Rkb3QnOidcXHUyMkVGJywnY3VkYXJybCc6J1xcdTI5MzgnLCdjdWRhcnJyJzonXFx1MjkzNScsJ2N1ZXByJzonXFx1MjJERScsJ2N1ZXNjJzonXFx1MjJERicsJ2N1bGFycic6J1xcdTIxQjYnLCdjdWxhcnJwJzonXFx1MjkzRCcsJ2N1cCc6J1xcdTIyMkEnLCdDdXAnOidcXHUyMkQzJywnY3VwYnJjYXAnOidcXHUyQTQ4JywnY3VwY2FwJzonXFx1MkE0NicsJ0N1cENhcCc6J1xcdTIyNEQnLCdjdXBjdXAnOidcXHUyQTRBJywnY3VwZG90JzonXFx1MjI4RCcsJ2N1cG9yJzonXFx1MkE0NScsJ2N1cHMnOidcXHUyMjJBXFx1RkUwMCcsJ2N1cmFycic6J1xcdTIxQjcnLCdjdXJhcnJtJzonXFx1MjkzQycsJ2N1cmx5ZXFwcmVjJzonXFx1MjJERScsJ2N1cmx5ZXFzdWNjJzonXFx1MjJERicsJ2N1cmx5dmVlJzonXFx1MjJDRScsJ2N1cmx5d2VkZ2UnOidcXHUyMkNGJywnY3VycmVuJzonXFx4QTQnLCdjdXJ2ZWFycm93bGVmdCc6J1xcdTIxQjYnLCdjdXJ2ZWFycm93cmlnaHQnOidcXHUyMUI3JywnY3V2ZWUnOidcXHUyMkNFJywnY3V3ZWQnOidcXHUyMkNGJywnY3djb25pbnQnOidcXHUyMjMyJywnY3dpbnQnOidcXHUyMjMxJywnY3lsY3R5JzonXFx1MjMyRCcsJ2RhZ2dlcic6J1xcdTIwMjAnLCdEYWdnZXInOidcXHUyMDIxJywnZGFsZXRoJzonXFx1MjEzOCcsJ2RhcnInOidcXHUyMTkzJywnZEFycic6J1xcdTIxRDMnLCdEYXJyJzonXFx1MjFBMScsJ2Rhc2gnOidcXHUyMDEwJywnZGFzaHYnOidcXHUyMkEzJywnRGFzaHYnOidcXHUyQUU0JywnZGJrYXJvdyc6J1xcdTI5MEYnLCdkYmxhYyc6J1xcdTAyREQnLCdkY2Fyb24nOidcXHUwMTBGJywnRGNhcm9uJzonXFx1MDEwRScsJ2RjeSc6J1xcdTA0MzQnLCdEY3knOidcXHUwNDE0JywnZGQnOidcXHUyMTQ2JywnREQnOidcXHUyMTQ1JywnZGRhZ2dlcic6J1xcdTIwMjEnLCdkZGFycic6J1xcdTIxQ0EnLCdERG90cmFoZCc6J1xcdTI5MTEnLCdkZG90c2VxJzonXFx1MkE3NycsJ2RlZyc6J1xceEIwJywnRGVsJzonXFx1MjIwNycsJ2RlbHRhJzonXFx1MDNCNCcsJ0RlbHRhJzonXFx1MDM5NCcsJ2RlbXB0eXYnOidcXHUyOUIxJywnZGZpc2h0JzonXFx1Mjk3RicsJ2Rmcic6J1xcdUQ4MzVcXHVERDIxJywnRGZyJzonXFx1RDgzNVxcdUREMDcnLCdkSGFyJzonXFx1Mjk2NScsJ2RoYXJsJzonXFx1MjFDMycsJ2RoYXJyJzonXFx1MjFDMicsJ0RpYWNyaXRpY2FsQWN1dGUnOidcXHhCNCcsJ0RpYWNyaXRpY2FsRG90JzonXFx1MDJEOScsJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnOidcXHUwMkREJywnRGlhY3JpdGljYWxHcmF2ZSc6J2AnLCdEaWFjcml0aWNhbFRpbGRlJzonXFx1MDJEQycsJ2RpYW0nOidcXHUyMkM0JywnZGlhbW9uZCc6J1xcdTIyQzQnLCdEaWFtb25kJzonXFx1MjJDNCcsJ2RpYW1vbmRzdWl0JzonXFx1MjY2NicsJ2RpYW1zJzonXFx1MjY2NicsJ2RpZSc6J1xceEE4JywnRGlmZmVyZW50aWFsRCc6J1xcdTIxNDYnLCdkaWdhbW1hJzonXFx1MDNERCcsJ2Rpc2luJzonXFx1MjJGMicsJ2Rpdic6J1xceEY3JywnZGl2aWRlJzonXFx4RjcnLCdkaXZpZGVvbnRpbWVzJzonXFx1MjJDNycsJ2Rpdm9ueCc6J1xcdTIyQzcnLCdkamN5JzonXFx1MDQ1MicsJ0RKY3knOidcXHUwNDAyJywnZGxjb3JuJzonXFx1MjMxRScsJ2RsY3JvcCc6J1xcdTIzMEQnLCdkb2xsYXInOickJywnZG9wZic6J1xcdUQ4MzVcXHVERDU1JywnRG9wZic6J1xcdUQ4MzVcXHVERDNCJywnZG90JzonXFx1MDJEOScsJ0RvdCc6J1xceEE4JywnRG90RG90JzonXFx1MjBEQycsJ2RvdGVxJzonXFx1MjI1MCcsJ2RvdGVxZG90JzonXFx1MjI1MScsJ0RvdEVxdWFsJzonXFx1MjI1MCcsJ2RvdG1pbnVzJzonXFx1MjIzOCcsJ2RvdHBsdXMnOidcXHUyMjE0JywnZG90c3F1YXJlJzonXFx1MjJBMScsJ2RvdWJsZWJhcndlZGdlJzonXFx1MjMwNicsJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMkYnLCdEb3VibGVEb3QnOidcXHhBOCcsJ0RvdWJsZURvd25BcnJvdyc6J1xcdTIxRDMnLCdEb3VibGVMZWZ0QXJyb3cnOidcXHUyMUQwJywnRG91YmxlTGVmdFJpZ2h0QXJyb3cnOidcXHUyMUQ0JywnRG91YmxlTGVmdFRlZSc6J1xcdTJBRTQnLCdEb3VibGVMb25nTGVmdEFycm93JzonXFx1MjdGOCcsJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcdTI3RkEnLCdEb3VibGVMb25nUmlnaHRBcnJvdyc6J1xcdTI3RjknLCdEb3VibGVSaWdodEFycm93JzonXFx1MjFEMicsJ0RvdWJsZVJpZ2h0VGVlJzonXFx1MjJBOCcsJ0RvdWJsZVVwQXJyb3cnOidcXHUyMUQxJywnRG91YmxlVXBEb3duQXJyb3cnOidcXHUyMUQ1JywnRG91YmxlVmVydGljYWxCYXInOidcXHUyMjI1JywnZG93bmFycm93JzonXFx1MjE5MycsJ0Rvd25hcnJvdyc6J1xcdTIxRDMnLCdEb3duQXJyb3cnOidcXHUyMTkzJywnRG93bkFycm93QmFyJzonXFx1MjkxMycsJ0Rvd25BcnJvd1VwQXJyb3cnOidcXHUyMUY1JywnRG93bkJyZXZlJzonXFx1MDMxMScsJ2Rvd25kb3duYXJyb3dzJzonXFx1MjFDQScsJ2Rvd25oYXJwb29ubGVmdCc6J1xcdTIxQzMnLCdkb3duaGFycG9vbnJpZ2h0JzonXFx1MjFDMicsJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOidcXHUyOTUwJywnRG93bkxlZnRUZWVWZWN0b3InOidcXHUyOTVFJywnRG93bkxlZnRWZWN0b3InOidcXHUyMUJEJywnRG93bkxlZnRWZWN0b3JCYXInOidcXHUyOTU2JywnRG93blJpZ2h0VGVlVmVjdG9yJzonXFx1Mjk1RicsJ0Rvd25SaWdodFZlY3Rvcic6J1xcdTIxQzEnLCdEb3duUmlnaHRWZWN0b3JCYXInOidcXHUyOTU3JywnRG93blRlZSc6J1xcdTIyQTQnLCdEb3duVGVlQXJyb3cnOidcXHUyMUE3JywnZHJia2Fyb3cnOidcXHUyOTEwJywnZHJjb3JuJzonXFx1MjMxRicsJ2RyY3JvcCc6J1xcdTIzMEMnLCdkc2NyJzonXFx1RDgzNVxcdURDQjknLCdEc2NyJzonXFx1RDgzNVxcdURDOUYnLCdkc2N5JzonXFx1MDQ1NScsJ0RTY3knOidcXHUwNDA1JywnZHNvbCc6J1xcdTI5RjYnLCdkc3Ryb2snOidcXHUwMTExJywnRHN0cm9rJzonXFx1MDExMCcsJ2R0ZG90JzonXFx1MjJGMScsJ2R0cmknOidcXHUyNUJGJywnZHRyaWYnOidcXHUyNUJFJywnZHVhcnInOidcXHUyMUY1JywnZHVoYXInOidcXHUyOTZGJywnZHdhbmdsZSc6J1xcdTI5QTYnLCdkemN5JzonXFx1MDQ1RicsJ0RaY3knOidcXHUwNDBGJywnZHppZ3JhcnInOidcXHUyN0ZGJywnZWFjdXRlJzonXFx4RTknLCdFYWN1dGUnOidcXHhDOScsJ2Vhc3Rlcic6J1xcdTJBNkUnLCdlY2Fyb24nOidcXHUwMTFCJywnRWNhcm9uJzonXFx1MDExQScsJ2VjaXInOidcXHUyMjU2JywnZWNpcmMnOidcXHhFQScsJ0VjaXJjJzonXFx4Q0EnLCdlY29sb24nOidcXHUyMjU1JywnZWN5JzonXFx1MDQ0RCcsJ0VjeSc6J1xcdTA0MkQnLCdlRERvdCc6J1xcdTJBNzcnLCdlZG90JzonXFx1MDExNycsJ2VEb3QnOidcXHUyMjUxJywnRWRvdCc6J1xcdTAxMTYnLCdlZSc6J1xcdTIxNDcnLCdlZkRvdCc6J1xcdTIyNTInLCdlZnInOidcXHVEODM1XFx1REQyMicsJ0Vmcic6J1xcdUQ4MzVcXHVERDA4JywnZWcnOidcXHUyQTlBJywnZWdyYXZlJzonXFx4RTgnLCdFZ3JhdmUnOidcXHhDOCcsJ2Vncyc6J1xcdTJBOTYnLCdlZ3Nkb3QnOidcXHUyQTk4JywnZWwnOidcXHUyQTk5JywnRWxlbWVudCc6J1xcdTIyMDgnLCdlbGludGVycyc6J1xcdTIzRTcnLCdlbGwnOidcXHUyMTEzJywnZWxzJzonXFx1MkE5NScsJ2Vsc2RvdCc6J1xcdTJBOTcnLCdlbWFjcic6J1xcdTAxMTMnLCdFbWFjcic6J1xcdTAxMTInLCdlbXB0eSc6J1xcdTIyMDUnLCdlbXB0eXNldCc6J1xcdTIyMDUnLCdFbXB0eVNtYWxsU3F1YXJlJzonXFx1MjVGQicsJ2VtcHR5dic6J1xcdTIyMDUnLCdFbXB0eVZlcnlTbWFsbFNxdWFyZSc6J1xcdTI1QUInLCdlbXNwJzonXFx1MjAwMycsJ2Vtc3AxMyc6J1xcdTIwMDQnLCdlbXNwMTQnOidcXHUyMDA1JywnZW5nJzonXFx1MDE0QicsJ0VORyc6J1xcdTAxNEEnLCdlbnNwJzonXFx1MjAwMicsJ2VvZ29uJzonXFx1MDExOScsJ0VvZ29uJzonXFx1MDExOCcsJ2VvcGYnOidcXHVEODM1XFx1REQ1NicsJ0VvcGYnOidcXHVEODM1XFx1REQzQycsJ2VwYXInOidcXHUyMkQ1JywnZXBhcnNsJzonXFx1MjlFMycsJ2VwbHVzJzonXFx1MkE3MScsJ2Vwc2knOidcXHUwM0I1JywnZXBzaWxvbic6J1xcdTAzQjUnLCdFcHNpbG9uJzonXFx1MDM5NScsJ2Vwc2l2JzonXFx1MDNGNScsJ2VxY2lyYyc6J1xcdTIyNTYnLCdlcWNvbG9uJzonXFx1MjI1NScsJ2Vxc2ltJzonXFx1MjI0MicsJ2Vxc2xhbnRndHInOidcXHUyQTk2JywnZXFzbGFudGxlc3MnOidcXHUyQTk1JywnRXF1YWwnOidcXHUyQTc1JywnZXF1YWxzJzonPScsJ0VxdWFsVGlsZGUnOidcXHUyMjQyJywnZXF1ZXN0JzonXFx1MjI1RicsJ0VxdWlsaWJyaXVtJzonXFx1MjFDQycsJ2VxdWl2JzonXFx1MjI2MScsJ2VxdWl2REQnOidcXHUyQTc4JywnZXF2cGFyc2wnOidcXHUyOUU1JywnZXJhcnInOidcXHUyOTcxJywnZXJEb3QnOidcXHUyMjUzJywnZXNjcic6J1xcdTIxMkYnLCdFc2NyJzonXFx1MjEzMCcsJ2VzZG90JzonXFx1MjI1MCcsJ2VzaW0nOidcXHUyMjQyJywnRXNpbSc6J1xcdTJBNzMnLCdldGEnOidcXHUwM0I3JywnRXRhJzonXFx1MDM5NycsJ2V0aCc6J1xceEYwJywnRVRIJzonXFx4RDAnLCdldW1sJzonXFx4RUInLCdFdW1sJzonXFx4Q0InLCdldXJvJzonXFx1MjBBQycsJ2V4Y2wnOichJywnZXhpc3QnOidcXHUyMjAzJywnRXhpc3RzJzonXFx1MjIwMycsJ2V4cGVjdGF0aW9uJzonXFx1MjEzMCcsJ2V4cG9uZW50aWFsZSc6J1xcdTIxNDcnLCdFeHBvbmVudGlhbEUnOidcXHUyMTQ3JywnZmFsbGluZ2RvdHNlcSc6J1xcdTIyNTInLCdmY3knOidcXHUwNDQ0JywnRmN5JzonXFx1MDQyNCcsJ2ZlbWFsZSc6J1xcdTI2NDAnLCdmZmlsaWcnOidcXHVGQjAzJywnZmZsaWcnOidcXHVGQjAwJywnZmZsbGlnJzonXFx1RkIwNCcsJ2Zmcic6J1xcdUQ4MzVcXHVERDIzJywnRmZyJzonXFx1RDgzNVxcdUREMDknLCdmaWxpZyc6J1xcdUZCMDEnLCdGaWxsZWRTbWFsbFNxdWFyZSc6J1xcdTI1RkMnLCdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOidcXHUyNUFBJywnZmpsaWcnOidmaicsJ2ZsYXQnOidcXHUyNjZEJywnZmxsaWcnOidcXHVGQjAyJywnZmx0bnMnOidcXHUyNUIxJywnZm5vZic6J1xcdTAxOTInLCdmb3BmJzonXFx1RDgzNVxcdURENTcnLCdGb3BmJzonXFx1RDgzNVxcdUREM0QnLCdmb3JhbGwnOidcXHUyMjAwJywnRm9yQWxsJzonXFx1MjIwMCcsJ2ZvcmsnOidcXHUyMkQ0JywnZm9ya3YnOidcXHUyQUQ5JywnRm91cmllcnRyZic6J1xcdTIxMzEnLCdmcGFydGludCc6J1xcdTJBMEQnLCdmcmFjMTInOidcXHhCRCcsJ2ZyYWMxMyc6J1xcdTIxNTMnLCdmcmFjMTQnOidcXHhCQycsJ2ZyYWMxNSc6J1xcdTIxNTUnLCdmcmFjMTYnOidcXHUyMTU5JywnZnJhYzE4JzonXFx1MjE1QicsJ2ZyYWMyMyc6J1xcdTIxNTQnLCdmcmFjMjUnOidcXHUyMTU2JywnZnJhYzM0JzonXFx4QkUnLCdmcmFjMzUnOidcXHUyMTU3JywnZnJhYzM4JzonXFx1MjE1QycsJ2ZyYWM0NSc6J1xcdTIxNTgnLCdmcmFjNTYnOidcXHUyMTVBJywnZnJhYzU4JzonXFx1MjE1RCcsJ2ZyYWM3OCc6J1xcdTIxNUUnLCdmcmFzbCc6J1xcdTIwNDQnLCdmcm93bic6J1xcdTIzMjInLCdmc2NyJzonXFx1RDgzNVxcdURDQkInLCdGc2NyJzonXFx1MjEzMScsJ2dhY3V0ZSc6J1xcdTAxRjUnLCdnYW1tYSc6J1xcdTAzQjMnLCdHYW1tYSc6J1xcdTAzOTMnLCdnYW1tYWQnOidcXHUwM0REJywnR2FtbWFkJzonXFx1MDNEQycsJ2dhcCc6J1xcdTJBODYnLCdnYnJldmUnOidcXHUwMTFGJywnR2JyZXZlJzonXFx1MDExRScsJ0djZWRpbCc6J1xcdTAxMjInLCdnY2lyYyc6J1xcdTAxMUQnLCdHY2lyYyc6J1xcdTAxMUMnLCdnY3knOidcXHUwNDMzJywnR2N5JzonXFx1MDQxMycsJ2dkb3QnOidcXHUwMTIxJywnR2RvdCc6J1xcdTAxMjAnLCdnZSc6J1xcdTIyNjUnLCdnRSc6J1xcdTIyNjcnLCdnZWwnOidcXHUyMkRCJywnZ0VsJzonXFx1MkE4QycsJ2dlcSc6J1xcdTIyNjUnLCdnZXFxJzonXFx1MjI2NycsJ2dlcXNsYW50JzonXFx1MkE3RScsJ2dlcyc6J1xcdTJBN0UnLCdnZXNjYyc6J1xcdTJBQTknLCdnZXNkb3QnOidcXHUyQTgwJywnZ2VzZG90byc6J1xcdTJBODInLCdnZXNkb3RvbCc6J1xcdTJBODQnLCdnZXNsJzonXFx1MjJEQlxcdUZFMDAnLCdnZXNsZXMnOidcXHUyQTk0JywnZ2ZyJzonXFx1RDgzNVxcdUREMjQnLCdHZnInOidcXHVEODM1XFx1REQwQScsJ2dnJzonXFx1MjI2QicsJ0dnJzonXFx1MjJEOScsJ2dnZyc6J1xcdTIyRDknLCdnaW1lbCc6J1xcdTIxMzcnLCdnamN5JzonXFx1MDQ1MycsJ0dKY3knOidcXHUwNDAzJywnZ2wnOidcXHUyMjc3JywnZ2xhJzonXFx1MkFBNScsJ2dsRSc6J1xcdTJBOTInLCdnbGonOidcXHUyQUE0JywnZ25hcCc6J1xcdTJBOEEnLCdnbmFwcHJveCc6J1xcdTJBOEEnLCdnbmUnOidcXHUyQTg4JywnZ25FJzonXFx1MjI2OScsJ2duZXEnOidcXHUyQTg4JywnZ25lcXEnOidcXHUyMjY5JywnZ25zaW0nOidcXHUyMkU3JywnZ29wZic6J1xcdUQ4MzVcXHVERDU4JywnR29wZic6J1xcdUQ4MzVcXHVERDNFJywnZ3JhdmUnOidgJywnR3JlYXRlckVxdWFsJzonXFx1MjI2NScsJ0dyZWF0ZXJFcXVhbExlc3MnOidcXHUyMkRCJywnR3JlYXRlckZ1bGxFcXVhbCc6J1xcdTIyNjcnLCdHcmVhdGVyR3JlYXRlcic6J1xcdTJBQTInLCdHcmVhdGVyTGVzcyc6J1xcdTIyNzcnLCdHcmVhdGVyU2xhbnRFcXVhbCc6J1xcdTJBN0UnLCdHcmVhdGVyVGlsZGUnOidcXHUyMjczJywnZ3Njcic6J1xcdTIxMEEnLCdHc2NyJzonXFx1RDgzNVxcdURDQTInLCdnc2ltJzonXFx1MjI3MycsJ2dzaW1lJzonXFx1MkE4RScsJ2dzaW1sJzonXFx1MkE5MCcsJ2d0JzonPicsJ0d0JzonXFx1MjI2QicsJ0dUJzonPicsJ2d0Y2MnOidcXHUyQUE3JywnZ3RjaXInOidcXHUyQTdBJywnZ3Rkb3QnOidcXHUyMkQ3JywnZ3RsUGFyJzonXFx1Mjk5NScsJ2d0cXVlc3QnOidcXHUyQTdDJywnZ3RyYXBwcm94JzonXFx1MkE4NicsJ2d0cmFycic6J1xcdTI5NzgnLCdndHJkb3QnOidcXHUyMkQ3JywnZ3RyZXFsZXNzJzonXFx1MjJEQicsJ2d0cmVxcWxlc3MnOidcXHUyQThDJywnZ3RybGVzcyc6J1xcdTIyNzcnLCdndHJzaW0nOidcXHUyMjczJywnZ3ZlcnRuZXFxJzonXFx1MjI2OVxcdUZFMDAnLCdndm5FJzonXFx1MjI2OVxcdUZFMDAnLCdIYWNlayc6J1xcdTAyQzcnLCdoYWlyc3AnOidcXHUyMDBBJywnaGFsZic6J1xceEJEJywnaGFtaWx0JzonXFx1MjEwQicsJ2hhcmRjeSc6J1xcdTA0NEEnLCdIQVJEY3knOidcXHUwNDJBJywnaGFycic6J1xcdTIxOTQnLCdoQXJyJzonXFx1MjFENCcsJ2hhcnJjaXInOidcXHUyOTQ4JywnaGFycncnOidcXHUyMUFEJywnSGF0JzonXicsJ2hiYXInOidcXHUyMTBGJywnaGNpcmMnOidcXHUwMTI1JywnSGNpcmMnOidcXHUwMTI0JywnaGVhcnRzJzonXFx1MjY2NScsJ2hlYXJ0c3VpdCc6J1xcdTI2NjUnLCdoZWxsaXAnOidcXHUyMDI2JywnaGVyY29uJzonXFx1MjJCOScsJ2hmcic6J1xcdUQ4MzVcXHVERDI1JywnSGZyJzonXFx1MjEwQycsJ0hpbGJlcnRTcGFjZSc6J1xcdTIxMEInLCdoa3NlYXJvdyc6J1xcdTI5MjUnLCdoa3N3YXJvdyc6J1xcdTI5MjYnLCdob2Fycic6J1xcdTIxRkYnLCdob210aHQnOidcXHUyMjNCJywnaG9va2xlZnRhcnJvdyc6J1xcdTIxQTknLCdob29rcmlnaHRhcnJvdyc6J1xcdTIxQUEnLCdob3BmJzonXFx1RDgzNVxcdURENTknLCdIb3BmJzonXFx1MjEwRCcsJ2hvcmJhcic6J1xcdTIwMTUnLCdIb3Jpem9udGFsTGluZSc6J1xcdTI1MDAnLCdoc2NyJzonXFx1RDgzNVxcdURDQkQnLCdIc2NyJzonXFx1MjEwQicsJ2hzbGFzaCc6J1xcdTIxMEYnLCdoc3Ryb2snOidcXHUwMTI3JywnSHN0cm9rJzonXFx1MDEyNicsJ0h1bXBEb3duSHVtcCc6J1xcdTIyNEUnLCdIdW1wRXF1YWwnOidcXHUyMjRGJywnaHlidWxsJzonXFx1MjA0MycsJ2h5cGhlbic6J1xcdTIwMTAnLCdpYWN1dGUnOidcXHhFRCcsJ0lhY3V0ZSc6J1xceENEJywnaWMnOidcXHUyMDYzJywnaWNpcmMnOidcXHhFRScsJ0ljaXJjJzonXFx4Q0UnLCdpY3knOidcXHUwNDM4JywnSWN5JzonXFx1MDQxOCcsJ0lkb3QnOidcXHUwMTMwJywnaWVjeSc6J1xcdTA0MzUnLCdJRWN5JzonXFx1MDQxNScsJ2lleGNsJzonXFx4QTEnLCdpZmYnOidcXHUyMUQ0JywnaWZyJzonXFx1RDgzNVxcdUREMjYnLCdJZnInOidcXHUyMTExJywnaWdyYXZlJzonXFx4RUMnLCdJZ3JhdmUnOidcXHhDQycsJ2lpJzonXFx1MjE0OCcsJ2lpaWludCc6J1xcdTJBMEMnLCdpaWludCc6J1xcdTIyMkQnLCdpaW5maW4nOidcXHUyOURDJywnaWlvdGEnOidcXHUyMTI5JywnaWpsaWcnOidcXHUwMTMzJywnSUpsaWcnOidcXHUwMTMyJywnSW0nOidcXHUyMTExJywnaW1hY3InOidcXHUwMTJCJywnSW1hY3InOidcXHUwMTJBJywnaW1hZ2UnOidcXHUyMTExJywnSW1hZ2luYXJ5SSc6J1xcdTIxNDgnLCdpbWFnbGluZSc6J1xcdTIxMTAnLCdpbWFncGFydCc6J1xcdTIxMTEnLCdpbWF0aCc6J1xcdTAxMzEnLCdpbW9mJzonXFx1MjJCNycsJ2ltcGVkJzonXFx1MDFCNScsJ0ltcGxpZXMnOidcXHUyMUQyJywnaW4nOidcXHUyMjA4JywnaW5jYXJlJzonXFx1MjEwNScsJ2luZmluJzonXFx1MjIxRScsJ2luZmludGllJzonXFx1MjlERCcsJ2lub2RvdCc6J1xcdTAxMzEnLCdpbnQnOidcXHUyMjJCJywnSW50JzonXFx1MjIyQycsJ2ludGNhbCc6J1xcdTIyQkEnLCdpbnRlZ2Vycyc6J1xcdTIxMjQnLCdJbnRlZ3JhbCc6J1xcdTIyMkInLCdpbnRlcmNhbCc6J1xcdTIyQkEnLCdJbnRlcnNlY3Rpb24nOidcXHUyMkMyJywnaW50bGFyaGsnOidcXHUyQTE3JywnaW50cHJvZCc6J1xcdTJBM0MnLCdJbnZpc2libGVDb21tYSc6J1xcdTIwNjMnLCdJbnZpc2libGVUaW1lcyc6J1xcdTIwNjInLCdpb2N5JzonXFx1MDQ1MScsJ0lPY3knOidcXHUwNDAxJywnaW9nb24nOidcXHUwMTJGJywnSW9nb24nOidcXHUwMTJFJywnaW9wZic6J1xcdUQ4MzVcXHVERDVBJywnSW9wZic6J1xcdUQ4MzVcXHVERDQwJywnaW90YSc6J1xcdTAzQjknLCdJb3RhJzonXFx1MDM5OScsJ2lwcm9kJzonXFx1MkEzQycsJ2lxdWVzdCc6J1xceEJGJywnaXNjcic6J1xcdUQ4MzVcXHVEQ0JFJywnSXNjcic6J1xcdTIxMTAnLCdpc2luJzonXFx1MjIwOCcsJ2lzaW5kb3QnOidcXHUyMkY1JywnaXNpbkUnOidcXHUyMkY5JywnaXNpbnMnOidcXHUyMkY0JywnaXNpbnN2JzonXFx1MjJGMycsJ2lzaW52JzonXFx1MjIwOCcsJ2l0JzonXFx1MjA2MicsJ2l0aWxkZSc6J1xcdTAxMjknLCdJdGlsZGUnOidcXHUwMTI4JywnaXVrY3knOidcXHUwNDU2JywnSXVrY3knOidcXHUwNDA2JywnaXVtbCc6J1xceEVGJywnSXVtbCc6J1xceENGJywnamNpcmMnOidcXHUwMTM1JywnSmNpcmMnOidcXHUwMTM0JywnamN5JzonXFx1MDQzOScsJ0pjeSc6J1xcdTA0MTknLCdqZnInOidcXHVEODM1XFx1REQyNycsJ0pmcic6J1xcdUQ4MzVcXHVERDBEJywnam1hdGgnOidcXHUwMjM3Jywnam9wZic6J1xcdUQ4MzVcXHVERDVCJywnSm9wZic6J1xcdUQ4MzVcXHVERDQxJywnanNjcic6J1xcdUQ4MzVcXHVEQ0JGJywnSnNjcic6J1xcdUQ4MzVcXHVEQ0E1JywnanNlcmN5JzonXFx1MDQ1OCcsJ0pzZXJjeSc6J1xcdTA0MDgnLCdqdWtjeSc6J1xcdTA0NTQnLCdKdWtjeSc6J1xcdTA0MDQnLCdrYXBwYSc6J1xcdTAzQkEnLCdLYXBwYSc6J1xcdTAzOUEnLCdrYXBwYXYnOidcXHUwM0YwJywna2NlZGlsJzonXFx1MDEzNycsJ0tjZWRpbCc6J1xcdTAxMzYnLCdrY3knOidcXHUwNDNBJywnS2N5JzonXFx1MDQxQScsJ2tmcic6J1xcdUQ4MzVcXHVERDI4JywnS2ZyJzonXFx1RDgzNVxcdUREMEUnLCdrZ3JlZW4nOidcXHUwMTM4Jywna2hjeSc6J1xcdTA0NDUnLCdLSGN5JzonXFx1MDQyNScsJ2tqY3knOidcXHUwNDVDJywnS0pjeSc6J1xcdTA0MEMnLCdrb3BmJzonXFx1RDgzNVxcdURENUMnLCdLb3BmJzonXFx1RDgzNVxcdURENDInLCdrc2NyJzonXFx1RDgzNVxcdURDQzAnLCdLc2NyJzonXFx1RDgzNVxcdURDQTYnLCdsQWFycic6J1xcdTIxREEnLCdsYWN1dGUnOidcXHUwMTNBJywnTGFjdXRlJzonXFx1MDEzOScsJ2xhZW1wdHl2JzonXFx1MjlCNCcsJ2xhZ3Jhbic6J1xcdTIxMTInLCdsYW1iZGEnOidcXHUwM0JCJywnTGFtYmRhJzonXFx1MDM5QicsJ2xhbmcnOidcXHUyN0U4JywnTGFuZyc6J1xcdTI3RUEnLCdsYW5nZCc6J1xcdTI5OTEnLCdsYW5nbGUnOidcXHUyN0U4JywnbGFwJzonXFx1MkE4NScsJ0xhcGxhY2V0cmYnOidcXHUyMTEyJywnbGFxdW8nOidcXHhBQicsJ2xhcnInOidcXHUyMTkwJywnbEFycic6J1xcdTIxRDAnLCdMYXJyJzonXFx1MjE5RScsJ2xhcnJiJzonXFx1MjFFNCcsJ2xhcnJiZnMnOidcXHUyOTFGJywnbGFycmZzJzonXFx1MjkxRCcsJ2xhcnJoayc6J1xcdTIxQTknLCdsYXJybHAnOidcXHUyMUFCJywnbGFycnBsJzonXFx1MjkzOScsJ2xhcnJzaW0nOidcXHUyOTczJywnbGFycnRsJzonXFx1MjFBMicsJ2xhdCc6J1xcdTJBQUInLCdsYXRhaWwnOidcXHUyOTE5JywnbEF0YWlsJzonXFx1MjkxQicsJ2xhdGUnOidcXHUyQUFEJywnbGF0ZXMnOidcXHUyQUFEXFx1RkUwMCcsJ2xiYXJyJzonXFx1MjkwQycsJ2xCYXJyJzonXFx1MjkwRScsJ2xiYnJrJzonXFx1Mjc3MicsJ2xicmFjZSc6J3snLCdsYnJhY2snOidbJywnbGJya2UnOidcXHUyOThCJywnbGJya3NsZCc6J1xcdTI5OEYnLCdsYnJrc2x1JzonXFx1Mjk4RCcsJ2xjYXJvbic6J1xcdTAxM0UnLCdMY2Fyb24nOidcXHUwMTNEJywnbGNlZGlsJzonXFx1MDEzQycsJ0xjZWRpbCc6J1xcdTAxM0InLCdsY2VpbCc6J1xcdTIzMDgnLCdsY3ViJzoneycsJ2xjeSc6J1xcdTA0M0InLCdMY3knOidcXHUwNDFCJywnbGRjYSc6J1xcdTI5MzYnLCdsZHF1byc6J1xcdTIwMUMnLCdsZHF1b3InOidcXHUyMDFFJywnbGRyZGhhcic6J1xcdTI5NjcnLCdsZHJ1c2hhcic6J1xcdTI5NEInLCdsZHNoJzonXFx1MjFCMicsJ2xlJzonXFx1MjI2NCcsJ2xFJzonXFx1MjI2NicsJ0xlZnRBbmdsZUJyYWNrZXQnOidcXHUyN0U4JywnbGVmdGFycm93JzonXFx1MjE5MCcsJ0xlZnRhcnJvdyc6J1xcdTIxRDAnLCdMZWZ0QXJyb3cnOidcXHUyMTkwJywnTGVmdEFycm93QmFyJzonXFx1MjFFNCcsJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnOidcXHUyMUM2JywnbGVmdGFycm93dGFpbCc6J1xcdTIxQTInLCdMZWZ0Q2VpbGluZyc6J1xcdTIzMDgnLCdMZWZ0RG91YmxlQnJhY2tldCc6J1xcdTI3RTYnLCdMZWZ0RG93blRlZVZlY3Rvcic6J1xcdTI5NjEnLCdMZWZ0RG93blZlY3Rvcic6J1xcdTIxQzMnLCdMZWZ0RG93blZlY3RvckJhcic6J1xcdTI5NTknLCdMZWZ0Rmxvb3InOidcXHUyMzBBJywnbGVmdGhhcnBvb25kb3duJzonXFx1MjFCRCcsJ2xlZnRoYXJwb29udXAnOidcXHUyMUJDJywnbGVmdGxlZnRhcnJvd3MnOidcXHUyMUM3JywnbGVmdHJpZ2h0YXJyb3cnOidcXHUyMTk0JywnTGVmdHJpZ2h0YXJyb3cnOidcXHUyMUQ0JywnTGVmdFJpZ2h0QXJyb3cnOidcXHUyMTk0JywnbGVmdHJpZ2h0YXJyb3dzJzonXFx1MjFDNicsJ2xlZnRyaWdodGhhcnBvb25zJzonXFx1MjFDQicsJ2xlZnRyaWdodHNxdWlnYXJyb3cnOidcXHUyMUFEJywnTGVmdFJpZ2h0VmVjdG9yJzonXFx1Mjk0RScsJ0xlZnRUZWUnOidcXHUyMkEzJywnTGVmdFRlZUFycm93JzonXFx1MjFBNCcsJ0xlZnRUZWVWZWN0b3InOidcXHUyOTVBJywnbGVmdHRocmVldGltZXMnOidcXHUyMkNCJywnTGVmdFRyaWFuZ2xlJzonXFx1MjJCMicsJ0xlZnRUcmlhbmdsZUJhcic6J1xcdTI5Q0YnLCdMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcdTIyQjQnLCdMZWZ0VXBEb3duVmVjdG9yJzonXFx1Mjk1MScsJ0xlZnRVcFRlZVZlY3Rvcic6J1xcdTI5NjAnLCdMZWZ0VXBWZWN0b3InOidcXHUyMUJGJywnTGVmdFVwVmVjdG9yQmFyJzonXFx1Mjk1OCcsJ0xlZnRWZWN0b3InOidcXHUyMUJDJywnTGVmdFZlY3RvckJhcic6J1xcdTI5NTInLCdsZWcnOidcXHUyMkRBJywnbEVnJzonXFx1MkE4QicsJ2xlcSc6J1xcdTIyNjQnLCdsZXFxJzonXFx1MjI2NicsJ2xlcXNsYW50JzonXFx1MkE3RCcsJ2xlcyc6J1xcdTJBN0QnLCdsZXNjYyc6J1xcdTJBQTgnLCdsZXNkb3QnOidcXHUyQTdGJywnbGVzZG90byc6J1xcdTJBODEnLCdsZXNkb3Rvcic6J1xcdTJBODMnLCdsZXNnJzonXFx1MjJEQVxcdUZFMDAnLCdsZXNnZXMnOidcXHUyQTkzJywnbGVzc2FwcHJveCc6J1xcdTJBODUnLCdsZXNzZG90JzonXFx1MjJENicsJ2xlc3NlcWd0cic6J1xcdTIyREEnLCdsZXNzZXFxZ3RyJzonXFx1MkE4QicsJ0xlc3NFcXVhbEdyZWF0ZXInOidcXHUyMkRBJywnTGVzc0Z1bGxFcXVhbCc6J1xcdTIyNjYnLCdMZXNzR3JlYXRlcic6J1xcdTIyNzYnLCdsZXNzZ3RyJzonXFx1MjI3NicsJ0xlc3NMZXNzJzonXFx1MkFBMScsJ2xlc3NzaW0nOidcXHUyMjcyJywnTGVzc1NsYW50RXF1YWwnOidcXHUyQTdEJywnTGVzc1RpbGRlJzonXFx1MjI3MicsJ2xmaXNodCc6J1xcdTI5N0MnLCdsZmxvb3InOidcXHUyMzBBJywnbGZyJzonXFx1RDgzNVxcdUREMjknLCdMZnInOidcXHVEODM1XFx1REQwRicsJ2xnJzonXFx1MjI3NicsJ2xnRSc6J1xcdTJBOTEnLCdsSGFyJzonXFx1Mjk2MicsJ2xoYXJkJzonXFx1MjFCRCcsJ2xoYXJ1JzonXFx1MjFCQycsJ2xoYXJ1bCc6J1xcdTI5NkEnLCdsaGJsayc6J1xcdTI1ODQnLCdsamN5JzonXFx1MDQ1OScsJ0xKY3knOidcXHUwNDA5JywnbGwnOidcXHUyMjZBJywnTGwnOidcXHUyMkQ4JywnbGxhcnInOidcXHUyMUM3JywnbGxjb3JuZXInOidcXHUyMzFFJywnTGxlZnRhcnJvdyc6J1xcdTIxREEnLCdsbGhhcmQnOidcXHUyOTZCJywnbGx0cmknOidcXHUyNUZBJywnbG1pZG90JzonXFx1MDE0MCcsJ0xtaWRvdCc6J1xcdTAxM0YnLCdsbW91c3QnOidcXHUyM0IwJywnbG1vdXN0YWNoZSc6J1xcdTIzQjAnLCdsbmFwJzonXFx1MkE4OScsJ2xuYXBwcm94JzonXFx1MkE4OScsJ2xuZSc6J1xcdTJBODcnLCdsbkUnOidcXHUyMjY4JywnbG5lcSc6J1xcdTJBODcnLCdsbmVxcSc6J1xcdTIyNjgnLCdsbnNpbSc6J1xcdTIyRTYnLCdsb2FuZyc6J1xcdTI3RUMnLCdsb2Fycic6J1xcdTIxRkQnLCdsb2Jyayc6J1xcdTI3RTYnLCdsb25nbGVmdGFycm93JzonXFx1MjdGNScsJ0xvbmdsZWZ0YXJyb3cnOidcXHUyN0Y4JywnTG9uZ0xlZnRBcnJvdyc6J1xcdTI3RjUnLCdsb25nbGVmdHJpZ2h0YXJyb3cnOidcXHUyN0Y3JywnTG9uZ2xlZnRyaWdodGFycm93JzonXFx1MjdGQScsJ0xvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcdTI3RjcnLCdsb25nbWFwc3RvJzonXFx1MjdGQycsJ2xvbmdyaWdodGFycm93JzonXFx1MjdGNicsJ0xvbmdyaWdodGFycm93JzonXFx1MjdGOScsJ0xvbmdSaWdodEFycm93JzonXFx1MjdGNicsJ2xvb3BhcnJvd2xlZnQnOidcXHUyMUFCJywnbG9vcGFycm93cmlnaHQnOidcXHUyMUFDJywnbG9wYXInOidcXHUyOTg1JywnbG9wZic6J1xcdUQ4MzVcXHVERDVEJywnTG9wZic6J1xcdUQ4MzVcXHVERDQzJywnbG9wbHVzJzonXFx1MkEyRCcsJ2xvdGltZXMnOidcXHUyQTM0JywnbG93YXN0JzonXFx1MjIxNycsJ2xvd2Jhcic6J18nLCdMb3dlckxlZnRBcnJvdyc6J1xcdTIxOTknLCdMb3dlclJpZ2h0QXJyb3cnOidcXHUyMTk4JywnbG96JzonXFx1MjVDQScsJ2xvemVuZ2UnOidcXHUyNUNBJywnbG96Zic6J1xcdTI5RUInLCdscGFyJzonKCcsJ2xwYXJsdCc6J1xcdTI5OTMnLCdscmFycic6J1xcdTIxQzYnLCdscmNvcm5lcic6J1xcdTIzMUYnLCdscmhhcic6J1xcdTIxQ0InLCdscmhhcmQnOidcXHUyOTZEJywnbHJtJzonXFx1MjAwRScsJ2xydHJpJzonXFx1MjJCRicsJ2xzYXF1byc6J1xcdTIwMzknLCdsc2NyJzonXFx1RDgzNVxcdURDQzEnLCdMc2NyJzonXFx1MjExMicsJ2xzaCc6J1xcdTIxQjAnLCdMc2gnOidcXHUyMUIwJywnbHNpbSc6J1xcdTIyNzInLCdsc2ltZSc6J1xcdTJBOEQnLCdsc2ltZyc6J1xcdTJBOEYnLCdsc3FiJzonWycsJ2xzcXVvJzonXFx1MjAxOCcsJ2xzcXVvcic6J1xcdTIwMUEnLCdsc3Ryb2snOidcXHUwMTQyJywnTHN0cm9rJzonXFx1MDE0MScsJ2x0JzonPCcsJ0x0JzonXFx1MjI2QScsJ0xUJzonPCcsJ2x0Y2MnOidcXHUyQUE2JywnbHRjaXInOidcXHUyQTc5JywnbHRkb3QnOidcXHUyMkQ2JywnbHRocmVlJzonXFx1MjJDQicsJ2x0aW1lcyc6J1xcdTIyQzknLCdsdGxhcnInOidcXHUyOTc2JywnbHRxdWVzdCc6J1xcdTJBN0InLCdsdHJpJzonXFx1MjVDMycsJ2x0cmllJzonXFx1MjJCNCcsJ2x0cmlmJzonXFx1MjVDMicsJ2x0clBhcic6J1xcdTI5OTYnLCdsdXJkc2hhcic6J1xcdTI5NEEnLCdsdXJ1aGFyJzonXFx1Mjk2NicsJ2x2ZXJ0bmVxcSc6J1xcdTIyNjhcXHVGRTAwJywnbHZuRSc6J1xcdTIyNjhcXHVGRTAwJywnbWFjcic6J1xceEFGJywnbWFsZSc6J1xcdTI2NDInLCdtYWx0JzonXFx1MjcyMCcsJ21hbHRlc2UnOidcXHUyNzIwJywnbWFwJzonXFx1MjFBNicsJ01hcCc6J1xcdTI5MDUnLCdtYXBzdG8nOidcXHUyMUE2JywnbWFwc3RvZG93bic6J1xcdTIxQTcnLCdtYXBzdG9sZWZ0JzonXFx1MjFBNCcsJ21hcHN0b3VwJzonXFx1MjFBNScsJ21hcmtlcic6J1xcdTI1QUUnLCdtY29tbWEnOidcXHUyQTI5JywnbWN5JzonXFx1MDQzQycsJ01jeSc6J1xcdTA0MUMnLCdtZGFzaCc6J1xcdTIwMTQnLCdtRERvdCc6J1xcdTIyM0EnLCdtZWFzdXJlZGFuZ2xlJzonXFx1MjIyMScsJ01lZGl1bVNwYWNlJzonXFx1MjA1RicsJ01lbGxpbnRyZic6J1xcdTIxMzMnLCdtZnInOidcXHVEODM1XFx1REQyQScsJ01mcic6J1xcdUQ4MzVcXHVERDEwJywnbWhvJzonXFx1MjEyNycsJ21pY3JvJzonXFx4QjUnLCdtaWQnOidcXHUyMjIzJywnbWlkYXN0JzonKicsJ21pZGNpcic6J1xcdTJBRjAnLCdtaWRkb3QnOidcXHhCNycsJ21pbnVzJzonXFx1MjIxMicsJ21pbnVzYic6J1xcdTIyOUYnLCdtaW51c2QnOidcXHUyMjM4JywnbWludXNkdSc6J1xcdTJBMkEnLCdNaW51c1BsdXMnOidcXHUyMjEzJywnbWxjcCc6J1xcdTJBREInLCdtbGRyJzonXFx1MjAyNicsJ21ucGx1cyc6J1xcdTIyMTMnLCdtb2RlbHMnOidcXHUyMkE3JywnbW9wZic6J1xcdUQ4MzVcXHVERDVFJywnTW9wZic6J1xcdUQ4MzVcXHVERDQ0JywnbXAnOidcXHUyMjEzJywnbXNjcic6J1xcdUQ4MzVcXHVEQ0MyJywnTXNjcic6J1xcdTIxMzMnLCdtc3Rwb3MnOidcXHUyMjNFJywnbXUnOidcXHUwM0JDJywnTXUnOidcXHUwMzlDJywnbXVsdGltYXAnOidcXHUyMkI4JywnbXVtYXAnOidcXHUyMkI4JywnbmFibGEnOidcXHUyMjA3JywnbmFjdXRlJzonXFx1MDE0NCcsJ05hY3V0ZSc6J1xcdTAxNDMnLCduYW5nJzonXFx1MjIyMFxcdTIwRDInLCduYXAnOidcXHUyMjQ5JywnbmFwRSc6J1xcdTJBNzBcXHUwMzM4JywnbmFwaWQnOidcXHUyMjRCXFx1MDMzOCcsJ25hcG9zJzonXFx1MDE0OScsJ25hcHByb3gnOidcXHUyMjQ5JywnbmF0dXInOidcXHUyNjZFJywnbmF0dXJhbCc6J1xcdTI2NkUnLCduYXR1cmFscyc6J1xcdTIxMTUnLCduYnNwJzonXFx4QTAnLCduYnVtcCc6J1xcdTIyNEVcXHUwMzM4JywnbmJ1bXBlJzonXFx1MjI0RlxcdTAzMzgnLCduY2FwJzonXFx1MkE0MycsJ25jYXJvbic6J1xcdTAxNDgnLCdOY2Fyb24nOidcXHUwMTQ3JywnbmNlZGlsJzonXFx1MDE0NicsJ05jZWRpbCc6J1xcdTAxNDUnLCduY29uZyc6J1xcdTIyNDcnLCduY29uZ2RvdCc6J1xcdTJBNkRcXHUwMzM4JywnbmN1cCc6J1xcdTJBNDInLCduY3knOidcXHUwNDNEJywnTmN5JzonXFx1MDQxRCcsJ25kYXNoJzonXFx1MjAxMycsJ25lJzonXFx1MjI2MCcsJ25lYXJoayc6J1xcdTI5MjQnLCduZWFycic6J1xcdTIxOTcnLCduZUFycic6J1xcdTIxRDcnLCduZWFycm93JzonXFx1MjE5NycsJ25lZG90JzonXFx1MjI1MFxcdTAzMzgnLCdOZWdhdGl2ZU1lZGl1bVNwYWNlJzonXFx1MjAwQicsJ05lZ2F0aXZlVGhpY2tTcGFjZSc6J1xcdTIwMEInLCdOZWdhdGl2ZVRoaW5TcGFjZSc6J1xcdTIwMEInLCdOZWdhdGl2ZVZlcnlUaGluU3BhY2UnOidcXHUyMDBCJywnbmVxdWl2JzonXFx1MjI2MicsJ25lc2Vhcic6J1xcdTI5MjgnLCduZXNpbSc6J1xcdTIyNDJcXHUwMzM4JywnTmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXHUyMjZCJywnTmVzdGVkTGVzc0xlc3MnOidcXHUyMjZBJywnTmV3TGluZSc6J1xcbicsJ25leGlzdCc6J1xcdTIyMDQnLCduZXhpc3RzJzonXFx1MjIwNCcsJ25mcic6J1xcdUQ4MzVcXHVERDJCJywnTmZyJzonXFx1RDgzNVxcdUREMTEnLCduZ2UnOidcXHUyMjcxJywnbmdFJzonXFx1MjI2N1xcdTAzMzgnLCduZ2VxJzonXFx1MjI3MScsJ25nZXFxJzonXFx1MjI2N1xcdTAzMzgnLCduZ2Vxc2xhbnQnOidcXHUyQTdFXFx1MDMzOCcsJ25nZXMnOidcXHUyQTdFXFx1MDMzOCcsJ25HZyc6J1xcdTIyRDlcXHUwMzM4JywnbmdzaW0nOidcXHUyMjc1Jywnbmd0JzonXFx1MjI2RicsJ25HdCc6J1xcdTIyNkJcXHUyMEQyJywnbmd0cic6J1xcdTIyNkYnLCduR3R2JzonXFx1MjI2QlxcdTAzMzgnLCduaGFycic6J1xcdTIxQUUnLCduaEFycic6J1xcdTIxQ0UnLCduaHBhcic6J1xcdTJBRjInLCduaSc6J1xcdTIyMEInLCduaXMnOidcXHUyMkZDJywnbmlzZCc6J1xcdTIyRkEnLCduaXYnOidcXHUyMjBCJywnbmpjeSc6J1xcdTA0NUEnLCdOSmN5JzonXFx1MDQwQScsJ25sYXJyJzonXFx1MjE5QScsJ25sQXJyJzonXFx1MjFDRCcsJ25sZHInOidcXHUyMDI1JywnbmxlJzonXFx1MjI3MCcsJ25sRSc6J1xcdTIyNjZcXHUwMzM4JywnbmxlZnRhcnJvdyc6J1xcdTIxOUEnLCduTGVmdGFycm93JzonXFx1MjFDRCcsJ25sZWZ0cmlnaHRhcnJvdyc6J1xcdTIxQUUnLCduTGVmdHJpZ2h0YXJyb3cnOidcXHUyMUNFJywnbmxlcSc6J1xcdTIyNzAnLCdubGVxcSc6J1xcdTIyNjZcXHUwMzM4JywnbmxlcXNsYW50JzonXFx1MkE3RFxcdTAzMzgnLCdubGVzJzonXFx1MkE3RFxcdTAzMzgnLCdubGVzcyc6J1xcdTIyNkUnLCduTGwnOidcXHUyMkQ4XFx1MDMzOCcsJ25sc2ltJzonXFx1MjI3NCcsJ25sdCc6J1xcdTIyNkUnLCduTHQnOidcXHUyMjZBXFx1MjBEMicsJ25sdHJpJzonXFx1MjJFQScsJ25sdHJpZSc6J1xcdTIyRUMnLCduTHR2JzonXFx1MjI2QVxcdTAzMzgnLCdubWlkJzonXFx1MjIyNCcsJ05vQnJlYWsnOidcXHUyMDYwJywnTm9uQnJlYWtpbmdTcGFjZSc6J1xceEEwJywnbm9wZic6J1xcdUQ4MzVcXHVERDVGJywnTm9wZic6J1xcdTIxMTUnLCdub3QnOidcXHhBQycsJ05vdCc6J1xcdTJBRUMnLCdOb3RDb25ncnVlbnQnOidcXHUyMjYyJywnTm90Q3VwQ2FwJzonXFx1MjI2RCcsJ05vdERvdWJsZVZlcnRpY2FsQmFyJzonXFx1MjIyNicsJ05vdEVsZW1lbnQnOidcXHUyMjA5JywnTm90RXF1YWwnOidcXHUyMjYwJywnTm90RXF1YWxUaWxkZSc6J1xcdTIyNDJcXHUwMzM4JywnTm90RXhpc3RzJzonXFx1MjIwNCcsJ05vdEdyZWF0ZXInOidcXHUyMjZGJywnTm90R3JlYXRlckVxdWFsJzonXFx1MjI3MScsJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOidcXHUyMjY3XFx1MDMzOCcsJ05vdEdyZWF0ZXJHcmVhdGVyJzonXFx1MjI2QlxcdTAzMzgnLCdOb3RHcmVhdGVyTGVzcyc6J1xcdTIyNzknLCdOb3RHcmVhdGVyU2xhbnRFcXVhbCc6J1xcdTJBN0VcXHUwMzM4JywnTm90R3JlYXRlclRpbGRlJzonXFx1MjI3NScsJ05vdEh1bXBEb3duSHVtcCc6J1xcdTIyNEVcXHUwMzM4JywnTm90SHVtcEVxdWFsJzonXFx1MjI0RlxcdTAzMzgnLCdub3Rpbic6J1xcdTIyMDknLCdub3RpbmRvdCc6J1xcdTIyRjVcXHUwMzM4Jywnbm90aW5FJzonXFx1MjJGOVxcdTAzMzgnLCdub3RpbnZhJzonXFx1MjIwOScsJ25vdGludmInOidcXHUyMkY3Jywnbm90aW52Yyc6J1xcdTIyRjYnLCdOb3RMZWZ0VHJpYW5nbGUnOidcXHUyMkVBJywnTm90TGVmdFRyaWFuZ2xlQmFyJzonXFx1MjlDRlxcdTAzMzgnLCdOb3RMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcdTIyRUMnLCdOb3RMZXNzJzonXFx1MjI2RScsJ05vdExlc3NFcXVhbCc6J1xcdTIyNzAnLCdOb3RMZXNzR3JlYXRlcic6J1xcdTIyNzgnLCdOb3RMZXNzTGVzcyc6J1xcdTIyNkFcXHUwMzM4JywnTm90TGVzc1NsYW50RXF1YWwnOidcXHUyQTdEXFx1MDMzOCcsJ05vdExlc3NUaWxkZSc6J1xcdTIyNzQnLCdOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcdTJBQTJcXHUwMzM4JywnTm90TmVzdGVkTGVzc0xlc3MnOidcXHUyQUExXFx1MDMzOCcsJ25vdG5pJzonXFx1MjIwQycsJ25vdG5pdmEnOidcXHUyMjBDJywnbm90bml2Yic6J1xcdTIyRkUnLCdub3RuaXZjJzonXFx1MjJGRCcsJ05vdFByZWNlZGVzJzonXFx1MjI4MCcsJ05vdFByZWNlZGVzRXF1YWwnOidcXHUyQUFGXFx1MDMzOCcsJ05vdFByZWNlZGVzU2xhbnRFcXVhbCc6J1xcdTIyRTAnLCdOb3RSZXZlcnNlRWxlbWVudCc6J1xcdTIyMEMnLCdOb3RSaWdodFRyaWFuZ2xlJzonXFx1MjJFQicsJ05vdFJpZ2h0VHJpYW5nbGVCYXInOidcXHUyOUQwXFx1MDMzOCcsJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcdTIyRUQnLCdOb3RTcXVhcmVTdWJzZXQnOidcXHUyMjhGXFx1MDMzOCcsJ05vdFNxdWFyZVN1YnNldEVxdWFsJzonXFx1MjJFMicsJ05vdFNxdWFyZVN1cGVyc2V0JzonXFx1MjI5MFxcdTAzMzgnLCdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzonXFx1MjJFMycsJ05vdFN1YnNldCc6J1xcdTIyODJcXHUyMEQyJywnTm90U3Vic2V0RXF1YWwnOidcXHUyMjg4JywnTm90U3VjY2VlZHMnOidcXHUyMjgxJywnTm90U3VjY2VlZHNFcXVhbCc6J1xcdTJBQjBcXHUwMzM4JywnTm90U3VjY2VlZHNTbGFudEVxdWFsJzonXFx1MjJFMScsJ05vdFN1Y2NlZWRzVGlsZGUnOidcXHUyMjdGXFx1MDMzOCcsJ05vdFN1cGVyc2V0JzonXFx1MjI4M1xcdTIwRDInLCdOb3RTdXBlcnNldEVxdWFsJzonXFx1MjI4OScsJ05vdFRpbGRlJzonXFx1MjI0MScsJ05vdFRpbGRlRXF1YWwnOidcXHUyMjQ0JywnTm90VGlsZGVGdWxsRXF1YWwnOidcXHUyMjQ3JywnTm90VGlsZGVUaWxkZSc6J1xcdTIyNDknLCdOb3RWZXJ0aWNhbEJhcic6J1xcdTIyMjQnLCducGFyJzonXFx1MjIyNicsJ25wYXJhbGxlbCc6J1xcdTIyMjYnLCducGFyc2wnOidcXHUyQUZEXFx1MjBFNScsJ25wYXJ0JzonXFx1MjIwMlxcdTAzMzgnLCducG9saW50JzonXFx1MkExNCcsJ25wcic6J1xcdTIyODAnLCducHJjdWUnOidcXHUyMkUwJywnbnByZSc6J1xcdTJBQUZcXHUwMzM4JywnbnByZWMnOidcXHUyMjgwJywnbnByZWNlcSc6J1xcdTJBQUZcXHUwMzM4JywnbnJhcnInOidcXHUyMTlCJywnbnJBcnInOidcXHUyMUNGJywnbnJhcnJjJzonXFx1MjkzM1xcdTAzMzgnLCducmFycncnOidcXHUyMTlEXFx1MDMzOCcsJ25yaWdodGFycm93JzonXFx1MjE5QicsJ25SaWdodGFycm93JzonXFx1MjFDRicsJ25ydHJpJzonXFx1MjJFQicsJ25ydHJpZSc6J1xcdTIyRUQnLCduc2MnOidcXHUyMjgxJywnbnNjY3VlJzonXFx1MjJFMScsJ25zY2UnOidcXHUyQUIwXFx1MDMzOCcsJ25zY3InOidcXHVEODM1XFx1RENDMycsJ05zY3InOidcXHVEODM1XFx1RENBOScsJ25zaG9ydG1pZCc6J1xcdTIyMjQnLCduc2hvcnRwYXJhbGxlbCc6J1xcdTIyMjYnLCduc2ltJzonXFx1MjI0MScsJ25zaW1lJzonXFx1MjI0NCcsJ25zaW1lcSc6J1xcdTIyNDQnLCduc21pZCc6J1xcdTIyMjQnLCduc3Bhcic6J1xcdTIyMjYnLCduc3FzdWJlJzonXFx1MjJFMicsJ25zcXN1cGUnOidcXHUyMkUzJywnbnN1Yic6J1xcdTIyODQnLCduc3ViZSc6J1xcdTIyODgnLCduc3ViRSc6J1xcdTJBQzVcXHUwMzM4JywnbnN1YnNldCc6J1xcdTIyODJcXHUyMEQyJywnbnN1YnNldGVxJzonXFx1MjI4OCcsJ25zdWJzZXRlcXEnOidcXHUyQUM1XFx1MDMzOCcsJ25zdWNjJzonXFx1MjI4MScsJ25zdWNjZXEnOidcXHUyQUIwXFx1MDMzOCcsJ25zdXAnOidcXHUyMjg1JywnbnN1cGUnOidcXHUyMjg5JywnbnN1cEUnOidcXHUyQUM2XFx1MDMzOCcsJ25zdXBzZXQnOidcXHUyMjgzXFx1MjBEMicsJ25zdXBzZXRlcSc6J1xcdTIyODknLCduc3Vwc2V0ZXFxJzonXFx1MkFDNlxcdTAzMzgnLCdudGdsJzonXFx1MjI3OScsJ250aWxkZSc6J1xceEYxJywnTnRpbGRlJzonXFx4RDEnLCdudGxnJzonXFx1MjI3OCcsJ250cmlhbmdsZWxlZnQnOidcXHUyMkVBJywnbnRyaWFuZ2xlbGVmdGVxJzonXFx1MjJFQycsJ250cmlhbmdsZXJpZ2h0JzonXFx1MjJFQicsJ250cmlhbmdsZXJpZ2h0ZXEnOidcXHUyMkVEJywnbnUnOidcXHUwM0JEJywnTnUnOidcXHUwMzlEJywnbnVtJzonIycsJ251bWVybyc6J1xcdTIxMTYnLCdudW1zcCc6J1xcdTIwMDcnLCdudmFwJzonXFx1MjI0RFxcdTIwRDInLCdudmRhc2gnOidcXHUyMkFDJywnbnZEYXNoJzonXFx1MjJBRCcsJ25WZGFzaCc6J1xcdTIyQUUnLCduVkRhc2gnOidcXHUyMkFGJywnbnZnZSc6J1xcdTIyNjVcXHUyMEQyJywnbnZndCc6Jz5cXHUyMEQyJywnbnZIYXJyJzonXFx1MjkwNCcsJ252aW5maW4nOidcXHUyOURFJywnbnZsQXJyJzonXFx1MjkwMicsJ252bGUnOidcXHUyMjY0XFx1MjBEMicsJ252bHQnOic8XFx1MjBEMicsJ252bHRyaWUnOidcXHUyMkI0XFx1MjBEMicsJ252ckFycic6J1xcdTI5MDMnLCdudnJ0cmllJzonXFx1MjJCNVxcdTIwRDInLCdudnNpbSc6J1xcdTIyM0NcXHUyMEQyJywnbndhcmhrJzonXFx1MjkyMycsJ253YXJyJzonXFx1MjE5NicsJ253QXJyJzonXFx1MjFENicsJ253YXJyb3cnOidcXHUyMTk2JywnbnduZWFyJzonXFx1MjkyNycsJ29hY3V0ZSc6J1xceEYzJywnT2FjdXRlJzonXFx4RDMnLCdvYXN0JzonXFx1MjI5QicsJ29jaXInOidcXHUyMjlBJywnb2NpcmMnOidcXHhGNCcsJ09jaXJjJzonXFx4RDQnLCdvY3knOidcXHUwNDNFJywnT2N5JzonXFx1MDQxRScsJ29kYXNoJzonXFx1MjI5RCcsJ29kYmxhYyc6J1xcdTAxNTEnLCdPZGJsYWMnOidcXHUwMTUwJywnb2Rpdic6J1xcdTJBMzgnLCdvZG90JzonXFx1MjI5OScsJ29kc29sZCc6J1xcdTI5QkMnLCdvZWxpZyc6J1xcdTAxNTMnLCdPRWxpZyc6J1xcdTAxNTInLCdvZmNpcic6J1xcdTI5QkYnLCdvZnInOidcXHVEODM1XFx1REQyQycsJ09mcic6J1xcdUQ4MzVcXHVERDEyJywnb2dvbic6J1xcdTAyREInLCdvZ3JhdmUnOidcXHhGMicsJ09ncmF2ZSc6J1xceEQyJywnb2d0JzonXFx1MjlDMScsJ29oYmFyJzonXFx1MjlCNScsJ29obSc6J1xcdTAzQTknLCdvaW50JzonXFx1MjIyRScsJ29sYXJyJzonXFx1MjFCQScsJ29sY2lyJzonXFx1MjlCRScsJ29sY3Jvc3MnOidcXHUyOUJCJywnb2xpbmUnOidcXHUyMDNFJywnb2x0JzonXFx1MjlDMCcsJ29tYWNyJzonXFx1MDE0RCcsJ09tYWNyJzonXFx1MDE0QycsJ29tZWdhJzonXFx1MDNDOScsJ09tZWdhJzonXFx1MDNBOScsJ29taWNyb24nOidcXHUwM0JGJywnT21pY3Jvbic6J1xcdTAzOUYnLCdvbWlkJzonXFx1MjlCNicsJ29taW51cyc6J1xcdTIyOTYnLCdvb3BmJzonXFx1RDgzNVxcdURENjAnLCdPb3BmJzonXFx1RDgzNVxcdURENDYnLCdvcGFyJzonXFx1MjlCNycsJ09wZW5DdXJseURvdWJsZVF1b3RlJzonXFx1MjAxQycsJ09wZW5DdXJseVF1b3RlJzonXFx1MjAxOCcsJ29wZXJwJzonXFx1MjlCOScsJ29wbHVzJzonXFx1MjI5NScsJ29yJzonXFx1MjIyOCcsJ09yJzonXFx1MkE1NCcsJ29yYXJyJzonXFx1MjFCQicsJ29yZCc6J1xcdTJBNUQnLCdvcmRlcic6J1xcdTIxMzQnLCdvcmRlcm9mJzonXFx1MjEzNCcsJ29yZGYnOidcXHhBQScsJ29yZG0nOidcXHhCQScsJ29yaWdvZic6J1xcdTIyQjYnLCdvcm9yJzonXFx1MkE1NicsJ29yc2xvcGUnOidcXHUyQTU3Jywnb3J2JzonXFx1MkE1QicsJ29TJzonXFx1MjRDOCcsJ29zY3InOidcXHUyMTM0JywnT3Njcic6J1xcdUQ4MzVcXHVEQ0FBJywnb3NsYXNoJzonXFx4RjgnLCdPc2xhc2gnOidcXHhEOCcsJ29zb2wnOidcXHUyMjk4Jywnb3RpbGRlJzonXFx4RjUnLCdPdGlsZGUnOidcXHhENScsJ290aW1lcyc6J1xcdTIyOTcnLCdPdGltZXMnOidcXHUyQTM3Jywnb3RpbWVzYXMnOidcXHUyQTM2Jywnb3VtbCc6J1xceEY2JywnT3VtbCc6J1xceEQ2Jywnb3ZiYXInOidcXHUyMzNEJywnT3ZlckJhcic6J1xcdTIwM0UnLCdPdmVyQnJhY2UnOidcXHUyM0RFJywnT3ZlckJyYWNrZXQnOidcXHUyM0I0JywnT3ZlclBhcmVudGhlc2lzJzonXFx1MjNEQycsJ3Bhcic6J1xcdTIyMjUnLCdwYXJhJzonXFx4QjYnLCdwYXJhbGxlbCc6J1xcdTIyMjUnLCdwYXJzaW0nOidcXHUyQUYzJywncGFyc2wnOidcXHUyQUZEJywncGFydCc6J1xcdTIyMDInLCdQYXJ0aWFsRCc6J1xcdTIyMDInLCdwY3knOidcXHUwNDNGJywnUGN5JzonXFx1MDQxRicsJ3BlcmNudCc6JyUnLCdwZXJpb2QnOicuJywncGVybWlsJzonXFx1MjAzMCcsJ3BlcnAnOidcXHUyMkE1JywncGVydGVuayc6J1xcdTIwMzEnLCdwZnInOidcXHVEODM1XFx1REQyRCcsJ1Bmcic6J1xcdUQ4MzVcXHVERDEzJywncGhpJzonXFx1MDNDNicsJ1BoaSc6J1xcdTAzQTYnLCdwaGl2JzonXFx1MDNENScsJ3BobW1hdCc6J1xcdTIxMzMnLCdwaG9uZSc6J1xcdTI2MEUnLCdwaSc6J1xcdTAzQzAnLCdQaSc6J1xcdTAzQTAnLCdwaXRjaGZvcmsnOidcXHUyMkQ0JywncGl2JzonXFx1MDNENicsJ3BsYW5jayc6J1xcdTIxMEYnLCdwbGFuY2toJzonXFx1MjEwRScsJ3BsYW5rdic6J1xcdTIxMEYnLCdwbHVzJzonKycsJ3BsdXNhY2lyJzonXFx1MkEyMycsJ3BsdXNiJzonXFx1MjI5RScsJ3BsdXNjaXInOidcXHUyQTIyJywncGx1c2RvJzonXFx1MjIxNCcsJ3BsdXNkdSc6J1xcdTJBMjUnLCdwbHVzZSc6J1xcdTJBNzInLCdQbHVzTWludXMnOidcXHhCMScsJ3BsdXNtbic6J1xceEIxJywncGx1c3NpbSc6J1xcdTJBMjYnLCdwbHVzdHdvJzonXFx1MkEyNycsJ3BtJzonXFx4QjEnLCdQb2luY2FyZXBsYW5lJzonXFx1MjEwQycsJ3BvaW50aW50JzonXFx1MkExNScsJ3BvcGYnOidcXHVEODM1XFx1REQ2MScsJ1BvcGYnOidcXHUyMTE5JywncG91bmQnOidcXHhBMycsJ3ByJzonXFx1MjI3QScsJ1ByJzonXFx1MkFCQicsJ3ByYXAnOidcXHUyQUI3JywncHJjdWUnOidcXHUyMjdDJywncHJlJzonXFx1MkFBRicsJ3ByRSc6J1xcdTJBQjMnLCdwcmVjJzonXFx1MjI3QScsJ3ByZWNhcHByb3gnOidcXHUyQUI3JywncHJlY2N1cmx5ZXEnOidcXHUyMjdDJywnUHJlY2VkZXMnOidcXHUyMjdBJywnUHJlY2VkZXNFcXVhbCc6J1xcdTJBQUYnLCdQcmVjZWRlc1NsYW50RXF1YWwnOidcXHUyMjdDJywnUHJlY2VkZXNUaWxkZSc6J1xcdTIyN0UnLCdwcmVjZXEnOidcXHUyQUFGJywncHJlY25hcHByb3gnOidcXHUyQUI5JywncHJlY25lcXEnOidcXHUyQUI1JywncHJlY25zaW0nOidcXHUyMkU4JywncHJlY3NpbSc6J1xcdTIyN0UnLCdwcmltZSc6J1xcdTIwMzInLCdQcmltZSc6J1xcdTIwMzMnLCdwcmltZXMnOidcXHUyMTE5JywncHJuYXAnOidcXHUyQUI5JywncHJuRSc6J1xcdTJBQjUnLCdwcm5zaW0nOidcXHUyMkU4JywncHJvZCc6J1xcdTIyMEYnLCdQcm9kdWN0JzonXFx1MjIwRicsJ3Byb2ZhbGFyJzonXFx1MjMyRScsJ3Byb2ZsaW5lJzonXFx1MjMxMicsJ3Byb2ZzdXJmJzonXFx1MjMxMycsJ3Byb3AnOidcXHUyMjFEJywnUHJvcG9ydGlvbic6J1xcdTIyMzcnLCdQcm9wb3J0aW9uYWwnOidcXHUyMjFEJywncHJvcHRvJzonXFx1MjIxRCcsJ3Byc2ltJzonXFx1MjI3RScsJ3BydXJlbCc6J1xcdTIyQjAnLCdwc2NyJzonXFx1RDgzNVxcdURDQzUnLCdQc2NyJzonXFx1RDgzNVxcdURDQUInLCdwc2knOidcXHUwM0M4JywnUHNpJzonXFx1MDNBOCcsJ3B1bmNzcCc6J1xcdTIwMDgnLCdxZnInOidcXHVEODM1XFx1REQyRScsJ1Fmcic6J1xcdUQ4MzVcXHVERDE0JywncWludCc6J1xcdTJBMEMnLCdxb3BmJzonXFx1RDgzNVxcdURENjInLCdRb3BmJzonXFx1MjExQScsJ3FwcmltZSc6J1xcdTIwNTcnLCdxc2NyJzonXFx1RDgzNVxcdURDQzYnLCdRc2NyJzonXFx1RDgzNVxcdURDQUMnLCdxdWF0ZXJuaW9ucyc6J1xcdTIxMEQnLCdxdWF0aW50JzonXFx1MkExNicsJ3F1ZXN0JzonPycsJ3F1ZXN0ZXEnOidcXHUyMjVGJywncXVvdCc6J1wiJywnUVVPVCc6J1wiJywnckFhcnInOidcXHUyMURCJywncmFjZSc6J1xcdTIyM0RcXHUwMzMxJywncmFjdXRlJzonXFx1MDE1NScsJ1JhY3V0ZSc6J1xcdTAxNTQnLCdyYWRpYyc6J1xcdTIyMUEnLCdyYWVtcHR5dic6J1xcdTI5QjMnLCdyYW5nJzonXFx1MjdFOScsJ1JhbmcnOidcXHUyN0VCJywncmFuZ2QnOidcXHUyOTkyJywncmFuZ2UnOidcXHUyOUE1JywncmFuZ2xlJzonXFx1MjdFOScsJ3JhcXVvJzonXFx4QkInLCdyYXJyJzonXFx1MjE5MicsJ3JBcnInOidcXHUyMUQyJywnUmFycic6J1xcdTIxQTAnLCdyYXJyYXAnOidcXHUyOTc1JywncmFycmInOidcXHUyMUU1JywncmFycmJmcyc6J1xcdTI5MjAnLCdyYXJyYyc6J1xcdTI5MzMnLCdyYXJyZnMnOidcXHUyOTFFJywncmFycmhrJzonXFx1MjFBQScsJ3JhcnJscCc6J1xcdTIxQUMnLCdyYXJycGwnOidcXHUyOTQ1JywncmFycnNpbSc6J1xcdTI5NzQnLCdyYXJydGwnOidcXHUyMUEzJywnUmFycnRsJzonXFx1MjkxNicsJ3JhcnJ3JzonXFx1MjE5RCcsJ3JhdGFpbCc6J1xcdTI5MUEnLCdyQXRhaWwnOidcXHUyOTFDJywncmF0aW8nOidcXHUyMjM2JywncmF0aW9uYWxzJzonXFx1MjExQScsJ3JiYXJyJzonXFx1MjkwRCcsJ3JCYXJyJzonXFx1MjkwRicsJ1JCYXJyJzonXFx1MjkxMCcsJ3JiYnJrJzonXFx1Mjc3MycsJ3JicmFjZSc6J30nLCdyYnJhY2snOiddJywncmJya2UnOidcXHUyOThDJywncmJya3NsZCc6J1xcdTI5OEUnLCdyYnJrc2x1JzonXFx1Mjk5MCcsJ3JjYXJvbic6J1xcdTAxNTknLCdSY2Fyb24nOidcXHUwMTU4JywncmNlZGlsJzonXFx1MDE1NycsJ1JjZWRpbCc6J1xcdTAxNTYnLCdyY2VpbCc6J1xcdTIzMDknLCdyY3ViJzonfScsJ3JjeSc6J1xcdTA0NDAnLCdSY3knOidcXHUwNDIwJywncmRjYSc6J1xcdTI5MzcnLCdyZGxkaGFyJzonXFx1Mjk2OScsJ3JkcXVvJzonXFx1MjAxRCcsJ3JkcXVvcic6J1xcdTIwMUQnLCdyZHNoJzonXFx1MjFCMycsJ1JlJzonXFx1MjExQycsJ3JlYWwnOidcXHUyMTFDJywncmVhbGluZSc6J1xcdTIxMUInLCdyZWFscGFydCc6J1xcdTIxMUMnLCdyZWFscyc6J1xcdTIxMUQnLCdyZWN0JzonXFx1MjVBRCcsJ3JlZyc6J1xceEFFJywnUkVHJzonXFx4QUUnLCdSZXZlcnNlRWxlbWVudCc6J1xcdTIyMEInLCdSZXZlcnNlRXF1aWxpYnJpdW0nOidcXHUyMUNCJywnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOidcXHUyOTZGJywncmZpc2h0JzonXFx1Mjk3RCcsJ3JmbG9vcic6J1xcdTIzMEInLCdyZnInOidcXHVEODM1XFx1REQyRicsJ1Jmcic6J1xcdTIxMUMnLCdySGFyJzonXFx1Mjk2NCcsJ3JoYXJkJzonXFx1MjFDMScsJ3JoYXJ1JzonXFx1MjFDMCcsJ3JoYXJ1bCc6J1xcdTI5NkMnLCdyaG8nOidcXHUwM0MxJywnUmhvJzonXFx1MDNBMScsJ3Job3YnOidcXHUwM0YxJywnUmlnaHRBbmdsZUJyYWNrZXQnOidcXHUyN0U5JywncmlnaHRhcnJvdyc6J1xcdTIxOTInLCdSaWdodGFycm93JzonXFx1MjFEMicsJ1JpZ2h0QXJyb3cnOidcXHUyMTkyJywnUmlnaHRBcnJvd0Jhcic6J1xcdTIxRTUnLCdSaWdodEFycm93TGVmdEFycm93JzonXFx1MjFDNCcsJ3JpZ2h0YXJyb3d0YWlsJzonXFx1MjFBMycsJ1JpZ2h0Q2VpbGluZyc6J1xcdTIzMDknLCdSaWdodERvdWJsZUJyYWNrZXQnOidcXHUyN0U3JywnUmlnaHREb3duVGVlVmVjdG9yJzonXFx1Mjk1RCcsJ1JpZ2h0RG93blZlY3Rvcic6J1xcdTIxQzInLCdSaWdodERvd25WZWN0b3JCYXInOidcXHUyOTU1JywnUmlnaHRGbG9vcic6J1xcdTIzMEInLCdyaWdodGhhcnBvb25kb3duJzonXFx1MjFDMScsJ3JpZ2h0aGFycG9vbnVwJzonXFx1MjFDMCcsJ3JpZ2h0bGVmdGFycm93cyc6J1xcdTIxQzQnLCdyaWdodGxlZnRoYXJwb29ucyc6J1xcdTIxQ0MnLCdyaWdodHJpZ2h0YXJyb3dzJzonXFx1MjFDOScsJ3JpZ2h0c3F1aWdhcnJvdyc6J1xcdTIxOUQnLCdSaWdodFRlZSc6J1xcdTIyQTInLCdSaWdodFRlZUFycm93JzonXFx1MjFBNicsJ1JpZ2h0VGVlVmVjdG9yJzonXFx1Mjk1QicsJ3JpZ2h0dGhyZWV0aW1lcyc6J1xcdTIyQ0MnLCdSaWdodFRyaWFuZ2xlJzonXFx1MjJCMycsJ1JpZ2h0VHJpYW5nbGVCYXInOidcXHUyOUQwJywnUmlnaHRUcmlhbmdsZUVxdWFsJzonXFx1MjJCNScsJ1JpZ2h0VXBEb3duVmVjdG9yJzonXFx1Mjk0RicsJ1JpZ2h0VXBUZWVWZWN0b3InOidcXHUyOTVDJywnUmlnaHRVcFZlY3Rvcic6J1xcdTIxQkUnLCdSaWdodFVwVmVjdG9yQmFyJzonXFx1Mjk1NCcsJ1JpZ2h0VmVjdG9yJzonXFx1MjFDMCcsJ1JpZ2h0VmVjdG9yQmFyJzonXFx1Mjk1MycsJ3JpbmcnOidcXHUwMkRBJywncmlzaW5nZG90c2VxJzonXFx1MjI1MycsJ3JsYXJyJzonXFx1MjFDNCcsJ3JsaGFyJzonXFx1MjFDQycsJ3JsbSc6J1xcdTIwMEYnLCdybW91c3QnOidcXHUyM0IxJywncm1vdXN0YWNoZSc6J1xcdTIzQjEnLCdybm1pZCc6J1xcdTJBRUUnLCdyb2FuZyc6J1xcdTI3RUQnLCdyb2Fycic6J1xcdTIxRkUnLCdyb2Jyayc6J1xcdTI3RTcnLCdyb3Bhcic6J1xcdTI5ODYnLCdyb3BmJzonXFx1RDgzNVxcdURENjMnLCdSb3BmJzonXFx1MjExRCcsJ3JvcGx1cyc6J1xcdTJBMkUnLCdyb3RpbWVzJzonXFx1MkEzNScsJ1JvdW5kSW1wbGllcyc6J1xcdTI5NzAnLCdycGFyJzonKScsJ3JwYXJndCc6J1xcdTI5OTQnLCdycHBvbGludCc6J1xcdTJBMTInLCdycmFycic6J1xcdTIxQzknLCdScmlnaHRhcnJvdyc6J1xcdTIxREInLCdyc2FxdW8nOidcXHUyMDNBJywncnNjcic6J1xcdUQ4MzVcXHVEQ0M3JywnUnNjcic6J1xcdTIxMUInLCdyc2gnOidcXHUyMUIxJywnUnNoJzonXFx1MjFCMScsJ3JzcWInOiddJywncnNxdW8nOidcXHUyMDE5JywncnNxdW9yJzonXFx1MjAxOScsJ3J0aHJlZSc6J1xcdTIyQ0MnLCdydGltZXMnOidcXHUyMkNBJywncnRyaSc6J1xcdTI1QjknLCdydHJpZSc6J1xcdTIyQjUnLCdydHJpZic6J1xcdTI1QjgnLCdydHJpbHRyaSc6J1xcdTI5Q0UnLCdSdWxlRGVsYXllZCc6J1xcdTI5RjQnLCdydWx1aGFyJzonXFx1Mjk2OCcsJ3J4JzonXFx1MjExRScsJ3NhY3V0ZSc6J1xcdTAxNUInLCdTYWN1dGUnOidcXHUwMTVBJywnc2JxdW8nOidcXHUyMDFBJywnc2MnOidcXHUyMjdCJywnU2MnOidcXHUyQUJDJywnc2NhcCc6J1xcdTJBQjgnLCdzY2Fyb24nOidcXHUwMTYxJywnU2Nhcm9uJzonXFx1MDE2MCcsJ3NjY3VlJzonXFx1MjI3RCcsJ3NjZSc6J1xcdTJBQjAnLCdzY0UnOidcXHUyQUI0Jywnc2NlZGlsJzonXFx1MDE1RicsJ1NjZWRpbCc6J1xcdTAxNUUnLCdzY2lyYyc6J1xcdTAxNUQnLCdTY2lyYyc6J1xcdTAxNUMnLCdzY25hcCc6J1xcdTJBQkEnLCdzY25FJzonXFx1MkFCNicsJ3NjbnNpbSc6J1xcdTIyRTknLCdzY3BvbGludCc6J1xcdTJBMTMnLCdzY3NpbSc6J1xcdTIyN0YnLCdzY3knOidcXHUwNDQxJywnU2N5JzonXFx1MDQyMScsJ3Nkb3QnOidcXHUyMkM1Jywnc2RvdGInOidcXHUyMkExJywnc2RvdGUnOidcXHUyQTY2Jywnc2VhcmhrJzonXFx1MjkyNScsJ3NlYXJyJzonXFx1MjE5OCcsJ3NlQXJyJzonXFx1MjFEOCcsJ3NlYXJyb3cnOidcXHUyMTk4Jywnc2VjdCc6J1xceEE3Jywnc2VtaSc6JzsnLCdzZXN3YXInOidcXHUyOTI5Jywnc2V0bWludXMnOidcXHUyMjE2Jywnc2V0bW4nOidcXHUyMjE2Jywnc2V4dCc6J1xcdTI3MzYnLCdzZnInOidcXHVEODM1XFx1REQzMCcsJ1Nmcic6J1xcdUQ4MzVcXHVERDE2Jywnc2Zyb3duJzonXFx1MjMyMicsJ3NoYXJwJzonXFx1MjY2RicsJ3NoY2hjeSc6J1xcdTA0NDknLCdTSENIY3knOidcXHUwNDI5Jywnc2hjeSc6J1xcdTA0NDgnLCdTSGN5JzonXFx1MDQyOCcsJ1Nob3J0RG93bkFycm93JzonXFx1MjE5MycsJ1Nob3J0TGVmdEFycm93JzonXFx1MjE5MCcsJ3Nob3J0bWlkJzonXFx1MjIyMycsJ3Nob3J0cGFyYWxsZWwnOidcXHUyMjI1JywnU2hvcnRSaWdodEFycm93JzonXFx1MjE5MicsJ1Nob3J0VXBBcnJvdyc6J1xcdTIxOTEnLCdzaHknOidcXHhBRCcsJ3NpZ21hJzonXFx1MDNDMycsJ1NpZ21hJzonXFx1MDNBMycsJ3NpZ21hZic6J1xcdTAzQzInLCdzaWdtYXYnOidcXHUwM0MyJywnc2ltJzonXFx1MjIzQycsJ3NpbWRvdCc6J1xcdTJBNkEnLCdzaW1lJzonXFx1MjI0MycsJ3NpbWVxJzonXFx1MjI0MycsJ3NpbWcnOidcXHUyQTlFJywnc2ltZ0UnOidcXHUyQUEwJywnc2ltbCc6J1xcdTJBOUQnLCdzaW1sRSc6J1xcdTJBOUYnLCdzaW1uZSc6J1xcdTIyNDYnLCdzaW1wbHVzJzonXFx1MkEyNCcsJ3NpbXJhcnInOidcXHUyOTcyJywnc2xhcnInOidcXHUyMTkwJywnU21hbGxDaXJjbGUnOidcXHUyMjE4Jywnc21hbGxzZXRtaW51cyc6J1xcdTIyMTYnLCdzbWFzaHAnOidcXHUyQTMzJywnc21lcGFyc2wnOidcXHUyOUU0Jywnc21pZCc6J1xcdTIyMjMnLCdzbWlsZSc6J1xcdTIzMjMnLCdzbXQnOidcXHUyQUFBJywnc210ZSc6J1xcdTJBQUMnLCdzbXRlcyc6J1xcdTJBQUNcXHVGRTAwJywnc29mdGN5JzonXFx1MDQ0QycsJ1NPRlRjeSc6J1xcdTA0MkMnLCdzb2wnOicvJywnc29sYic6J1xcdTI5QzQnLCdzb2xiYXInOidcXHUyMzNGJywnc29wZic6J1xcdUQ4MzVcXHVERDY0JywnU29wZic6J1xcdUQ4MzVcXHVERDRBJywnc3BhZGVzJzonXFx1MjY2MCcsJ3NwYWRlc3VpdCc6J1xcdTI2NjAnLCdzcGFyJzonXFx1MjIyNScsJ3NxY2FwJzonXFx1MjI5MycsJ3NxY2Fwcyc6J1xcdTIyOTNcXHVGRTAwJywnc3FjdXAnOidcXHUyMjk0Jywnc3FjdXBzJzonXFx1MjI5NFxcdUZFMDAnLCdTcXJ0JzonXFx1MjIxQScsJ3Nxc3ViJzonXFx1MjI4RicsJ3Nxc3ViZSc6J1xcdTIyOTEnLCdzcXN1YnNldCc6J1xcdTIyOEYnLCdzcXN1YnNldGVxJzonXFx1MjI5MScsJ3Nxc3VwJzonXFx1MjI5MCcsJ3Nxc3VwZSc6J1xcdTIyOTInLCdzcXN1cHNldCc6J1xcdTIyOTAnLCdzcXN1cHNldGVxJzonXFx1MjI5MicsJ3NxdSc6J1xcdTI1QTEnLCdzcXVhcmUnOidcXHUyNUExJywnU3F1YXJlJzonXFx1MjVBMScsJ1NxdWFyZUludGVyc2VjdGlvbic6J1xcdTIyOTMnLCdTcXVhcmVTdWJzZXQnOidcXHUyMjhGJywnU3F1YXJlU3Vic2V0RXF1YWwnOidcXHUyMjkxJywnU3F1YXJlU3VwZXJzZXQnOidcXHUyMjkwJywnU3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcdTIyOTInLCdTcXVhcmVVbmlvbic6J1xcdTIyOTQnLCdzcXVhcmYnOidcXHUyNUFBJywnc3F1Zic6J1xcdTI1QUEnLCdzcmFycic6J1xcdTIxOTInLCdzc2NyJzonXFx1RDgzNVxcdURDQzgnLCdTc2NyJzonXFx1RDgzNVxcdURDQUUnLCdzc2V0bW4nOidcXHUyMjE2Jywnc3NtaWxlJzonXFx1MjMyMycsJ3NzdGFyZic6J1xcdTIyQzYnLCdzdGFyJzonXFx1MjYwNicsJ1N0YXInOidcXHUyMkM2Jywnc3RhcmYnOidcXHUyNjA1Jywnc3RyYWlnaHRlcHNpbG9uJzonXFx1MDNGNScsJ3N0cmFpZ2h0cGhpJzonXFx1MDNENScsJ3N0cm5zJzonXFx4QUYnLCdzdWInOidcXHUyMjgyJywnU3ViJzonXFx1MjJEMCcsJ3N1YmRvdCc6J1xcdTJBQkQnLCdzdWJlJzonXFx1MjI4NicsJ3N1YkUnOidcXHUyQUM1Jywnc3ViZWRvdCc6J1xcdTJBQzMnLCdzdWJtdWx0JzonXFx1MkFDMScsJ3N1Ym5lJzonXFx1MjI4QScsJ3N1Ym5FJzonXFx1MkFDQicsJ3N1YnBsdXMnOidcXHUyQUJGJywnc3VicmFycic6J1xcdTI5NzknLCdzdWJzZXQnOidcXHUyMjgyJywnU3Vic2V0JzonXFx1MjJEMCcsJ3N1YnNldGVxJzonXFx1MjI4NicsJ3N1YnNldGVxcSc6J1xcdTJBQzUnLCdTdWJzZXRFcXVhbCc6J1xcdTIyODYnLCdzdWJzZXRuZXEnOidcXHUyMjhBJywnc3Vic2V0bmVxcSc6J1xcdTJBQ0InLCdzdWJzaW0nOidcXHUyQUM3Jywnc3Vic3ViJzonXFx1MkFENScsJ3N1YnN1cCc6J1xcdTJBRDMnLCdzdWNjJzonXFx1MjI3QicsJ3N1Y2NhcHByb3gnOidcXHUyQUI4Jywnc3VjY2N1cmx5ZXEnOidcXHUyMjdEJywnU3VjY2VlZHMnOidcXHUyMjdCJywnU3VjY2VlZHNFcXVhbCc6J1xcdTJBQjAnLCdTdWNjZWVkc1NsYW50RXF1YWwnOidcXHUyMjdEJywnU3VjY2VlZHNUaWxkZSc6J1xcdTIyN0YnLCdzdWNjZXEnOidcXHUyQUIwJywnc3VjY25hcHByb3gnOidcXHUyQUJBJywnc3VjY25lcXEnOidcXHUyQUI2Jywnc3VjY25zaW0nOidcXHUyMkU5Jywnc3VjY3NpbSc6J1xcdTIyN0YnLCdTdWNoVGhhdCc6J1xcdTIyMEInLCdzdW0nOidcXHUyMjExJywnU3VtJzonXFx1MjIxMScsJ3N1bmcnOidcXHUyNjZBJywnc3VwJzonXFx1MjI4MycsJ1N1cCc6J1xcdTIyRDEnLCdzdXAxJzonXFx4QjknLCdzdXAyJzonXFx4QjInLCdzdXAzJzonXFx4QjMnLCdzdXBkb3QnOidcXHUyQUJFJywnc3VwZHN1Yic6J1xcdTJBRDgnLCdzdXBlJzonXFx1MjI4NycsJ3N1cEUnOidcXHUyQUM2Jywnc3VwZWRvdCc6J1xcdTJBQzQnLCdTdXBlcnNldCc6J1xcdTIyODMnLCdTdXBlcnNldEVxdWFsJzonXFx1MjI4NycsJ3N1cGhzb2wnOidcXHUyN0M5Jywnc3VwaHN1Yic6J1xcdTJBRDcnLCdzdXBsYXJyJzonXFx1Mjk3QicsJ3N1cG11bHQnOidcXHUyQUMyJywnc3VwbmUnOidcXHUyMjhCJywnc3VwbkUnOidcXHUyQUNDJywnc3VwcGx1cyc6J1xcdTJBQzAnLCdzdXBzZXQnOidcXHUyMjgzJywnU3Vwc2V0JzonXFx1MjJEMScsJ3N1cHNldGVxJzonXFx1MjI4NycsJ3N1cHNldGVxcSc6J1xcdTJBQzYnLCdzdXBzZXRuZXEnOidcXHUyMjhCJywnc3Vwc2V0bmVxcSc6J1xcdTJBQ0MnLCdzdXBzaW0nOidcXHUyQUM4Jywnc3Vwc3ViJzonXFx1MkFENCcsJ3N1cHN1cCc6J1xcdTJBRDYnLCdzd2FyaGsnOidcXHUyOTI2Jywnc3dhcnInOidcXHUyMTk5Jywnc3dBcnInOidcXHUyMUQ5Jywnc3dhcnJvdyc6J1xcdTIxOTknLCdzd253YXInOidcXHUyOTJBJywnc3psaWcnOidcXHhERicsJ1RhYic6J1xcdCcsJ3RhcmdldCc6J1xcdTIzMTYnLCd0YXUnOidcXHUwM0M0JywnVGF1JzonXFx1MDNBNCcsJ3RicmsnOidcXHUyM0I0JywndGNhcm9uJzonXFx1MDE2NScsJ1RjYXJvbic6J1xcdTAxNjQnLCd0Y2VkaWwnOidcXHUwMTYzJywnVGNlZGlsJzonXFx1MDE2MicsJ3RjeSc6J1xcdTA0NDInLCdUY3knOidcXHUwNDIyJywndGRvdCc6J1xcdTIwREInLCd0ZWxyZWMnOidcXHUyMzE1JywndGZyJzonXFx1RDgzNVxcdUREMzEnLCdUZnInOidcXHVEODM1XFx1REQxNycsJ3RoZXJlNCc6J1xcdTIyMzQnLCd0aGVyZWZvcmUnOidcXHUyMjM0JywnVGhlcmVmb3JlJzonXFx1MjIzNCcsJ3RoZXRhJzonXFx1MDNCOCcsJ1RoZXRhJzonXFx1MDM5OCcsJ3RoZXRhc3ltJzonXFx1MDNEMScsJ3RoZXRhdic6J1xcdTAzRDEnLCd0aGlja2FwcHJveCc6J1xcdTIyNDgnLCd0aGlja3NpbSc6J1xcdTIyM0MnLCdUaGlja1NwYWNlJzonXFx1MjA1RlxcdTIwMEEnLCd0aGluc3AnOidcXHUyMDA5JywnVGhpblNwYWNlJzonXFx1MjAwOScsJ3Roa2FwJzonXFx1MjI0OCcsJ3Roa3NpbSc6J1xcdTIyM0MnLCd0aG9ybic6J1xceEZFJywnVEhPUk4nOidcXHhERScsJ3RpbGRlJzonXFx1MDJEQycsJ1RpbGRlJzonXFx1MjIzQycsJ1RpbGRlRXF1YWwnOidcXHUyMjQzJywnVGlsZGVGdWxsRXF1YWwnOidcXHUyMjQ1JywnVGlsZGVUaWxkZSc6J1xcdTIyNDgnLCd0aW1lcyc6J1xceEQ3JywndGltZXNiJzonXFx1MjJBMCcsJ3RpbWVzYmFyJzonXFx1MkEzMScsJ3RpbWVzZCc6J1xcdTJBMzAnLCd0aW50JzonXFx1MjIyRCcsJ3RvZWEnOidcXHUyOTI4JywndG9wJzonXFx1MjJBNCcsJ3RvcGJvdCc6J1xcdTIzMzYnLCd0b3BjaXInOidcXHUyQUYxJywndG9wZic6J1xcdUQ4MzVcXHVERDY1JywnVG9wZic6J1xcdUQ4MzVcXHVERDRCJywndG9wZm9yayc6J1xcdTJBREEnLCd0b3NhJzonXFx1MjkyOScsJ3RwcmltZSc6J1xcdTIwMzQnLCd0cmFkZSc6J1xcdTIxMjInLCdUUkFERSc6J1xcdTIxMjInLCd0cmlhbmdsZSc6J1xcdTI1QjUnLCd0cmlhbmdsZWRvd24nOidcXHUyNUJGJywndHJpYW5nbGVsZWZ0JzonXFx1MjVDMycsJ3RyaWFuZ2xlbGVmdGVxJzonXFx1MjJCNCcsJ3RyaWFuZ2xlcSc6J1xcdTIyNUMnLCd0cmlhbmdsZXJpZ2h0JzonXFx1MjVCOScsJ3RyaWFuZ2xlcmlnaHRlcSc6J1xcdTIyQjUnLCd0cmlkb3QnOidcXHUyNUVDJywndHJpZSc6J1xcdTIyNUMnLCd0cmltaW51cyc6J1xcdTJBM0EnLCdUcmlwbGVEb3QnOidcXHUyMERCJywndHJpcGx1cyc6J1xcdTJBMzknLCd0cmlzYic6J1xcdTI5Q0QnLCd0cml0aW1lJzonXFx1MkEzQicsJ3RycGV6aXVtJzonXFx1MjNFMicsJ3RzY3InOidcXHVEODM1XFx1RENDOScsJ1RzY3InOidcXHVEODM1XFx1RENBRicsJ3RzY3knOidcXHUwNDQ2JywnVFNjeSc6J1xcdTA0MjYnLCd0c2hjeSc6J1xcdTA0NUInLCdUU0hjeSc6J1xcdTA0MEInLCd0c3Ryb2snOidcXHUwMTY3JywnVHN0cm9rJzonXFx1MDE2NicsJ3R3aXh0JzonXFx1MjI2QycsJ3R3b2hlYWRsZWZ0YXJyb3cnOidcXHUyMTlFJywndHdvaGVhZHJpZ2h0YXJyb3cnOidcXHUyMUEwJywndWFjdXRlJzonXFx4RkEnLCdVYWN1dGUnOidcXHhEQScsJ3VhcnInOidcXHUyMTkxJywndUFycic6J1xcdTIxRDEnLCdVYXJyJzonXFx1MjE5RicsJ1VhcnJvY2lyJzonXFx1Mjk0OScsJ3VicmN5JzonXFx1MDQ1RScsJ1VicmN5JzonXFx1MDQwRScsJ3VicmV2ZSc6J1xcdTAxNkQnLCdVYnJldmUnOidcXHUwMTZDJywndWNpcmMnOidcXHhGQicsJ1VjaXJjJzonXFx4REInLCd1Y3knOidcXHUwNDQzJywnVWN5JzonXFx1MDQyMycsJ3VkYXJyJzonXFx1MjFDNScsJ3VkYmxhYyc6J1xcdTAxNzEnLCdVZGJsYWMnOidcXHUwMTcwJywndWRoYXInOidcXHUyOTZFJywndWZpc2h0JzonXFx1Mjk3RScsJ3Vmcic6J1xcdUQ4MzVcXHVERDMyJywnVWZyJzonXFx1RDgzNVxcdUREMTgnLCd1Z3JhdmUnOidcXHhGOScsJ1VncmF2ZSc6J1xceEQ5JywndUhhcic6J1xcdTI5NjMnLCd1aGFybCc6J1xcdTIxQkYnLCd1aGFycic6J1xcdTIxQkUnLCd1aGJsayc6J1xcdTI1ODAnLCd1bGNvcm4nOidcXHUyMzFDJywndWxjb3JuZXInOidcXHUyMzFDJywndWxjcm9wJzonXFx1MjMwRicsJ3VsdHJpJzonXFx1MjVGOCcsJ3VtYWNyJzonXFx1MDE2QicsJ1VtYWNyJzonXFx1MDE2QScsJ3VtbCc6J1xceEE4JywnVW5kZXJCYXInOidfJywnVW5kZXJCcmFjZSc6J1xcdTIzREYnLCdVbmRlckJyYWNrZXQnOidcXHUyM0I1JywnVW5kZXJQYXJlbnRoZXNpcyc6J1xcdTIzREQnLCdVbmlvbic6J1xcdTIyQzMnLCdVbmlvblBsdXMnOidcXHUyMjhFJywndW9nb24nOidcXHUwMTczJywnVW9nb24nOidcXHUwMTcyJywndW9wZic6J1xcdUQ4MzVcXHVERDY2JywnVW9wZic6J1xcdUQ4MzVcXHVERDRDJywndXBhcnJvdyc6J1xcdTIxOTEnLCdVcGFycm93JzonXFx1MjFEMScsJ1VwQXJyb3cnOidcXHUyMTkxJywnVXBBcnJvd0Jhcic6J1xcdTI5MTInLCdVcEFycm93RG93bkFycm93JzonXFx1MjFDNScsJ3VwZG93bmFycm93JzonXFx1MjE5NScsJ1VwZG93bmFycm93JzonXFx1MjFENScsJ1VwRG93bkFycm93JzonXFx1MjE5NScsJ1VwRXF1aWxpYnJpdW0nOidcXHUyOTZFJywndXBoYXJwb29ubGVmdCc6J1xcdTIxQkYnLCd1cGhhcnBvb25yaWdodCc6J1xcdTIxQkUnLCd1cGx1cyc6J1xcdTIyOEUnLCdVcHBlckxlZnRBcnJvdyc6J1xcdTIxOTYnLCdVcHBlclJpZ2h0QXJyb3cnOidcXHUyMTk3JywndXBzaSc6J1xcdTAzQzUnLCdVcHNpJzonXFx1MDNEMicsJ3Vwc2loJzonXFx1MDNEMicsJ3Vwc2lsb24nOidcXHUwM0M1JywnVXBzaWxvbic6J1xcdTAzQTUnLCdVcFRlZSc6J1xcdTIyQTUnLCdVcFRlZUFycm93JzonXFx1MjFBNScsJ3VwdXBhcnJvd3MnOidcXHUyMUM4JywndXJjb3JuJzonXFx1MjMxRCcsJ3VyY29ybmVyJzonXFx1MjMxRCcsJ3VyY3JvcCc6J1xcdTIzMEUnLCd1cmluZyc6J1xcdTAxNkYnLCdVcmluZyc6J1xcdTAxNkUnLCd1cnRyaSc6J1xcdTI1RjknLCd1c2NyJzonXFx1RDgzNVxcdURDQ0EnLCdVc2NyJzonXFx1RDgzNVxcdURDQjAnLCd1dGRvdCc6J1xcdTIyRjAnLCd1dGlsZGUnOidcXHUwMTY5JywnVXRpbGRlJzonXFx1MDE2OCcsJ3V0cmknOidcXHUyNUI1JywndXRyaWYnOidcXHUyNUI0JywndXVhcnInOidcXHUyMUM4JywndXVtbCc6J1xceEZDJywnVXVtbCc6J1xceERDJywndXdhbmdsZSc6J1xcdTI5QTcnLCd2YW5ncnQnOidcXHUyOTlDJywndmFyZXBzaWxvbic6J1xcdTAzRjUnLCd2YXJrYXBwYSc6J1xcdTAzRjAnLCd2YXJub3RoaW5nJzonXFx1MjIwNScsJ3ZhcnBoaSc6J1xcdTAzRDUnLCd2YXJwaSc6J1xcdTAzRDYnLCd2YXJwcm9wdG8nOidcXHUyMjFEJywndmFycic6J1xcdTIxOTUnLCd2QXJyJzonXFx1MjFENScsJ3ZhcnJobyc6J1xcdTAzRjEnLCd2YXJzaWdtYSc6J1xcdTAzQzInLCd2YXJzdWJzZXRuZXEnOidcXHUyMjhBXFx1RkUwMCcsJ3ZhcnN1YnNldG5lcXEnOidcXHUyQUNCXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcSc6J1xcdTIyOEJcXHVGRTAwJywndmFyc3Vwc2V0bmVxcSc6J1xcdTJBQ0NcXHVGRTAwJywndmFydGhldGEnOidcXHUwM0QxJywndmFydHJpYW5nbGVsZWZ0JzonXFx1MjJCMicsJ3ZhcnRyaWFuZ2xlcmlnaHQnOidcXHUyMkIzJywndkJhcic6J1xcdTJBRTgnLCdWYmFyJzonXFx1MkFFQicsJ3ZCYXJ2JzonXFx1MkFFOScsJ3ZjeSc6J1xcdTA0MzInLCdWY3knOidcXHUwNDEyJywndmRhc2gnOidcXHUyMkEyJywndkRhc2gnOidcXHUyMkE4JywnVmRhc2gnOidcXHUyMkE5JywnVkRhc2gnOidcXHUyMkFCJywnVmRhc2hsJzonXFx1MkFFNicsJ3ZlZSc6J1xcdTIyMjgnLCdWZWUnOidcXHUyMkMxJywndmVlYmFyJzonXFx1MjJCQicsJ3ZlZWVxJzonXFx1MjI1QScsJ3ZlbGxpcCc6J1xcdTIyRUUnLCd2ZXJiYXInOid8JywnVmVyYmFyJzonXFx1MjAxNicsJ3ZlcnQnOid8JywnVmVydCc6J1xcdTIwMTYnLCdWZXJ0aWNhbEJhcic6J1xcdTIyMjMnLCdWZXJ0aWNhbExpbmUnOid8JywnVmVydGljYWxTZXBhcmF0b3InOidcXHUyNzU4JywnVmVydGljYWxUaWxkZSc6J1xcdTIyNDAnLCdWZXJ5VGhpblNwYWNlJzonXFx1MjAwQScsJ3Zmcic6J1xcdUQ4MzVcXHVERDMzJywnVmZyJzonXFx1RDgzNVxcdUREMTknLCd2bHRyaSc6J1xcdTIyQjInLCd2bnN1Yic6J1xcdTIyODJcXHUyMEQyJywndm5zdXAnOidcXHUyMjgzXFx1MjBEMicsJ3ZvcGYnOidcXHVEODM1XFx1REQ2NycsJ1ZvcGYnOidcXHVEODM1XFx1REQ0RCcsJ3Zwcm9wJzonXFx1MjIxRCcsJ3ZydHJpJzonXFx1MjJCMycsJ3ZzY3InOidcXHVEODM1XFx1RENDQicsJ1ZzY3InOidcXHVEODM1XFx1RENCMScsJ3ZzdWJuZSc6J1xcdTIyOEFcXHVGRTAwJywndnN1Ym5FJzonXFx1MkFDQlxcdUZFMDAnLCd2c3VwbmUnOidcXHUyMjhCXFx1RkUwMCcsJ3ZzdXBuRSc6J1xcdTJBQ0NcXHVGRTAwJywnVnZkYXNoJzonXFx1MjJBQScsJ3Z6aWd6YWcnOidcXHUyOTlBJywnd2NpcmMnOidcXHUwMTc1JywnV2NpcmMnOidcXHUwMTc0Jywnd2VkYmFyJzonXFx1MkE1RicsJ3dlZGdlJzonXFx1MjIyNycsJ1dlZGdlJzonXFx1MjJDMCcsJ3dlZGdlcSc6J1xcdTIyNTknLCd3ZWllcnAnOidcXHUyMTE4Jywnd2ZyJzonXFx1RDgzNVxcdUREMzQnLCdXZnInOidcXHVEODM1XFx1REQxQScsJ3dvcGYnOidcXHVEODM1XFx1REQ2OCcsJ1dvcGYnOidcXHVEODM1XFx1REQ0RScsJ3dwJzonXFx1MjExOCcsJ3dyJzonXFx1MjI0MCcsJ3dyZWF0aCc6J1xcdTIyNDAnLCd3c2NyJzonXFx1RDgzNVxcdURDQ0MnLCdXc2NyJzonXFx1RDgzNVxcdURDQjInLCd4Y2FwJzonXFx1MjJDMicsJ3hjaXJjJzonXFx1MjVFRicsJ3hjdXAnOidcXHUyMkMzJywneGR0cmknOidcXHUyNUJEJywneGZyJzonXFx1RDgzNVxcdUREMzUnLCdYZnInOidcXHVEODM1XFx1REQxQicsJ3hoYXJyJzonXFx1MjdGNycsJ3hoQXJyJzonXFx1MjdGQScsJ3hpJzonXFx1MDNCRScsJ1hpJzonXFx1MDM5RScsJ3hsYXJyJzonXFx1MjdGNScsJ3hsQXJyJzonXFx1MjdGOCcsJ3htYXAnOidcXHUyN0ZDJywneG5pcyc6J1xcdTIyRkInLCd4b2RvdCc6J1xcdTJBMDAnLCd4b3BmJzonXFx1RDgzNVxcdURENjknLCdYb3BmJzonXFx1RDgzNVxcdURENEYnLCd4b3BsdXMnOidcXHUyQTAxJywneG90aW1lJzonXFx1MkEwMicsJ3hyYXJyJzonXFx1MjdGNicsJ3hyQXJyJzonXFx1MjdGOScsJ3hzY3InOidcXHVEODM1XFx1RENDRCcsJ1hzY3InOidcXHVEODM1XFx1RENCMycsJ3hzcWN1cCc6J1xcdTJBMDYnLCd4dXBsdXMnOidcXHUyQTA0JywneHV0cmknOidcXHUyNUIzJywneHZlZSc6J1xcdTIyQzEnLCd4d2VkZ2UnOidcXHUyMkMwJywneWFjdXRlJzonXFx4RkQnLCdZYWN1dGUnOidcXHhERCcsJ3lhY3knOidcXHUwNDRGJywnWUFjeSc6J1xcdTA0MkYnLCd5Y2lyYyc6J1xcdTAxNzcnLCdZY2lyYyc6J1xcdTAxNzYnLCd5Y3knOidcXHUwNDRCJywnWWN5JzonXFx1MDQyQicsJ3llbic6J1xceEE1JywneWZyJzonXFx1RDgzNVxcdUREMzYnLCdZZnInOidcXHVEODM1XFx1REQxQycsJ3lpY3knOidcXHUwNDU3JywnWUljeSc6J1xcdTA0MDcnLCd5b3BmJzonXFx1RDgzNVxcdURENkEnLCdZb3BmJzonXFx1RDgzNVxcdURENTAnLCd5c2NyJzonXFx1RDgzNVxcdURDQ0UnLCdZc2NyJzonXFx1RDgzNVxcdURDQjQnLCd5dWN5JzonXFx1MDQ0RScsJ1lVY3knOidcXHUwNDJFJywneXVtbCc6J1xceEZGJywnWXVtbCc6J1xcdTAxNzgnLCd6YWN1dGUnOidcXHUwMTdBJywnWmFjdXRlJzonXFx1MDE3OScsJ3pjYXJvbic6J1xcdTAxN0UnLCdaY2Fyb24nOidcXHUwMTdEJywnemN5JzonXFx1MDQzNycsJ1pjeSc6J1xcdTA0MTcnLCd6ZG90JzonXFx1MDE3QycsJ1pkb3QnOidcXHUwMTdCJywnemVldHJmJzonXFx1MjEyOCcsJ1plcm9XaWR0aFNwYWNlJzonXFx1MjAwQicsJ3pldGEnOidcXHUwM0I2JywnWmV0YSc6J1xcdTAzOTYnLCd6ZnInOidcXHVEODM1XFx1REQzNycsJ1pmcic6J1xcdTIxMjgnLCd6aGN5JzonXFx1MDQzNicsJ1pIY3knOidcXHUwNDE2JywnemlncmFycic6J1xcdTIxREQnLCd6b3BmJzonXFx1RDgzNVxcdURENkInLCdab3BmJzonXFx1MjEyNCcsJ3pzY3InOidcXHVEODM1XFx1RENDRicsJ1pzY3InOidcXHVEODM1XFx1RENCNScsJ3p3aic6J1xcdTIwMEQnLCd6d25qJzonXFx1MjAwQyd9O1xuXHR2YXIgZGVjb2RlTWFwTGVnYWN5ID0geydhYWN1dGUnOidcXHhFMScsJ0FhY3V0ZSc6J1xceEMxJywnYWNpcmMnOidcXHhFMicsJ0FjaXJjJzonXFx4QzInLCdhY3V0ZSc6J1xceEI0JywnYWVsaWcnOidcXHhFNicsJ0FFbGlnJzonXFx4QzYnLCdhZ3JhdmUnOidcXHhFMCcsJ0FncmF2ZSc6J1xceEMwJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhcmluZyc6J1xceEU1JywnQXJpbmcnOidcXHhDNScsJ2F0aWxkZSc6J1xceEUzJywnQXRpbGRlJzonXFx4QzMnLCdhdW1sJzonXFx4RTQnLCdBdW1sJzonXFx4QzQnLCdicnZiYXInOidcXHhBNicsJ2NjZWRpbCc6J1xceEU3JywnQ2NlZGlsJzonXFx4QzcnLCdjZWRpbCc6J1xceEI4JywnY2VudCc6J1xceEEyJywnY29weSc6J1xceEE5JywnQ09QWSc6J1xceEE5JywnY3VycmVuJzonXFx4QTQnLCdkZWcnOidcXHhCMCcsJ2RpdmlkZSc6J1xceEY3JywnZWFjdXRlJzonXFx4RTknLCdFYWN1dGUnOidcXHhDOScsJ2VjaXJjJzonXFx4RUEnLCdFY2lyYyc6J1xceENBJywnZWdyYXZlJzonXFx4RTgnLCdFZ3JhdmUnOidcXHhDOCcsJ2V0aCc6J1xceEYwJywnRVRIJzonXFx4RDAnLCdldW1sJzonXFx4RUInLCdFdW1sJzonXFx4Q0InLCdmcmFjMTInOidcXHhCRCcsJ2ZyYWMxNCc6J1xceEJDJywnZnJhYzM0JzonXFx4QkUnLCdndCc6Jz4nLCdHVCc6Jz4nLCdpYWN1dGUnOidcXHhFRCcsJ0lhY3V0ZSc6J1xceENEJywnaWNpcmMnOidcXHhFRScsJ0ljaXJjJzonXFx4Q0UnLCdpZXhjbCc6J1xceEExJywnaWdyYXZlJzonXFx4RUMnLCdJZ3JhdmUnOidcXHhDQycsJ2lxdWVzdCc6J1xceEJGJywnaXVtbCc6J1xceEVGJywnSXVtbCc6J1xceENGJywnbGFxdW8nOidcXHhBQicsJ2x0JzonPCcsJ0xUJzonPCcsJ21hY3InOidcXHhBRicsJ21pY3JvJzonXFx4QjUnLCdtaWRkb3QnOidcXHhCNycsJ25ic3AnOidcXHhBMCcsJ25vdCc6J1xceEFDJywnbnRpbGRlJzonXFx4RjEnLCdOdGlsZGUnOidcXHhEMScsJ29hY3V0ZSc6J1xceEYzJywnT2FjdXRlJzonXFx4RDMnLCdvY2lyYyc6J1xceEY0JywnT2NpcmMnOidcXHhENCcsJ29ncmF2ZSc6J1xceEYyJywnT2dyYXZlJzonXFx4RDInLCdvcmRmJzonXFx4QUEnLCdvcmRtJzonXFx4QkEnLCdvc2xhc2gnOidcXHhGOCcsJ09zbGFzaCc6J1xceEQ4Jywnb3RpbGRlJzonXFx4RjUnLCdPdGlsZGUnOidcXHhENScsJ291bWwnOidcXHhGNicsJ091bWwnOidcXHhENicsJ3BhcmEnOidcXHhCNicsJ3BsdXNtbic6J1xceEIxJywncG91bmQnOidcXHhBMycsJ3F1b3QnOidcIicsJ1FVT1QnOidcIicsJ3JhcXVvJzonXFx4QkInLCdyZWcnOidcXHhBRScsJ1JFRyc6J1xceEFFJywnc2VjdCc6J1xceEE3Jywnc2h5JzonXFx4QUQnLCdzdXAxJzonXFx4QjknLCdzdXAyJzonXFx4QjInLCdzdXAzJzonXFx4QjMnLCdzemxpZyc6J1xceERGJywndGhvcm4nOidcXHhGRScsJ1RIT1JOJzonXFx4REUnLCd0aW1lcyc6J1xceEQ3JywndWFjdXRlJzonXFx4RkEnLCdVYWN1dGUnOidcXHhEQScsJ3VjaXJjJzonXFx4RkInLCdVY2lyYyc6J1xceERCJywndWdyYXZlJzonXFx4RjknLCdVZ3JhdmUnOidcXHhEOScsJ3VtbCc6J1xceEE4JywndXVtbCc6J1xceEZDJywnVXVtbCc6J1xceERDJywneWFjdXRlJzonXFx4RkQnLCdZYWN1dGUnOidcXHhERCcsJ3llbic6J1xceEE1JywneXVtbCc6J1xceEZGJ307XG5cdHZhciBkZWNvZGVNYXBOdW1lcmljID0geycwJzonXFx1RkZGRCcsJzEyOCc6J1xcdTIwQUMnLCcxMzAnOidcXHUyMDFBJywnMTMxJzonXFx1MDE5MicsJzEzMic6J1xcdTIwMUUnLCcxMzMnOidcXHUyMDI2JywnMTM0JzonXFx1MjAyMCcsJzEzNSc6J1xcdTIwMjEnLCcxMzYnOidcXHUwMkM2JywnMTM3JzonXFx1MjAzMCcsJzEzOCc6J1xcdTAxNjAnLCcxMzknOidcXHUyMDM5JywnMTQwJzonXFx1MDE1MicsJzE0Mic6J1xcdTAxN0QnLCcxNDUnOidcXHUyMDE4JywnMTQ2JzonXFx1MjAxOScsJzE0Nyc6J1xcdTIwMUMnLCcxNDgnOidcXHUyMDFEJywnMTQ5JzonXFx1MjAyMicsJzE1MCc6J1xcdTIwMTMnLCcxNTEnOidcXHUyMDE0JywnMTUyJzonXFx1MDJEQycsJzE1Myc6J1xcdTIxMjInLCcxNTQnOidcXHUwMTYxJywnMTU1JzonXFx1MjAzQScsJzE1Nic6J1xcdTAxNTMnLCcxNTgnOidcXHUwMTdFJywnMTU5JzonXFx1MDE3OCd9O1xuXHR2YXIgaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMgPSBbMSwyLDMsNCw1LDYsNyw4LDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDEyNywxMjgsMTI5LDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDEzOSwxNDAsMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNTUsMTU2LDE1NywxNTgsMTU5LDY0OTc2LDY0OTc3LDY0OTc4LDY0OTc5LDY0OTgwLDY0OTgxLDY0OTgyLDY0OTgzLDY0OTg0LDY0OTg1LDY0OTg2LDY0OTg3LDY0OTg4LDY0OTg5LDY0OTkwLDY0OTkxLDY0OTkyLDY0OTkzLDY0OTk0LDY0OTk1LDY0OTk2LDY0OTk3LDY0OTk4LDY0OTk5LDY1MDAwLDY1MDAxLDY1MDAyLDY1MDAzLDY1MDA0LDY1MDA1LDY1MDA2LDY1MDA3LDY1NTM0LDY1NTM1LDEzMTA3MCwxMzEwNzEsMTk2NjA2LDE5NjYwNywyNjIxNDIsMjYyMTQzLDMyNzY3OCwzMjc2NzksMzkzMjE0LDM5MzIxNSw0NTg3NTAsNDU4NzUxLDUyNDI4Niw1MjQyODcsNTg5ODIyLDU4OTgyMyw2NTUzNTgsNjU1MzU5LDcyMDg5NCw3MjA4OTUsNzg2NDMwLDc4NjQzMSw4NTE5NjYsODUxOTY3LDkxNzUwMiw5MTc1MDMsOTgzMDM4LDk4MzAzOSwxMDQ4NTc0LDEwNDg1NzUsMTExNDExMCwxMTE0MTExXTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHR2YXIgb2JqZWN0ID0ge307XG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIGhhcyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XG5cdFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eU5hbWUpO1xuXHR9O1xuXG5cdHZhciBjb250YWlucyA9IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGlmIChhcnJheVtpbmRleF0gPT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR2YXIgbWVyZ2UgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRzO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0dmFyIGtleTtcblx0XHRmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuXHRcdFx0Ly8gQSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGlzIG5vdCBuZWVkZWQgaGVyZSwgc2luY2Ugb25seSByZWNvZ25pemVkXG5cdFx0XHQvLyBvcHRpb24gbmFtZXMgYXJlIHVzZWQgYW55d2F5LiBBbnkgb3RoZXJzIGFyZSBpZ25vcmVkLlxuXHRcdFx0cmVzdWx0W2tleV0gPSBoYXMob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gTW9kaWZpZWQgdmVyc2lvbiBvZiBgdWNzMmVuY29kZWA7IHNlZSBodHRwczovL210aHMuYmUvcHVueWNvZGUuXG5cdHZhciBjb2RlUG9pbnRUb1N5bWJvbCA9IGZ1bmN0aW9uKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRikge1xuXHRcdFx0Ly8gU2VlIGlzc3VlICM0OlxuXHRcdFx0Ly8g4oCcT3RoZXJ3aXNlLCBpZiB0aGUgbnVtYmVyIGlzIGluIHRoZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGIG9yIGlzXG5cdFx0XHQvLyBncmVhdGVyIHRoYW4gMHgxMEZGRkYsIHRoZW4gdGhpcyBpcyBhIHBhcnNlIGVycm9yLiBSZXR1cm4gYSBVK0ZGRkRcblx0XHRcdC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUi7igJ1cblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSBvdXRzaWRlIHRoZSBwZXJtaXNzaWJsZSBVbmljb2RlIHJhbmdlJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1xcdUZGRkQnO1xuXHRcdH1cblx0XHRpZiAoaGFzKGRlY29kZU1hcE51bWVyaWMsIGNvZGVQb2ludCkpIHtcblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVjb2RlTWFwTnVtZXJpY1tjb2RlUG9pbnRdO1xuXHRcdH1cblx0XHRpZiAoc3RyaWN0ICYmIGNvbnRhaW5zKGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzLCBjb2RlUG9pbnQpKSB7XG5cdFx0XHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuXHRcdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcblx0XHR9XG5cdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH07XG5cblx0dmFyIGhleEVzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRcdHJldHVybiAnJiN4JyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICc7Jztcblx0fTtcblxuXHR2YXIgZGVjRXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdFx0cmV0dXJuICcmIycgKyBjb2RlUG9pbnQgKyAnOyc7XG5cdH07XG5cblx0dmFyIHBhcnNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1BhcnNlIGVycm9yOiAnICsgbWVzc2FnZSk7XG5cdH07XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIGVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBlbmNvZGUub3B0aW9ucyk7XG5cdFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuXHRcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50LnRlc3Qoc3RyaW5nKSkge1xuXHRcdFx0cGFyc2VFcnJvcignZm9yYmlkZGVuIGNvZGUgcG9pbnQnKTtcblx0XHR9XG5cdFx0dmFyIGVuY29kZUV2ZXJ5dGhpbmcgPSBvcHRpb25zLmVuY29kZUV2ZXJ5dGhpbmc7XG5cdFx0dmFyIHVzZU5hbWVkUmVmZXJlbmNlcyA9IG9wdGlvbnMudXNlTmFtZWRSZWZlcmVuY2VzO1xuXHRcdHZhciBhbGxvd1Vuc2FmZVN5bWJvbHMgPSBvcHRpb25zLmFsbG93VW5zYWZlU3ltYm9scztcblx0XHR2YXIgZXNjYXBlQ29kZVBvaW50ID0gb3B0aW9ucy5kZWNpbWFsID8gZGVjRXNjYXBlIDogaGV4RXNjYXBlO1xuXG5cdFx0dmFyIGVzY2FwZUJtcFN5bWJvbCA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChzeW1ib2wuY2hhckNvZGVBdCgwKSk7XG5cdFx0fTtcblxuXHRcdGlmIChlbmNvZGVFdmVyeXRoaW5nKSB7XG5cdFx0XHQvLyBFbmNvZGUgQVNDSUkgc3ltYm9scy5cblx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4QXNjaWlXaGl0ZWxpc3QsIGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0XHQvLyBVc2UgbmFtZWQgcmVmZXJlbmNlcyBpZiByZXF1ZXN0ZWQgJiBwb3NzaWJsZS5cblx0XHRcdFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcyAmJiBoYXMoZW5jb2RlTWFwLCBzeW1ib2wpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzeW1ib2xdICsgJzsnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBlc2NhcGVCbXBTeW1ib2woc3ltYm9sKTtcblx0XHRcdH0pO1xuXHRcdFx0Ly8gU2hvcnRlbiBhIGZldyBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcblx0XHRcdC8vIGlzIHdpdGhpbiB0aGUgQVNDSUkgcmFuZ2UuXG5cdFx0XHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XG5cdFx0XHRcdHN0cmluZyA9IHN0cmluZ1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8mZ3Q7XFx1MjBEMi9nLCAnJm52Z3Q7Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvJmx0O1xcdTIwRDIvZywgJyZudmx0OycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyYjeDY2OyYjeDZBOy9nLCAnJmZqbGlnOycpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzLlxuXHRcdFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xuXHRcdFx0XHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cblx0XHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm90ZTogYW55IHJlbWFpbmluZyBub24tQVNDSUkgc3ltYm9scyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBgaWZgLlxuXHRcdH0gZWxzZSBpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XG5cdFx0XHQvLyBBcHBseSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cblx0XHRcdC8vIEVuY29kZSBgPD5cIicmYCB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cblx0XHRcdGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XG5cdFx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7IC8vIG5vIG5lZWQgdG8gY2hlY2sgYGhhcygpYCBoZXJlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2hvcnRlbiBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmUgaXNcblx0XHRcdC8vIGA8PlwiJyZgLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nXG5cdFx0XHRcdC5yZXBsYWNlKC8mZ3Q7XFx1MjBEMi9nLCAnJm52Z3Q7Jylcblx0XHRcdFx0LnJlcGxhY2UoLyZsdDtcXHUyMEQyL2csICcmbnZsdDsnKTtcblx0XHRcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXG5cdFx0XHRcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7Jztcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xuXHRcdFx0Ly8gRW5jb2RlIGA8PlwiJyZgIHVzaW5nIGhleGFkZWNpbWFsIGVzY2FwZXMsIG5vdyB0aGF0IHRoZXnigJlyZSBub3QgaGFuZGxlZFxuXHRcdFx0Ly8gdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZXNjYXBlQm1wU3ltYm9sKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0Ly8gRW5jb2RlIGFzdHJhbCBzeW1ib2xzLlxuXHRcdFx0LnJlcGxhY2UocmVnZXhBc3RyYWxTeW1ib2xzLCBmdW5jdGlvbigkMCkge1xuXHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0dmFyIGhpZ2ggPSAkMC5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHR2YXIgbG93ID0gJDAuY2hhckNvZGVBdCgxKTtcblx0XHRcdFx0dmFyIGNvZGVQb2ludCA9IChoaWdoIC0gMHhEODAwKSAqIDB4NDAwICsgbG93IC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdFx0fSlcblx0XHRcdC8vIEVuY29kZSBhbnkgcmVtYWluaW5nIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBwcmludGFibGUgQVNDSUkgc3ltYm9sc1xuXHRcdFx0Ly8gdXNpbmcgYSBoZXhhZGVjaW1hbCBlc2NhcGUuXG5cdFx0XHQucmVwbGFjZShyZWdleEJtcFdoaXRlbGlzdCwgZXNjYXBlQm1wU3ltYm9sKTtcblx0fTtcblx0Ly8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXG5cdGVuY29kZS5vcHRpb25zID0ge1xuXHRcdCdhbGxvd1Vuc2FmZVN5bWJvbHMnOiBmYWxzZSxcblx0XHQnZW5jb2RlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHRcdCdzdHJpY3QnOiBmYWxzZSxcblx0XHQndXNlTmFtZWRSZWZlcmVuY2VzJzogZmFsc2UsXG5cdFx0J2RlY2ltYWwnIDogZmFsc2Vcblx0fTtcblxuXHR2YXIgZGVjb2RlID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWNvZGUub3B0aW9ucyk7XG5cdFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuXHRcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkRW50aXR5LnRlc3QoaHRtbCkpIHtcblx0XHRcdHBhcnNlRXJyb3IoJ21hbGZvcm1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0fVxuXHRcdHJldHVybiBodG1sLnJlcGxhY2UocmVnZXhEZWNvZGUsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpIHtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgc2VtaWNvbG9uO1xuXHRcdFx0dmFyIGRlY0RpZ2l0cztcblx0XHRcdHZhciBoZXhEaWdpdHM7XG5cdFx0XHR2YXIgcmVmZXJlbmNlO1xuXHRcdFx0dmFyIG5leHQ7XG5cblx0XHRcdGlmICgkMSkge1xuXHRcdFx0XHRyZWZlcmVuY2UgPSAkMTtcblx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGRlY29kZU1hcCwgcmVmZXJlbmNlKWAuXG5cdFx0XHRcdHJldHVybiBkZWNvZGVNYXBbcmVmZXJlbmNlXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCQyKSB7XG5cdFx0XHRcdC8vIERlY29kZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyB3aXRob3V0IHRyYWlsaW5nIGA7YCwgZS5nLiBgJmFtcGAuXG5cdFx0XHRcdC8vIFRoaXMgaXMgb25seSBhIHBhcnNlIGVycm9yIGlmIGl0IGdldHMgY29udmVydGVkIHRvIGAmYCwgb3IgaWYgaXQgaXNcblx0XHRcdFx0Ly8gZm9sbG93ZWQgYnkgYD1gIGluIGFuIGF0dHJpYnV0ZSBjb250ZXh0LlxuXHRcdFx0XHRyZWZlcmVuY2UgPSAkMjtcblx0XHRcdFx0bmV4dCA9ICQzO1xuXHRcdFx0XHRpZiAobmV4dCAmJiBvcHRpb25zLmlzQXR0cmlidXRlVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoc3RyaWN0ICYmIG5leHQgPT0gJz0nKSB7XG5cdFx0XHRcdFx0XHRwYXJzZUVycm9yKCdgJmAgZGlkIG5vdCBzdGFydCBhIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICQwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0XHRcdHBhcnNlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXBMZWdhY3ksIHJlZmVyZW5jZSlgLlxuXHRcdFx0XHRcdHJldHVybiBkZWNvZGVNYXBMZWdhY3lbcmVmZXJlbmNlXSArIChuZXh0IHx8ICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDQpIHtcblx0XHRcdFx0Ly8gRGVjb2RlIGRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiMxMTk1NTg7YC5cblx0XHRcdFx0ZGVjRGlnaXRzID0gJDQ7XG5cdFx0XHRcdHNlbWljb2xvbiA9ICQ1O1xuXHRcdFx0XHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcblx0XHRcdFx0XHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvZGVQb2ludCA9IHBhcnNlSW50KGRlY0RpZ2l0cywgMTApO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDYpIHtcblx0XHRcdFx0Ly8gRGVjb2RlIGhleGFkZWNpbWFsIGVzY2FwZXMsIGUuZy4gYCYjeDFEMzA2O2AuXG5cdFx0XHRcdGhleERpZ2l0cyA9ICQ2O1xuXHRcdFx0XHRzZW1pY29sb24gPSAkNztcblx0XHRcdFx0aWYgKHN0cmljdCAmJiAhc2VtaWNvbG9uKSB7XG5cdFx0XHRcdFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludFRvU3ltYm9sKGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2XigJlyZSBzdGlsbCBoZXJlLCBgaWYgKCQ3KWAgaXMgaW1wbGllZDsgaXTigJlzIGFuIGFtYmlndW91c1xuXHRcdFx0Ly8gYW1wZXJzYW5kIGZvciBzdXJlLiBodHRwczovL210aHMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHNcblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcihcblx0XHRcdFx0XHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJDA7XG5cdFx0fSk7XG5cdH07XG5cdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxuXHRkZWNvZGUub3B0aW9ucyA9IHtcblx0XHQnaXNBdHRyaWJ1dGVWYWx1ZSc6IGZhbHNlLFxuXHRcdCdzdHJpY3QnOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBlc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKCQwKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZXNjYXBlTWFwLCAkMClgIGhlcmUuXG5cdFx0XHRyZXR1cm4gZXNjYXBlTWFwWyQwXTtcblx0XHR9KTtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgaGUgPSB7XG5cdFx0J3ZlcnNpb24nOiAnMS4yLjAnLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZXNjYXBlJzogZXNjYXBlLFxuXHRcdCd1bmVzY2FwZSc6IGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGhlO1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBoZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGhlKSB7XG5cdFx0XHRcdGhhcyhoZSwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGhlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QuaGUgPSBoZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2Bcbi8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG52YXIgZG9jdW1lbnREb3RBbGwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkb2N1bWVudC5hbGwgPT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmFsbCAhPT0gdW5kZWZpbmVkID8gZG9jdW1lbnQuYWxsIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gZG9jdW1lbnREb3RBbGwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICF2YWx1ZS5wcm90b3R5cGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSBkb2N1bWVudERvdEFsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIXZhbHVlLnByb3RvdHlwZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcblx0fTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGluZm86ICfihLnvuI8nLFxuXHRzdWNjZXNzOiAn4pyFJyxcblx0d2FybmluZzogJ+KaoO+4jycsXG5cdGVycm9yOiAn4p2M77iPJ1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwubG91cGUgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIGFuc2lDb2xvcnMgPSB7XG4gICAgYm9sZDogWycxJywgJzIyJ10sXG4gICAgZGltOiBbJzInLCAnMjInXSxcbiAgICBpdGFsaWM6IFsnMycsICcyMyddLFxuICAgIHVuZGVybGluZTogWyc0JywgJzI0J10sXG4gICAgLy8gNSAmIDYgYXJlIGJsaW5raW5nXG4gICAgaW52ZXJzZTogWyc3JywgJzI3J10sXG4gICAgaGlkZGVuOiBbJzgnLCAnMjgnXSxcbiAgICBzdHJpa2U6IFsnOScsICcyOSddLFxuICAgIC8vIDEwLTIwIGFyZSBmb250c1xuICAgIC8vIDIxLTI5IGFyZSByZXNldHMgZm9yIDEtOVxuICAgIGJsYWNrOiBbJzMwJywgJzM5J10sXG4gICAgcmVkOiBbJzMxJywgJzM5J10sXG4gICAgZ3JlZW46IFsnMzInLCAnMzknXSxcbiAgICB5ZWxsb3c6IFsnMzMnLCAnMzknXSxcbiAgICBibHVlOiBbJzM0JywgJzM5J10sXG4gICAgbWFnZW50YTogWyczNScsICczOSddLFxuICAgIGN5YW46IFsnMzYnLCAnMzknXSxcbiAgICB3aGl0ZTogWyczNycsICczOSddLFxuICAgIGJyaWdodGJsYWNrOiBbJzMwOzEnLCAnMzknXSxcbiAgICBicmlnaHRyZWQ6IFsnMzE7MScsICczOSddLFxuICAgIGJyaWdodGdyZWVuOiBbJzMyOzEnLCAnMzknXSxcbiAgICBicmlnaHR5ZWxsb3c6IFsnMzM7MScsICczOSddLFxuICAgIGJyaWdodGJsdWU6IFsnMzQ7MScsICczOSddLFxuICAgIGJyaWdodG1hZ2VudGE6IFsnMzU7MScsICczOSddLFxuICAgIGJyaWdodGN5YW46IFsnMzY7MScsICczOSddLFxuICAgIGJyaWdodHdoaXRlOiBbJzM3OzEnLCAnMzknXSxcbiAgICBncmV5OiBbJzkwJywgJzM5J11cbiAgfTtcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBzcGVjaWFsOiAnY3lhbicsXG4gICAgbnVtYmVyOiAneWVsbG93JyxcbiAgICBiaWdpbnQ6ICd5ZWxsb3cnLFxuICAgIGJvb2xlYW46ICd5ZWxsb3cnLFxuICAgIHVuZGVmaW5lZDogJ2dyZXknLFxuICAgIG51bGw6ICdib2xkJyxcbiAgICBzdHJpbmc6ICdncmVlbicsXG4gICAgc3ltYm9sOiAnZ3JlZW4nLFxuICAgIGRhdGU6ICdtYWdlbnRhJyxcbiAgICByZWdleHA6ICdyZWQnXG4gIH07XG4gIHZhciB0cnVuY2F0b3IgPSAn4oCmJztcblxuICBmdW5jdGlvbiBjb2xvcmlzZSh2YWx1ZSwgc3R5bGVUeXBlKSB7XG4gICAgdmFyIGNvbG9yID0gYW5zaUNvbG9yc1tzdHlsZXNbc3R5bGVUeXBlXV0gfHwgYW5zaUNvbG9yc1tzdHlsZVR5cGVdO1xuXG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXFx4MUJbXCIuY29uY2F0KGNvbG9yWzBdLCBcIm1cIikuY29uY2F0KFN0cmluZyh2YWx1ZSksIFwiXFx4MUJbXCIpLmNvbmNhdChjb2xvclsxXSwgXCJtXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXNlT3B0aW9ucygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkc2hvd0hpZGRlbiA9IF9yZWYuc2hvd0hpZGRlbixcbiAgICAgICAgc2hvd0hpZGRlbiA9IF9yZWYkc2hvd0hpZGRlbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHNob3dIaWRkZW4sXG4gICAgICAgIF9yZWYkZGVwdGggPSBfcmVmLmRlcHRoLFxuICAgICAgICBkZXB0aCA9IF9yZWYkZGVwdGggPT09IHZvaWQgMCA/IDIgOiBfcmVmJGRlcHRoLFxuICAgICAgICBfcmVmJGNvbG9ycyA9IF9yZWYuY29sb3JzLFxuICAgICAgICBjb2xvcnMgPSBfcmVmJGNvbG9ycyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGNvbG9ycyxcbiAgICAgICAgX3JlZiRjdXN0b21JbnNwZWN0ID0gX3JlZi5jdXN0b21JbnNwZWN0LFxuICAgICAgICBjdXN0b21JbnNwZWN0ID0gX3JlZiRjdXN0b21JbnNwZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRjdXN0b21JbnNwZWN0LFxuICAgICAgICBfcmVmJHNob3dQcm94eSA9IF9yZWYuc2hvd1Byb3h5LFxuICAgICAgICBzaG93UHJveHkgPSBfcmVmJHNob3dQcm94eSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHNob3dQcm94eSxcbiAgICAgICAgX3JlZiRtYXhBcnJheUxlbmd0aCA9IF9yZWYubWF4QXJyYXlMZW5ndGgsXG4gICAgICAgIG1heEFycmF5TGVuZ3RoID0gX3JlZiRtYXhBcnJheUxlbmd0aCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfcmVmJG1heEFycmF5TGVuZ3RoLFxuICAgICAgICBfcmVmJGJyZWFrTGVuZ3RoID0gX3JlZi5icmVha0xlbmd0aCxcbiAgICAgICAgYnJlYWtMZW5ndGggPSBfcmVmJGJyZWFrTGVuZ3RoID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9yZWYkYnJlYWtMZW5ndGgsXG4gICAgICAgIF9yZWYkc2VlbiA9IF9yZWYuc2VlbixcbiAgICAgICAgc2VlbiA9IF9yZWYkc2VlbiA9PT0gdm9pZCAwID8gW10gOiBfcmVmJHNlZW4sXG4gICAgICAgIF9yZWYkdHJ1bmNhdGUgPSBfcmVmLnRydW5jYXRlLFxuICAgICAgICB0cnVuY2F0ZSA9IF9yZWYkdHJ1bmNhdGUgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3JlZiR0cnVuY2F0ZSxcbiAgICAgICAgX3JlZiRzdHlsaXplID0gX3JlZi5zdHlsaXplLFxuICAgICAgICBzdHlsaXplID0gX3JlZiRzdHlsaXplID09PSB2b2lkIDAgPyBTdHJpbmcgOiBfcmVmJHN0eWxpemU7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHNob3dIaWRkZW46IEJvb2xlYW4oc2hvd0hpZGRlbiksXG4gICAgICBkZXB0aDogTnVtYmVyKGRlcHRoKSxcbiAgICAgIGNvbG9yczogQm9vbGVhbihjb2xvcnMpLFxuICAgICAgY3VzdG9tSW5zcGVjdDogQm9vbGVhbihjdXN0b21JbnNwZWN0KSxcbiAgICAgIHNob3dQcm94eTogQm9vbGVhbihzaG93UHJveHkpLFxuICAgICAgbWF4QXJyYXlMZW5ndGg6IE51bWJlcihtYXhBcnJheUxlbmd0aCksXG4gICAgICBicmVha0xlbmd0aDogTnVtYmVyKGJyZWFrTGVuZ3RoKSxcbiAgICAgIHRydW5jYXRlOiBOdW1iZXIodHJ1bmNhdGUpLFxuICAgICAgc2Vlbjogc2VlbixcbiAgICAgIHN0eWxpemU6IHN0eWxpemVcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuY29sb3JzKSB7XG4gICAgICBvcHRpb25zLnN0eWxpemUgPSBjb2xvcmlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIGxlbmd0aCkge1xuICAgIHZhciB0YWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVuY2F0b3I7XG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gICAgdmFyIHRhaWxMZW5ndGggPSB0YWlsLmxlbmd0aDtcbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIGlmICh0YWlsTGVuZ3RoID4gbGVuZ3RoICYmIHN0cmluZ0xlbmd0aCA+IHRhaWxMZW5ndGgpIHtcbiAgICAgIHJldHVybiB0YWlsO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmdMZW5ndGggPiBsZW5ndGggJiYgc3RyaW5nTGVuZ3RoID4gdGFpbExlbmd0aCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN0cmluZy5zbGljZSgwLCBsZW5ndGggLSB0YWlsTGVuZ3RoKSkuY29uY2F0KHRhaWwpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuICBmdW5jdGlvbiBpbnNwZWN0TGlzdChsaXN0LCBvcHRpb25zLCBpbnNwZWN0SXRlbSkge1xuICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcsICc7XG4gICAgaW5zcGVjdEl0ZW0gPSBpbnNwZWN0SXRlbSB8fCBvcHRpb25zLmluc3BlY3Q7XG4gICAgdmFyIHNpemUgPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBvcmlnaW5hbExlbmd0aCA9IG9wdGlvbnMudHJ1bmNhdGU7XG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHZhciBwZWVrID0gJyc7XG4gICAgdmFyIHRydW5jYXRlZCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgIHZhciBsYXN0ID0gaSArIDEgPT09IGxpc3QubGVuZ3RoO1xuICAgICAgdmFyIHNlY29uZFRvTGFzdCA9IGkgKyAyID09PSBsaXN0Lmxlbmd0aDtcbiAgICAgIHRydW5jYXRlZCA9IFwiXCIuY29uY2F0KHRydW5jYXRvciwgXCIoXCIpLmNvbmNhdChsaXN0Lmxlbmd0aCAtIGksIFwiKVwiKTtcbiAgICAgIHZhciB2YWx1ZSA9IGxpc3RbaV07IC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcmVtYWluaW5nIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYSBzZXBhcmF0b3Igb2YgYCwgYFxuXG4gICAgICBvcHRpb25zLnRydW5jYXRlID0gb3JpZ2luYWxMZW5ndGggLSBvdXRwdXQubGVuZ3RoIC0gKGxhc3QgPyAwIDogc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICB2YXIgc3RyaW5nID0gcGVlayB8fCBpbnNwZWN0SXRlbSh2YWx1ZSwgb3B0aW9ucykgKyAobGFzdCA/ICcnIDogc2VwYXJhdG9yKTtcbiAgICAgIHZhciBuZXh0TGVuZ3RoID0gb3V0cHV0Lmxlbmd0aCArIHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgdHJ1bmNhdGVkTGVuZ3RoID0gbmV4dExlbmd0aCArIHRydW5jYXRlZC5sZW5ndGg7IC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgZWxlbWVudCwgYW5kIGFkZGluZyBpdCB3b3VsZFxuICAgICAgLy8gdGFrZSB1cyBvdmVyIGxlbmd0aCwgYnV0IGFkZGluZyB0aGUgdHJ1bmNhdG9yIHdvdWxkbid0IC0gdGhlbiBicmVhayBub3dcblxuICAgICAgaWYgKGxhc3QgJiYgbmV4dExlbmd0aCA+IG9yaWdpbmFsTGVuZ3RoICYmIG91dHB1dC5sZW5ndGggKyB0cnVuY2F0ZWQubGVuZ3RoIDw9IG9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzbid0IHRoZSBsYXN0IG9yIHNlY29uZCB0byBsYXN0IGVsZW1lbnQgdG8gc2NhbixcbiAgICAgIC8vIGJ1dCB0aGUgc3RyaW5nIGlzIGFscmVhZHkgb3ZlciBsZW5ndGggdGhlbiBicmVhayBoZXJlXG5cblxuICAgICAgaWYgKCFsYXN0ICYmICFzZWNvbmRUb0xhc3QgJiYgdHJ1bmNhdGVkTGVuZ3RoID4gb3JpZ2luYWxMZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFBlZWsgYXQgdGhlIG5leHQgc3RyaW5nIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGRcbiAgICAgIC8vIGJyZWFrIGVhcmx5IGJlZm9yZSBhZGRpbmcgdGhpcyBpdGVtIHRvIHRoZSBvdXRwdXRcblxuXG4gICAgICBwZWVrID0gbGFzdCA/ICcnIDogaW5zcGVjdEl0ZW0obGlzdFtpICsgMV0sIG9wdGlvbnMpICsgKHNlY29uZFRvTGFzdCA/ICcnIDogc2VwYXJhdG9yKTsgLy8gSWYgd2UgaGF2ZSBvbmUgZWxlbWVudCBsZWZ0LCBidXQgdGhpcyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlIG5leHQgdGFrZXMgb3ZlciBsZW5ndGgsIHRoZSBicmVhayBlYXJseVxuXG4gICAgICBpZiAoIWxhc3QgJiYgc2Vjb25kVG9MYXN0ICYmIHRydW5jYXRlZExlbmd0aCA+IG9yaWdpbmFsTGVuZ3RoICYmIG5leHRMZW5ndGggKyBwZWVrLmxlbmd0aCA+IG9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQgKz0gc3RyaW5nOyAvLyBJZiB0aGUgbmV4dCBlbGVtZW50IHRha2VzIHVzIHRvIGxlbmd0aCAtXG4gICAgICAvLyBidXQgdGhlcmUgYXJlIG1vcmUgYWZ0ZXIgdGhhdCwgdGhlbiB3ZSBzaG91bGQgdHJ1bmNhdGUgbm93XG5cbiAgICAgIGlmICghbGFzdCAmJiAhc2Vjb25kVG9MYXN0ICYmIG5leHRMZW5ndGggKyBwZWVrLmxlbmd0aCA+PSBvcmlnaW5hbExlbmd0aCkge1xuICAgICAgICB0cnVuY2F0ZWQgPSBcIlwiLmNvbmNhdCh0cnVuY2F0b3IsIFwiKFwiKS5jb25jYXQobGlzdC5sZW5ndGggLSBpIC0gMSwgXCIpXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdHJ1bmNhdGVkID0gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG91dHB1dCkuY29uY2F0KHRydW5jYXRlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBxdW90ZUNvbXBsZXhLZXkoa2V5KSB7XG4gICAgaWYgKGtleS5tYXRjaCgvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLykpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdFByb3BlcnR5KF9yZWYyLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICBrZXkgPSBfcmVmM1swXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmM1sxXTtcblxuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gMjtcblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAga2V5ID0gcXVvdGVDb21wbGV4S2V5KGtleSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ICE9PSAnbnVtYmVyJykge1xuICAgICAga2V5ID0gXCJbXCIuY29uY2F0KG9wdGlvbnMuaW5zcGVjdChrZXksIG9wdGlvbnMpLCBcIl1cIik7XG4gICAgfVxuXG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSBrZXkubGVuZ3RoO1xuICAgIHZhbHVlID0gb3B0aW9ucy5pbnNwZWN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpLmNvbmNhdCh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0QXJyYXkoYXJyYXksIG9wdGlvbnMpIHtcbiAgICAvLyBPYmplY3Qua2V5cyB3aWxsIGFsd2F5cyBvdXRwdXQgdGhlIEFycmF5IGluZGljZXMgZmlyc3QsIHNvIHdlIGNhbiBzbGljZSBieVxuICAgIC8vIGBhcnJheS5sZW5ndGhgIHRvIGdldCBub24taW5kZXggcHJvcGVydGllc1xuICAgIHZhciBub25JbmRleFByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhhcnJheSkuc2xpY2UoYXJyYXkubGVuZ3RoKTtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCAmJiAhbm9uSW5kZXhQcm9wZXJ0aWVzLmxlbmd0aCkgcmV0dXJuICdbXSc7XG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSA0O1xuICAgIHZhciBsaXN0Q29udGVudHMgPSBpbnNwZWN0TGlzdChhcnJheSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSBsaXN0Q29udGVudHMubGVuZ3RoO1xuICAgIHZhciBwcm9wZXJ0eUNvbnRlbnRzID0gJyc7XG5cbiAgICBpZiAobm9uSW5kZXhQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgcHJvcGVydHlDb250ZW50cyA9IGluc3BlY3RMaXN0KG5vbkluZGV4UHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gW2tleSwgYXJyYXlba2V5XV07XG4gICAgICB9KSwgb3B0aW9ucywgaW5zcGVjdFByb3BlcnR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJbIFwiLmNvbmNhdChsaXN0Q29udGVudHMpLmNvbmNhdChwcm9wZXJ0eUNvbnRlbnRzID8gXCIsIFwiLmNvbmNhdChwcm9wZXJ0eUNvbnRlbnRzKSA6ICcnLCBcIiBdXCIpO1xuICB9XG5cbiAgLyogIVxuICAgKiBDaGFpIC0gZ2V0RnVuY05hbWUgdXRpbGl0eVxuICAgKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICAgKiBNSVQgTGljZW5zZWRcbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyAuZ2V0RnVuY05hbWUoY29uc3RydWN0b3JGbilcbiAgICpcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLlxuICAgKiBXaGVuIGEgbm9uLWZ1bmN0aW9uIGluc3RhbmNlIGlzIHBhc3NlZCwgcmV0dXJucyBgbnVsbGAuXG4gICAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBhRnVuYy5uYW1lYCBpcyBub3QgZGVmaW5lZC5cbiAgICpcbiAgICogQG5hbWUgZ2V0RnVuY05hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3RcbiAgICogQG5hbWVzcGFjZSBVdGlsc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgdG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBmdW5jdGlvbk5hbWVNYXRjaCA9IC9cXHMqZnVuY3Rpb24oPzpcXHN8XFxzKlxcL1xcKlteKD86KlxcLyldK1xcKlxcL1xccyopKihbXlxcc1xcKFxcL10rKS87XG4gIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGFGdW5jKSB7XG4gICAgaWYgKHR5cGVvZiBhRnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYUZ1bmMubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgRnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5IGFuZCBpZiBhRnVuYy5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgICB2YXIgbWF0Y2ggPSB0b1N0cmluZy5jYWxsKGFGdW5jKS5tYXRjaChmdW5jdGlvbk5hbWVNYXRjaCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBgbmFtZWAgcHJvcGVydHkgd2UganVzdCB1c2UgaXRcbiAgICAgIG5hbWUgPSBhRnVuYy5uYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgdmFyIGdldEZ1bmNOYW1lXzEgPSBnZXRGdW5jTmFtZTtcblxuICB2YXIgZ2V0QXJyYXlOYW1lID0gZnVuY3Rpb24gZ2V0QXJyYXlOYW1lKGFycmF5KSB7XG4gICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgTm9kZS5qcycgQnVmZmVycywgd2hpY2ggcmVwb3J0IHRvIGJlIFVpbnQ4QXJyYXlcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBhcnJheSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgcmV0dXJuICdCdWZmZXInO1xuICAgIH1cblxuICAgIGlmIChhcnJheVtTeW1ib2wudG9TdHJpbmdUYWddKSB7XG4gICAgICByZXR1cm4gYXJyYXlbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0RnVuY05hbWVfMShhcnJheS5jb25zdHJ1Y3Rvcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5zcGVjdFR5cGVkQXJyYXkoYXJyYXksIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IGdldEFycmF5TmFtZShhcnJheSk7XG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSBuYW1lLmxlbmd0aCArIDQ7IC8vIE9iamVjdC5rZXlzIHdpbGwgYWx3YXlzIG91dHB1dCB0aGUgQXJyYXkgaW5kaWNlcyBmaXJzdCwgc28gd2UgY2FuIHNsaWNlIGJ5XG4gICAgLy8gYGFycmF5Lmxlbmd0aGAgdG8gZ2V0IG5vbi1pbmRleCBwcm9wZXJ0aWVzXG5cbiAgICB2YXIgbm9uSW5kZXhQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoYXJyYXkpLnNsaWNlKGFycmF5Lmxlbmd0aCk7XG4gICAgaWYgKCFhcnJheS5sZW5ndGggJiYgIW5vbkluZGV4UHJvcGVydGllcy5sZW5ndGgpIHJldHVybiBcIlwiLmNvbmNhdChuYW1lLCBcIltdXCIpOyAvLyBBcyB3ZSBrbm93IFR5cGVkQXJyYXlzIG9ubHkgY29udGFpbiBVbnNpZ25lZCBJbnRlZ2Vycywgd2UgY2FuIHNraXAgaW5zcGVjdGluZyBlYWNoIG9uZSBhbmQgc2ltcGx5XG4gICAgLy8gc3R5bGlzZSB0aGUgdG9TdHJpbmcoKSB2YWx1ZSBvZiB0aGVtXG5cbiAgICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyaW5nID0gXCJcIi5jb25jYXQob3B0aW9ucy5zdHlsaXplKHRydW5jYXRlKGFycmF5W2ldLCBvcHRpb25zLnRydW5jYXRlKSwgJ251bWJlcicpKS5jb25jYXQoaSA9PT0gYXJyYXkubGVuZ3RoIC0gMSA/ICcnIDogJywgJyk7XG4gICAgICBvcHRpb25zLnRydW5jYXRlIC09IHN0cmluZy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJheVtpXSAhPT0gYXJyYXkubGVuZ3RoICYmIG9wdGlvbnMudHJ1bmNhdGUgPD0gMykge1xuICAgICAgICBvdXRwdXQgKz0gXCJcIi5jb25jYXQodHJ1bmNhdG9yLCBcIihcIikuY29uY2F0KGFycmF5Lmxlbmd0aCAtIGFycmF5W2ldICsgMSwgXCIpXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ICs9IHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlDb250ZW50cyA9ICcnO1xuXG4gICAgaWYgKG5vbkluZGV4UHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHByb3BlcnR5Q29udGVudHMgPSBpbnNwZWN0TGlzdChub25JbmRleFByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtrZXksIGFycmF5W2tleV1dO1xuICAgICAgfSksIG9wdGlvbnMsIGluc3BlY3RQcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUsIFwiWyBcIikuY29uY2F0KG91dHB1dCkuY29uY2F0KHByb3BlcnR5Q29udGVudHMgPyBcIiwgXCIuY29uY2F0KHByb3BlcnR5Q29udGVudHMpIDogJycsIFwiIF1cIik7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0RGF0ZShkYXRlT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byAtIHRydW5jYXRlIHRoZSB0aW1lIHBvcnRpb24sIGJ1dCBuZXZlciB0aGUgZGF0ZVxuICAgIHZhciBzcGxpdCA9IGRhdGVPYmplY3QudG9KU09OKCkuc3BsaXQoJ1QnKTtcbiAgICB2YXIgZGF0ZSA9IHNwbGl0WzBdO1xuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoXCJcIi5jb25jYXQoZGF0ZSwgXCJUXCIpLmNvbmNhdCh0cnVuY2F0ZShzcGxpdFsxXSwgb3B0aW9ucy50cnVuY2F0ZSAtIGRhdGUubGVuZ3RoIC0gMSkpLCAnZGF0ZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IGdldEZ1bmNOYW1lXzEoZnVuYyk7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoJ1tGdW5jdGlvbl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoXCJbRnVuY3Rpb24gXCIuY29uY2F0KHRydW5jYXRlKG5hbWUsIG9wdGlvbnMudHJ1bmNhdGUgLSAxMSksIFwiXVwiKSwgJ3NwZWNpYWwnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RNYXBFbnRyeShfcmVmLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGtleSA9IF9yZWYyWzBdLFxuICAgICAgICB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSA0O1xuICAgIGtleSA9IG9wdGlvbnMuaW5zcGVjdChrZXksIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0ga2V5Lmxlbmd0aDtcbiAgICB2YWx1ZSA9IG9wdGlvbnMuaW5zcGVjdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCIgPT4gXCIpLmNvbmNhdCh2YWx1ZSk7XG4gIH0gLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgYG1hcC5lbnRyaWVzKClgXG5cblxuICBmdW5jdGlvbiBtYXBUb0VudHJpZXMobWFwKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0TWFwKG1hcCwgb3B0aW9ucykge1xuICAgIHZhciBzaXplID0gbWFwLnNpemUgLSAxO1xuXG4gICAgaWYgKHNpemUgPD0gMCkge1xuICAgICAgcmV0dXJuICdNYXB7fSc7XG4gICAgfVxuXG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSA3O1xuICAgIHJldHVybiBcIk1hcHsgXCIuY29uY2F0KGluc3BlY3RMaXN0KG1hcFRvRW50cmllcyhtYXApLCBvcHRpb25zLCBpbnNwZWN0TWFwRW50cnkpLCBcIiB9XCIpO1xuICB9XG5cbiAgdmFyIGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGkgIT09IGk7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cblxuICBmdW5jdGlvbiBpbnNwZWN0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdHlsaXplKCdOYU4nLCAnbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoJ0luZmluaXR5JywgJ251bWJlcicpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZSgnLUluZmluaXR5JywgJ251bWJlcicpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPT09IDApIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoMSAvIG51bWJlciA9PT0gSW5maW5pdHkgPyAnKzAnIDogJy0wJywgJ251bWJlcicpO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUodHJ1bmNhdGUobnVtYmVyLCBvcHRpb25zLnRydW5jYXRlKSwgJ251bWJlcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdEJpZ0ludChudW1iZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgbnVtcyA9IHRydW5jYXRlKG51bWJlci50b1N0cmluZygpLCBvcHRpb25zLnRydW5jYXRlIC0gMSk7XG4gICAgaWYgKG51bXMgIT09IHRydW5jYXRvcikgbnVtcyArPSAnbic7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShudW1zLCAnYmlnaW50Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0UmVnRXhwKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIGZsYWdzID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLycpWzJdO1xuICAgIHZhciBzb3VyY2VMZW5ndGggPSBvcHRpb25zLnRydW5jYXRlIC0gKDIgKyBmbGFncy5sZW5ndGgpO1xuICAgIHZhciBzb3VyY2UgPSB2YWx1ZS5zb3VyY2U7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShcIi9cIi5jb25jYXQodHJ1bmNhdGUoc291cmNlLCBzb3VyY2VMZW5ndGgpLCBcIi9cIikuY29uY2F0KGZsYWdzKSwgJ3JlZ2V4cCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdFNldChzZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoc2V0LnNpemUgPT09IDApIHJldHVybiAnU2V0e30nO1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gNztcbiAgICByZXR1cm4gXCJTZXR7IFwiLmNvbmNhdChpbnNwZWN0TGlzdChhcnJheUZyb21TZXQoc2V0KSwgb3B0aW9ucyksIFwiIH1cIik7XG4gIH1cblxuICB2YXIgc3RyaW5nRXNjYXBlQ2hhcnMgPSBuZXcgUmVnRXhwKFwiWydcXFxcdTAwMDAtXFxcXHUwMDFmXFxcXHUwMDdmLVxcXFx1MDA5ZlxcXFx1MDBhZFxcXFx1MDYwMC1cXFxcdTA2MDRcXFxcdTA3MGZcXFxcdTE3YjRcXFxcdTE3YjVcIiArIFwiXFxcXHUyMDBjLVxcXFx1MjAwZlxcXFx1MjAyOC1cXFxcdTIwMmZcXFxcdTIwNjAtXFxcXHUyMDZmXFxcXHVmZWZmXFxcXHVmZmYwLVxcXFx1ZmZmZl1cIiwgJ2cnKTtcbiAgdmFyIGVzY2FwZUNoYXJhY3RlcnMgPSB7XG4gICAgJ1xcYic6ICdcXFxcYicsXG4gICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgJ1xcbic6ICdcXFxcbicsXG4gICAgJ1xcZic6ICdcXFxcZicsXG4gICAgJ1xccic6ICdcXFxccicsXG4gICAgXCInXCI6IFwiXFxcXCdcIixcbiAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgfTtcbiAgdmFyIGhleCA9IDE2O1xuICB2YXIgdW5pY29kZUxlbmd0aCA9IDQ7XG5cbiAgZnVuY3Rpb24gZXNjYXBlKGNoYXIpIHtcbiAgICByZXR1cm4gZXNjYXBlQ2hhcmFjdGVyc1tjaGFyXSB8fCBcIlxcXFx1XCIuY29uY2F0KFwiMDAwMFwiLmNvbmNhdChjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoaGV4KSkuc2xpY2UoLXVuaWNvZGVMZW5ndGgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKHN0cmluZ0VzY2FwZUNoYXJzLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoc3RyaW5nRXNjYXBlQ2hhcnMsIGVzY2FwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShcIidcIi5jb25jYXQodHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zLnRydW5jYXRlIC0gMiksIFwiJ1wiKSwgJ3N0cmluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdFN5bWJvbCh2YWx1ZSkge1xuICAgIGlmICgnZGVzY3JpcHRpb24nIGluIFN5bWJvbC5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5kZXNjcmlwdGlvbiA/IFwiU3ltYm9sKFwiLmNvbmNhdCh2YWx1ZS5kZXNjcmlwdGlvbiwgXCIpXCIpIDogJ1N5bWJvbCgpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBnZXRQcm9taXNlVmFsdWUgPSBmdW5jdGlvbiBnZXRQcm9taXNlVmFsdWUoKSB7XG4gICAgcmV0dXJuICdQcm9taXNle+KApn0nO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgdmFyIF9wcm9jZXNzJGJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKSxcbiAgICAgICAgZ2V0UHJvbWlzZURldGFpbHMgPSBfcHJvY2VzcyRiaW5kaW5nLmdldFByb21pc2VEZXRhaWxzLFxuICAgICAgICBrUGVuZGluZyA9IF9wcm9jZXNzJGJpbmRpbmcua1BlbmRpbmcsXG4gICAgICAgIGtSZWplY3RlZCA9IF9wcm9jZXNzJGJpbmRpbmcua1JlamVjdGVkO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2V0UHJvbWlzZURldGFpbHMoUHJvbWlzZS5yZXNvbHZlKCkpKSkge1xuICAgICAgZ2V0UHJvbWlzZVZhbHVlID0gZnVuY3Rpb24gZ2V0UHJvbWlzZVZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfZ2V0UHJvbWlzZURldGFpbHMgPSBnZXRQcm9taXNlRGV0YWlscyh2YWx1ZSksXG4gICAgICAgICAgICBfZ2V0UHJvbWlzZURldGFpbHMyID0gX3NsaWNlZFRvQXJyYXkoX2dldFByb21pc2VEZXRhaWxzLCAyKSxcbiAgICAgICAgICAgIHN0YXRlID0gX2dldFByb21pc2VEZXRhaWxzMlswXSxcbiAgICAgICAgICAgIGlubmVyVmFsdWUgPSBfZ2V0UHJvbWlzZURldGFpbHMyWzFdO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0ga1BlbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gJ1Byb21pc2V7PHBlbmRpbmc+fSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJQcm9taXNlXCIuY29uY2F0KHN0YXRlID09PSBrUmVqZWN0ZWQgPyAnIScgOiAnJywgXCJ7XCIpLmNvbmNhdChvcHRpb25zLmluc3BlY3QoaW5uZXJWYWx1ZSwgb3B0aW9ucyksIFwifVwiKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChub3ROb2RlKSB7XG4gICAgLyogaWdub3JlICovXG4gIH1cblxuICB2YXIgaW5zcGVjdFByb21pc2UgPSBnZXRQcm9taXNlVmFsdWU7XG5cbiAgZnVuY3Rpb24gaW5zcGVjdE9iamVjdChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpIDogW107XG5cbiAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDAgJiYgc3ltYm9scy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAne30nO1xuICAgIH1cblxuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gNDtcbiAgICBvcHRpb25zLnNlZW4gPSBvcHRpb25zLnNlZW4gfHwgW107XG5cbiAgICBpZiAob3B0aW9ucy5zZWVuLmluZGV4T2Yob2JqZWN0KSA+PSAwKSB7XG4gICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cblxuICAgIG9wdGlvbnMuc2Vlbi5wdXNoKG9iamVjdCk7XG4gICAgdmFyIHByb3BlcnR5Q29udGVudHMgPSBpbnNwZWN0TGlzdChwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pLCBvcHRpb25zLCBpbnNwZWN0UHJvcGVydHkpO1xuICAgIHZhciBzeW1ib2xDb250ZW50cyA9IGluc3BlY3RMaXN0KHN5bWJvbHMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSksIG9wdGlvbnMsIGluc3BlY3RQcm9wZXJ0eSk7XG4gICAgb3B0aW9ucy5zZWVuLnBvcCgpO1xuICAgIHZhciBzZXAgPSAnJztcblxuICAgIGlmIChwcm9wZXJ0eUNvbnRlbnRzICYmIHN5bWJvbENvbnRlbnRzKSB7XG4gICAgICBzZXAgPSAnLCAnO1xuICAgIH1cblxuICAgIHJldHVybiBcInsgXCIuY29uY2F0KHByb3BlcnR5Q29udGVudHMpLmNvbmNhdChzZXApLmNvbmNhdChzeW1ib2xDb250ZW50cywgXCIgfVwiKTtcbiAgfVxuXG4gIHZhciB0b1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZyA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IGZhbHNlO1xuICBmdW5jdGlvbiBpbnNwZWN0Q2xhc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9ICcnO1xuXG4gICAgaWYgKHRvU3RyaW5nVGFnICYmIHRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG4gICAgICBuYW1lID0gdmFsdWVbdG9TdHJpbmdUYWddO1xuICAgIH1cblxuICAgIG5hbWUgPSBuYW1lIHx8IGdldEZ1bmNOYW1lXzEodmFsdWUuY29uc3RydWN0b3IpOyAvLyBCYWJlbCB0cmFuc2Zvcm1zIGFub255bW91cyBjbGFzc2VzIHRvIHRoZSBuYW1lIGBfY2xhc3NgXG5cbiAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gJ19jbGFzcycpIHtcbiAgICAgIG5hbWUgPSAnPEFub255bW91cyBDbGFzcz4nO1xuICAgIH1cblxuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gbmFtZS5sZW5ndGg7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUpLmNvbmNhdChpbnNwZWN0T2JqZWN0KHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0QXJndW1lbnRzKGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiAnQXJndW1lbnRzW10nO1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gMTM7XG4gICAgcmV0dXJuIFwiQXJndW1lbnRzWyBcIi5jb25jYXQoaW5zcGVjdExpc3QoYXJncywgb3B0aW9ucyksIFwiIF1cIik7XG4gIH1cblxuICB2YXIgZXJyb3JLZXlzID0gWydzdGFjaycsICdsaW5lJywgJ2NvbHVtbicsICduYW1lJywgJ21lc3NhZ2UnLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdjb2x1bW5OdW1iZXInLCAnbnVtYmVyJywgJ2Rlc2NyaXB0aW9uJ107XG4gIGZ1bmN0aW9uIGluc3BlY3RPYmplY3QkMShlcnJvciwgb3B0aW9ucykge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyb3IpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZXJyb3JLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG4gICAgdmFyIG5hbWUgPSBlcnJvci5uYW1lO1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gbmFtZS5sZW5ndGg7XG4gICAgdmFyIG1lc3NhZ2UgPSAnJztcblxuICAgIGlmICh0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1lc3NhZ2UgPSB0cnVuY2F0ZShlcnJvci5tZXNzYWdlLCBvcHRpb25zLnRydW5jYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydGllcy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJyc7XG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSBtZXNzYWdlLmxlbmd0aCArIDU7XG4gICAgdmFyIHByb3BlcnR5Q29udGVudHMgPSBpbnNwZWN0TGlzdChwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgZXJyb3Jba2V5XV07XG4gICAgfSksIG9wdGlvbnMsIGluc3BlY3RQcm9wZXJ0eSk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUpLmNvbmNhdChtZXNzYWdlKS5jb25jYXQocHJvcGVydHlDb250ZW50cyA/IFwiIHsgXCIuY29uY2F0KHByb3BlcnR5Q29udGVudHMsIFwiIH1cIikgOiAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0QXR0cmlidXRlKF9yZWYsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZjJbMV07XG5cbiAgICBvcHRpb25zLnRydW5jYXRlIC09IDM7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQob3B0aW9ucy5zdHlsaXplKGtleSwgJ3llbGxvdycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQob3B0aW9ucy5zdHlsaXplKGtleSwgJ3llbGxvdycpLCBcIj1cIikuY29uY2F0KG9wdGlvbnMuc3R5bGl6ZShcIlxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSwgJ3N0cmluZycpKTtcbiAgfVxuICBmdW5jdGlvbiBpbnNwZWN0SFRNTENvbGxlY3Rpb24oY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgIHJldHVybiBpbnNwZWN0TGlzdChjb2xsZWN0aW9uLCBvcHRpb25zLCBpbnNwZWN0SFRNTCwgJ1xcbicpO1xuICB9XG4gIGZ1bmN0aW9uIGluc3BlY3RIVE1MKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlTmFtZXMoKTtcbiAgICB2YXIgbmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBoZWFkID0gb3B0aW9ucy5zdHlsaXplKFwiPFwiLmNvbmNhdChuYW1lKSwgJ3NwZWNpYWwnKTtcbiAgICB2YXIgaGVhZENsb3NlID0gb3B0aW9ucy5zdHlsaXplKFwiPlwiLCAnc3BlY2lhbCcpO1xuICAgIHZhciB0YWlsID0gb3B0aW9ucy5zdHlsaXplKFwiPC9cIi5jb25jYXQobmFtZSwgXCI+XCIpLCAnc3BlY2lhbCcpO1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgLT0gbmFtZS5sZW5ndGggKiAyICsgNTtcbiAgICB2YXIgcHJvcGVydHlDb250ZW50cyA9ICcnO1xuXG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgcHJvcGVydHlDb250ZW50cyArPSAnICc7XG4gICAgICBwcm9wZXJ0eUNvbnRlbnRzICs9IGluc3BlY3RMaXN0KHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtrZXksIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSldO1xuICAgICAgfSksIG9wdGlvbnMsIGluc3BlY3RBdHRyaWJ1dGUsICcgJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy50cnVuY2F0ZSAtPSBwcm9wZXJ0eUNvbnRlbnRzLmxlbmd0aDtcbiAgICB2YXIgdHJ1bmNhdGUgPSBvcHRpb25zLnRydW5jYXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IGluc3BlY3RIVE1MQ29sbGVjdGlvbihlbGVtZW50LmNoaWxkcmVuLCBvcHRpb25zKTtcblxuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiB0cnVuY2F0ZSkge1xuICAgICAgY2hpbGRyZW4gPSBcIlwiLmNvbmNhdCh0cnVuY2F0b3IsIFwiKFwiKS5jb25jYXQoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGgsIFwiKVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZCkuY29uY2F0KHByb3BlcnR5Q29udGVudHMpLmNvbmNhdChoZWFkQ2xvc2UpLmNvbmNhdChjaGlsZHJlbikuY29uY2F0KHRhaWwpO1xuICB9XG5cbiAgdmFyIHN5bWJvbHNTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nO1xuICB2YXIgY2hhaUluc3BlY3QgPSBzeW1ib2xzU3VwcG9ydGVkID8gU3ltYm9sLmZvcignY2hhaS9pbnNwZWN0JykgOiAnQEBjaGFpL2luc3BlY3QnO1xuICB2YXIgbm9kZUluc3BlY3QgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICAgIHZhciBub2RlVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuICAgIG5vZGVJbnNwZWN0ID0gbm9kZVV0aWwuaW5zcGVjdCA/IG5vZGVVdGlsLmluc3BlY3QuY3VzdG9tIDogZmFsc2U7XG4gIH0gY2F0Y2ggKG5vTm9kZUluc3BlY3QpIHtcbiAgICBub2RlSW5zcGVjdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNvbnN0cnVjdG9yTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHN0cmluZ1RhZ01hcCA9IHt9O1xuICB2YXIgYmFzZVR5cGVzTWFwID0ge1xuICAgIHVuZGVmaW5lZDogZnVuY3Rpb24gdW5kZWZpbmVkJDEodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgICB9LFxuICAgIG51bGw6IGZ1bmN0aW9uIF9udWxsKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdHlsaXplKG51bGwsICdudWxsJyk7XG4gICAgfSxcbiAgICBib29sZWFuOiBmdW5jdGlvbiBib29sZWFuKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdHlsaXplKHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH0sXG4gICAgQm9vbGVhbjogZnVuY3Rpb24gQm9vbGVhbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZSh2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9LFxuICAgIG51bWJlcjogaW5zcGVjdE51bWJlcixcbiAgICBOdW1iZXI6IGluc3BlY3ROdW1iZXIsXG4gICAgYmlnaW50OiBpbnNwZWN0QmlnSW50LFxuICAgIEJpZ0ludDogaW5zcGVjdEJpZ0ludCxcbiAgICBzdHJpbmc6IGluc3BlY3RTdHJpbmcsXG4gICAgU3RyaW5nOiBpbnNwZWN0U3RyaW5nLFxuICAgIGZ1bmN0aW9uOiBpbnNwZWN0RnVuY3Rpb24sXG4gICAgRnVuY3Rpb246IGluc3BlY3RGdW5jdGlvbixcbiAgICBzeW1ib2w6IGluc3BlY3RTeW1ib2wsXG4gICAgLy8gQSBTeW1ib2wgcG9seWZpbGwgd2lsbCByZXR1cm4gYFN5bWJvbGAgbm90IGBzeW1ib2xgIGZyb20gdHlwZWRldGVjdFxuICAgIFN5bWJvbDogaW5zcGVjdFN5bWJvbCxcbiAgICBBcnJheTogaW5zcGVjdEFycmF5LFxuICAgIERhdGU6IGluc3BlY3REYXRlLFxuICAgIE1hcDogaW5zcGVjdE1hcCxcbiAgICBTZXQ6IGluc3BlY3RTZXQsXG4gICAgUmVnRXhwOiBpbnNwZWN0UmVnRXhwLFxuICAgIFByb21pc2U6IGluc3BlY3RQcm9taXNlLFxuICAgIC8vIFdlYWtTZXQsIFdlYWtNYXAgYXJlIHRvdGFsbHkgb3BhcXVlIHRvIHVzXG4gICAgV2Vha1NldDogZnVuY3Rpb24gV2Vha1NldCh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZSgnV2Vha1NldHvigKZ9JywgJ3NwZWNpYWwnKTtcbiAgICB9LFxuICAgIFdlYWtNYXA6IGZ1bmN0aW9uIFdlYWtNYXAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoJ1dlYWtNYXB74oCmfScsICdzcGVjaWFsJyk7XG4gICAgfSxcbiAgICBBcmd1bWVudHM6IGluc3BlY3RBcmd1bWVudHMsXG4gICAgSW50OEFycmF5OiBpbnNwZWN0VHlwZWRBcnJheSxcbiAgICBVaW50OEFycmF5OiBpbnNwZWN0VHlwZWRBcnJheSxcbiAgICBVaW50OENsYW1wZWRBcnJheTogaW5zcGVjdFR5cGVkQXJyYXksXG4gICAgSW50MTZBcnJheTogaW5zcGVjdFR5cGVkQXJyYXksXG4gICAgVWludDE2QXJyYXk6IGluc3BlY3RUeXBlZEFycmF5LFxuICAgIEludDMyQXJyYXk6IGluc3BlY3RUeXBlZEFycmF5LFxuICAgIFVpbnQzMkFycmF5OiBpbnNwZWN0VHlwZWRBcnJheSxcbiAgICBGbG9hdDMyQXJyYXk6IGluc3BlY3RUeXBlZEFycmF5LFxuICAgIEZsb2F0NjRBcnJheTogaW5zcGVjdFR5cGVkQXJyYXksXG4gICAgR2VuZXJhdG9yOiBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcbiAgICBEYXRhVmlldzogZnVuY3Rpb24gRGF0YVZpZXcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcbiAgICBBcnJheUJ1ZmZlcjogZnVuY3Rpb24gQXJyYXlCdWZmZXIoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcbiAgICBFcnJvcjogaW5zcGVjdE9iamVjdCQxLFxuICAgIEhUTUxDb2xsZWN0aW9uOiBpbnNwZWN0SFRNTENvbGxlY3Rpb24sXG4gICAgTm9kZUxpc3Q6IGluc3BlY3RIVE1MQ29sbGVjdGlvblxuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG4gIHZhciBpbnNwZWN0Q3VzdG9tID0gZnVuY3Rpb24gaW5zcGVjdEN1c3RvbSh2YWx1ZSwgb3B0aW9ucywgdHlwZSkge1xuICAgIGlmIChjaGFpSW5zcGVjdCBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWVbY2hhaUluc3BlY3RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWVbY2hhaUluc3BlY3RdKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChub2RlSW5zcGVjdCAmJiBub2RlSW5zcGVjdCBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWVbbm9kZUluc3BlY3RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWVbbm9kZUluc3BlY3RdKG9wdGlvbnMuZGVwdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICgnaW5zcGVjdCcgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5pbnNwZWN0KG9wdGlvbnMuZGVwdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICgnY29uc3RydWN0b3InIGluIHZhbHVlICYmIGNvbnN0cnVjdG9yTWFwLmhhcyh2YWx1ZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck1hcC5nZXQodmFsdWUuY29uc3RydWN0b3IpKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nVGFnTWFwW3R5cGVdKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVGFnTWFwW3R5cGVdKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgdmFyIHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gbm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBvcHRpb25zLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGN1c3RvbUluc3BlY3QgPSBfb3B0aW9ucy5jdXN0b21JbnNwZWN0O1xuICAgIHZhciB0eXBlID0gdmFsdWUgPT09IG51bGwgPyAnbnVsbCcgOiBfdHlwZW9mKHZhbHVlKTtcblxuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdHlwZSA9IHRvU3RyaW5nJDEuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICAgIH0gLy8gSWYgaXQgaXMgYSBiYXNlIHZhbHVlIHRoYXQgd2UgYWxyZWFkeSBzdXBwb3J0LCB0aGVuIHVzZSBMb3VwZSdzIGluc3BlY3RvclxuXG5cbiAgICBpZiAoYmFzZVR5cGVzTWFwW3R5cGVdKSB7XG4gICAgICByZXR1cm4gYmFzZVR5cGVzTWFwW3R5cGVdKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9IC8vIElmIGBvcHRpb25zLmN1c3RvbUluc3BlY3RgIGlzIHNldCB0byB0cnVlIHRoZW4gdHJ5IHRvIHVzZSB0aGUgY3VzdG9tIGluc3BlY3RvclxuXG5cbiAgICBpZiAoY3VzdG9tSW5zcGVjdCAmJiB2YWx1ZSkge1xuICAgICAgdmFyIG91dHB1dCA9IGluc3BlY3RDdXN0b20odmFsdWUsIG9wdGlvbnMsIHR5cGUpO1xuXG4gICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnc3RyaW5nJykgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgcmV0dXJuIGluc3BlY3Qob3V0cHV0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSB2YWx1ZSA/IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgOiBmYWxzZTsgLy8gSWYgaXQncyBhIHBsYWluIE9iamVjdCB0aGVuIHVzZSBMb3VwZSdzIGluc3BlY3RvclxuXG4gICAgaWYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdE9iamVjdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfSAvLyBTcGVjaWZpY2FsbHkgYWNjb3VudCBmb3IgSFRNTEVsZW1lbnRzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cblxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGluc3BlY3RIVE1MKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoJ2NvbnN0cnVjdG9yJyBpbiB2YWx1ZSkge1xuICAgICAgLy8gSWYgaXQgaXMgYSBjbGFzcywgaW5zcGVjdCBpdCBsaWtlIGFuIG9iamVjdCBidXQgYWRkIHRoZSBjb25zdHJ1Y3RvciBuYW1lXG4gICAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICByZXR1cm4gaW5zcGVjdENsYXNzKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH0gLy8gSWYgaXQgaXMgYW4gb2JqZWN0IHdpdGggYW4gYW5vbnltb3VzIHByb3RvdHlwZSwgZGlzcGxheSBpdCBhcyBhbiBvYmplY3QuXG5cblxuICAgICAgcmV0dXJuIGluc3BlY3RPYmplY3QodmFsdWUsIG9wdGlvbnMpO1xuICAgIH0gLy8gbGFzdCBjaGFuY2UgdG8gY2hlY2sgaWYgaXQncyBhbiBvYmplY3RcblxuXG4gICAgaWYgKHZhbHVlID09PSBPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdE9iamVjdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfSAvLyBXZSBoYXZlIHJ1biBvdXQgb2Ygb3B0aW9ucyEgSnVzdCBzdHJpbmdpZnkgdGhlIHZhbHVlXG5cblxuICAgIHJldHVybiBvcHRpb25zLnN0eWxpemUoU3RyaW5nKHZhbHVlKSwgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb25zdHJ1Y3Rvcihjb25zdHJ1Y3RvciwgaW5zcGVjdG9yKSB7XG4gICAgaWYgKGNvbnN0cnVjdG9yTWFwLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvck1hcC5hZGQoY29uc3RydWN0b3IsIGluc3BlY3Rvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJTdHJpbmdUYWcoc3RyaW5nVGFnLCBpbnNwZWN0b3IpIHtcbiAgICBpZiAoc3RyaW5nVGFnIGluIHN0cmluZ1RhZ01hcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0cmluZ1RhZ01hcFtzdHJpbmdUYWddID0gaW5zcGVjdG9yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBjdXN0b20gPSBjaGFpSW5zcGVjdDtcblxuICBleHBvcnRzLmN1c3RvbSA9IGN1c3RvbTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gaW5zcGVjdDtcbiAgZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgZXhwb3J0cy5yZWdpc3RlckNvbnN0cnVjdG9yID0gcmVnaXN0ZXJDb25zdHJ1Y3RvcjtcbiAgZXhwb3J0cy5yZWdpc3RlclN0cmluZ1RhZyA9IHJlZ2lzdGVyU3RyaW5nVGFnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9ICgpID0+IChbXSk7XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IFwiLi4vbm9kZV9tb2R1bGVzL21vY2hhL2xpYiBzeW5jIHJlY3Vyc2l2ZVwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0OyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBwYXRodmFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2dpY2FscGFyYWRveC9maWx0clxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmhhc1Byb3BlcnR5KG9iamVjdCwgbmFtZSlcbiAqXG4gKiBUaGlzIGFsbG93cyBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgb3duXG4gKiBvciBpbmhlcml0ZWQgZnJvbSBwcm90b3R5cGUgY2hhaW4gbmFtZWQgcHJvcGVydHkuXG4gKlxuICogQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGBpbmBcbiAqIG9wZXJhdG9yIGJ1dCB3b3JrcyBwcm9wZXJseSB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICogYW5kIG90aGVyIHByaW1pdGl2ZXMuXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdzdHInKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdjb25zdHJ1Y3RvcicpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ2JhcicpOyAgLy8gZmFsc2VcbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgJ2xlbmd0aCcpOyAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgMSk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgNSk7ICAvLyBmYWxzZVxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAnbGVuZ3RoJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgMik7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgMyk7ICAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgaXQgZXhpc3RzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBoYXNQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBgaW5gIG9wZXJhdG9yIGRvZXMgbm90IHdvcmsgd2l0aCBwcmltaXRpdmVzLlxuICByZXR1cm4gbmFtZSBpbiBPYmplY3Qob2JqKTtcbn1cblxuLyogIVxuICogIyMgcGFyc2VQYXRoKHBhdGgpXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2Ugc3RyaW5nIG9iamVjdFxuICogcGF0aHMuIFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIGBpbnRlcm5hbEdldFBhdGhWYWx1ZWAuXG4gKlxuICogICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKCdteW9iamVjdC5wcm9wZXJ0eS5zdWJwcm9wJyk7XG4gKlxuICogIyMjIFBhdGhzOlxuICpcbiAqICogQ2FuIGJlIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkLlxuICogKiBBcnJheXMgYXJlIGFsc28gdmFsaWQgdXNpbmcgdGhlIGZvcm1hbCBgbXlvYmplY3QuZG9jdW1lbnRbM10ucHJvcGVydHlgLlxuICogKiBMaXRlcmFsIGRvdHMgYW5kIGJyYWNrZXRzIChub3QgZGVsaW1pdGVyKSBtdXN0IGJlIGJhY2tzbGFzaC1lc2NhcGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoLyhbXlxcXFxdKVxcWy9nLCAnJDEuWycpO1xuICB2YXIgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcXFwufFteLl0rPykrL2cpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uIG1hcE1hdGNoZXModmFsdWUpIHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PT0gJ2NvbnN0cnVjdG9yJyB8fFxuICAgICAgdmFsdWUgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICB2YWx1ZSA9PT0gJ3Byb3RvdHlwZSdcbiAgICApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdmFyIHJlZ2V4cCA9IC9eXFxbKFxcZCspXFxdJC87XG4gICAgdmFyIG1BcnIgPSByZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgdmFyIHBhcnNlZCA9IG51bGw7XG4gICAgaWYgKG1BcnIpIHtcbiAgICAgIHBhcnNlZCA9IHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQgPSB7IHA6IHZhbHVlLnJlcGxhY2UoL1xcXFwoWy5bXFxdXSkvZywgJyQxJykgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcbn1cblxuLyogIVxuICogIyMgaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWRbLCBwYXRoRGVwdGhdKVxuICpcbiAqIEhlbHBlciBjb21wYW5pb24gZnVuY3Rpb24gZm9yIGAucGFyc2VQYXRoYCB0aGF0IHJldHVybnNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IHRoZSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgICAgIHZhciB2YWx1ZSA9IGdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGAuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggKG5lc3RpbmcgbGV2ZWwpIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7T2JqZWN0fFVuZGVmaW5lZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkLCBwYXRoRGVwdGgpIHtcbiAgdmFyIHRlbXBvcmFyeVZhbHVlID0gb2JqO1xuICB2YXIgcmVzID0gbnVsbDtcbiAgcGF0aERlcHRoID0gdHlwZW9mIHBhdGhEZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyBwYXJzZWQubGVuZ3RoIDogcGF0aERlcHRoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aERlcHRoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodGVtcG9yYXJ5VmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSA9IHRlbXBvcmFyeVZhbHVlW3BhcnQuaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSA9IHRlbXBvcmFyeVZhbHVlW3BhcnQucF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSBwYXRoRGVwdGggLSAxKSB7XG4gICAgICAgIHJlcyA9IHRlbXBvcmFyeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbi8qICFcbiAqICMjIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsdWUsIHBhcnNlZClcbiAqXG4gKiBDb21wYW5pb24gZnVuY3Rpb24gZm9yIGBwYXJzZVBhdGhgIHRoYXQgc2V0c1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgYSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCAndmFsdWUnLCBwYXJzZWQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFuZCBkZWZpbmUgb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdG8gdXNlIHVwb24gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWwsIHBhcnNlZCkge1xuICB2YXIgdGVtcE9iaiA9IG9iajtcbiAgdmFyIHBhdGhEZXB0aCA9IHBhcnNlZC5sZW5ndGg7XG4gIHZhciBwYXJ0ID0gbnVsbDtcbiAgLy8gSGVyZSB3ZSBpdGVyYXRlIHRocm91Z2ggZXZlcnkgcGFydCBvZiB0aGUgcGF0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhEZXB0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gbnVsbDtcbiAgICB2YXIgcHJvcFZhbCA9IG51bGw7XG4gICAgcGFydCA9IHBhcnNlZFtpXTtcblxuICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCwgd2Ugc2V0IHRoZSAncHJvcE5hbWUnIHZhbHVlIHdpdGggdGhlIHByb3BlcnR5IG5hbWVcbiAgICBpZiAoaSA9PT0gcGF0aERlcHRoIC0gMSkge1xuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIE5vdyB3ZSBzZXQgdGhlIHByb3BlcnR5IHdpdGggdGhlIG5hbWUgaGVsZCBieSAncHJvcE5hbWUnIG9uIG9iamVjdCB3aXRoIHRoZSBkZXNpcmVkIHZhbFxuICAgICAgdGVtcE9ialtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5wICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQucF0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQucF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydC5pICE9PSAndW5kZWZpbmVkJyAmJiB0ZW1wT2JqW3BhcnQuaV0pIHtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3BhcnQuaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBvYmogZG9lc24ndCBoYXZlIHRoZSBwcm9wZXJ0eSB3ZSBjcmVhdGUgb25lIHdpdGggdGhhdCBuYW1lIHRvIGRlZmluZSBpdFxuICAgICAgdmFyIG5leHQgPSBwYXJzZWRbaSArIDFdO1xuICAgICAgLy8gSGVyZSB3ZSBzZXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdoaWNoIHdpbGwgYmUgZGVmaW5lZFxuICAgICAgcHJvcE5hbWUgPSB0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJyA/IHBhcnQuaSA6IHBhcnQucDtcbiAgICAgIC8vIEhlcmUgd2UgZGVjaWRlIGlmIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBhbiBhcnJheSBvciBhIG5ldyBvYmplY3RcbiAgICAgIHByb3BWYWwgPSB0eXBlb2YgbmV4dC5wID09PSAndW5kZWZpbmVkJyA/IFtdIDoge307XG4gICAgICB0ZW1wT2JqW3Byb3BOYW1lXSA9IHByb3BWYWw7XG4gICAgICB0ZW1wT2JqID0gdGVtcE9ialtwcm9wTmFtZV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoSW5mbyhvYmplY3QsIHBhdGgpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBpbmZvIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiBUaGUgcGF0aCBpbmZvIGNvbnNpc3RzIG9mIGFuIG9iamVjdCB3aXRoIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogKiBwYXJlbnQgLSBUaGUgcGFyZW50IG9iamVjdCBvZiB0aGUgcHJvcGVydHkgcmVmZXJlbmNlZCBieSBgcGF0aGBcbiAqICogbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaW5hbCBwcm9wZXJ0eSwgYSBudW1iZXIgaWYgaXQgd2FzIGFuIGFycmF5IGluZGV4ZXJcbiAqICogdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogKiBleGlzdHMgLSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBleGlzdHMgb3Igbm90XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IGluZm9cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhJbmZvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhJbmZvKG9iaiwgcGF0aCkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICB2YXIgbGFzdCA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMV07XG4gIHZhciBpbmZvID0ge1xuICAgIHBhcmVudDpcbiAgICAgIHBhcnNlZC5sZW5ndGggPiAxID9cbiAgICAgICAgaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQsIHBhcnNlZC5sZW5ndGggLSAxKSA6XG4gICAgICAgIG9iaixcbiAgICBuYW1lOiBsYXN0LnAgfHwgbGFzdC5pLFxuICAgIHZhbHVlOiBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCksXG4gIH07XG4gIGluZm8uZXhpc3RzID0gaGFzUHJvcGVydHkoaW5mby5wYXJlbnQsIGluZm8ubmFtZSk7XG5cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUob2JqZWN0LCBwYXRoKVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMS5zdHInKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDEuYXR0WzJdJyk7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDIuYXJyWzBdLm5lc3RlZCcpOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhWYWx1ZShvYmosIHBhdGgpIHtcbiAgdmFyIGluZm8gPSBnZXRQYXRoSW5mbyhvYmosIHBhdGgpO1xuICByZXR1cm4gaW5mby52YWx1ZTtcbn1cblxuLyoqXG4gKiAjIyMgLnNldFBhdGhWYWx1ZShvYmplY3QsIHBhdGgsIHZhbHVlKVxuICpcbiAqIERlZmluZSB0aGUgdmFsdWUgaW4gYW4gb2JqZWN0IGF0IGEgZ2l2ZW4gc3RyaW5nIHBhdGguXG4gKlxuICogYGBganNcbiAqIHZhciBvYmogPSB7XG4gKiAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgfVxuICogICAsIHByb3AyOiB7XG4gKiAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgIH1cbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIGFjY2VwdGFibGUuXG4gKlxuICogYGBganNcbiAqIHZhciBwcm9wZXJ0aWVzID0gcmVxdWlyZSgndGVhLXByb3BlcnRpZXMnKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AxLnN0cicsICdIZWxsbyBVbml2ZXJzZSEnKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AxLmFyclsyXScsICdCJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMi5hcnJbMF0ubmVzdGVkLnZhbHVlJywgeyBoZWxsbzogJ3VuaXZlcnNlJyB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0UGF0aFZhbHVlKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgocGF0aCk7XG4gIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsLCBwYXJzZWQpO1xuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGFzUHJvcGVydHk6IGhhc1Byb3BlcnR5LFxuICBnZXRQYXRoSW5mbzogZ2V0UGF0aEluZm8sXG4gIGdldFBhdGhWYWx1ZTogZ2V0UGF0aFZhbHVlLFxuICBzZXRQYXRoVmFsdWU6IHNldFBhdGhWYWx1ZSxcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJylcblN0cmVhbS5waXBlbGluZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpXG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIi8qKlxuICogTGlua3MgdG8gQVBJIGRvY3VtZW50YXRpb25cbiAqL1xuXG5jb25zdCBBUElEb2N1bWVudGF0aW9uID0ge1xuICBkZXNrdG9wQWdlbnQ6IFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudFwiLFxuICBhZGRDb250ZXh0TGlzdGVuZXI6XG4gICAgXCJodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvMS4yL2FwaS9yZWYvRGVza3RvcEFnZW50I2FkZGNvbnRleHRsaXN0ZW5lclwiLFxuICBhZGRJbnRlbnRMaXN0ZW5lcjpcbiAgICBcImh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNhZGRpbnRlbnRsaXN0ZW5lclwiLFxuICBicm9hZGNhc3Q6IFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzL2FwaS9yZWYvRGVza3RvcEFnZW50I2Jyb2FkY2FzdFwiLFxuICBmaW5kSW50ZW50OiBcImh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy8xLjIvYXBpL3JlZi9EZXNrdG9wQWdlbnQjZmluZGludGVudFwiLFxuICBmaW5kSW50ZW50c0J5Q29udGV4dDpcbiAgICBcImh0dHBzOi8vZmRjMy5maW5vcy5vcmcvZG9jcy8xLjIvYXBpL3JlZi9EZXNrdG9wQWdlbnQjZmluZGludGVudHNieWNvbnRleHRcIixcbiAgZ2V0Q3VycmVudENoYW5uZWw6XG4gICAgXCJodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvMS4yL2FwaS9yZWYvRGVza3RvcEFnZW50I2dldGN1cnJlbnRjaGFubmVsXCIsXG4gIGdldEluZm86IFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNnZXRpbmZvXCIsXG4gIGdldEluZm8yXzA6IFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzL2FwaS9yZWYvRGVza3RvcEFnZW50I2dldGluZm9cIixcbiAgZ2V0T3JDcmVhdGVDaGFubmVsOlxuICAgIFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNnZXRvcmNyZWF0ZWNoYW5uZWxcIixcbiAgZ2V0U3lzdGVtQ2hhbm5lbHM6XG4gICAgXCJodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvMS4yL2FwaS9yZWYvRGVza3RvcEFnZW50I2dldHN5c3RlbWNoYW5uZWxzXCIsXG4gIGpvaW5DaGFubmVsOlxuICAgIFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNqb2luY2hhbm5lbFwiLFxuICBsZWF2ZUN1cnJlbnRDaGFubmVsOlxuICAgIFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNsZWF2ZWN1cnJlbnRjaGFubmVsXCIsXG4gIG9wZW46IFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNvcGVuXCIsXG4gIHJhaXNlSW50ZW50OlxuICAgIFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzLzEuMi9hcGkvcmVmL0Rlc2t0b3BBZ2VudCNyYWlzZWludGVudFwiLFxuICByYWlzZUludGVudEZvckNvbnRleHQ6XG4gICAgXCJodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvMS4yL2FwaS9yZWYvRGVza3RvcEFnZW50I3JhaXNlaW50ZW50Zm9yY29udGV4dFwiLFxuICBhcHBNZXRhZGF0YTogXCJodHRwczovL2ZkYzMuZmlub3Mub3JnL2RvY3MvYXBpL3JlZi9NZXRhZGF0YSNhcHBtZXRhZGF0YVwiLFxuICBmaW5kSW5zdGFuY2VzOlxuICAgIFwiaHR0cHM6Ly9mZGMzLmZpbm9zLm9yZy9kb2NzL2FwaS9yZWYvRGVza3RvcEFnZW50I2ZpbmRpbnN0YW5jZXNcIixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IEFQSURvY3VtZW50YXRpb247XG4iLCIvKipcbiAqIENvbnN0YW50cyB1c2VkIGluIGNvbXBsaWFuY2UgdGVzdGluZ1xuICovXG5jb25zdCBjb25zdGFudHMgPSB7XG4gIEZkYzNUaW1lb3V0OiA1MDAsIC8vIFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGUgRkRDM1JlYWR5IGV2ZW50IGR1cmluZyBpbml0aWFsaXNhdGlvblxuICBUZXN0VGltZW91dDogOTAwMCwgLy8gVGVzdHMgdGhhdCB0YWtlIGxvbmdlciB0aGFuIHRoaXMgKGluIG1pbGxpc2Vjb25kcykgd2lsbCBmYWlsXG4gIFdhaXRUaW1lOiAzMDAwLCAvLyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgbW9jayBhcHBzIHRvIGZpbmlzaCBwcm9jZXNzaW5nXG4gIFdpbmRvd0Nsb3NlV2FpdFRpbWU6IDEwMCwgLy8gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGFsbG93IGZvciBjbGVhbi11cCBvZiBjbG9zZWQgd2luZG93c1xufSBhcyBjb25zdDtcblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnRzO1xuIiwiaW1wb3J0IG1vY2hhLCB7IFN1aXRlIH0gZnJvbSBcIm1vY2hhXCI7XG5pbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuaW1wb3J0IGZkYzNBZGRDb250ZXh0TGlzdGVuZXJfMV8yIGZyb20gXCIuL3YxLjIvYmFzaWMvZmRjMy5hZGRDb250ZXh0TGlzdGVuZXJcIjtcbmltcG9ydCBmZGMzQWRkSW50ZW50TGlzdGVuZXJfMV8yIGZyb20gXCIuL3YxLjIvYmFzaWMvZmRjMy5hZGRJbnRlbnRMaXN0ZW5lclwiO1xuaW1wb3J0IGZkYzNCcm9hZGNhc3RfMV8yIGZyb20gXCIuL3YxLjIvYWR2YW5jZWQvZmRjMy5icm9hZGNhc3RcIjtcbmltcG9ydCBmZGMzRmluZEludGVudF8xXzIgZnJvbSBcIi4vdjEuMi9hZHZhbmNlZC9mZGMzLmZpbmRJbnRlbnRcIjtcbmltcG9ydCBmZGMzRmluZEludGVudHNCeUNvbnRleHRfMV8yIGZyb20gXCIuL3YxLjIvYWR2YW5jZWQvZmRjMy5maW5kSW50ZW50c0J5Q29udGV4dFwiO1xuaW1wb3J0IGZkYzNHZXRDdXJyZW50Q2hhbm5lbF8xXzIgZnJvbSBcIi4vdjEuMi9iYXNpYy9mZGMzLmdldEN1cnJlbnRDaGFubmVsXCI7XG5pbXBvcnQgZmRjM0dldEluZm9fMV8yIGZyb20gXCIuL3YxLjIvYmFzaWMvZmRjMy5nZXRJbmZvXCI7XG5pbXBvcnQgZmRjM0dldE9yQ3JlYXRlQ2hhbm5lbF8xXzIgZnJvbSBcIi4vdjEuMi9iYXNpYy9mZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbFwiO1xuaW1wb3J0IGZkYzNHZXRTeXN0ZW1DaGFubmVsc18xXzIgZnJvbSBcIi4vdjEuMi9iYXNpYy9mZGMzLmdldFN5c3RlbUNoYW5uZWxzXCI7XG5pbXBvcnQgZmRjM0pvaW5DaGFubmVsXzFfMiBmcm9tIFwiLi92MS4yL2Jhc2ljL2ZkYzMuam9pbkNoYW5uZWxcIjtcbmltcG9ydCBmZGMzTGVhdmVDdXJyZW50Q2hhbm5lbF8xXzIgZnJvbSBcIi4vdjEuMi9iYXNpYy9mZGMzLmxlYXZlQ3VycmVudENoYW5uZWxcIjtcbmltcG9ydCBmZGMzT3Blbl8xXzIgZnJvbSBcIi4vdjEuMi9hZHZhbmNlZC9mZGMzLm9wZW5cIjtcbmltcG9ydCBmZGMzUmFpc2VJbnRlbnRfMV8yIGZyb20gXCIuL3YxLjIvYWR2YW5jZWQvZmRjMy5yYWlzZUludGVudFwiO1xuaW1wb3J0IGZkYzNSYWlzZUludGVudEZvckNvbnRleHRfMV8yIGZyb20gXCIuL3YxLjIvYmFzaWMvZmRjMy5yYWlzZUludGVudEZvckNvbnRleHRcIjtcbmltcG9ydCBmZGMzQWRkQ29udGV4dExpc3RlbmVyXzJfMCBmcm9tIFwiLi92Mi4wL2Jhc2ljL2ZkYzMuYWRkQ29udGV4dExpc3RlbmVyXCI7XG5pbXBvcnQgZmRjM0FkZEludGVudExpc3RlbmVyXzJfMCBmcm9tIFwiLi92Mi4wL2Jhc2ljL2ZkYzMuYWRkSW50ZW50TGlzdGVuZXJcIjtcbmltcG9ydCBmZGMzQnJvYWRjYXN0XzJfMCBmcm9tIFwiLi92Mi4wL2FkdmFuY2VkL2ZkYzMuYnJvYWRjYXN0XCI7XG4vLyBpbXBvcnQgZmRjM0ZpbmRJbnRlbnRfMl8wIGZyb20gXCIuL3YyLjAvZmRjMy5maW5kSW50ZW50XCI7XG4vLyBpbXBvcnQgZmRjM0ZpbmRJbnRlbnRzQnlDb250ZXh0XzJfMCBmcm9tIFwiLi92Mi4wL2ZkYzMuZmluZEludGVudHNCeUNvbnRleHRcIjtcbmltcG9ydCBmZGMzR2V0Q3VycmVudENoYW5uZWxfMl8wIGZyb20gXCIuL3YyLjAvYmFzaWMvZmRjMy5nZXRDdXJyZW50Q2hhbm5lbFwiO1xuaW1wb3J0IGZkYzNHZXRJbmZvXzJfMCBmcm9tIFwiLi92Mi4wL2FkdmFuY2VkL2ZkYzMuZ2V0SW5mb1wiO1xuaW1wb3J0IGZkYzNHZXRJbnN0YW5jZXNfMl8wIGZyb20gXCIuL3YyLjAvYWR2YW5jZWQvZmRjMy5maW5kSW5zdGFuY2VzXCI7XG5pbXBvcnQgZmRjM0dldE9yQ3JlYXRlQ2hhbm5lbF8yXzAgZnJvbSBcIi4vdjIuMC9iYXNpYy9mZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbFwiO1xuaW1wb3J0IGZkYzNHZXRVc2VyQ2hhbm5lbHNfMl8wIGZyb20gXCIuL3YyLjAvYmFzaWMvZmRjMy5nZXRVc2VyQ2hhbm5lbHNcIjtcbmltcG9ydCBmZGMzZ2V0QXBwTWV0YWRhdGFfMl8wIGZyb20gXCIuL3YyLjAvYWR2YW5jZWQvZmRjMy5nZXRBcHBNZXRhZGF0YVwiO1xuaW1wb3J0IGZkYzNGaW5kSW5zdGFuY2VzXzJfMCBmcm9tIFwiLi92Mi4wL2FkdmFuY2VkL2ZkYzMuZmluZEluc3RhbmNlc1wiO1xuaW1wb3J0IGZkYzNKb2luVXNlckNoYW5uZWxfMl8wIGZyb20gXCIuL3YyLjAvYmFzaWMvZmRjMy5qb2luVXNlckNoYW5uZWxcIjtcbmltcG9ydCBmZGMzTGVhdmVDdXJyZW50Q2hhbm5lbF8yXzAgZnJvbSBcIi4vdjIuMC9iYXNpYy9mZGMzLmxlYXZlQ3VycmVudENoYW5uZWxcIjtcbi8vIGltcG9ydCBmZGMzT3Blbl8yXzAgZnJvbSBcIi4vdjIuMC9mZGMzLm9wZW5cIjtcbi8vIGltcG9ydCBmZGMzUmFpc2VJbnRlbnRfMl8wIGZyb20gXCIuL3YyLjAvZmRjMy5yYWlzZUludGVudFwiO1xuaW1wb3J0IGZkYzNSYWlzZUludGVudEZvckNvbnRleHRfMl8wIGZyb20gXCIuL3YyLjAvYmFzaWMvZmRjMy5yYWlzZUludGVudEZvckNvbnRleHRcIjtcblxudHlwZSB0ZXN0U2V0ID0geyBba2V5OiBzdHJpbmddOiAoKCkgPT4gdm9pZClbXSB9O1xuXG5jb25zdCBiYXNpY1N1aXRlXzFfMjogdGVzdFNldCA9IHtcbiAgZmRjM0FkZENvbnRleHRMaXN0ZW5lcl8xXzI6IFtmZGMzQWRkQ29udGV4dExpc3RlbmVyXzFfMl0sXG4gIGZkYzNBZGRJbnRlbnRMaXN0ZW5lcl8xXzI6IFtmZGMzQWRkSW50ZW50TGlzdGVuZXJfMV8yXSxcbiAgZmRjM0dldEN1cnJlbnRDaGFubmVsXzFfMjogW2ZkYzNHZXRDdXJyZW50Q2hhbm5lbF8xXzJdLFxuICBmZGMzR2V0SW5mb18xXzI6IFtmZGMzR2V0SW5mb18xXzJdLFxuICBmZGMzR2V0T3JDcmVhdGVDaGFubmVsXzFfMjogW2ZkYzNHZXRPckNyZWF0ZUNoYW5uZWxfMV8yXSxcbiAgZmRjM0dldFN5c3RlbUNoYW5uZWxzXzFfMjogW2ZkYzNHZXRTeXN0ZW1DaGFubmVsc18xXzJdLFxuICBmZGMzSm9pbkNoYW5uZWxfMV8yOiBbZmRjM0pvaW5DaGFubmVsXzFfMl0sXG4gIGZkYzNMZWF2ZUN1cnJlbnRDaGFubmVsXzFfMjogW2ZkYzNMZWF2ZUN1cnJlbnRDaGFubmVsXzFfMl0sXG4gIGZkYzNSYWlzZUludGVudEZvckNvbnRleHRfMV8yOiBbZmRjM1JhaXNlSW50ZW50Rm9yQ29udGV4dF8xXzJdLFxufTtcblxuY29uc3QgYmFzaWNTdWl0ZV8yXzA6IHRlc3RTZXQgPSB7XG4gIGZkYzNBZGRDb250ZXh0TGlzdGVuZXJfMl8wOiBbZmRjM0FkZENvbnRleHRMaXN0ZW5lcl8yXzBdLFxuICBmZGMzQWRkSW50ZW50TGlzdGVuZXJfMl8wOiBbZmRjM0FkZEludGVudExpc3RlbmVyXzJfMF0sXG4gIGZkYzNHZXRDdXJyZW50Q2hhbm5lbF8yXzA6IFtmZGMzR2V0Q3VycmVudENoYW5uZWxfMl8wXSxcbiAgZmRjM0dldEluZm9fMl8wOiBbZmRjM0dldEluZm9fMl8wXSxcbiAgZmRjM0dldE9yQ3JlYXRlQ2hhbm5lbF8yXzA6IFtmZGMzR2V0T3JDcmVhdGVDaGFubmVsXzJfMF0sXG4gIGZkYzNHZXRVc2VyQ2hhbm5lbHNfMl8wOiBbZmRjM0dldFVzZXJDaGFubmVsc18yXzBdLFxuICBmZGMzSm9pblVzZXJDaGFubmVsXzJfMDogW2ZkYzNKb2luVXNlckNoYW5uZWxfMl8wXSxcbiAgZmRjM0xlYXZlQ3VycmVudENoYW5uZWxfMl8wOiBbZmRjM0xlYXZlQ3VycmVudENoYW5uZWxfMl8wXSxcbiAgZmRjM1JhaXNlSW50ZW50Rm9yQ29udGV4dF8yXzA6IFtmZGMzUmFpc2VJbnRlbnRGb3JDb250ZXh0XzJfMF0sXG59O1xuXG5jb25zdCBhZHZhbmNlZFN1aXRlXzFfMjogdGVzdFNldCA9IHtcbiAgZmRjM09wZW5fMV8yOiBbZmRjM09wZW5fMV8yXSxcbiAgZmRjM0Jyb2FkY2FzdF8xXzI6IFtmZGMzQnJvYWRjYXN0XzFfMl0sXG4gIGZkYzNGaW5kSW50ZW50XzFfMjogW2ZkYzNGaW5kSW50ZW50XzFfMl0sXG4gIGZkYzNSYWlzZUludGVudF8xXzI6IFtmZGMzUmFpc2VJbnRlbnRfMV8yXSxcbiAgZmRjM0ZpbmRJbnRlbnRzQnlDb250ZXh0XzFfMjogW2ZkYzNGaW5kSW50ZW50c0J5Q29udGV4dF8xXzJdLFxufTtcblxuY29uc3QgYWR2YW5jZWRTdWl0ZV8yXzA6IHRlc3RTZXQgPSB7XG4gIGZkYzNCcm9hZGNhc3RfMl8wOiBbZmRjM0Jyb2FkY2FzdF8yXzBdLFxuICBmZGMzR2V0SW5mb18yXzA6IFtmZGMzR2V0SW5mb18yXzBdLFxuICBmZGMzRmluZEluc3RhbmNlc18yXzA6IFtmZGMzRmluZEluc3RhbmNlc18yXzBdLFxuICBmZGMzZ2V0QXBwTWV0YWRhdGFfMl8wOiBbZmRjM2dldEFwcE1ldGFkYXRhXzJfMF0sXG59O1xuXG5mdW5jdGlvbiBzdHJpcFN1aXRlcyh0czogdGVzdFNldFtdKTogKCgpID0+IHZvaWQpW10ge1xuICBjb25zdCBvdXQ6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHRzLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHNldHMgPSBPYmplY3QudmFsdWVzKGl0ZW0pO1xuICAgIHNldHMuZm9yRWFjaCgoc2V0KSA9PiBzZXQuZm9yRWFjaCgodGVzdCkgPT4gb3V0LnB1c2godGVzdCkpKTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBjb25zdCBhbGxUZXN0czogdGVzdFNldCA9IHtcbiAgXCJBbGwgMS4yXCI6IHN0cmlwU3VpdGVzKFtiYXNpY1N1aXRlXzFfMiwgYWR2YW5jZWRTdWl0ZV8xXzJdKSxcbiAgXCJBbGwgMi4wXCI6IHN0cmlwU3VpdGVzKFtiYXNpY1N1aXRlXzJfMCwgYWR2YW5jZWRTdWl0ZV8yXzBdKSxcbiAgXCJCYXNpYyAxLjJcIjogc3RyaXBTdWl0ZXMoW2Jhc2ljU3VpdGVfMV8yXSksXG4gIFwiQmFzaWMgMi4wXCI6IHN0cmlwU3VpdGVzKFtiYXNpY1N1aXRlXzJfMF0pLFxuICBcIkFkdmFuY2VkIDEuMlwiOiBzdHJpcFN1aXRlcyhbYWR2YW5jZWRTdWl0ZV8xXzJdKSxcbiAgXCJBZHZhbmNlZCAyLjBcIjogc3RyaXBTdWl0ZXMoW2FkdmFuY2VkU3VpdGVfMl8wXSksXG4gIC4uLmJhc2ljU3VpdGVfMV8yLFxuICAuLi5hZHZhbmNlZFN1aXRlXzFfMixcbiAgLi4uYmFzaWNTdWl0ZV8yXzAsXG4gIC4uLmFkdmFuY2VkU3VpdGVfMl8wLFxufTtcblxuZXhwb3J0IGNvbnN0IHBhY2tzOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nW10gfSA9IHtcbiAgXCIxLjIgKENvbWJpbmVkKVwiOiBbXCJBbGwgMS4yXCIsIFwiQmFzaWMgMS4yXCIsIFwiQWR2YW5jZWQgMS4yXCJdLFxuICBcIjEuMiAoSW5kaXZpZHVhbCBCYXNpYylcIjogT2JqZWN0LmtleXMoYmFzaWNTdWl0ZV8xXzIpLFxuICBcIjEuMiAoSW5kaXZpZHVhbCBBZHZhbmNlZClcIjogT2JqZWN0LmtleXMoYWR2YW5jZWRTdWl0ZV8xXzIpLFxuICBcIjIuMCAoQ29tYmluZWQpXCI6IFtcIkFsbCAyLjBcIiwgXCJCYXNpYyAyLjBcIiwgXCJBZHZhbmNlZCAyLjBcIl0sXG4gIFwiMi4wIChJbmRpdmlkdWFsIEJhc2ljKVwiOiBPYmplY3Qua2V5cyhiYXNpY1N1aXRlXzJfMCksXG4gIFwiMi4wIChJbmRpdmlkdWFsIEFkdmFuY2VkKVwiOiBPYmplY3Qua2V5cyhhZHZhbmNlZFN1aXRlXzJfMCksXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFja05hbWVzKCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHBhY2tzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhY2tNZW1iZXJzKHBhY2tOYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBwYWNrc1twYWNrTmFtZV07XG59XG5cbi8qKlxuICogSW50ZW5kZWQgZm9yIHJ1bm5pbmcgdGVzdHMgaW4gY29udGFpbmVyIHdpdGggcmVzdWx0cyBzaG93blxuICogaW4gSFRNTCBwYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBleGVjdXRlVGVzdHNJbkJyb3dzZXIgPSAocGFjazogc3RyaW5nKSA9PiB7XG4gIChtb2NoYSBhcyBhbnkpLnRpbWVvdXQoY29uc3RhbnRzLlRlc3RUaW1lb3V0KTtcbiAgY29uc3Qgc3VpdGUgPSBhbGxUZXN0c1twYWNrXTtcbiAgc3VpdGUuZm9yRWFjaCgocykgPT4gcygpKTtcbiAgbW9jaGEucnVuKCk7XG59O1xuIiwiaW1wb3J0IHsgTGlzdGVuZXIsIENoYW5uZWwsIENvbnRleHQsIGdldEN1cnJlbnRDaGFubmVsIH0gZnJvbSBcImZkYzNfMV8yXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcbmltcG9ydCB7IHNsZWVwLCB3YWl0IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzXCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcbmNvbnN0IGRvY3VtZW50YXRpb24gPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5kZXNrdG9wQWdlbnQgKyBcIlxcclxcbkNhdXNlOlwiO1xuXG5pbnRlcmZhY2UgQXBwQ29udHJvbENvbnRleHQgZXh0ZW5kcyBDb250ZXh0IHtcbiAgdGVzdElkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5icm9hZGNhc3RcIiwgKCkgPT4ge1xuICAgIGxldCBsaXN0ZW5lcjogTGlzdGVuZXI7XG4gICAgbGV0IGxpc3RlbmVyMjogTGlzdGVuZXI7XG5cbiAgICBpdChcIkJyb2FkY2FzdCBtZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgZmRjMy5icm9hZGNhc3Qoe1xuICAgICAgICB0eXBlOiBcImZkYzMuaW5zdHJ1bWVudFwiLFxuICAgICAgICBpZDogeyB0aWNrZXI6IFwiQUFQTFwiIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwiU3lzdGVtIGNoYW5uZWxzXCIsICgpID0+IHtcbiAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB1bnN1YnNjcmliZUxpc3RlbmVycygpO1xuICAgICAgICBhd2FpdCBmZGMzLmxlYXZlQ3VycmVudENoYW5uZWwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhZnRlckVhY2goYXN5bmMgZnVuY3Rpb24gYWZ0ZXJFYWNoKCkge1xuICAgICAgICBhd2FpdCBjbG9zZUNoYW5uZWxzQXBwV2luZG93KHRoaXMuY3VycmVudFRlc3QudGl0bGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkMSA9XG4gICAgICAgIFwiKFVDQmFzaWNVc2FnZTEpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBhZGRpbmcgYSBsaXN0ZW5lciB0aGVuIGpvaW5pbmcgYSB1c2VyIGNoYW5uZWwgYmVmb3JlIGFwcCBCIGJyb2FkY2FzdHMgY29udGV4dCB0byB0aGUgc2FtZSBjaGFubmVsXCI7XG4gICAgICBpdChzY1Rlc3RJZDEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lciB0byBhcHAgQVxcclxcbi0gQXBwIEEgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgZmRjMy5pbnN0cnVtZW50IGNvbnRleHQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgc2NUZXN0SWQxLFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihudWxsLCBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vSm9pbiBzeXN0ZW0gY2hhbm5lbCAxXG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCByZXRyaWV2ZUFuZEpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblJldHJpZXZlZFVzZXJDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkMSxcbiAgICAgICAgICB1c2VyQ2hhbm5lbElkOiBjaGFubmVsLmlkLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vd2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL3JlamVjdCBpZiBubyBjb250ZXh0IHJlY2VpdmVkXG4gICAgICAgIGlmICghcmVjZWl2ZWRDb250ZXh0KSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBjb250ZXh0IHJlY2VpdmVkXCIgKyBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NUZXN0SWQyID1cbiAgICAgICAgXCIoVUNCYXNpY1VzYWdlMikgU2hvdWxkIHJlY2VpdmUgY29udGV4dCB3aGVuIGpvaW5pbmcgYSB1c2VyIGNoYW5uZWwgdGhlbiBhZGRpbmcgYSBjb250ZXh0IGxpc3RlbmVyIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgdG8gdGhlIHNhbWUgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQyLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFkZCBsaXN0ZW5lciBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCB0byBBcHAgQVxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIHNjVGVzdElkMixcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9Kb2luIHN5c3RlbSBjaGFubmVsIDFcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IHJldHJpZXZlQW5kSm9pbkNoYW5uZWwoMSk7XG5cbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyID0gZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIobnVsbCwgYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLmpvaW5SZXRyaWV2ZWRVc2VyQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMS4yXCIsXG4gICAgICAgICAgdGVzdElkOiBzY1Rlc3RJZDIsXG4gICAgICAgICAgdXNlckNoYW5uZWxJZDogY2hhbm5lbC5pZCxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL3dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG5cbiAgICAgICAgLy9GYWlsIGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgTm8gY29udGV4dCByZWNlaXZlZCFcXG4ke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkMyA9XG4gICAgICAgIFwiKFVDQmFzaWNVc2FnZTMpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBhcHAgQiBqb2lucyB0aGVuIGJyb2FkY2FzdHMgY29udGV4dCB0byBhIHVzZXIgY2hhbm5lbCBiZWZvcmUgQSBqb2lucyBhbmQgbGlzdGVucyBvbiB0aGUgc2FtZSBjaGFubmVsXCI7XG4gICAgICBpdChzY1Rlc3RJZDMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBmZGMzLmluc3RydW1lbnQgY29udGV4dFxcclxcbi0gQXBwIEEgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyJHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIHNjVGVzdElkMyxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9yZXRyaWV2ZSBhIHVzZXIgY2hhbm5lbCB0byBwYXNzIHRvIGNoYW5uZWxzIGFwcFxuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZ2V0VXNlckNoYW5uZWwoMSk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luUmV0cmlldmVkVXNlckNoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjEuMlwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQzLFxuICAgICAgICAgIHVzZXJDaGFubmVsSWQ6IGNoYW5uZWwuaWQsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9Kb2luIHN5c3RlbSBjaGFubmVsIDFcbiAgICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChjaGFubmVsLmlkKTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgLy9BZGQgZmRjMy5pbnN0cnVtZW50IGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihudWxsLCBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NUZXN0SWQ0ID1cbiAgICAgICAgXCIoVUNGaWx0ZXJlZENvbnRleHQxKSBTaG91bGQgcmVjZWl2ZSBjb250ZXh0IHdoZW4gYXBwIEEgam9pbnMgYSB1c2VyIGNoYW5uZWwgYmVmb3JlIGFkZGluZyBhIGxpc3RlbmVyIGFuZCBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoZSBzYW1lIHVzZXIgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQ0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyXFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIHNjVGVzdElkNCxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcImZkYzMuaW5zdHJ1bWVudFwiLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vSm9pbiBzeXN0ZW0gY2hhbm5lbCAxXG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCByZXRyaWV2ZUFuZEpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblJldHJpZXZlZFVzZXJDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkNCxcbiAgICAgICAgICB1c2VyQ2hhbm5lbElkOiBjaGFubmVsLmlkLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NUZXN0SWQ1ID1cbiAgICAgICAgXCIoVUNGaWx0ZXJlZENvbnRleHQyKSBTaG91bGQgcmVjZWl2ZSBtdWx0aXBsZSBjb250ZXh0cyB3aGVuIGFwcCBCIGJyb2FkY2FzdHMgdGhlIGxpc3RlbmVkIHR5cGVzIHRvIHRoZSBzYW1lIHVzZXIgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQ1LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBhbmQgZmRjMy5jb250YWN0IGNvbnRleHQgbGlzdGVuZXJcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGJvdGggY29udGV4dCB0eXBlcyR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBzY1Rlc3RJZDUsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuICAgICAgICBsZXQgY29udGV4dFR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZCb3RoQ29udGV4dHNSZWNlaXZlZCgpIHtcbiAgICAgICAgICBpZiAoY29udGV4dFR5cGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhY29udGV4dFR5cGVzLmluY2x1ZGVzKFwiZmRjMy5jb250YWN0XCIpIHx8XG4gICAgICAgICAgICAgICFjb250ZXh0VHlwZXMuaW5jbHVkZXMoXCJmZGMzLmluc3RydW1lbnRcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcIkluY29ycmVjdCBjb250ZXh0IHJlY2VpdmVkXCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcImZkYzMuaW5zdHJ1bWVudFwiLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGNvbnRleHRUeXBlcy5wdXNoKGNvbnRleHQudHlwZSk7XG4gICAgICAgICAgY2hlY2tJZkJvdGhDb250ZXh0c1JlY2VpdmVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vQWRkIHNlY29uZCBjb250ZXh0IGxpc3RlbmVyIHRvIGFwcCBBXG4gICAgICAgIGxpc3RlbmVyMiA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwiZmRjMy5jb250YWN0XCIsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgY29udGV4dFR5cGVzLnB1c2goY29udGV4dC50eXBlKTtcbiAgICAgICAgICBjaGVja0lmQm90aENvbnRleHRzUmVjZWl2ZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcjIpO1xuXG4gICAgICAgIC8vSm9pbiBzeXN0ZW0gY2hhbm5lbCAxXG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCByZXRyaWV2ZUFuZEpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblJldHJpZXZlZFVzZXJDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkNSxcbiAgICAgICAgICB1c2VyQ2hhbm5lbElkOiBjaGFubmVsLmlkLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICAgICAgYEF0IGxlYXN0IG9uZSBjb250ZXh0IHdhcyBub3QgcmVjZWl2ZWQhXFxuJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDYgPVxuICAgICAgICBcIihVQ0ZpbHRlcmVkQ29udGV4dDMpIFNob3VsZCBub3QgcmVjZWl2ZSBjb250ZXh0IHdoZW4gQSAmIEIgam9pbiBkaWZmZXJlbnQgdXNlciBjaGFubmVscyBhbmQgYXBwIEIgYnJvYWRjYXN0cyBhIGxpc3RlbmVkIHR5cGVcIjtcbiAgICAgIGl0KHNjVGVzdElkNiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdCBjb250ZXh0IGxpc3RlbmVyXFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDJcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBib3RoIGNvbnRleHQgdHlwZXMke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwiZmRjMy5pbnN0cnVtZW50XCIsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0FkZCBmZGMzLmNvbnRhY3QgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lcjIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcImZkYzMuY29udGFjdFwiLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcjIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXdhaXQgZmRjMy5nZXRTeXN0ZW1DaGFubmVscygpO1xuICAgICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoIDwgMSlcbiAgICAgICAgICBhc3NlcnQuZmFpbChcIk5vIHN5c3RlbSBjaGFubmVscyBhdmFpbGFibGUgZm9yIGFwcCBBXCIpO1xuXG4gICAgICAgIC8vSm9pbiBhIGRpZmZlcmVudCBjaGFubmVsIHRvIHRoZSBvbmUgcGFzc2VkIHRvIGNoYW5uZWxzQXBwXG4gICAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoY2hhbm5lbHNbMF0uaWQpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblJldHJpZXZlZFVzZXJDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkNixcbiAgICAgICAgICB1c2VyQ2hhbm5lbElkOiBjaGFubmVsc1sxXS5pZCxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9HaXZlIGxpc3RlbmVycyB0aW1lIHRvIHJlY2VpdmUgY29udGV4dFxuICAgICAgICBhd2FpdCB3YWl0KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NUZXN0SWQ3ID1cbiAgICAgICAgXCIoVUNVbnN1YnNjcmliZSkgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiB1bnN1YnNjcmliaW5nIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoYXQgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQ3LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGNvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEEgdW5zdWJzY3JpYmVzIHRoZSBsaXN0ZW5lclxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgc2NUZXN0SWQ3LFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwiZmRjMy5pbnN0cnVtZW50XCIsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0pvaW4gc3lzdGVtIGNoYW5uZWwgMVxuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgcmV0cmlldmVBbmRKb2luQ2hhbm5lbCgxKTtcblxuICAgICAgICAvL1Vuc3Vic2NyaWJlIGZyb20gbGlzdGVuZXJzXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXdhaXQgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChcIkxpc3RlbmVyIHVuZGVmaW5lZFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luUmV0cmlldmVkVXNlckNoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjEuMlwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQ3LFxuICAgICAgICAgIHVzZXJDaGFubmVsSWQ6IGNoYW5uZWwuaWQsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkOCA9XG4gICAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0NCkgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiBqb2luaW5nIHR3byBkaWZmZXJlbnQgdXNlciBjaGFubmVscyBiZWZvcmUgYXBwIEIgYnJvYWRjYXN0cyB0aGUgbGlzdGVuZWQgdHlwZSB0byB0aGUgZmlyc3QgY2hhbm5lbCB0aGF0IHdhcyBqb2luZWRcIjtcbiAgICAgIGl0KHNjVGVzdElkOCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMlxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy9DaGFubmVsc0FwcCBqb2lucyBhIGNoYW5uZWwgYW5kIHRoZW4gam9pbnMgYW5vdGhlclxuICAgICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IGZkYzMuZ2V0U3lzdGVtQ2hhbm5lbHMoKTtcbiAgICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBzeXN0ZW0gY2hhbm5lbHMgYXZhaWxhYmxlIGZvciBhcHAgQVwiKTtcblxuICAgICAgICAvL0pvaW4gYSBjaGFubmVsIGJlZm9yZSBqb2luaW5nIGEgZGlmZmVyZW50IGNoYW5uZWxcbiAgICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChjaGFubmVsc1swXS5pZCk7XG4gICAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoY2hhbm5lbHNbMV0uaWQpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblJldHJpZXZlZFVzZXJDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkOCxcbiAgICAgICAgICB1c2VyQ2hhbm5lbElkOiBjaGFubmVsc1swXS5pZCxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9HaXZlIGxpc3RlbmVyIHRpbWUgdG8gcmVjZWl2ZSBjb250ZXh0XG4gICAgICAgIGF3YWl0IHdhaXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDkgPVxuICAgICAgICBcIihVQ0ZpbHRlcmVkQ29udGV4dDUpIFNob3VsZCBub3QgcmVjZWl2ZSBjb250ZXh0IHdoZW4gam9pbmluZyBhbmQgdGhlbiBsZWF2aW5nIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoZSBzYW1lIGNoYW5uZWxcIjtcbiAgICAgIGl0KHNjVGVzdElkOSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBBIGxlYXZlcyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9BZGQgYSBjb250ZXh0IGxpc3RlbmVycyB0byBhcHAgQVxuICAgICAgICBsaXN0ZW5lciA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwiZmRjMy5pbnN0cnVtZW50XCIsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0pvaW4gc3lzdGVtIGNoYW5uZWwgMVxuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgcmV0cmlldmVBbmRKb2luQ2hhbm5lbCgxKTtcblxuICAgICAgICAvL0FwcCBBIGxlYXZlcyBjaGFubmVsIDFcbiAgICAgICAgYXdhaXQgZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsKCk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luUmV0cmlldmVkVXNlckNoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjEuMlwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQ5LFxuICAgICAgICAgIHVzZXJDaGFubmVsSWQ6IGNoYW5uZWwuaWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vR2l2ZSBsaXN0ZW5lciB0aW1lIHRvIHJlY2VpdmUgY29udGV4dFxuICAgICAgICBhd2FpdCB3YWl0KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwiQXBwIGNoYW5uZWxzXCIsICgpID0+IHtcbiAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB1bnN1YnNjcmliZUxpc3RlbmVycygpO1xuICAgICAgICBhd2FpdCBmZGMzLmxlYXZlQ3VycmVudENoYW5uZWwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhZnRlckVhY2goYXN5bmMgZnVuY3Rpb24gYWZ0ZXJFYWNoKCkge1xuICAgICAgICBhd2FpdCBjbG9zZUNoYW5uZWxzQXBwV2luZG93KHRoaXMuY3VycmVudFRlc3QudGl0bGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkID1cbiAgICAgICAgXCIoQUNCYXNpY1VzYWdlMSkgU2hvdWxkIHJlY2VpdmUgY29udGV4dCB3aGVuIGFwcCBhIGFkZHMgYSBsaXN0ZW5lciBhbmQgYXBwIEIgYnJvYWRjYXN0cyB0byB0aGUgc2FtZSBhcHAgY2hhbm5lbFwiO1xuICAgICAgaXQoYWNUZXN0SWQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBhbiBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEEgYWRkcyBhZGRzIGEgY29udGV4dCBsaXN0ZW5lciBvZiB0eXBlIG51bGxcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgc2FtZSBhcHAgY2hhbm5lbCBhcyBBXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkLFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgLy9BZGQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IHRlc3RDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihudWxsLCBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMS4yXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZCxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG5cbiAgICAgICAgLy9GYWlsIGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgTm8gY29udGV4dCByZWNlaXZlZCFcXG4ke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkMiA9XG4gICAgICAgIFwiKEFDQmFzaWNVc2FnZTIpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBhcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgdG8gYW4gYXBwIGNoYW5uZWwgYmVmb3JlIEEgcmV0cmlldmVzIGN1cnJlbnQgY29udGV4dFwiO1xuICAgICAgaXQoYWNUZXN0SWQyLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSAmIEIgcmV0cmlldmUgdGhlIHNhbWUgYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudFxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGN1cnJlbnQgY29udGV4dCBvZiB0eXBlIG51bGwke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkMixcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkMixcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRoZSBmaW5pc2ggZXhlY3V0aW5nXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL1JldHJpZXZlIGN1cnJlbnQgY29udGV4dCBmcm9tIGNoYW5uZWxcbiAgICAgICAgYXdhaXQgdGVzdENoYW5uZWwuZ2V0Q3VycmVudENvbnRleHQoKS50aGVuKGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgcmVjZWl2ZWRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9GYWlsIGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgTm8gY29udGV4dCByZWNlaXZlZCFcXG4ke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkNCA9XG4gICAgICAgIFwiKEFDRmlsdGVyZWRDb250ZXh0MSkgU2hvdWxkIG9ubHkgcmVjZWl2ZSB0aGUgbGlzdGVuZWQgY29udGV4dCB3aGVuIGFwcCBCIGJyb2FkY2FzdHMgbXVsdGlwbGUgY29udGV4dHMgdG8gdGhlIHNhbWUgYXBwIGNoYW5uZWxcIjtcbiAgICAgIGl0KGFjVGVzdElkNCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQSBhZGRzIGEgY29udGV4dCBsaXN0ZW5lciBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIHRoZSBzYW1lIGFwcCBjaGFubmVsIGFzIEFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgYSBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50IGFuZCBmZGMzLmNvbnRhY3Qke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkNCxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLnJldHJpZXZlVGVzdEFwcENoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0Q29udGFjdENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjEuMlwiLFxuICAgICAgICAgIHRlc3RJZDogYWNUZXN0SWQ0LFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQ1ID1cbiAgICAgICAgXCIoQUNGaWx0ZXJlZENvbnRleHQyKSBTaG91bGQgcmVjZWl2ZSBtdWx0aXBsZSBjb250ZXh0cyB3aGVuIGFwcCBCIGJyb2FkY2FzdHMgdGhlIGxpc3RlbmVkIHR5cGVzIHRvIHRoZSBzYW1lIGFwcCBjaGFubmVsXCI7XG4gICAgICBpdChhY1Rlc3RJZDUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBhbiBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEEgYWRkcyBhIGNvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIHRoZSBzYW1lIGFwcCBjaGFubmVsIGFzIEFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgYSBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50IGFuZCBmZGMzLmNvbnRhY3Qke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICBsZXQgY29udGV4dFR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkNSxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9BZGQgZmRjMy5pbnN0cnVtZW50IGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFR5cGVzLnB1c2goY29udGV4dC50eXBlKTtcbiAgICAgICAgICAgIGNoZWNrSWZCb3RoQ29udGV4dHNSZWNlaXZlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0FkZCBmZGMzLmNvbnRhY3QgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lcjIgPSB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmNvbnRhY3RcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29udGV4dFR5cGVzLnB1c2goY29udGV4dC50eXBlKTtcbiAgICAgICAgICAgIGNoZWNrSWZCb3RoQ29udGV4dHNSZWNlaXZlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyMik7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkNSxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZCb3RoQ29udGV4dHNSZWNlaXZlZCgpIHtcbiAgICAgICAgICBpZiAoY29udGV4dFR5cGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhY29udGV4dFR5cGVzLmluY2x1ZGVzKFwiZmRjMy5jb250YWN0XCIpIHx8XG4gICAgICAgICAgICAgICFjb250ZXh0VHlwZXMuaW5jbHVkZXMoXCJmZGMzLmluc3RydW1lbnRcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcIkluY29ycmVjdCBjb250ZXh0IHJlY2VpdmVkXCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQ2ID1cbiAgICAgICAgXCIoQUNVbnN1YnNjcmliZSkgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiB1bnN1YnNjcmliaW5nIGFuIGFwcCBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRvIHRoYXQgY2hhbm5lbFwiO1xuICAgICAgaXQoYWNUZXN0SWQ2LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSByZXRyaWV2ZXMgYW4gYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBBIGFkZHMgYSBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgbnVsbFxcclxcbi0gQXBwIEEgdW5zdWJzY3JpYmVzIHRoZSBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIHRoZSBzYW1lIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCBhbmQgZmRjMy5jb250YWN0JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9SZXRyaWV2ZSBhbiBhcHAgY2hhbm5lbFxuICAgICAgICBjb25zdCB0ZXN0Q2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwidGVzdC1jaGFubmVsXCIpO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBhY1Rlc3RJZDYsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIobnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgJHtlcnJvck1lc3NhZ2V9ICR7Y29udGV4dC50eXBlfSBjb250ZXh0IHJlY2VpdmVkYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vVW5zdWJzY3JpYmUgZnJvbSBhcHAgY2hhbm5lbFxuICAgICAgICBsaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RDb250YWN0Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMS4yXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDYsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkNyA9XG4gICAgICAgIFwiKEFDRmlsdGVyZWRDb250ZXh0MykgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiBhcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgdG8gYSBkaWZmZXJlbnQgYXBwIGNoYW5uZWxcIjtcbiAgICAgIGl0KGFjVGVzdElkNywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQSBhZGRzIGEgY29udGV4dCBsaXN0ZW5lciBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIGEgZGlmZmVyZW50IGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcbiAgICAgICAgICBcImEtZGlmZmVyZW50LXRlc3QtY2hhbm5lbFwiXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9BZGQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IHRlc3RDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICBcImZkYzMuaW5zdHJ1bWVudFwiLFxuICAgICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZmFpbChgJHtlcnJvck1lc3NhZ2V9ICR7Y29udGV4dC50eXBlfSBjb250ZXh0IHJlY2VpdmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMS4yXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDcsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9HaXZlIGxpc3RlbmVyIHRpbWUgdG8gcmVjZWl2ZSBjb250ZXh0XG4gICAgICAgIGF3YWl0IHdhaXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhY1Rlc3RJZDggPVxuICAgICAgICBcIihBQ0ZpbHRlcmVkQ29udGV4dDQpIFNob3VsZCBub3QgcmVjZWl2ZSBjb250ZXh0IHdoZW4gcmV0cmlldmluZyB0d28gZGlmZmVyZW50IGFwcCBjaGFubmVscyBiZWZvcmUgYXBwIEIgYnJvYWRjYXN0cyB0aGUgbGlzdGVuZWQgdHlwZSB0byB0aGUgZmlyc3QgY2hhbm5lbCB0aGF0IHdhcyByZXRyaWV2ZWRcIjtcbiAgICAgIGl0KGFjVGVzdElkOCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQSBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEEgYWRkcyBhIGNvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgZmlyc3QgY2hhbm5lbCB0aGF0IEEgcmV0cmlldmVkXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgbGV0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkOCxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9BcHAgQSByZXRyaWV2ZXMgYSBkaWZmZXJlbnQgYXBwIGNoYW5uZWxcbiAgICAgICAgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImEtZGlmZmVyZW50LXRlc3QtY2hhbm5lbFwiKTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyID0gdGVzdENoYW5uZWwuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkOCxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQ5ID1cbiAgICAgICAgXCIoQUNDb250ZXh0SGlzdG9yeVR5cGVkKSBTaG91bGQgcmVjZWl2ZSBib3RoIGNvbnRleHRzIHdoZW4gYXBwIEIgYnJvYWRjYXN0cyBib3RoIGNvbnRleHRzIHRvIHRoZSBzYW1lIGFwcCBjaGFubmVsIGFuZCBBIGdldHMgY3VycmVudCBjb250ZXh0IGZvciBlYWNoIHR5cGVcIjtcbiAgICAgIGl0KGFjVGVzdElkOSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiByZXRyaWV2ZXMgdGhlIHNhbWUgYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgYSBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50IGFuZCBmZGMzLmNvbnRhY3RcXHJcXG4tIEFwcCBBIGdldHMgY3VycmVudCBjb250ZXh0IGZvciB0eXBlcyBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcInRlc3QtY2hhbm5lbFwiKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLnJldHJpZXZlVGVzdEFwcENoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0Q29udGFjdENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjEuMlwiLFxuICAgICAgICAgIHRlc3RJZDogYWNUZXN0SWQ5LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIFwiQ2hhbm5lbHNBcHBcIixcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL2dldCBjb250ZXh0cyBmcm9tIENoYW5uZWxzQXBwXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dChcImZkYzMuaW5zdHJ1bWVudFwiKTtcbiAgICAgICAgZXhwZWN0KGNvbnRleHQubmFtZSkudG8uYmUuZXF1YWxzKFwiSGlzdG9yeS1pdGVtLTFcIiwgZXJyb3JNZXNzYWdlKTtcblxuICAgICAgICBjb25zdCBjb250YWN0Q29udGV4dCA9IGF3YWl0IHRlc3RDaGFubmVsLmdldEN1cnJlbnRDb250ZXh0KFxuICAgICAgICAgIFwiZmRjMy5jb250YWN0XCJcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNvbnRhY3RDb250ZXh0Lm5hbWUpLnRvLmJlLmVxdWFscyhcbiAgICAgICAgICBcIkhpc3RvcnktaXRlbS0xXCIsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQxMCA9XG4gICAgICAgIFwiKEFDQ29udGV4dEhpc3RvcnlNdWx0aXBsZSkgU2hvdWxkIHJldHJpZXZlIHRoZSBsYXN0IGJyb2FkY2FzdCBjb250ZXh0IGl0ZW0gd2hlbiBhcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCB3aXRoIG11bHRpcGxlIGhpc3RvcnkgaXRlbXMgdG8gdGhlIHNhbWUgYXBwIGNoYW5uZWwgYW5kIEEgZ2V0cyBjdXJyZW50IGNvbnRleHRcIjtcbiAgICAgIGl0KGFjVGVzdElkMTAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBhbiBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIHRoZSBzYW1lIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIHR3byBkaWZmZXJlbnQgY29udGV4dHMgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBBIGdldHMgY3VycmVudCBjb250ZXh0IGZvciB0eXBlcyBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkMTAsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RDb250YWN0Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMS4yXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDEwLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgICAgaGlzdG9yeUl0ZW1zOiAyLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCBhbmQgZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgXCJDaGFubmVsc0FwcFwiLFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL1JldHJpZXZlIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dChcImZkYzMuaW5zdHJ1bWVudFwiKTtcbiAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGV4cGVjdChjb250ZXh0Lm5hbWUpLnRvLmJlLmVxdWFscyhcIkhpc3RvcnktaXRlbS0yXCIsIGVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgY29uc3QgY29udGV4dDIgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dChcImZkYzMuY29udGFjdFwiKTtcbiAgICAgICAgZXhwZWN0KGNvbnRleHQyLnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuY29udGFjdFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICBleHBlY3QoY29udGV4dDIubmFtZSkudG8uYmUuZXF1YWxzKFwiSGlzdG9yeS1pdGVtLTJcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhY1Rlc3RJZDExID1cbiAgICAgICAgXCIoQUNDb250ZXh0SGlzdG9yeUxhc3QpIFNob3VsZCByZXRyaWV2ZSB0aGUgbGFzdCBicm9hZGNhc3QgY29udGV4dCBpdGVtIHdoZW4gYXBwIEIgYnJvYWRjYXN0cyB0d28gZGlmZmVyZW50IGNvbnRleHRzIHRvIHRoZSBzYW1lIGFwcCBjaGFubmVsIGFuZCBBIGdldHMgY3VycmVudCBjb250ZXh0XCI7XG4gICAgICBpdChhY1Rlc3RJZDExLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSByZXRyaWV2ZXMgYW4gYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgc2FtZSBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBhIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdFxcclxcbi0gQXBwIEIgZ2V0cyBjdXJyZW50IGNvbnRleHQgd2l0aCBubyBmaWx0ZXIgYXBwbGllZCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcInRlc3QtY2hhbm5lbFwiKTtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgYWNUZXN0SWQxMSxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIxLjJcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkMTEsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICBcIkNoYW5uZWxzQXBwXCIsXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpO1xuXG4gICAgICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBDb250ZXh0IHJldHJpZXZlZFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gXCJmZGMzLmluc3RydW1lbnRcIikge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICAgICAgXCJEaWQgbm90IHJldHJpZXZlIGxhc3QgYnJvYWRjYXN0IGNvbnRleHQgZnJvbSBhcHAgQlwiLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmNvbnRhY3RcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXRyaWV2ZUFuZEpvaW5DaGFubmVsID0gYXN5bmMgKFxuICAgICAgY2hhbm5lbE51bWJlcjogbnVtYmVyXG4gICAgKTogUHJvbWlzZTxDaGFubmVsPiA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZ2V0VXNlckNoYW5uZWwoY2hhbm5lbE51bWJlcik7XG4gICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKGNoYW5uZWwuaWQpO1xuICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFVzZXJDaGFubmVsID0gYXN5bmMgKGNoYW5uZWw6IG51bWJlcik6IFByb21pc2U8Q2hhbm5lbD4gPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbHMgPSBhd2FpdCBmZGMzLmdldFN5c3RlbUNoYW5uZWxzKCk7XG4gICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbHNbY2hhbm5lbCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBzeXN0ZW0gY2hhbm5lbHMgYXZhaWxhYmxlIGZvciBhcHAgQVwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lck9iamVjdCkge1xuICAgICAgYXNzZXJ0LmlzVHJ1ZShcbiAgICAgICAgdHlwZW9mIGxpc3RlbmVyT2JqZWN0ID09PSBcIm9iamVjdFwiLFxuICAgICAgICBcIk5vIGxpc3RlbmVyIG9iamVjdCBmb3VuZFwiXG4gICAgICApO1xuICAgICAgZXhwZWN0KHR5cGVvZiBsaXN0ZW5lck9iamVjdC51bnN1YnNjcmliZSkudG8uYmUuZXF1YWxzKFxuICAgICAgICBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTGlzdGVuZXIgZG9lcyBub3QgY29udGFpbiBhbiB1bnN1YnNjcmliZSBtZXRob2RcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjbG9zZUNoYW5uZWxzQXBwV2luZG93KHRlc3RJZDogc3RyaW5nKSB7XG4gICAgICAvL1RlbGwgQ2hhbm5lbHNBcHAgdG8gY2xvc2Ugd2luZG93XG4gICAgICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGJyb2FkY2FzdEFwcENoYW5uZWxDbG9zZVdpbmRvdyh0ZXN0SWQpO1xuXG4gICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIHJlc3BvbmRcbiAgICAgIGF3YWl0IHdhaXRGb3JDb250ZXh0KFwid2luZG93Q2xvc2VkXCIsIHRlc3RJZCwgYXBwQ29udHJvbENoYW5uZWwpO1xuICAgICAgYXdhaXQgd2FpdChjb25zdGFudHMuV2luZG93Q2xvc2VXYWl0VGltZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYnJvYWRjYXN0QXBwQ2hhbm5lbENsb3NlV2luZG93ID0gYXN5bmMgKHRlc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIik7XG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICAgIGNvbnN0IGNsb3NlQ29udGV4dDogQXBwQ29udHJvbENvbnRleHQgPSB7XG4gICAgICAgIHR5cGU6IFwiY2xvc2VXaW5kb3dcIixcbiAgICAgICAgdGVzdElkOiB0ZXN0SWQsXG4gICAgICB9O1xuICAgICAgYXBwQ29udHJvbENoYW5uZWwuYnJvYWRjYXN0KGNsb3NlQ29udGV4dCk7XG4gICAgICByZXR1cm4gYXBwQ29udHJvbENoYW5uZWw7XG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHVuc3Vic2NyaWJlTGlzdGVuZXJzKCkge1xuICAgICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0ZW5lcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBsaXN0ZW5lcjIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXIyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdhaXRGb3JDb250ZXh0ID0gKFxuICAgICAgY29udGV4dFR5cGU6IHN0cmluZyxcbiAgICAgIHRlc3RJZDogc3RyaW5nLFxuICAgICAgY2hhbm5lbD86IENoYW5uZWxcbiAgICApOiBQcm9taXNlPENvbnRleHQ+ID0+IHtcbiAgICAgIGxldCBleGVjdXRpb25MaXN0ZW5lcjogTGlzdGVuZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8Q29udGV4dD4oYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICBgIFdhaXRpbmcgZm9yIHR5cGU6IFwiJHtjb250ZXh0VHlwZX1cIiwgb24gY2hhbm5lbDogXCIke2NoYW5uZWwuaWR9XCIgaW4gdGVzdDogXCIke3Rlc3RJZH1cImBcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBoYW5kbGVyID0gKGNvbnRleHQ6IEFwcENvbnRyb2xDb250ZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKHRlc3RJZCkge1xuICAgICAgICAgICAgaWYgKHRlc3RJZCA9PSBjb250ZXh0LnRlc3RJZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgYCBSZWNlaXZlZCAke2NvbnRleHRUeXBlfSBmb3IgdGVzdDogJHt0ZXN0SWR9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uTGlzdGVuZXIpIGV4ZWN1dGlvbkxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgICBgIElnbm9yaW5nIFwiJHtjb250ZXh0VHlwZX1cIiBjb250ZXh0IGR1ZSB0byBtaXNtYXRjaGVkIHRlc3RJZCAoZXhwZWN0ZWQ6IFwiJHt0ZXN0SWR9XCIsIGdvdCBcIiR7Y29udGV4dC50ZXN0SWR9XCIpYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgYCBSZWNlaXZlZCAod2l0aG91dCB0ZXN0SWQpIFwiJHtjb250ZXh0VHlwZX1cIiBmb3IgdGVzdDogXCIke3Rlc3RJZH1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkxpc3RlbmVyKSBleGVjdXRpb25MaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBjaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgaGFuZGxlcik7XG4gICAgICAgICAgLy9BcHAgY2hhbm5lbHMgZG8gbm90IGF1dG8tYnJvYWRjYXN0IGN1cnJlbnQgY29udGV4dCB3aGVuIHlvdSBzdGFydCBsaXN0ZW5pbmcsIHNvIHJldHJpZXZlIGN1cnJlbnQgY29udGV4dCB0byBhdm9pZCByYWNlc1xuICAgICAgICAgIGNvbnN0IGNjSGFuZGxlciA9IGFzeW5jIChjb250ZXh0OiBBcHBDb250cm9sQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKHRlc3RJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0SWQgPT0gY29udGV4dD8udGVzdElkICYmIGNvbnRleHQ/LnR5cGUgPT0gY29udGV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICAgICAgICBgIFJlY2VpdmVkIFwiJHtjb250ZXh0VHlwZX1cIiAoZnJvbSBjdXJyZW50IGNvbnRleHQpIGZvciB0ZXN0OiBcIiR7dGVzdElkfVwiYFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSAvL2RvIG5vdCB3YXJuIGFzIGl0IHdpbGwgYmUgaWdub3JpbmcgbWlzbWF0Y2hlcyB3aGljaCB3aWxsIGJlIGNvbW1vblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgK1xuICAgICAgICAgICAgICAgICAgICAgIGAgQ0hlY2tpbmcgZm9yIGN1cnJlbnQgY29udGV4dCBvZiB0eXBlIFwiJHtjb250ZXh0VHlwZX1cIiBmb3IgdGVzdDogXCIke3Rlc3RJZH1cIiBDdXJyZW50IGNvbnRleHQgZGlkICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID8gXCJcIiA6IFwiTk9UIFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSBleGlzdCwgXG4gICAgaGFkIHRlc3RJZDogXCIke2NvbnRleHQ/LnRlc3RJZH1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RJZCA9PSBjb250ZXh0Py50ZXN0SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImRpZCBtYXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkaWQgTk9UIG1hdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSBcbiAgICBhbmQgdHlwZSBcIiR7Y29udGV4dD8udHlwZX1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ/LnR5cGUgPT0gY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImRpZCBtYXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkaWQgTk9UIG1hdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgICAgIGAgUmVjZWl2ZWQgXCIke2NvbnRleHRUeXBlfVwiIChmcm9tIGN1cnJlbnQgY29udGV4dCkgZm9yIGFuIHVuc3BlY2lmaWVkIHRlc3RgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uTGlzdGVuZXIpIGV4ZWN1dGlvbkxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpLnRoZW4oY2NIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbnR5cGUgQ2hhbm5lbHNBcHBDb250ZXh0ID0gQ29udGV4dCAmIHtcbiAgY29tbWFuZHM6IHN0cmluZ1tdO1xuICBjb25maWc6IHtcbiAgICB0ZXN0SWQ6IHN0cmluZztcbiAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiBib29sZWFuO1xuICAgIGhpc3RvcnlJdGVtczogbnVtYmVyO1xuICAgIGZkYzNBcGlWZXJzaW9uOiBzdHJpbmc7XG4gICAgdXNlckNoYW5uZWxJZDogc3RyaW5nO1xuICB9O1xufTtcblxudHlwZSBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgZmRjM0FwaVZlcnNpb246IHN0cmluZztcbiAgdGVzdElkOiBzdHJpbmc7XG4gIHVzZXJDaGFubmVsSWQ/OiBzdHJpbmc7XG4gIG5vdGlmeUFwcEFPbkNvbXBsZXRpb24/OiBib29sZWFuO1xuICBoaXN0b3J5SXRlbXM/OiBudW1iZXI7XG59O1xuXG5mdW5jdGlvbiBidWlsZENoYW5uZWxzQXBwQ29udGV4dChcbiAgbW9ja0FwcENvbW1hbmRzOiBzdHJpbmdbXSxcbiAgY29uZmlnOiBDaGFubmVsc0FwcENvbmZpZ1xuKTogQ2hhbm5lbHNBcHBDb250ZXh0IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImNoYW5uZWxzQXBwQ29udGV4dFwiLFxuICAgIGNvbW1hbmRzOiBtb2NrQXBwQ29tbWFuZHMsXG4gICAgY29uZmlnOiB7XG4gICAgICBmZGMzQXBpVmVyc2lvbjogY29uZmlnLmZkYzNBcGlWZXJzaW9uLFxuICAgICAgdGVzdElkOiBjb25maWcudGVzdElkLFxuICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogY29uZmlnLm5vdGlmeUFwcEFPbkNvbXBsZXRpb24gPz8gZmFsc2UsXG4gICAgICBoaXN0b3J5SXRlbXM6IGNvbmZpZy5oaXN0b3J5SXRlbXMgPz8gMSxcbiAgICAgIHVzZXJDaGFubmVsSWQ6IGNvbmZpZy51c2VyQ2hhbm5lbElkID8/IG51bGwsXG4gICAgfSxcbiAgfTtcbn1cblxuY29uc3QgY29tbWFuZHMgPSB7XG4gIGpvaW5SZXRyaWV2ZWRVc2VyQ2hhbm5lbDogXCJqb2luUmV0cmlldmVkVXNlckNoYW5uZWxcIixcbiAgcmV0cmlldmVUZXN0QXBwQ2hhbm5lbDogXCJyZXRyaWV2ZVRlc3RBcHBDaGFubmVsXCIsXG4gIGJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0OiBcImJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0XCIsXG4gIGJyb2FkY2FzdENvbnRhY3RDb250ZXh0OiBcImJyb2FkY2FzdENvbnRhY3RDb250ZXh0XCIsXG59O1xuIiwiaW1wb3J0IHsgUmVzb2x2ZUVycm9yIH0gZnJvbSBcImZkYzNfMV8yXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18xXzIvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcbmNvbnN0IGZpbmRJbnRlbnREb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uZmluZEludGVudCArIFwiXFxyXFxuQ2F1c2VcIjtcblxuLyoqXG4gKiBEZXRhaWxzIG9uIHRoZSBtb2NrIGFwcHMgdXNlZCBpbiB0aGVzZSB0ZXN0cyBjYW4gYmUgZm91bmQgaW4gL21vY2svUkVBRE1FLm1kXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5maW5kSW50ZW50XCIsICgpID0+IHtcbiAgICBpdChcIihJbnRlbnRBcHBEKSBTaG91bGQgZmluZCBpbnRlbnQgJ2FUZXN0aW5nSW50ZW50JyBiZWxvbmdpbmcgb25seSB0byBhcHAgaW50ZW50LWFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwSW50ZW50ID0gYXdhaXQgZmRjMy5maW5kSW50ZW50KFwiYVRlc3RpbmdJbnRlbnRcIik7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmludGVudCkudG8uZGVlcC5lcShcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICBkaXNwbGF5TmFtZTogXCJBIFRlc3RpbmcgSW50ZW50XCIsXG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRJbnRlbnREb2NzXG4gICAgICApO1xuICAgICAgZXhwZWN0KGFwcEludGVudC5hcHBzKS50by5oYXZlLmxlbmd0aCgxLCBmaW5kSW50ZW50RG9jcyk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmFwcHNbMF0pLnRvLmhhdmUucHJvcGVydHkoXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcIkludGVudEFwcEFcIixcbiAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcIihXcm9uZ0ludGVudEFwcEQpIFNob3VsZCB0aHJvdyBOb0FwcHNGb3VuZCBlcnJvciB3aGVuIGludGVudCBkb2VzIG5vdCBleGlzdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLmZpbmRJbnRlbnQoXCJub25FeGlzdGVudEludGVudFwiKTtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBlcnJvciB3YXMgdGhyb3duXCIsIGZpbmRJbnRlbnREb2NzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICBSZXNvbHZlRXJyb3IuTm9BcHBzRm91bmQsXG4gICAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKEludGVudEFwcERSaWdodENvbnRleHQpIFNob3VsZCBmaW5kIGludGVudCAnYVRlc3RpbmdJbnRlbnQnIGJlbG9uZ2luZyBvbmx5IHRvIGFwcCBpbnRlbnQtYSB3aXRoIGNvbnRleHQgJ3Rlc3RDb250ZXh0WCdcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwSW50ZW50ID0gYXdhaXQgZmRjMy5maW5kSW50ZW50KFwiYVRlc3RpbmdJbnRlbnRcIiwge1xuICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WFwiLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmludGVudCkudG8uZGVlcC5lcShcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICBkaXNwbGF5TmFtZTogXCJBIFRlc3RpbmcgSW50ZW50XCIsXG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRJbnRlbnREb2NzXG4gICAgICApO1xuICAgICAgZXhwZWN0KGFwcEludGVudC5hcHBzKS50by5oYXZlLmxlbmd0aCgxLCBmaW5kSW50ZW50RG9jcyk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmFwcHNbMF0pLnRvLmhhdmUucHJvcGVydHkoXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcIkludGVudEFwcEFcIixcbiAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcIihJbnRlbnRBcHBEV3JvbmdDb250ZXh0KSBTaG91bGQgdGhyb3cgTm9BcHBzRm91bmQgZXJyb3Igd2hlbiBpbnRlbnQgZXhpc3RzIGJ1dCBjb250ZXh0IGRvZXMgbm90XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZkYzMuZmluZEludGVudChcImFUZXN0aW5nSW50ZW50XCIsIHtcbiAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBlcnJvciB3YXMgdGhyb3duXCIsIGZpbmRJbnRlbnREb2NzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICBSZXNvbHZlRXJyb3IuTm9BcHBzRm91bmQsXG4gICAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKEludGVudEFwcERNdWx0aXBsZTEpIFNob3VsZCBmaW5kIGludGVudCAnc2hhcmVkVGVzdGluZ0ludGVudDEnIGJlbG9uZ2luZyB0byBtdWx0aXBsZSBhcHBzIChpbnRlbnQtYSAmIGludGVudC1iKVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcHBJbnRlbnQgPSBhd2FpdCBmZGMzLmZpbmRJbnRlbnQoXCJzaGFyZWRUZXN0aW5nSW50ZW50MVwiKTtcbiAgICAgIGV4cGVjdChhcHBJbnRlbnQuaW50ZW50KS50by5kZWVwLmVxKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzaGFyZWRUZXN0aW5nSW50ZW50MVwiLFxuICAgICAgICAgIGRpc3BsYXlOYW1lOiBcIlNoYXJlZCBUZXN0aW5nIEludGVudFwiLFxuICAgICAgICB9LFxuICAgICAgICBmaW5kSW50ZW50RG9jc1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChhcHBJbnRlbnQuYXBwcykudG8uaGF2ZS5sZW5ndGgoMiwgZmluZEludGVudERvY3MpO1xuICAgICAgZXhwZWN0KGFwcEludGVudC5hcHBzWzBdKS50by5oYXZlLnByb3BlcnR5KFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJJbnRlbnRBcHBBXCIsXG4gICAgICAgIGZpbmRJbnRlbnREb2NzXG4gICAgICApO1xuICAgICAgZXhwZWN0KGFwcEludGVudC5hcHBzWzFdKS50by5oYXZlLnByb3BlcnR5KFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJJbnRlbnRBcHBCXCIsXG4gICAgICAgIGZpbmRJbnRlbnREb2NzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCIoSW50ZW50QXBwRE11bHRpcGxlMikgU2hvdWxkIGZpbmQgaW50ZW50ICdzaGFyZWRUZXN0aW5nSW50ZW50MScgYmVsb25naW5nIHRvIG11bHRpcGxlIGFwcHMgKGludGVudC1hICYgaW50ZW50LWIpIGZpbHRlcmVkIGJ5IHNwZWNpZmljIGNvbnRleHQgJ3Rlc3RDb250ZXh0WCdcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwSW50ZW50ID0gYXdhaXQgZmRjMy5maW5kSW50ZW50KFwic2hhcmVkVGVzdGluZ0ludGVudDFcIiwge1xuICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WFwiLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmludGVudCkudG8uZGVlcC5lcShcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hhcmVkVGVzdGluZ0ludGVudDFcIixcbiAgICAgICAgICBkaXNwbGF5TmFtZTogXCJTaGFyZWQgVGVzdGluZyBJbnRlbnRcIixcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmFwcHMpLnRvLmhhdmUubGVuZ3RoKDIsIGZpbmRJbnRlbnREb2NzKTtcbiAgICAgIGV4cGVjdChhcHBJbnRlbnQuYXBwc1swXSkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiSW50ZW50QXBwQVwiLFxuICAgICAgICBmaW5kSW50ZW50RG9jc1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChhcHBJbnRlbnQuYXBwc1sxXSkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiSW50ZW50QXBwQlwiLFxuICAgICAgICBmaW5kSW50ZW50RG9jc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KFwiKEludGVudEFwcERNdWx0aXBsZTMpIFNob3VsZCBmaW5kIGludGVudCAnc2hhcmVkVGVzdGluZ0ludGVudDEnIGJlbG9uZ2luZyB0byBhcHAgJ2ludGVudC1iJyB3aGVuIGZpbHRlcmVkIGJ5IHNwZWNpZmljIGNvbnRleHQgJ3Rlc3RDb250ZXh0WSdcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwSW50ZW50ID0gYXdhaXQgZmRjMy5maW5kSW50ZW50KFwic2hhcmVkVGVzdGluZ0ludGVudDFcIiwge1xuICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmludGVudCkudG8uZGVlcC5lcShcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hhcmVkVGVzdGluZ0ludGVudDFcIixcbiAgICAgICAgICBkaXNwbGF5TmFtZTogXCJTaGFyZWQgVGVzdGluZyBJbnRlbnRcIixcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEludGVudERvY3NcbiAgICAgICk7XG4gICAgICBleHBlY3QoYXBwSW50ZW50LmFwcHMpLnRvLmhhdmUubGVuZ3RoKDEsIGZpbmRJbnRlbnREb2NzKTtcbiAgICAgIGV4cGVjdChhcHBJbnRlbnQuYXBwc1swXSkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiSW50ZW50QXBwQlwiLFxuICAgICAgICBmaW5kSW50ZW50RG9jc1xuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgeyBSZXNvbHZlRXJyb3IgfSBmcm9tIFwiZmRjM18xXzJcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZmluZEludGVudHNCeUNvbnRleHREb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uZmluZEludGVudHNCeUNvbnRleHQgKyBcIlxcclxcbkNhdXNlXCI7XG5cbi8qKlxuICogRGV0YWlscyBvbiB0aGUgbW9jayBhcHBzIHVzZWQgaW4gdGhlc2UgdGVzdHMgY2FuIGJlIGZvdW5kIGluIC9tb2NrL1JFQURNRS5tZFxuICovXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMuZmluZEludGVudHNCeUNvbnRleHRcIiwgKCkgPT4ge1xuICAgIGl0KFwiKFNpbmdsZUNvbnRleHQpIFNob3VsZCBmaW5kIGludGVudHMgYnkgY29udGV4dCAndGVzdENvbnRleHRYJ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnRlbnRzID0gYXdhaXQgZmRjMy5maW5kSW50ZW50c0J5Q29udGV4dCh7XG4gICAgICAgICAgdHlwZTogXCJ0ZXN0Q29udGV4dFhcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChpbnRlbnRzKS50by5oYXZlLmxlbmd0aCgzLCBmaW5kSW50ZW50c0J5Q29udGV4dERvY3MpO1xuXG4gICAgICAgIGNvbnN0IGludGVudE5hbWVzID0gaW50ZW50cy5tYXAoKGFwcEludGVudCkgPT4gYXBwSW50ZW50LmludGVudC5uYW1lKTtcbiAgICAgICAgZXhwZWN0KGludGVudE5hbWVzKS50by5oYXZlLmFsbC5tZW1iZXJzKFxuICAgICAgICAgIFtcImFUZXN0aW5nSW50ZW50XCIsIFwic2hhcmVkVGVzdGluZ0ludGVudDFcIiwgXCJjVGVzdGluZ0ludGVudFwiXSxcbiAgICAgICAgICBmaW5kSW50ZW50c0J5Q29udGV4dERvY3NcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBhVGVzdGluZ0ludGVudCA9IGludGVudHMuZmluZChcbiAgICAgICAgICAoYXBwSW50ZW50KSA9PiBhcHBJbnRlbnQuaW50ZW50Lm5hbWUgPT09IFwiYVRlc3RpbmdJbnRlbnRcIlxuICAgICAgICApO1xuICAgICAgICBleHBlY3QoYVRlc3RpbmdJbnRlbnQuYXBwcykudG8uaGF2ZS5sZW5ndGgoMSwgZmluZEludGVudHNCeUNvbnRleHREb2NzKTtcbiAgICAgICAgZXhwZWN0KGFUZXN0aW5nSW50ZW50LmFwcHNbMF0ubmFtZSkudG8uZXEoXG4gICAgICAgICAgXCJJbnRlbnRBcHBBXCIsXG4gICAgICAgICAgZmluZEludGVudHNCeUNvbnRleHREb2NzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3Qgc2hhcmVkVGVzdGluZ0ludGVudDEgPSBpbnRlbnRzLmZpbmQoXG4gICAgICAgICAgKGFwcEludGVudCkgPT4gYXBwSW50ZW50LmludGVudC5uYW1lID09PSBcInNoYXJlZFRlc3RpbmdJbnRlbnQxXCJcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNoYXJlZFRlc3RpbmdJbnRlbnQxLmFwcHMpLnRvLmhhdmUubGVuZ3RoKFxuICAgICAgICAgIDIsXG4gICAgICAgICAgZmluZEludGVudHNCeUNvbnRleHREb2NzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNoYXJlZEFwcE5hbWVzID0gc2hhcmVkVGVzdGluZ0ludGVudDEuYXBwcy5tYXAoKGFwcCkgPT4gYXBwLm5hbWUpO1xuICAgICAgICBleHBlY3Qoc2hhcmVkQXBwTmFtZXMpLnRvLmhhdmUuYWxsLm1lbWJlcnMoXG4gICAgICAgICAgW1wiSW50ZW50QXBwQVwiLCBcIkludGVudEFwcEJcIl0sXG4gICAgICAgICAgZmluZEludGVudHNCeUNvbnRleHREb2NzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY1Rlc3RpbmdJbnRlbnQgPSBpbnRlbnRzLmZpbmQoXG4gICAgICAgICAgKGFwcEludGVudCkgPT4gYXBwSW50ZW50LmludGVudC5uYW1lID09PSBcImNUZXN0aW5nSW50ZW50XCJcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNUZXN0aW5nSW50ZW50LmFwcHMpLnRvLmhhdmUubGVuZ3RoKDEsIGZpbmRJbnRlbnRzQnlDb250ZXh0RG9jcyk7XG4gICAgICAgIGV4cGVjdChjVGVzdGluZ0ludGVudC5hcHBzWzBdLm5hbWUpLnRvLmVxKFxuICAgICAgICAgIFwiSW50ZW50QXBwQ1wiLFxuICAgICAgICAgIGZpbmRJbnRlbnRzQnlDb250ZXh0RG9jc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZmluZEludGVudHNCeUNvbnRleHREb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKE5vQ29udGV4dCkgUGFzc2luZyBhbiBpbnZhbGlkIGNvbnRleHQgY2F1c2VzIGEgTm9BcHBzRm91bmQgZXJyb3IgdG8gYmUgdGhyb3duXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHR5cGU6IFwiVGhpc0NvbnRleHREb2VzTm90RXhpc3RcIixcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLmZpbmRJbnRlbnRzQnlDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICBhc3NlcnQuZmFpbChcbiAgICAgICAgICBcIkV4cGVjdGVkIGVycm9yIE5vQXBwc0ZvdW5kIG5vdCB0aHJvd25cIixcbiAgICAgICAgICBmaW5kSW50ZW50c0J5Q29udGV4dERvY3NcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICBSZXNvbHZlRXJyb3IuTm9BcHBzRm91bmQsXG4gICAgICAgICAgZmluZEludGVudHNCeUNvbnRleHREb2NzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgT3BlbkVycm9yLCBDb250ZXh0LCBDaGFubmVsLCBMaXN0ZW5lciB9IGZyb20gXCJmZGMzXzFfMlwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi4vLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18xXzIvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5pbXBvcnQgeyBzbGVlcCwgd2FpdCB9IGZyb20gXCIuLi8uLi8uLi91dGlsc1wiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5cbmNvbnN0IGFwcEJOYW1lID0gXCJNb2NrQXBwXCI7XG5jb25zdCBhcHBCSWQgPSBcIk1vY2tBcHBJZFwiO1xuY29uc3Qgbm9MaXN0ZW5lckFwcElkID0gXCJJbnRlbnRBcHBBSWRcIjtcbmNvbnN0IG5vTGlzdGVuZXJBcHBOYW1lID0gXCJJbnRlbnRBcHBBXCI7XG5jb25zdCBnZW5lcmljTGlzdGVuZXJBcHBJZCA9IFwiSW50ZW50QXBwQ0lkXCI7XG5jb25zdCBnZW5lcmljTGlzdGVuZXJBcHBOYW1lID0gXCJJbnRlbnRBcHBDXCI7XG5cbmNvbnN0IG9wZW5Eb2NzID0gXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24ub3BlbiArIFwiXFxyXFxuQ2F1c2VcIjtcblxuLyoqXG4gKiBEZXRhaWxzIG9uIHRoZSBtb2NrIGFwcHMgdXNlZCBpbiB0aGVzZSB0ZXN0cyBjYW4gYmUgZm91bmQgaW4gL21vY2svUkVBRE1FLm1kXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5vcGVuXCIsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMubGVhdmVDdXJyZW50Q2hhbm5lbCgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQU9wZW5zQjFUZXN0ID1cbiAgICAgIFwiKEFPcGVuc0IxKSBDYW4gb3BlbiBhcHAgQiBmcm9tIGFwcCBBIHdpdGggbm8gY29udGV4dCBhbmQgc3RyaW5nIGFzIHRhcmdldFwiO1xuICAgIGl0KEFPcGVuc0IxVGVzdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChcIkZEQzMtQ29uZm9ybWFuY2UtQ2hhbm5lbFwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVJlY2VpdmVyKFwiZmRjMy1jb25mb3JtYW5jZS1vcGVuZWRcIik7XG4gICAgICBhd2FpdCBmZGMzLm9wZW4oYXBwQk5hbWUpO1xuICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgYXdhaXQgY2xvc2VBcHBXaW5kb3dzKEFPcGVuc0IxVGVzdCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBT3BlbnNCMlRlc3QgPVxuICAgICAgXCIoQU9wZW5zQjIpIENhbiBvcGVuIGFwcCBCIGZyb20gYXBwIEEgd2l0aCBubyBjb250ZXh0IGFuZCBBcHBNZXRhZGF0YSAobmFtZSkgYXMgdGFyZ2V0XCI7XG4gICAgaXQoQU9wZW5zQjJUZXN0LCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKFwiRkRDMy1Db25mb3JtYW5jZS1DaGFubmVsXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUmVjZWl2ZXIoXCJmZGMzLWNvbmZvcm1hbmNlLW9wZW5lZFwiKTtcbiAgICAgIGF3YWl0IGZkYzMub3Blbih7IG5hbWU6IGFwcEJOYW1lIH0pO1xuICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgYXdhaXQgY2xvc2VBcHBXaW5kb3dzKEFPcGVuc0IyVGVzdCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBT3BlbnNCM1Rlc3QgPVxuICAgICAgXCIoQU9wZW5zQjMpIENhbiBvcGVuIGFwcCBCIGZyb20gYXBwIEEgd2l0aCBubyBjb250ZXh0IGFuZCBBcHBNZXRhZGF0YSAobmFtZSBhbmQgYXBwSWQpIGFzIHRhcmdldFwiO1xuICAgIGl0KEFPcGVuc0IzVGVzdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChcIkZEQzMtQ29uZm9ybWFuY2UtQ2hhbm5lbFwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVJlY2VpdmVyKFwiZmRjMy1jb25mb3JtYW5jZS1vcGVuZWRcIik7XG4gICAgICBhd2FpdCBmZGMzLm9wZW4oeyBuYW1lOiBhcHBCTmFtZSwgYXBwSWQ6IGFwcEJJZCB9KTtcbiAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgIGF3YWl0IGNsb3NlQXBwV2luZG93cyhBT3BlbnNCM1Rlc3QpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQUZhaWxzVG9PcGVuQjFUZXN0ID1cbiAgICAgIFwiKEFGYWlsc1RvT3BlbkIxKSBSZWNlaXZlIEFwcE5vdEZvdW5kIGVycm9yIHdoZW4gdGFyZ2V0aW5nIG5vbi1leGlzdGVudCBhcHAgbmFtZSBhcyB0YXJnZXRcIjtcbiAgICBpdChBRmFpbHNUb09wZW5CMVRlc3QsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcIlRoaXNBcHBEb2VzTm90RXhpc3RcIik7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiTm8gZXJyb3Igd2FzIG5vdCB0aHJvd25cIiwgb3BlbkRvY3MpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXhwZWN0KGV4KS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiLCBPcGVuRXJyb3IuQXBwTm90Rm91bmQsIG9wZW5Eb2NzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBBRmFpbHNUb09wZW5CMlRlc3QgPVxuICAgICAgXCIoQUZhaWxzVG9PcGVuQjIpIFJlY2VpdmUgQXBwTm90Rm91bmQgZXJyb3Igd2hlbiB0YXJnZXRpbmcgbm9uLWV4aXN0ZW50IGFwcCBBcHBNZXRhZGF0YSAobmFtZSkgYXMgdGFyZ2V0XCI7XG4gICAgaXQoQUZhaWxzVG9PcGVuQjJUZXN0LCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oe1xuICAgICAgICAgIG5hbWU6IFwiVGhpc0FwcERvZXNOb3RFeGlzdFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBlcnJvciB3YXMgbm90IHRocm93blwiLCBvcGVuRG9jcyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBleHBlY3QoZXgpLnRvLmhhdmUucHJvcGVydHkoXCJtZXNzYWdlXCIsIE9wZW5FcnJvci5BcHBOb3RGb3VuZCwgb3BlbkRvY3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgQUZhaWxzVG9PcGVuQjMgPVxuICAgICAgXCIoQUZhaWxzVG9PcGVuQjMpIFJlY2VpdmUgQXBwTm90Rm91bmQgZXJyb3Igd2hlbiB0YXJnZXRpbmcgbm9uLWV4aXN0ZW50IGFwcCBBcHBNZXRhZGF0YSAobmFtZSBhbmQgYXBwSWQpIGFzIHRhcmdldFwiO1xuICAgIGl0KEFGYWlsc1RvT3BlbkIzLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oe1xuICAgICAgICAgIG5hbWU6IFwiVGhpc0FwcERvZXNOb3RFeGlzdFwiLFxuICAgICAgICAgIGFwcElkOiBcIlRoaXNBcHBEb2VzTm90RXhpc3RcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiTm8gZXJyb3Igd2FzIG5vdCB0aHJvd25cIiwgb3BlbkRvY3MpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXhwZWN0KGV4KS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiLCBPcGVuRXJyb3IuQXBwTm90Rm91bmQsIG9wZW5Eb2NzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IEFPcGVuc0JXaXRoU3BlY2lmaWNDb250ZXh0MVRlc3QgPVxuICAgICAgXCIoQU9wZW5zQldpdGhTcGVjaWZpY0NvbnRleHQxKSBDYW4gb3BlbiBhcHAgQiBmcm9tIGFwcCBBIHdpdGggY29udGV4dCBhbmQgc3RyaW5nIGFzIHRhcmdldCwgYXBwIEIgYWRkcyBzcGVjaWZpYyBsaXN0ZW5lclwiO1xuICAgIGl0KEFPcGVuc0JXaXRoU3BlY2lmaWNDb250ZXh0MVRlc3QsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoXCJGREMzLUNvbmZvcm1hbmNlLUNoYW5uZWxcIik7XG4gICAgICBjb25zdCByZWNlaXZlciA9IGNyZWF0ZVJlY2VpdmVyKFwiZmRjMy1jb25mb3JtYW5jZS1jb250ZXh0LXJlY2VpdmVkXCIpO1xuICAgICAgYXdhaXQgZmRjMy5vcGVuKGFwcEJOYW1lLCB7XG4gICAgICAgIG5hbWU6IFwiY29udGV4dFwiLFxuICAgICAgICB0eXBlOiBcImZkYzMudGVzdFJlY2VpdmVyXCIsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSAoYXdhaXQgcmVjZWl2ZXIpIGFzIGFueTtcbiAgICAgIGV4cGVjdChyZWNlaXZlZFZhbHVlLmNvbnRleHQubmFtZSkudG8uZXEoXCJjb250ZXh0XCIsIG9wZW5Eb2NzKTtcbiAgICAgIGV4cGVjdChyZWNlaXZlZFZhbHVlLmNvbnRleHQudHlwZSkudG8uZXEoXCJmZGMzLnRlc3RSZWNlaXZlclwiLCBvcGVuRG9jcyk7XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhTcGVjaWZpY0NvbnRleHQxVGVzdCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBT3BlbnNCV2l0aFNwZWNpZmljQ29udGV4dDJUZXN0ID1cbiAgICAgIFwiKEFPcGVuc0JXaXRoU3BlY2lmaWNDb250ZXh0MikgQ2FuIG9wZW4gYXBwIEIgZnJvbSBhcHAgQSB3aXRoIGNvbnRleHQgYW5kIEFwcE1ldGFkYXRhIChuYW1lKSBhcyB0YXJnZXQsIGFwcCBCIGFkZHMgc3BlY2lmaWMgbGlzdGVuZXJcIjtcbiAgICBpdChBT3BlbnNCV2l0aFNwZWNpZmljQ29udGV4dDJUZXN0LCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKFwiRkRDMy1Db25mb3JtYW5jZS1DaGFubmVsXCIpO1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSBjcmVhdGVSZWNlaXZlcihcImZkYzMtY29uZm9ybWFuY2UtY29udGV4dC1yZWNlaXZlZFwiKTtcbiAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgeyBuYW1lOiBhcHBCTmFtZSB9LFxuICAgICAgICB7IG5hbWU6IFwiY29udGV4dFwiLCB0eXBlOiBcImZkYzMudGVzdFJlY2VpdmVyXCIgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSAoYXdhaXQgcmVjZWl2ZXIpIGFzIGFueTtcbiAgICAgIGV4cGVjdChyZWNlaXZlZFZhbHVlLmNvbnRleHQubmFtZSkudG8uZXEoXCJjb250ZXh0XCIsIG9wZW5Eb2NzKTtcbiAgICAgIGV4cGVjdChyZWNlaXZlZFZhbHVlLmNvbnRleHQudHlwZSkudG8uZXEoXCJmZGMzLnRlc3RSZWNlaXZlclwiLCBvcGVuRG9jcyk7XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhTcGVjaWZpY0NvbnRleHQyVGVzdCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBT3BlbnNCV2l0aFNwZWNpZmljQ29udGV4dDNUZXN0ID1cbiAgICAgIFwiKEFPcGVuc0JXaXRoU3BlY2lmaWNDb250ZXh0MykgQ2FuIG9wZW4gYXBwIEIgZnJvbSBhcHAgQSB3aXRoIGNvbnRleHQgYW5kIEFwcE1ldGFkYXRhIChuYW1lIGFuZCBhcHBJZCkgYXMgdGFyZ2V0LCBhcHAgQiBhZGRzIHNwZWNpZmljIGxpc3RlbmVyXCI7XG4gICAgaXQoQU9wZW5zQldpdGhTcGVjaWZpY0NvbnRleHQzVGVzdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChcIkZEQzMtQ29uZm9ybWFuY2UtQ2hhbm5lbFwiKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gY3JlYXRlUmVjZWl2ZXIoXCJmZGMzLWNvbmZvcm1hbmNlLWNvbnRleHQtcmVjZWl2ZWRcIik7XG4gICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgIHsgbmFtZTogYXBwQk5hbWUsIGFwcElkOiBhcHBCSWQgfSxcbiAgICAgICAgeyBuYW1lOiBcImNvbnRleHRcIiwgdHlwZTogXCJmZGMzLnRlc3RSZWNlaXZlclwiIH1cbiAgICAgICk7XG4gICAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gKGF3YWl0IHJlY2VpdmVyKSBhcyBhbnk7XG4gICAgICBleHBlY3QocmVjZWl2ZWRWYWx1ZS5jb250ZXh0Lm5hbWUpLnRvLmVxKFwiY29udGV4dFwiLCBvcGVuRG9jcyk7XG4gICAgICBleHBlY3QocmVjZWl2ZWRWYWx1ZS5jb250ZXh0LnR5cGUpLnRvLmVxKFwiZmRjMy50ZXN0UmVjZWl2ZXJcIiwgb3BlbkRvY3MpO1xuICAgICAgYXdhaXQgY2xvc2VBcHBXaW5kb3dzKEFPcGVuc0JXaXRoU3BlY2lmaWNDb250ZXh0M1Rlc3QpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQU9wZW5zQldpdGhDb250ZXh0MVRlc3QgPVxuICAgICAgXCIoQU9wZW5zQldpdGhDb250ZXh0MSkgQ2FuIG9wZW4gYXBwIEIgZnJvbSBhcHAgQSB3aXRoIGNvbnRleHQgYW5kIHN0cmluZyBhcyB0YXJnZXQsIGFwcCBCIGFkZHMgZ2VuZXJpYyBsaXN0ZW5lclwiO1xuICAgIGl0KEFPcGVuc0JXaXRoQ29udGV4dDFUZXN0LCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKFwiZmRjMy5yYWlzZUludGVudFwiKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gY3JlYXRlUmVjZWl2ZXIoXCJmZGMzLWNvbmZvcm1hbmNlLWNvbnRleHQtcmVjZWl2ZWRcIik7XG4gICAgICBhd2FpdCBmZGMzLm9wZW4oZ2VuZXJpY0xpc3RlbmVyQXBwTmFtZSwge1xuICAgICAgICBuYW1lOiBcImNvbnRleHRcIixcbiAgICAgICAgdHlwZTogXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiLFxuICAgICAgfSk7XG4gICAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gKGF3YWl0IHJlY2VpdmVyKSBhcyBhbnk7XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhDb250ZXh0MVRlc3QpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC5uYW1lKS50by5lcShcImNvbnRleHRcIiwgb3BlbkRvY3MpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC50eXBlKS50by5lcShcbiAgICAgICAgXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiLFxuICAgICAgICBvcGVuRG9jc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IEFPcGVuc0JXaXRoQ29udGV4dDJUZXN0ID1cbiAgICAgIFwiKEFPcGVuc0JXaXRoQ29udGV4dDIpIENhbiBvcGVuIGFwcCBCIGZyb20gYXBwIEEgd2l0aCBjb250ZXh0IGFuZCBBcHBNZXRhZGF0YSAobmFtZSkgYXMgdGFyZ2V0LCBhcHAgQiBhZGRzIGdlbmVyaWMgbGlzdGVuZXJcIjtcbiAgICBpdChBT3BlbnNCV2l0aENvbnRleHQyVGVzdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChcImZkYzMucmFpc2VJbnRlbnRcIik7XG4gICAgICBjb25zdCByZWNlaXZlciA9IGNyZWF0ZVJlY2VpdmVyKFwiZmRjMy1jb25mb3JtYW5jZS1jb250ZXh0LXJlY2VpdmVkXCIpO1xuICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICB7IG5hbWU6IGdlbmVyaWNMaXN0ZW5lckFwcE5hbWUgfSxcbiAgICAgICAgeyBuYW1lOiBcImNvbnRleHRcIiwgdHlwZTogXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiIH1cbiAgICAgICk7XG4gICAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gKGF3YWl0IHJlY2VpdmVyKSBhcyBhbnk7XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhDb250ZXh0MlRlc3QpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC5uYW1lKS50by5lcShcImNvbnRleHRcIiwgb3BlbkRvY3MpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC50eXBlKS50by5lcShcbiAgICAgICAgXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiLFxuICAgICAgICBvcGVuRG9jc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IEFPcGVuc0JXaXRoQ29udGV4dDNUZXN0ID1cbiAgICAgIFwiKEFPcGVuc0JXaXRoQ29udGV4dDMpIENhbiBvcGVuIGFwcCBCIGZyb20gYXBwIEEgd2l0aCBjb250ZXh0IGFuZCBBcHBNZXRhZGF0YSAobmFtZSBhbmQgYXBwSWQpIGFzIHRhcmdldCwgYXBwIEIgYWRkcyBnZW5lcmljIGxpc3RlbmVyXCI7XG4gICAgaXQoQU9wZW5zQldpdGhDb250ZXh0M1Rlc3QsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoXCJmZGMzLnJhaXNlSW50ZW50XCIpO1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSBjcmVhdGVSZWNlaXZlcihcImZkYzMtY29uZm9ybWFuY2UtY29udGV4dC1yZWNlaXZlZFwiKTtcbiAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgeyBuYW1lOiBnZW5lcmljTGlzdGVuZXJBcHBOYW1lLCBhcHBJZDogZ2VuZXJpY0xpc3RlbmVyQXBwSWQgfSxcbiAgICAgICAgeyBuYW1lOiBcImNvbnRleHRcIiwgdHlwZTogXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiIH1cbiAgICAgICk7XG4gICAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gKGF3YWl0IHJlY2VpdmVyKSBhcyBhbnk7XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhDb250ZXh0M1Rlc3QpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC5uYW1lKS50by5lcShcImNvbnRleHRcIiwgb3BlbkRvY3MpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC50eXBlKS50by5lcShcbiAgICAgICAgXCJmZGMzLmdlbmVyaWNMaXN0ZW5lclwiLFxuICAgICAgICBvcGVuRG9jc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IEFPcGVuc0JXaXRoV3JvbmdDb250ZXh0VGVzdCA9XG4gICAgICBcIihBT3BlbnNCV2l0aFdyb25nQ29udGV4dCkgUmVjZWl2ZSBBcHBUaW1lb3V0IGVycm9yIHdoZW4gdGFyZ2V0aW5nIGFwcCB3aXRoIHdyb25nIGNvbnRleHRcIjtcbiAgICBpdChBT3BlbnNCV2l0aFdyb25nQ29udGV4dFRlc3QsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoXCJGREMzLUNvbmZvcm1hbmNlLUNoYW5uZWxcIik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBuYW1lOiBhcHBCTmFtZSB9LFxuICAgICAgICAgIHsgbmFtZTogXCJjb250ZXh0XCIsIHR5cGU6IFwiZmRjMy50aGlzQ29udGV4dERvZXNOb3RFeGlzdFwiIH1cbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBlcnJvciB3YXMgbm90IHRocm93blwiLCBvcGVuRG9jcyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBleHBlY3QoZXgpLnRvLmhhdmUucHJvcGVydHkoXCJtZXNzYWdlXCIsIE9wZW5FcnJvci5BcHBUaW1lb3V0LCBvcGVuRG9jcyk7XG4gICAgICB9XG4gICAgICBhd2FpdCBjbG9zZUFwcFdpbmRvd3MoQU9wZW5zQldpdGhXcm9uZ0NvbnRleHRUZXN0KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IEFPcGVuc0JOb0xpc3RlblRlc3QgPVxuICAgICAgXCIoQU9wZW5zQk5vTGlzdGVuKSBSZWNlaXZlIEFwcFRpbWVvdXQgZXJyb3Igd2hlbiB0YXJnZXRpbmcgYXBwIHdpdGggbm8gbGlzdGVuZXJzXCI7XG4gICAgaXQoQU9wZW5zQk5vTGlzdGVuVGVzdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmRjMy5qb2luQ2hhbm5lbChcImZkYzMucmFpc2VJbnRlbnRcIik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBuYW1lOiBub0xpc3RlbmVyQXBwTmFtZSwgYXBwSWQ6IG5vTGlzdGVuZXJBcHBJZCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJjb250ZXh0XCIsIHR5cGU6IFwiZmRjMy50ZXN0UmVjZWl2ZXJcIiB9XG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiTm8gZXJyb3Igd2FzIG5vdCB0aHJvd25cIiwgb3BlbkRvY3MpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXhwZWN0KGV4KS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiLCBPcGVuRXJyb3IuQXBwVGltZW91dCwgb3BlbkRvY3MpO1xuICAgICAgfVxuICAgICAgYXdhaXQgY2xvc2VBcHBXaW5kb3dzKEFPcGVuc0JOb0xpc3RlblRlc3QpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQU9wZW5zQk11bHRpcGxlTGlzdGVuVGVzdCA9XG4gICAgICBcIihBT3BlbnNCTXVsdGlwbGVMaXN0ZW4pIENhbiBvcGVuIGFwcCBCIGZyb20gYXBwIEEgd2l0aCBjb250ZXh0IGFuZCBBcHBNZXRhZGF0YSAobmFtZSBhbmQgYXBwSWQpIGFzIHRhcmdldCwgYXBwIEIgaGFzIG9wZW5lZCBtdWx0aXBsZSBsaXN0ZW5lcnNcIjtcbiAgICBpdChBT3BlbnNCTXVsdGlwbGVMaXN0ZW5UZXN0LCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKFwiRkRDMy1Db25mb3JtYW5jZS1DaGFubmVsXCIpO1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSBjcmVhdGVSZWNlaXZlcihcbiAgICAgICAgXCJmZGMzLWNvbmZvcm1hbmNlLWNvbnRleHQtcmVjZWl2ZWQtbXVsdGlwbGVcIlxuICAgICAgKTtcbiAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgeyBuYW1lOiBhcHBCTmFtZSwgYXBwSWQ6IGFwcEJJZCB9LFxuICAgICAgICB7IG5hbWU6IFwiY29udGV4dFwiLCB0eXBlOiBcImZkYzMudGVzdFJlY2VpdmVyTXVsdGlwbGVcIiB9XG4gICAgICApO1xuICAgICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IChhd2FpdCByZWNlaXZlcikgYXMgYW55O1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC5uYW1lKS50by5lcShcImNvbnRleHRcIiwgb3BlbkRvY3MpO1xuICAgICAgZXhwZWN0KHJlY2VpdmVkVmFsdWUuY29udGV4dC50eXBlKS50by5lcShcbiAgICAgICAgXCJmZGMzLnRlc3RSZWNlaXZlck11bHRpcGxlXCIsXG4gICAgICAgIG9wZW5Eb2NzXG4gICAgICApO1xuICAgICAgYXdhaXQgY2xvc2VBcHBXaW5kb3dzKEFPcGVuc0JNdWx0aXBsZUxpc3RlblRlc3QpO1xuICAgIH0pO1xuICB9KTtcblxuLy8gY3JlYXRlcyBhIGNoYW5uZWwgYW5kIHN1YnNjcmliZXMgZm9yIGJyb2FkY2FzdCBjb250ZXh0cy4gVGhpcyBpc1xuLy8gdXNlZCBieSB0aGUgJ21vY2sgYXBwJyB0byBzZW5kIG1lc3NhZ2VzIGJhY2sgdG8gdGhlIHRlc3QgcnVubmVyIGZvciB2YWxpZGF0aW9uXG5jb25zdCBjcmVhdGVSZWNlaXZlciA9IChjb250ZXh0VHlwZTogc3RyaW5nKSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICBjb25zdCBtZXNzYWdlUmVjZWl2ZWQgPSBuZXcgUHJvbWlzZTxDb250ZXh0Pihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgKGNvbnRleHQpID0+IHtcbiAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBsaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgLy9pZiBubyBjb250ZXh0IHJlY2VpdmVkIHJlamVjdCBwcm9taXNlXG4gICAgY29uc3QgeyBwcm9taXNlOiB0aGVQcm9taXNlLCB0aW1lb3V0OiB0aGVUaW1lb3V0IH0gPSBzbGVlcCgpO1xuICAgIHRpbWVvdXQgPSB0aGVUaW1lb3V0O1xuICAgIGF3YWl0IHRoZVByb21pc2U7XG4gICAgcmVqZWN0KG5ldyBFcnJvcihcIk5vIGNvbnRleHQgcmVjZWl2ZWQgZnJvbSBhcHAgQlwiKSk7XG4gIH0pO1xuXG4gIHJldHVybiBtZXNzYWdlUmVjZWl2ZWQ7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBjbG9zZUFwcFdpbmRvd3ModGVzdElkKSB7XG4gIGF3YWl0IGJyb2FkY2FzdENsb3NlV2luZG93KHRlc3RJZCk7XG4gIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgYXdhaXQgd2FpdEZvckNvbnRleHQoXCJ3aW5kb3dDbG9zZWRcIiwgdGVzdElkLCBhcHBDb250cm9sQ2hhbm5lbCk7XG4gIGF3YWl0IHdhaXQoY29uc3RhbnRzLldpbmRvd0Nsb3NlV2FpdFRpbWUpO1xufVxuXG5jb25zdCBicm9hZGNhc3RDbG9zZVdpbmRvdyA9IGFzeW5jIChjdXJyZW50VGVzdCkgPT4ge1xuICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIik7XG4gIGFwcENvbnRyb2xDaGFubmVsLmJyb2FkY2FzdCh7XG4gICAgdHlwZTogXCJjbG9zZVdpbmRvd1wiLFxuICAgIHRlc3RJZDogY3VycmVudFRlc3QsXG4gIH0gYXMgQXBwQ29udHJvbENvbnRleHQpO1xufTtcblxuY29uc3Qgd2FpdEZvckNvbnRleHQgPSAoXG4gIGNvbnRleHRUeXBlOiBzdHJpbmcsXG4gIHRlc3RJZDogc3RyaW5nLFxuICBjaGFubmVsPzogQ2hhbm5lbFxuKTogUHJvbWlzZTxDb250ZXh0PiA9PiB7XG4gIGxldCBleGVjdXRpb25MaXN0ZW5lcjogTGlzdGVuZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxDb250ZXh0Pihhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgIGAgV2FpdGluZyBmb3IgdHlwZTogXCIke2NvbnRleHRUeXBlfVwiLCBvbiBjaGFubmVsOiBcIiR7Y2hhbm5lbC5pZH1cIiBpbiB0ZXN0OiBcIiR7dGVzdElkfVwiYFxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gKGNvbnRleHQ6IEFwcENvbnRyb2xDb250ZXh0KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgIHdhaXRmb3Jjb250ZXh0IGhhbmRlciByZWFjaGVkYCk7XG4gICAgICBpZiAodGVzdElkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgJHt0ZXN0SWR9IFZTICR7Y29udGV4dC50ZXN0SWR9YCk7XG4gICAgICAgIGlmICh0ZXN0SWQgPT0gY29udGV4dC50ZXN0SWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIERhdGUubm93KCkgKyBgIFJlY2VpdmVkICR7Y29udGV4dFR5cGV9IGZvciB0ZXN0OiAke3Rlc3RJZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgYCBJZ25vcmluZyBcIiR7Y29udGV4dFR5cGV9XCIgY29udGV4dCBkdWUgdG8gbWlzbWF0Y2hlZCB0ZXN0SWQgKGV4cGVjdGVkOiBcIiR7dGVzdElkfVwiLCBnb3QgXCIke2NvbnRleHQudGVzdElkfVwiKWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgIGAgUmVjZWl2ZWQgKHdpdGhvdXQgdGVzdElkKSBcIiR7Y29udGV4dFR5cGV9XCIgZm9yIHRlc3Q6IFwiJHt0ZXN0SWR9XCJgXG4gICAgICAgICk7XG4gICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiYWRkaW5nIGxpc3RlbmVyIGluIHdhaXRmb3Jjb250ZXh0XCIpO1xuICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBjaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgaGFuZGxlcik7XG4gICAgICAvL0FwcCBjaGFubmVscyBkbyBub3QgYXV0by1icm9hZGNhc3QgY3VycmVudCBjb250ZXh0IHdoZW4geW91IHN0YXJ0IGxpc3RlbmluZywgc28gcmV0cmlldmUgY3VycmVudCBjb250ZXh0IHRvIGF2b2lkIHJhY2VzXG4gICAgICBjb25zdCBjY0hhbmRsZXIgPSBhc3luYyAoY29udGV4dDogQXBwQ29udHJvbENvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodGVzdElkKSB7XG4gICAgICAgICAgICBpZiAodGVzdElkID09IGNvbnRleHQ/LnRlc3RJZCAmJiBjb250ZXh0Py50eXBlID09IGNvbnRleHRUeXBlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIERhdGUubm93KCkgK1xuICAgICAgICAgICAgICAgICAgYCBSZWNlaXZlZCBcIiR7Y29udGV4dFR5cGV9XCIgKGZyb20gY3VycmVudCBjb250ZXh0KSBmb3IgdGVzdDogXCIke3Rlc3RJZH1cImBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkxpc3RlbmVyKSBleGVjdXRpb25MaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgfSAvL2RvIG5vdCB3YXJuIGFzIGl0IHdpbGwgYmUgaWdub3JpbmcgbWlzbWF0Y2hlcyB3aGljaCB3aWxsIGJlIGNvbW1vblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIERhdGUubm93KCkgK1xuICAgICAgICAgICAgICAgICAgYCBDSGVja2luZyBmb3IgY3VycmVudCBjb250ZXh0IG9mIHR5cGUgXCIke2NvbnRleHRUeXBlfVwiIGZvciB0ZXN0OiBcIiR7dGVzdElkfVwiIEN1cnJlbnQgY29udGV4dCBkaWQgJHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA/IFwiXCIgOiBcIk5PVCBcIlxuICAgICAgICAgICAgICAgICAgfSBleGlzdCxcbiAgICAgICAgICAgIGhhZCB0ZXN0SWQ6IFwiJHtjb250ZXh0Py50ZXN0SWR9XCIgKCR7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RJZCA9PSBjb250ZXh0Py50ZXN0SWQgPyBcImRpZCBtYXRjaFwiIDogXCJkaWQgTk9UIG1hdGNoXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBhbmQgdHlwZSBcIiR7Y29udGV4dD8udHlwZX1cIiB2cyAke2NvbnRleHRUeXBlfSAoJHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dD8udHlwZSA9PSBjb250ZXh0VHlwZSA/IFwiZGlkIG1hdGNoXCIgOiBcImRpZCBOT1QgbWF0Y2hcIlxuICAgICAgICAgICAgICAgICAgfSlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICBgIFJlY2VpdmVkIFwiJHtjb250ZXh0VHlwZX1cIiAoZnJvbSBjdXJyZW50IGNvbnRleHQpIGZvciBhbiB1bnNwZWNpZmllZCB0ZXN0YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpLnRoZW4oY2NIYW5kbGVyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuaW50ZXJmYWNlIEFwcENvbnRyb2xDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIHRlc3RJZDogc3RyaW5nO1xufVxuIiwiaW1wb3J0IHtcbiAgQXBwTWV0YWRhdGEsXG4gIENoYW5uZWwsXG4gIENvbnRleHQsXG4gIEludGVudFJlc29sdXRpb24sXG4gIExpc3RlbmVyLFxuICBSZXNvbHZlRXJyb3IsXG59IGZyb20gXCJmZGMzXzFfMlwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi4vLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18xXzIvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5pbXBvcnQgeyBzbGVlcCwgd2FpdCB9IGZyb20gXCIuLi8uLi8uLi91dGlsc1wiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5jb25zdCByYWlzZUludGVudERvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5yYWlzZUludGVudCArIFwiXFxyXFxuQ2F1c2VcIjtcblxuLyoqXG4gKiBEZXRhaWxzIG9uIHRoZSBtb2NrIGFwcHMgdXNlZCBpbiB0aGVzZSB0ZXN0cyBjYW4gYmUgZm91bmQgaW4gL21vY2svUkVBRE1FLm1kXG4gKi9cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5yYWlzZUludGVudFwiLCAoKSA9PiB7XG4gICAgYmVmb3JlKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiZmRjMy5yYWlzZUludGVudFwiKTtcbiAgICAgIGF3YWl0IGZkYzMuam9pbkNoYW5uZWwoXCJmZGMzLnJhaXNlSW50ZW50XCIpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKGFzeW5jIGZ1bmN0aW9uIGFmdGVyRWFjaCgpIHtcbiAgICAgIGF3YWl0IGNsb3NlSW50ZW50QXBwc1dpbmRvd3ModGhpcy5jdXJyZW50VGVzdC50aXRsZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZXN0MSA9XG4gICAgICBcIihTaW5nbGVSZXNvbHZlMSkgU2hvdWxkIHN0YXJ0IGFwcCBpbnRlbnQtYiB3aGVuIHJhaXNpbmcgaW50ZW50ICdzaGFyZWRUZXN0aW5nSW50ZW50MScgd2l0aCBjb250ZXh0ICd0ZXN0Q29udGV4dFknXCI7XG4gICAgaXQodGVzdDEsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVJlY2VpdmVyKFwiZmRjMy1pbnRlbnQtYi1vcGVuZWRcIik7XG4gICAgICBjb25zb2xlLmxvZyhcInJlY2VpdmVyIGFkZGVkXCIpO1xuICAgICAgY29uc3QgaW50ZW50UmVzb2x1dGlvbiA9IGF3YWl0IGZkYzMucmFpc2VJbnRlbnQoXCJzaGFyZWRUZXN0aW5nSW50ZW50MVwiLCB7XG4gICAgICAgIHR5cGU6IFwidGVzdENvbnRleHRZXCIsXG4gICAgICB9KTtcblxuICAgICAgdmFsaWRhdGVJbnRlbnRSZXNvbHV0aW9uKFwiSW50ZW50QXBwQlwiLCBpbnRlbnRSZXNvbHV0aW9uKTtcbiAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRlc3QyID1cbiAgICAgIFwiKFRhcmdldGVkUmVzb2x2ZTEpIFNob3VsZCBzdGFydCBhcHAgaW50ZW50LWEgd2hlbiB0YXJnZXRlZCBieSByYWlzaW5nIGludGVudCAnYVRlc3RpbmdJbnRlbnQnIHdpdGggY29udGV4dCAndGVzdENvbnRleHRYJ1wiO1xuICAgIGl0KHRlc3QyLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVSZWNlaXZlcihcImZkYzMtaW50ZW50LWEtb3BlbmVkXCIpO1xuICAgICAgY29uc3QgaW50ZW50UmVzb2x1dGlvbiA9IGF3YWl0IGZkYzMucmFpc2VJbnRlbnQoXG4gICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGVzdENvbnRleHRYXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwiSW50ZW50QXBwQVwiXG4gICAgICApO1xuICAgICAgdmFsaWRhdGVJbnRlbnRSZXNvbHV0aW9uKFwiSW50ZW50QXBwQVwiLCBpbnRlbnRSZXNvbHV0aW9uKTtcbiAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRlc3QzID1cbiAgICAgIFwiKFRhcmdldGVkUmVzb2x2ZTIpIFNob3VsZCBzdGFydCBhcHAgaW50ZW50LWEgd2hlbiB0YXJnZXRlZCAobmFtZSkgYnkgcmFpc2luZyBpbnRlbnQgJ2FUZXN0aW5nSW50ZW50JyB3aXRoIGNvbnRleHQgJ3Rlc3RDb250ZXh0WCdcIjtcbiAgICBpdCh0ZXN0MywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUmVjZWl2ZXIoXCJmZGMzLWludGVudC1hLW9wZW5lZFwiKTtcbiAgICAgIGNvbnN0IGludGVudFJlc29sdXRpb24gPSBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFxuICAgICAgICBcImFUZXN0aW5nSW50ZW50XCIsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WFwiLFxuICAgICAgICB9LFxuICAgICAgICB7IG5hbWU6IFwiSW50ZW50QXBwQVwiIH1cbiAgICAgICk7XG5cbiAgICAgIHZhbGlkYXRlSW50ZW50UmVzb2x1dGlvbihcIkludGVudEFwcEFcIiwgaW50ZW50UmVzb2x1dGlvbik7XG4gICAgICBhd2FpdCByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZXN0NCA9XG4gICAgICBcIihUYXJnZXRlZFJlc29sdmUzKSBTaG91bGQgc3RhcnQgYXBwIGludGVudC1hIHdoZW4gdGFyZ2V0ZWQgKG5hbWUgYW5kIGFwcElkKSBieSByYWlzaW5nIGludGVudCAnYVRlc3RpbmdJbnRlbnQnIHdpdGggY29udGV4dCAndGVzdENvbnRleHRYJ1wiO1xuICAgIGl0KHRlc3Q0LCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVSZWNlaXZlcihcImZkYzMtaW50ZW50LWEtb3BlbmVkXCIpO1xuICAgICAgY29uc3QgaW50ZW50UmVzb2x1dGlvbiA9IGF3YWl0IGZkYzMucmFpc2VJbnRlbnQoXG4gICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGVzdENvbnRleHRYXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgbmFtZTogXCJJbnRlbnRBcHBBXCIsIGFwcElkOiBcIkludGVudEFwcEFJZFwiIH1cbiAgICAgICk7XG4gICAgICB2YWxpZGF0ZUludGVudFJlc29sdXRpb24oXCJJbnRlbnRBcHBBXCIsIGludGVudFJlc29sdXRpb24pO1xuICAgICAgYXdhaXQgcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgY29uc3QgdGVzdDUgPVxuICAgICAgXCIoRmFpbGVkUmVzb2x2ZTEpIFNob3VsZCBmYWlsIHRvIHJhaXNlIGludGVudCB3aGVuIHRhcmdldGVkIGFwcCBpbnRlbnQtYSwgY29udGV4dCAndGVzdENvbnRleHRZJyBhbmQgaW50ZW50ICdhVGVzdGluZ0ludGVudCcgZG8gbm90IGNvcnJlbGF0ZVwiO1xuICAgIGl0KHRlc3Q1LCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFxuICAgICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJbnRlbnRBcHBBXCJcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJFcnJvciB3YXMgbm90IHRocm93blwiKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcIm1lc3NhZ2VcIiwgUmVzb2x2ZUVycm9yLk5vQXBwc0ZvdW5kKTtcblxuICAgICAgICAvL3JhaXNlIGludGVudCBzbyB0aGF0IGFmdGVyRWFjaCByZXNvbHZlc1xuICAgICAgICBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFwic2hhcmVkVGVzdGluZ0ludGVudDFcIiwge1xuICAgICAgICAgIHR5cGU6IFwidGVzdENvbnRleHRZXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRlc3Q2ID1cbiAgICAgIFwiKEZhaWxlZFJlc29sdmUyKSBTaG91bGQgZmFpbCB0byByYWlzZSBpbnRlbnQgd2hlbiB0YXJnZXRlZCBhcHAgaW50ZW50LWEgKG5hbWUgYW5kIGFwcElkKSwgY29udGV4dCAndGVzdENvbnRleHRZJyBhbmQgaW50ZW50ICdhVGVzdGluZ0ludGVudCcgZG8gbm90IGNvcnJlbGF0ZVwiO1xuICAgIGl0KHRlc3Q2LCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFxuICAgICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuYW1lOiBcIkludGVudEFwcEFcIiwgYXBwSWQ6IFwiSW50ZW50QXBwQUlkXCIgfVxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuZmFpbChcIkVycm9yIHdhcyBub3QgdGhyb3duXCIsIHJhaXNlSW50ZW50RG9jcyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBleHBlY3QoZXgpLnRvLmhhdmUucHJvcGVydHkoXG4gICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgUmVzb2x2ZUVycm9yLk5vQXBwc0ZvdW5kLFxuICAgICAgICAgIHJhaXNlSW50ZW50RG9jc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vcmFpc2UgaW50ZW50IHNvIHRoYXQgYWZ0ZXJFYWNoIHJlc29sdmVzXG4gICAgICAgIGF3YWl0IGZkYzMucmFpc2VJbnRlbnQoXCJzaGFyZWRUZXN0aW5nSW50ZW50MVwiLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXN0Q29udGV4dFlcIixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZXN0NyA9XG4gICAgICBcIihGYWlsZWRSZXNvbHZlMykgU2hvdWxkIGZhaWwgdG8gcmFpc2UgaW50ZW50IHdoZW4gdGFyZ2V0ZWQgYXBwIGludGVudC1hIChuYW1lKSwgY29udGV4dCAndGVzdENvbnRleHRZJyBhbmQgaW50ZW50ICdhVGVzdGluZ0ludGVudCcgZG8gbm90IGNvcnJlbGF0ZVwiO1xuICAgIGl0KHRlc3Q3LCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFxuICAgICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuYW1lOiBcIkludGVudEFwcEFcIiB9XG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiRXJyb3Igd2FzIG5vdCB0aHJvd25cIiwgcmFpc2VJbnRlbnREb2NzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICBSZXNvbHZlRXJyb3IuTm9BcHBzRm91bmQsXG4gICAgICAgICAgcmFpc2VJbnRlbnREb2NzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9yYWlzZSBpbnRlbnQgc28gdGhhdCBhZnRlckVhY2ggcmVzb2x2ZXNcbiAgICAgICAgYXdhaXQgZmRjMy5yYWlzZUludGVudChcInNoYXJlZFRlc3RpbmdJbnRlbnQxXCIsIHtcbiAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHRlc3Q4ID1cbiAgICAgIFwiKEZhaWxlZFJlc29sdmU0KSBTaG91bGQgZmFpbCB0byByYWlzZSBpbnRlbnQgd2hlbiB0YXJnZXRlZCBhcHAgaW50ZW50LWMsIGNvbnRleHQgJ3Rlc3RDb250ZXh0WCcgYW5kIGludGVudCAnYVRlc3RpbmdJbnRlbnQnIGRvIG5vdCBjb3JyZWxhdGVcIjtcbiAgICBpdCh0ZXN0OCwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmRjMy5yYWlzZUludGVudChcbiAgICAgICAgICBcImFUZXN0aW5nSW50ZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXN0Q29udGV4dFhcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW50ZW50QXBwQ1wiXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiRXJyb3Igd2FzIG5vdCB0aHJvd25cIiwgcmFpc2VJbnRlbnREb2NzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICBSZXNvbHZlRXJyb3IuTm9BcHBzRm91bmQsXG4gICAgICAgICAgcmFpc2VJbnRlbnREb2NzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9yYWlzZSBpbnRlbnQgc28gdGhhdCBhZnRlckVhY2ggcmVzb2x2ZXNcbiAgICAgICAgYXdhaXQgZmRjMy5yYWlzZUludGVudChcInNoYXJlZFRlc3RpbmdJbnRlbnQxXCIsIHtcbiAgICAgICAgICB0eXBlOiBcInRlc3RDb250ZXh0WVwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbmNvbnN0IHZhbGlkYXRlSW50ZW50UmVzb2x1dGlvbiA9IChcbiAgYXBwTmFtZTogc3RyaW5nLFxuICBpbnRlbnRSZXNvbHV0aW9uOiBJbnRlbnRSZXNvbHV0aW9uXG4pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnRlbnRSZXNvbHV0aW9uLnNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGV4cGVjdChpbnRlbnRSZXNvbHV0aW9uLnNvdXJjZSkudG8uZXEoYXBwTmFtZSwgcmFpc2VJbnRlbnREb2NzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW50ZW50UmVzb2x1dGlvbi5zb3VyY2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICBleHBlY3QoKGludGVudFJlc29sdXRpb24uc291cmNlIGFzIEFwcE1ldGFkYXRhKS5uYW1lKS50by5lcShcbiAgICAgIGFwcE5hbWUsXG4gICAgICByYWlzZUludGVudERvY3NcbiAgICApO1xuICB9IGVsc2UgYXNzZXJ0LmZhaWwoXCJJbnZhbGlkIGludGVudCByZXNvbHV0aW9uIG9iamVjdFwiKTtcbn07XG5cbmNvbnN0IGJyb2FkY2FzdENsb3NlV2luZG93ID0gYXN5bmMgKGN1cnJlbnRUZXN0KSA9PiB7XG4gIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgYXBwQ29udHJvbENoYW5uZWwuYnJvYWRjYXN0KHtcbiAgICB0eXBlOiBcImNsb3NlV2luZG93XCIsXG4gICAgdGVzdElkOiBjdXJyZW50VGVzdCxcbiAgfSBhcyBBcHBDb250cm9sQ29udGV4dCk7XG59O1xuXG4vLyBjcmVhdGVzIGEgY2hhbm5lbCBhbmQgc3Vic2NyaWJlcyBmb3IgYnJvYWRjYXN0IGNvbnRleHRzLiBUaGlzIGlzXG4vLyB1c2VkIGJ5IHRoZSAnbW9jayBhcHAnIHRvIHNlbmQgbWVzc2FnZXMgYmFjayB0byB0aGUgdGVzdCBydW5uZXIgZm9yIHZhbGlkYXRpb25cbmNvbnN0IGNyZWF0ZVJlY2VpdmVyID0gKGNvbnRleHRUeXBlOiBzdHJpbmcpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGNvbnN0IG1lc3NhZ2VSZWNlaXZlZCA9IG5ldyBQcm9taXNlPENvbnRleHQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKGNvbnRleHRUeXBlLCAoY29udGV4dCkgPT4ge1xuICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG5cbiAgICAvL2lmIG5vIGNvbnRleHQgcmVjZWl2ZWQgcmVqZWN0IHByb21pc2VcbiAgICBjb25zdCB7IHByb21pc2U6IHNsZWVwUHJvbWlzZSwgdGltZW91dDogdGhlVGltZW91dCB9ID0gc2xlZXAoKTtcbiAgICB0aW1lb3V0ID0gdGhlVGltZW91dDtcbiAgICBhd2FpdCBzbGVlcFByb21pc2U7XG4gICAgcmVqZWN0KG5ldyBFcnJvcihcIk5vIGNvbnRleHQgcmVjZWl2ZWQgZnJvbSBhcHAgQlwiKSk7XG4gIH0pO1xuXG4gIHJldHVybiBtZXNzYWdlUmVjZWl2ZWQ7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBjbG9zZUludGVudEFwcHNXaW5kb3dzKHRlc3RJZCkge1xuICBhd2FpdCBicm9hZGNhc3RDbG9zZVdpbmRvdyh0ZXN0SWQpO1xuICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIik7XG4gIGF3YWl0IHdhaXRGb3JDb250ZXh0KFwid2luZG93Q2xvc2VkXCIsIHRlc3RJZCwgYXBwQ29udHJvbENoYW5uZWwpO1xuICBhd2FpdCB3YWl0KGNvbnN0YW50cy5XaW5kb3dDbG9zZVdhaXRUaW1lKTtcbn1cblxuY29uc3Qgd2FpdEZvckNvbnRleHQgPSAoXG4gIGNvbnRleHRUeXBlOiBzdHJpbmcsXG4gIHRlc3RJZDogc3RyaW5nLFxuICBjaGFubmVsPzogQ2hhbm5lbFxuKTogUHJvbWlzZTxDb250ZXh0PiA9PiB7XG4gIGxldCBleGVjdXRpb25MaXN0ZW5lcjogTGlzdGVuZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxDb250ZXh0Pihhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgIGAgV2FpdGluZyBmb3IgdHlwZTogXCIke2NvbnRleHRUeXBlfVwiLCBvbiBjaGFubmVsOiBcIiR7Y2hhbm5lbC5pZH1cIiBpbiB0ZXN0OiBcIiR7dGVzdElkfVwiYFxuICAgICk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gKGNvbnRleHQ6IEFwcENvbnRyb2xDb250ZXh0KSA9PiB7XG4gICAgICBpZiAodGVzdElkKSB7XG4gICAgICAgIGlmICh0ZXN0SWQgPT0gY29udGV4dC50ZXN0SWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIERhdGUubm93KCkgKyBgIFJlY2VpdmVkICR7Y29udGV4dFR5cGV9IGZvciB0ZXN0OiAke3Rlc3RJZH1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgYCBJZ25vcmluZyBcIiR7Y29udGV4dFR5cGV9XCIgY29udGV4dCBkdWUgdG8gbWlzbWF0Y2hlZCB0ZXN0SWQgKGV4cGVjdGVkOiBcIiR7dGVzdElkfVwiLCBnb3QgXCIke2NvbnRleHQudGVzdElkfVwiKWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgIGAgUmVjZWl2ZWQgKHdpdGhvdXQgdGVzdElkKSBcIiR7Y29udGV4dFR5cGV9XCIgZm9yIHRlc3Q6IFwiJHt0ZXN0SWR9XCJgXG4gICAgICAgICk7XG4gICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4ZWN1dGlvbkxpc3RlbmVyID0gY2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoY29udGV4dFR5cGUsIGhhbmRsZXIpO1xuICAgICAgLy9BcHAgY2hhbm5lbHMgZG8gbm90IGF1dG8tYnJvYWRjYXN0IGN1cnJlbnQgY29udGV4dCB3aGVuIHlvdSBzdGFydCBsaXN0ZW5pbmcsIHNvIHJldHJpZXZlIGN1cnJlbnQgY29udGV4dCB0byBhdm9pZCByYWNlc1xuICAgICAgY29uc3QgY2NIYW5kbGVyID0gYXN5bmMgKGNvbnRleHQ6IEFwcENvbnRyb2xDb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRlc3RJZCkge1xuICAgICAgICAgICAgaWYgKHRlc3RJZCA9PSBjb250ZXh0Py50ZXN0SWQgJiYgY29udGV4dD8udHlwZSA9PSBjb250ZXh0VHlwZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICAgIGAgUmVjZWl2ZWQgXCIke2NvbnRleHRUeXBlfVwiIChmcm9tIGN1cnJlbnQgY29udGV4dCkgZm9yIHRlc3Q6IFwiJHt0ZXN0SWR9XCJgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgIH0gLy9kbyBub3Qgd2FybiBhcyBpdCB3aWxsIGJlIGlnbm9yaW5nIG1pc21hdGNoZXMgd2hpY2ggd2lsbCBiZSBjb21tb25cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICAgIGAgQ0hlY2tpbmcgZm9yIGN1cnJlbnQgY29udGV4dCBvZiB0eXBlIFwiJHtjb250ZXh0VHlwZX1cIiBmb3IgdGVzdDogXCIke3Rlc3RJZH1cIiBDdXJyZW50IGNvbnRleHQgZGlkICR7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPyBcIlwiIDogXCJOT1QgXCJcbiAgICAgICAgICAgICAgICAgIH0gZXhpc3QsIFxuaGFkIHRlc3RJZDogXCIke2NvbnRleHQ/LnRlc3RJZH1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdElkID09IGNvbnRleHQ/LnRlc3RJZCA/IFwiZGlkIG1hdGNoXCIgOiBcImRpZCBOT1QgbWF0Y2hcIlxuICAgICAgICAgICAgICAgICAgfSkgXG5hbmQgdHlwZSBcIiR7Y29udGV4dD8udHlwZX1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dD8udHlwZSA9PSBjb250ZXh0VHlwZSA/IFwiZGlkIG1hdGNoXCIgOiBcImRpZCBOT1QgbWF0Y2hcIlxuICAgICAgICAgICAgICAgICAgfSlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICBgIFJlY2VpdmVkIFwiJHtjb250ZXh0VHlwZX1cIiAoZnJvbSBjdXJyZW50IGNvbnRleHQpIGZvciBhbiB1bnNwZWNpZmllZCB0ZXN0YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpLnRoZW4oY2NIYW5kbGVyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuaW50ZXJmYWNlIEFwcENvbnRyb2xDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIHRlc3RJZDogc3RyaW5nO1xufVxuIiwiaW1wb3J0IHsgTGlzdGVuZXIgfSBmcm9tIFwiZmRjM18xXzJcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZG9jdW1lbnRhdGlvbiA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmFkZENvbnRleHRMaXN0ZW5lciArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmFkZENvbnRleHRMaXN0ZW5lclwiLCAoKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lcjtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKEJhc2ljQ0wxKSBNZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dFR5cGUgPSBcImZkYzMuY29udGFjdFwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIgPSBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgKGluZm86IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYENvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSAke2NvbnRleHRUeXBlfSB0cmlnZ2VyZWQgd2l0aCByZXN1bHQgJHtpbmZvfWBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKGRvY3VtZW50YXRpb24gKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCIoQmFzaWNDTDIpIFJldHVybnMgbGlzdGVuZXIgb2JqZWN0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyID0gZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIobnVsbCwgKCkgPT4ge30pO1xuICAgICAgICBhc3NlcnQuaXNUcnVlKGxpc3RlbmVyICYmIHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJvYmplY3RcIiwgZG9jdW1lbnRhdGlvbik7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgbGlzdGVuZXIudW5zdWJzY3JpYmUsIGRvY3VtZW50YXRpb24pLnRvLmJlLmVxdWFscyhcbiAgICAgICAgICBcImZ1bmN0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKGRvY3VtZW50YXRpb24gKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiIsImltcG9ydCB7IExpc3RlbmVyIH0gZnJvbSBcImZkYzNfMV8yXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18xXzIvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmFkZEludGVudExpc3RlbmVyXCIsICgpID0+IHtcbiAgICBsZXQgbGlzdGVuZXI6IExpc3RlbmVyO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCIoQmFzaWNJTDEpIE1ldGhvZCBpcyBjYWxsYWJsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRlbnROYW1lID0gXCJmZGMzLmNvbmZvcm1hbmNlTGlzdGVuZXJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyID0gZmRjMy5hZGRJbnRlbnRMaXN0ZW5lcihpbnRlbnROYW1lLCAoaW5mbzogYW55KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgSW50ZW50IGxpc3RlbmVyIGZvciBpbnRlbnQgJHtpbnRlbnROYW1lfSB0cmlnZ2VyZWQgd2l0aCByZXN1bHQgJHtpbmZvfWBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KGxpc3RlbmVyKS50by5oYXZlLnByb3BlcnR5KFwidW5zdWJzY3JpYmVcIikudGhhdC5pcy5hKFwiZnVuY3Rpb25cIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBhc3NlcnQuZmFpbChcbiAgICAgICAgICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICtcbiAgICAgICAgICAgIEFQSURvY3VtZW50YXRpb24uYWRkSW50ZW50TGlzdGVuZXIgK1xuICAgICAgICAgICAgXCJcXHJcXG5DYXVzZVwiICtcbiAgICAgICAgICAgIChleC5tZXNzYWdlID8/IGV4KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiIsImltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZ2V0Q3VycmVudENoYW5uZWxEb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uZ2V0Q3VycmVudENoYW5uZWwgKyBcIlxcclxcbkNhdXNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5nZXRDdXJyZW50Q2hhbm5lbFwiLCAoKSA9PiB7XG4gICAgaXQoXCIoQmFzaWNDSDEpIE1ldGhvZCBpcyBjYWxsYWJsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZmRjMy5nZXRDdXJyZW50Q2hhbm5lbCgpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0Q3VycmVudENoYW5uZWxEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKEJhc2ljQ0gyKSBnZXRDdXJyZW50Q2hhbm5lbCgpIHJldHVybnMgbnVsbCBpZiBubyBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZmRjMy5nZXRDdXJyZW50Q2hhbm5lbCgpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCkuZXF1YWxzKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0Q3VycmVudENoYW5uZWxEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18xXzIvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcbmNvbnN0IGdldEluZm9Eb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uZ2V0SW5mbyArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldEluZm9cIiwgKCkgPT4ge1xuICAgIGl0KFwiKEJhc2ljR0kxKSBSZXR1cm5zIEltcGxlbWVudGF0aW9uTWV0YWRhdGEgb2JqZWN0XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBmZGMzLmdldEluZm8oKTtcbiAgICAgICAgZXhwZWN0KGluZm8sIGdldEluZm9Eb2NzKS50by5oYXZlLnByb3BlcnR5KFwiZmRjM1ZlcnNpb25cIik7XG4gICAgICAgIGV4cGVjdChpbmZvLCBnZXRJbmZvRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcInByb3ZpZGVyXCIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0SW5mb0RvY3MgKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiIsImltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcyA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmdldE9yQ3JlYXRlQ2hhbm5lbCArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbFwiLCAoKSA9PiB7XG4gICAgaXQoXCIoQmFzaWNBQzEpIFJldHVybnMgQ2hhbm5lbCBvYmplY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiRkRDM0NvbmZvcm1hbmNlXCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcImlkXCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcInR5cGVcIik7XG4gICAgICAgIGV4cGVjdChjaGFubmVsLCBnZXRPckNyZWF0ZUNoYW5uZWxEb2NzKS50by5oYXZlLnByb3BlcnR5KFwiYnJvYWRjYXN0XCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcImdldEN1cnJlbnRDb250ZXh0XCJcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNoYW5uZWwsIGdldE9yQ3JlYXRlQ2hhbm5lbERvY3MpLnRvLmhhdmUucHJvcGVydHkoXG4gICAgICAgICAgXCJhZGRDb250ZXh0TGlzdGVuZXJcIlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0T3JDcmVhdGVDaGFubmVsRG9jcyArIChleC5tZXNzYWdlID8/IGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMV8yL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuaW1wb3J0IHsgQ2hhbm5lbCB9IGZyb20gXCJmZGMzXzFfMlwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5jb25zdCBnZXRTeXN0ZW1DaGFubmVsRG9jcyA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmdldFN5c3RlbUNoYW5uZWxzICsgXCJcXHJcXG5DYXVzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMuZ2V0U3lzdGVtQ2hhbm5lbHNcIiwgKCkgPT4ge1xuICAgIGl0KFwiKEJhc2ljVUMxKSBDaGFubmVsIG9iamVjdCBpcyB2YWxpZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IGZkYzMuZ2V0U3lzdGVtQ2hhbm5lbHMoKTtcbiAgICAgIGV4cGVjdChjaGFubmVscy5sZW5ndGgsIGdldFN5c3RlbUNoYW5uZWxEb2NzKS50by5iZS5ncmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgY2hhbm5lbHMpLnRvLmJlLmVxdWFscyhcIm9iamVjdFwiLCBnZXRTeXN0ZW1DaGFubmVsRG9jcyk7XG4gICAgICBleHBlY3QoY2hhbm5lbHNbMF0pLnRvLmhhdmUucHJvcGVydHkoXCJ0eXBlXCIpO1xuICAgICAgZXhwZWN0KGNoYW5uZWxzWzBdKS50by5oYXZlLnByb3BlcnR5KFwiaWRcIik7XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJmZGMzXzFfMlwiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMV8yL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5cbmZ1bmN0aW9uIHdyYXBQcm9taXNlKCk6IHtcbiAgcHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgcmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xufSB7XG4gIGxldCB3cmFwcGVyUmVzb2x2ZTtcbiAgbGV0IHdyYXBwZXJSZWplY3Q7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cmFwcGVyUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgd3JhcHBlclJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogd3JhcHBlclJlc29sdmUsIHJlamVjdDogd3JhcHBlclJlamVjdCB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMuam9pbkNoYW5uZWxcIiwgKCkgPT4ge1xuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmZGMzLmxlYXZlQ3VycmVudENoYW5uZWwoKTtcbiAgICB9KTtcblxuICAgIGl0KFwiKEJhc2ljSkMxKSBDYW4gam9pbiBjaGFubmVsIGFuZCBicm9hZGNhc3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHdyYXBQcm9taXNlKCk7XG4gICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IGZkYzMuZ2V0U3lzdGVtQ2hhbm5lbHMoKTtcblxuICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmZGMzLmpvaW5DaGFubmVsKGNoYW5uZWxzWzBdLmlkKTtcblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRDdXJyZW50Q2hhbm5lbCgpO1xuXG4gICAgICAgICAgZXhwZWN0KGN1cnJlbnRDaGFubmVsKS50by5ub3QuYmUubnVsbDtcblxuICAgICAgICAgIGNvbnN0IGdvdENvbnRleHQgPSAoYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwic29tZUNvbnRleHRcIiwgKGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN0eC50eXBlID09IFwic29tZUNvbnRleHRcIikge1xuICAgICAgICAgICAgICB3cmFwcGVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIucmVqZWN0KFwid3JvbmcgY29udGV4dCB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY3VycmVudENoYW5uZWwuYnJvYWRjYXN0KHtcbiAgICAgICAgICAgIHR5cGU6IFwic29tZUNvbnRleHRcIixcbiAgICAgICAgICAgIGlkOiB7IG5hbWU6IFwiaGVsbG9cIiB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgd3JhcHBlci5wcm9taXNlO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFwiRXJyb3Igd2hpbGUgam9pbmluZyBjaGFubmVsOiBcIiArIChleC5tZXNzYWdlID8/IGV4KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiTm8gc3lzdGVtIGNoYW5uZWxzIGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMV8yL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsXCIsICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaXQoXCIoQmFzaWNMQzEpIE1ldGhvZCBpcyBjYWxsYWJsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGZkYzMubGVhdmVDdXJyZW50Q2hhbm5lbCgpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICtcbiAgICAgICAgICBBUElEb2N1bWVudGF0aW9uLmxlYXZlQ3VycmVudENoYW5uZWwgK1xuICAgICAgICAgIFwiXFxyXFxuQ2F1c2VcIiArXG4gICAgICAgICAgKGV4Lm1lc3NhZ2UgPz8gZXgpXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4iLCJpbXBvcnQgeyBSZXNvbHZlRXJyb3IgfSBmcm9tIFwiZmRjM18xXzJcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzFfMi9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZG9jcyA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgK1xuICBBUElEb2N1bWVudGF0aW9uLnJhaXNlSW50ZW50Rm9yQ29udGV4dCArXG4gIFwiXFxyXFxuQ2F1c2U6IFwiO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMucmFpc2VJbnRlbnRGb3JDb250ZXh0XCIsIGFzeW5jICgpID0+IHtcbiAgICBpdChcIihCYXNpY1JJMSkgUGFzc2luZyBhbiBpbnZhbGlkIGNvbnRleHQgY2F1c2VzIGEgTm9BcHBzRm91bmQgZXJyb3IgdG8gYmUgdGhyb3duXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHR5cGU6IFwiVGhpc0NvbnRleHREb2VzTm90RXhpc3RcIixcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZkYzMucmFpc2VJbnRlbnRGb3JDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICBhc3NlcnQuZmFpbChcIkV4cGVjdGVkIGVycm9yIE5vQXBwc0ZvdW5kIG5vdCB0aHJvd25cIiwgZG9jcyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBleHBlY3QoZXgpLnRvLmhhdmUucHJvcGVydHkoXCJtZXNzYWdlXCIsIFJlc29sdmVFcnJvci5Ob0FwcHNGb3VuZCwgZG9jcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgTGlzdGVuZXIsIENoYW5uZWwsIENvbnRleHQgfSBmcm9tIFwiZmRjM18yXzBcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBjb25zdGFudHMgZnJvbSBcIi4uLy4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMl8wL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuaW1wb3J0IHsgc2xlZXAsIHdhaXQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHNcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZG9jdW1lbnRhdGlvbiA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmRlc2t0b3BBZ2VudCArIFwiXFxyXFxuQ2F1c2U6XCI7XG5cbmludGVyZmFjZSBBcHBDb250cm9sQ29udGV4dCBleHRlbmRzIENvbnRleHQge1xuICB0ZXN0SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmJyb2FkY2FzdFwiLCAoKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lcjtcbiAgICBsZXQgbGlzdGVuZXIyOiBMaXN0ZW5lcjtcbiAgICBsZXQgZXhlY3V0aW9uTGlzdGVuZXI6IExpc3RlbmVyO1xuXG4gICAgaXQoXCJCcm9hZGNhc3QgbWV0aG9kIGlzIGNhbGxhYmxlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMuYnJvYWRjYXN0KHtcbiAgICAgICAgdHlwZTogXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgaWQ6IHsgdGlja2VyOiBcIkFBUExcIiB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIlN5c3RlbSBjaGFubmVsc1wiLCAoKSA9PiB7XG4gICAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdW5zdWJzY3JpYmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgYXdhaXQgZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsKCk7XG4gICAgICB9KTtcblxuICAgICAgYWZ0ZXJFYWNoKGFzeW5jIGZ1bmN0aW9uIGFmdGVyRWFjaCgpIHtcbiAgICAgICAgYXdhaXQgY2xvc2VDaGFubmVsc0FwcFdpbmRvdyh0aGlzLmN1cnJlbnRUZXN0LnRpdGxlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDEgPVxuICAgICAgICBcIihVQ0Jhc2ljVXNhZ2UxKSBTaG91bGQgcmVjZWl2ZSBjb250ZXh0IHdoZW4gYWRkaW5nIGEgbGlzdGVuZXIgdGhlbiBqb2luaW5nIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgdG8gdGhlIHNhbWUgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQxLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBZGQgZmRjMy5pbnN0cnVtZW50IGNvbnRleHQgbGlzdGVuZXIgdG8gYXBwIEFcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIHNjVGVzdElkMSxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyID0gYXdhaXQgZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIobnVsbCwgYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0pvaW4gdXNlciBjaGFubmVsIDFcbiAgICAgICAgYXdhaXQgam9pbkNoYW5uZWwoMSk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luVXNlckNoYW5uZWxPbmUsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQxLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcElkXCIgfSxcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL3dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG5cbiAgICAgICAgLy9yZWplY3QgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFwiTm8gY29udGV4dCByZWNlaXZlZFwiICsgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkMiA9XG4gICAgICAgIFwiKFVDQmFzaWNVc2FnZTIpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBqb2luaW5nIGEgdXNlciBjaGFubmVsIHRoZW4gYWRkaW5nIGEgY29udGV4dCBsaXN0ZW5lciBiZWZvcmUgYXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IHRvIHRoZSBzYW1lIGNoYW5uZWxcIjtcbiAgICAgIGl0KHNjVGVzdElkMiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBZGQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQgdG8gQXBwIEFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBmZGMzLmluc3RydW1lbnQgY29udGV4dCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBzY1Rlc3RJZDIsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vSm9pbiB1c2VyIGNoYW5uZWwgMVxuICAgICAgICBhd2FpdCBqb2luQ2hhbm5lbCgxKTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgLy9BZGQgZmRjMy5pbnN0cnVtZW50IGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihudWxsLCBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblVzZXJDaGFubmVsT25lLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkMixcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy93YWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vRmFpbCBpZiBubyBjb250ZXh0IHJlY2VpdmVkXG4gICAgICAgIGlmICghcmVjZWl2ZWRDb250ZXh0KSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYE5vIGNvbnRleHQgcmVjZWl2ZWQhXFxuJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDMgPVxuICAgICAgICBcIihVQ0Jhc2ljVXNhZ2UzKSBTaG91bGQgcmVjZWl2ZSBjb250ZXh0IHdoZW4gYXBwIEIgam9pbnMgdGhlbiBicm9hZGNhc3RzIGNvbnRleHQgdG8gYSB1c2VyIGNoYW5uZWwgYmVmb3JlIEEgam9pbnMgYW5kIGxpc3RlbnMgb24gdGhlIHNhbWUgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQiBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgZmRjMy5pbnN0cnVtZW50IGNvbnRleHRcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEEgYWRkcyBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lciR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBzY1Rlc3RJZDMsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblVzZXJDaGFubmVsT25lLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkMyxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9Kb2luIHVzZXIgY2hhbm5lbCAxXG4gICAgICAgIGF3YWl0IGpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKG51bGwsIGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgcmVjZWl2ZWRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vRmFpbCBpZiBubyBjb250ZXh0IHJlY2VpdmVkXG4gICAgICAgIGlmICghcmVjZWl2ZWRDb250ZXh0KSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYE5vIGNvbnRleHQgcmVjZWl2ZWQhXFxuJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDQgPVxuICAgICAgICBcIihVQ0ZpbHRlcmVkQ29udGV4dDEpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBhcHAgQSBhZGRzIGEgbGlzdGVuZXIgYmVmb3JlIGpvaW5pbmcgYSB1c2VyIGNoYW5uZWwsIHRoZW4gYXBwIEIgYnJvYWRjYXN0cyB0aGUgbGlzdGVuZWQgdHlwZSB0byB0aGUgc2FtZSB1c2VyIGNoYW5uZWxcIjtcbiAgICAgIGl0KHNjVGVzdElkNCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxcclxcbi0gQXBwIEEgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBzY1Rlc3RJZDQsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyID0gYXdhaXQgZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL0pvaW4gdXNlciBjaGFubmVsIDFcbiAgICAgICAgam9pbkNoYW5uZWwoMSk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luVXNlckNoYW5uZWxPbmUsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0Q29udGFjdENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQ0LFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcElkXCIgfSxcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG5cbiAgICAgICAgLy9GYWlsIGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgTm8gY29udGV4dCByZWNlaXZlZCFcXG4ke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkNSA9XG4gICAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0MikgU2hvdWxkIHJlY2VpdmUgY29udGV4dCB3aGVuIGFwcCBBIGpvaW5zIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhZGRpbmcgYSBjb250ZXh0IGxpc3RlbmVyLCB0aGVuIGFwcCBCIGJyb2FkY2FzdHMgdGhlIGxpc3RlbmVkIHR5cGUgdG8gdGhlIHNhbWUgdXNlciBjaGFubmVsXCI7XG4gICAgICBpdChzY1Rlc3RJZDUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEEgYWRkcyBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgc2NUZXN0SWQ1LFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICAvL0pvaW4gdXNlciBjaGFubmVsIDFcbiAgICAgICAgam9pbkNoYW5uZWwoMSk7XG5cbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICBcImZkYzMuaW5zdHJ1bWVudFwiLFxuICAgICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblVzZXJDaGFubmVsT25lLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkNSxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vcmVqZWN0IGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChcIk5vIGNvbnRleHQgcmVjZWl2ZWRcIiArIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY1Rlc3RJZDYgPVxuICAgICAgICBcIihVQ0ZpbHRlcmVkQ29udGV4dDMpIFNob3VsZCByZWNlaXZlIGNvbnRleHQgd2hlbiBhcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgdG8gYSB1c2VyIGNoYW5uZWwgYmVmb3JlIEEgYWRkcyBhIGxpc3RlbmVyIG9mIHRoZSBzYW1lIHR5cGUgYnJvYWRjYXN0IGJ5IEIgYW5kIGpvaW5zIHRoZSBzYW1lIHVzZXIgY2hhbm5lbFwiO1xuICAgICAgaXQoc2NUZXN0SWQ2LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyXFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50JHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIHNjVGVzdElkNixcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5qb2luVXNlckNoYW5uZWxPbmUsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0Q29udGFjdENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogc2NUZXN0SWQ2LFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcElkXCIgfSxcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG5cbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICBcImZkYzMuaW5zdHJ1bWVudFwiLFxuICAgICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIC8vSm9pbiB1c2VyIGNoYW5uZWwgMVxuICAgICAgICBqb2luQ2hhbm5lbCgxKTtcblxuICAgICAgICAvL3JlamVjdCBpZiBubyBjb250ZXh0IHJlY2VpdmVkXG4gICAgICAgIGlmICghcmVjZWl2ZWRDb250ZXh0KSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBjb250ZXh0IHJlY2VpdmVkXCIgKyBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NUZXN0SWQ3ID1cbiAgICAgICAgXCIoVUNGaWx0ZXJlZENvbnRleHQ0KSBTaG91bGQgcmVjZWl2ZSBjb250ZXh0IHdoZW4gYXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IHRvIGEgdXNlciBjaGFubmVsIGJlZm9yZSBBIGpvaW5zIHRoZSBzYW1lIHVzZXIgY2hhbm5lbCBhbmQgYWRkcyBhIGxpc3RlbmVyIG9mIHRoZSBzYW1lIHR5cGUgdGhhdCB3YXMgYnJvYWRjYXN0IGJ5IEJcIjtcbiAgICAgIGl0KHNjVGVzdElkNywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyXFxyXFxuLSBBcHAgQiBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBzY1Rlc3RJZDcsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblVzZXJDaGFubmVsT25lLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkNyxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vSm9pbiB1c2VyIGNoYW5uZWwgMVxuICAgICAgICBqb2luQ2hhbm5lbCgxKTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgLy9BZGQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZXh0LnR5cGUpLnRvLmJlLmVxdWFscyhcImZkYzMuaW5zdHJ1bWVudFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVjZWl2ZWRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgLy9GYWlsIGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgTm8gY29udGV4dCByZWNlaXZlZCFcXG4ke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkOCA9XG4gICAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0NSkgU2hvdWxkIHJlY2VpdmUgbXVsdGlwbGUgY29udGV4dHMgd2hlbiBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlcyB0byB0aGUgc2FtZSB1c2VyIGNoYW5uZWxcIjtcbiAgICAgIGl0KHNjVGVzdElkNywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdCBjb250ZXh0IGxpc3RlbmVyXFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBib3RoIGNvbnRleHQgdHlwZXMke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgc2NUZXN0SWQ4LFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGNvbnRleHRUeXBlczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBsZXQgcmVjZWl2ZWRDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tJZkJvdGhDb250ZXh0c1JlY2VpdmVkKCkge1xuICAgICAgICAgIGlmIChjb250ZXh0VHlwZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFjb250ZXh0VHlwZXMuaW5jbHVkZXMoXCJmZGMzLmNvbnRhY3RcIikgfHxcbiAgICAgICAgICAgICAgIWNvbnRleHRUeXBlcy5pbmNsdWRlcyhcImZkYzMuaW5zdHJ1bWVudFwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGFzc2VydC5mYWlsKFwiSW5jb3JyZWN0IGNvbnRleHQgcmVjZWl2ZWRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9BZGQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHRUeXBlcy5wdXNoKGNvbnRleHQudHlwZSk7XG4gICAgICAgICAgICBjaGVja0lmQm90aENvbnRleHRzUmVjZWl2ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgLy9BZGQgc2Vjb25kIGNvbnRleHQgbGlzdGVuZXIgdG8gYXBwIEFcbiAgICAgICAgbGlzdGVuZXIyID0gYXdhaXQgZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIoXCJmZGMzLmNvbnRhY3RcIiwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBjb250ZXh0VHlwZXMucHVzaChjb250ZXh0LnR5cGUpO1xuICAgICAgICAgIGNoZWNrSWZCb3RoQ29udGV4dHNSZWNlaXZlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyMik7XG5cbiAgICAgICAgLy9Kb2luIHVzZXIgY2hhbm5lbCAxXG4gICAgICAgIGF3YWl0IGpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMuam9pblVzZXJDaGFubmVsT25lLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkOCxcbiAgICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vUmVqZWN0IGlmIG5vIGNvbnRleHQgcmVjZWl2ZWRcbiAgICAgICAgaWYgKCFyZWNlaXZlZENvbnRleHQpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgJHtlcnJvck1lc3NhZ2V9IEF0IGxlYXN0IG9uZSBjb250ZXh0IHdhcyBub3QgcmVjZWl2ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjVGVzdElkOSA9XG4gICAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0NikgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiBBICYgQiBqb2luIGRpZmZlcmVudCB1c2VyIGNoYW5uZWxzIGFuZCBhcHAgQiBicm9hZGNhc3RzIGEgbGlzdGVuZWQgdHlwZVwiO1xuICAgICAgaXQoc2NUZXN0SWQ5LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGZkYzMuaW5zdHJ1bWVudCBhbmQgZmRjMy5jb250YWN0IGNvbnRleHQgbGlzdGVuZXJcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMlxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGJvdGggY29udGV4dCB0eXBlcyR7ZG9jdW1lbnRhdGlvbn1gO1xuICAgICAgICBsZXQgdGltZW91dDtcblxuICAgICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgLy9BZGQgZmRjMy5jb250YWN0IGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIyID0gYXdhaXQgZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIoXCJmZGMzLmNvbnRhY3RcIiwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgJHtlcnJvck1lc3NhZ2V9ICR7Y29udGV4dC50eXBlfSBjb250ZXh0IHJlY2VpdmVkYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIyKTtcblxuICAgICAgICAvL0NoYW5uZWxzQXBwIGpvaW5zIGNoYW5uZWwgMlxuICAgICAgICBhd2FpdCBqb2luQ2hhbm5lbCgyKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLmpvaW5Vc2VyQ2hhbm5lbE9uZSxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RDb250YWN0Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMi4wXCIsXG4gICAgICAgICAgdGVzdElkOiBzY1Rlc3RJZDksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcElkXCIgfSxcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL0dpdmUgbGlzdGVuZXIgdGltZSB0byByZWNlaXZlIGNvbnRleHRcbiAgICAgICAgY29uc3QgeyBwcm9taXNlOiBzbGVlcFByb21pc2UsIHRpbWVvdXQ6IHRoZVRpbWVvdXQgfSA9IHNsZWVwKCk7XG4gICAgICAgIHRpbWVvdXQgPSB0aGVUaW1lb3V0O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzY1Rlc3RJZDEwID1cbiAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0NykgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiB1bnN1YnNjcmliaW5nIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoYXQgY2hhbm5lbFwiO1xuICAgIGl0KHNjVGVzdElkMTAsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSBhZGRzIGNvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEEgdW5zdWJzY3JpYmVzIHRoZSBsaXN0ZW5lclxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgIHNjVGVzdElkMTAsXG4gICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICk7XG5cbiAgICAgIC8vQWRkIGZkYzMuaW5zdHJ1bWVudCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwiZmRjMy5pbnN0cnVtZW50XCIsIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgLy9Kb2luIHVzZXIgY2hhbm5lbCAxXG4gICAgICBhd2FpdCBqb2luQ2hhbm5lbCgxKTtcblxuICAgICAgLy9VbnN1YnNjcmliZSBmcm9tIGxpc3RlbmVyc1xuICAgICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQuZmFpbChcIkxpc3RlbmVyIHVuZGVmaW5lZFwiLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICBjb21tYW5kcy5qb2luVXNlckNoYW5uZWxPbmUsXG4gICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgdGVzdElkOiBzY1Rlc3RJZDEwLFxuICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICk7XG5cbiAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG4gICAgfSk7XG5cbiAgICBjb25zdCBzY1Rlc3RJZDExID1cbiAgICAgIFwiKFVDRmlsdGVyZWRDb250ZXh0OCkgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiBqb2luaW5nIHR3byBkaWZmZXJlbnQgdXNlciBjaGFubmVscyBiZWZvcmUgYXBwIEIgYnJvYWRjYXN0cyB0aGUgbGlzdGVuZWQgdHlwZSB0byB0aGUgZmlyc3QgY2hhbm5lbCB0aGF0IHdhcyBqb2luZWRcIjtcbiAgICBpdChzY1Rlc3RJZDExLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBBIGpvaW5zIGNoYW5uZWwgMlxcclxcbi0gQXBwIEIgam9pbnMgY2hhbm5lbCAxXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcbiAgICAgIGxldCB0aW1lb3V0O1xuXG4gICAgICAvL0FkZCBmZGMzLmluc3RydW1lbnQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChgJHtlcnJvck1lc3NhZ2V9ICR7Y29udGV4dC50eXBlfSBjb250ZXh0IHJlY2VpdmVkYCk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vQ2hhbm5lbHNBcHAgam9pbnMgYSBjaGFubmVsIGFuZCB0aGVuIGpvaW5zIGFub3RoZXJcbiAgICAgIGF3YWl0IGpvaW5DaGFubmVsKDEpO1xuICAgICAgYXdhaXQgam9pbkNoYW5uZWwoMik7XG5cbiAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgIGNvbW1hbmRzLmpvaW5Vc2VyQ2hhbm5lbE9uZSxcbiAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICB0ZXN0SWQ6IHNjVGVzdElkMTEsXG4gICAgICB9O1xuXG4gICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgKTtcblxuICAgICAgLy9HaXZlIGxpc3RlbmVyIHRpbWUgdG8gcmVjZWl2ZSBjb250ZXh0XG4gICAgICBjb25zdCB7IHByb21pc2U6IHNsZWVwUHJvbWlzZSwgdGltZW91dDogdGhlVGltZW91dCB9ID0gc2xlZXAoKTtcbiAgICAgIHRpbWVvdXQgPSB0aGVUaW1lb3V0O1xuICAgICAgYXdhaXQgc2xlZXBQcm9taXNlO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2NUZXN0SWQxMiA9XG4gICAgICBcIihVQ0ZpbHRlcmVkQ29udGV4dDkpIFNob3VsZCBub3QgcmVjZWl2ZSBjb250ZXh0IHdoZW4gam9pbmluZyBhbmQgdGhlbiBsZWF2aW5nIGEgdXNlciBjaGFubmVsIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoZSBzYW1lIGNoYW5uZWxcIjtcbiAgICBpdChzY1Rlc3RJZDEyLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgYWRkcyBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQSBqb2lucyBjaGFubmVsIDFcXHJcXG4tIEFwcCBBIGxlYXZlcyBjaGFubmVsIDFcXHJcXG4tIEFwcCBCIGpvaW5zIGNoYW5uZWwgMVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50JHtkb2N1bWVudGF0aW9ufWA7XG4gICAgICBsZXQgdGltZW91dDtcbiAgICAgIC8vQWRkIGEgY29udGV4dCBsaXN0ZW5lcnMgdG8gYXBwIEFcbiAgICAgIGxpc3RlbmVyID0gYXdhaXQgZmRjMy5hZGRDb250ZXh0TGlzdGVuZXIoXCJmZGMzLmluc3RydW1lbnRcIiwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgfSk7XG5cbiAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAvL0pvaW4gdXNlciBjaGFubmVsIDFcbiAgICAgIGF3YWl0IGpvaW5DaGFubmVsKDEpO1xuXG4gICAgICAvL0FwcCBBIGxlYXZlcyBjaGFubmVsIDFcbiAgICAgIGF3YWl0IGZkYzMubGVhdmVDdXJyZW50Q2hhbm5lbCgpO1xuXG4gICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICBjb21tYW5kcy5qb2luVXNlckNoYW5uZWxPbmUsXG4gICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgdGVzdElkOiBzY1Rlc3RJZDEyLFxuICAgICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICk7XG5cbiAgICAgIC8vR2l2ZSBsaXN0ZW5lciB0aW1lIHRvIHJlY2VpdmUgY29udGV4dFxuICAgICAgY29uc3QgeyBwcm9taXNlOiBzbGVlcFByb21pc2UsIHRpbWVvdXQ6IHRoZVRpbWVvdXQgfSA9IHNsZWVwKCk7XG4gICAgICB0aW1lb3V0ID0gdGhlVGltZW91dDtcbiAgICAgIGF3YWl0IHNsZWVwUHJvbWlzZTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwiQXBwIGNoYW5uZWxzXCIsICgpID0+IHtcbiAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB1bnN1YnNjcmliZUxpc3RlbmVycygpO1xuICAgICAgICBhd2FpdCBmZGMzLmxlYXZlQ3VycmVudENoYW5uZWwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhZnRlckVhY2goYXN5bmMgZnVuY3Rpb24gYWZ0ZXJFYWNoKCkge1xuICAgICAgICBhd2FpdCBjbG9zZUNoYW5uZWxzQXBwV2luZG93KHRoaXMuY3VycmVudFRlc3QudGl0bGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkID1cbiAgICAgICAgXCIoQUNCYXNpY1VzYWdlMSkgU2hvdWxkIHJlY2VpdmUgY29udGV4dCB3aGVuIGFwcCBhIGFkZHMgYSBsaXN0ZW5lciBhbmQgYXBwIEIgYnJvYWRjYXN0cyB0byB0aGUgc2FtZSBhcHAgY2hhbm5lbFwiO1xuICAgICAgaXQoYWNUZXN0SWQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBhbiBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEEgYWRkcyBhZGRzIGEgY29udGV4dCBsaXN0ZW5lciBvZiB0eXBlIG51bGxcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgc2FtZSBhcHAgY2hhbm5lbCBhcyBBXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgYWNUZXN0SWQsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcInRlc3QtY2hhbm5lbFwiKTtcbiAgICAgICAgbGV0IHJlY2VpdmVkQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZWNlaXZlZENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLnJldHJpZXZlVGVzdEFwcENoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogYWNUZXN0SWQsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICAgICAgYEF0IGxlYXN0IG9uZSBjb250ZXh0IHdhcyBub3QgcmVjZWl2ZWQhXFxuJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhY1Rlc3RJZDIgPVxuICAgICAgICBcIihBQ0Jhc2ljVXNhZ2UyKSBTaG91bGQgcmVjZWl2ZSBjb250ZXh0IHdoZW4gYXBwIEIgYnJvYWRjYXN0cyBjb250ZXh0IHRvIGFuIGFwcCBjaGFubmVsIGJlZm9yZSBBIHJldHJpZXZlcyBjdXJyZW50IGNvbnRleHRcIjtcbiAgICAgIGl0KGFjVGVzdElkMiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgJiBCIHJldHJpZXZlIHRoZSBzYW1lIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBjdXJyZW50IGNvbnRleHQgb2YgdHlwZSBudWxsJHtkb2N1bWVudGF0aW9ufWA7XG5cbiAgICAgICAgLy9MaXN0ZW4gZm9yIHdoZW4gQ2hhbm5lbHNBcHAgZXhlY3V0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyID0gd2FpdEZvckNvbnRleHQoXG4gICAgICAgICAgXCJleGVjdXRpb25Db21wbGV0ZVwiLFxuICAgICAgICAgIGFjVGVzdElkMixcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9SZXRyaWV2ZSBhbiBhcHAgY2hhbm5lbFxuICAgICAgICBjb25zdCB0ZXN0Q2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwidGVzdC1jaGFubmVsXCIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMi4wXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDIsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL1JldHJpZXZlIGN1cnJlbnQgY29udGV4dCBmcm9tIGNoYW5uZWxcbiAgICAgICAgYXdhaXQgdGVzdENoYW5uZWwuZ2V0Q3VycmVudENvbnRleHQoKS50aGVuKGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGNvbnRleHQudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5pbnN0cnVtZW50XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgcmVjZWl2ZWRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0aGUgZmluaXNoIGV4ZWN1dGluZ1xuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQ0ID1cbiAgICAgICAgXCIoQUNGaWx0ZXJlZENvbnRleHQxKSBTaG91bGQgb25seSByZWNlaXZlIHRoZSBsaXN0ZW5lZCBjb250ZXh0IHdoZW4gYXBwIEIgYnJvYWRjYXN0cyBtdWx0aXBsZSBjb250ZXh0cyB0byB0aGUgc2FtZSBhcHAgY2hhbm5lbFwiO1xuICAgICAgaXQoYWNUZXN0SWQ0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSByZXRyaWV2ZXMgYW4gYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBBIGFkZHMgYSBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQiByZXRyaWV2ZXMgdGhlIHNhbWUgYXBwIGNoYW5uZWwgYXMgQVxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBhIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBhY1Rlc3RJZDQsXG4gICAgICAgICAgYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCByZWNlaXZlZENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgLy9BZGQgY29udGV4dCBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IHRlc3RDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICBcImZkYzMuaW5zdHJ1bWVudFwiLFxuICAgICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlY2VpdmVkQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhbGlkYXRlTGlzdGVuZXJPYmplY3QobGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29tbWFuZHMgPSBbXG4gICAgICAgICAgY29tbWFuZHMucmV0cmlldmVUZXN0QXBwQ2hhbm5lbCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dCxcbiAgICAgICAgICBjb21tYW5kcy5icm9hZGNhc3RDb250YWN0Q29udGV4dCxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMi4wXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDQsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcblxuICAgICAgICAvL0ZhaWwgaWYgbm8gY29udGV4dCByZWNlaXZlZFxuICAgICAgICBpZiAoIXJlY2VpdmVkQ29udGV4dCkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKGBObyBjb250ZXh0IHJlY2VpdmVkIVxcbiR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQ3ID1cbiAgICAgICAgXCIoQUNGaWx0ZXJlZENvbnRleHQyKSBTaG91bGQgbm90IHJlY2VpdmUgY29udGV4dCB3aGVuIGFwcCBCIGJyb2FkY2FzdHMgY29udGV4dCB0byBhIGRpZmZlcmVudCBhcHAgY2hhbm5lbFwiO1xuICAgICAgaXQoYWNUZXN0SWQ3LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXHJcXG5TdGVwcyB0byByZXByb2R1Y2U6XFxyXFxuLSBBcHAgQSByZXRyaWV2ZXMgYW4gYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBBIGFkZHMgYSBjb250ZXh0IGxpc3RlbmVyIG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50XFxyXFxuLSBBcHAgQiByZXRyaWV2ZXMgYSBkaWZmZXJlbnQgYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgYSBjb250ZXh0IG9mIHR5cGUgZmRjMy5pbnN0cnVtZW50JHtkb2N1bWVudGF0aW9ufWA7XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXG4gICAgICAgICAgXCJhLWRpZmZlcmVudC10ZXN0LWNoYW5uZWxcIlxuICAgICAgICApO1xuXG4gICAgICAgIC8vQWRkIGNvbnRleHQgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLnJldHJpZXZlVGVzdEFwcENoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogYWNUZXN0SWQ3LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCB0aGVuIGV4ZWN1dGUgY29tbWFuZHMgaW4gb3JkZXJcbiAgICAgICAgYXdhaXQgZmRjMy5vcGVuKFxuICAgICAgICAgIHsgYXBwSWQ6IFwiQ2hhbm5lbHNBcHBJZFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9HaXZlIGxpc3RlbmVyIHRpbWUgdG8gcmVjZWl2ZSBjb250ZXh0XG4gICAgICAgIGNvbnN0IHsgcHJvbWlzZTogc2xlZXBQcm9taXNlLCB0aW1lb3V0OiB0aGVUaW1lb3V0IH0gPSBzbGVlcCgpO1xuICAgICAgICB0aW1lb3V0ID0gdGhlVGltZW91dDtcbiAgICAgICAgYXdhaXQgc2xlZXBQcm9taXNlO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjVGVzdElkNiA9XG4gICAgICAgIFwiKEFDVW5zdWJzY3JpYmUpIFNob3VsZCBub3QgcmVjZWl2ZSBjb250ZXh0IHdoZW4gdW5zdWJzY3JpYmluZyBhbiBhcHAgY2hhbm5lbCBiZWZvcmUgYXBwIEIgYnJvYWRjYXN0cyB0byB0aGF0IGNoYW5uZWxcIjtcbiAgICAgIGl0KGFjVGVzdElkNiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQSBhZGRzIGEgY29udGV4dCBsaXN0ZW5lciBvZiB0eXBlIG51bGxcXHJcXG4tIEFwcCBBIHVuc3Vic2NyaWJlcyB0aGUgYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgc2FtZSBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEIgYnJvYWRjYXN0cyBhIGNvbnRleHQgb2YgdHlwZSBmZGMzLmluc3RydW1lbnQgYW5kIGZkYzMuY29udGFjdCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcInRlc3QtY2hhbm5lbFwiKTtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgYWNUZXN0SWQ2LFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyID0gYXdhaXQgdGVzdENoYW5uZWwuYWRkQ29udGV4dExpc3RlbmVyKG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyKTtcblxuICAgICAgICAvL1Vuc3Vic2NyaWJlIGZyb20gYXBwIGNoYW5uZWxcbiAgICAgICAgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcblxuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbW1hbmRzID0gW1xuICAgICAgICAgIGNvbW1hbmRzLnJldHJpZXZlVGVzdEFwcENoYW5uZWwsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0SW5zdHJ1bWVudENvbnRleHQsXG4gICAgICAgICAgY29tbWFuZHMuYnJvYWRjYXN0Q29udGFjdENvbnRleHQsXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb25maWc6IENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICAgICAgICAgIGZkYzNBcGlWZXJzaW9uOiBcIjIuMFwiLFxuICAgICAgICAgIHRlc3RJZDogYWNUZXN0SWQ2LFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcElkXCIgfSxcbiAgICAgICAgICBidWlsZENoYW5uZWxzQXBwQ29udGV4dChjaGFubmVsc0FwcENvbW1hbmRzLCBjaGFubmVsc0FwcENvbmZpZylcbiAgICAgICAgKTtcblxuICAgICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIGV4ZWN1dGVcbiAgICAgICAgYXdhaXQgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXI7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWNUZXN0SWQxMCA9XG4gICAgICAgIFwiKEFDRmlsdGVyZWRDb250ZXh0MykgU2hvdWxkIG5vdCByZWNlaXZlIGNvbnRleHQgd2hlbiByZXRyaWV2aW5nIHR3byBkaWZmZXJlbnQgYXBwIGNoYW5uZWxzIGJlZm9yZSBhcHAgQiBicm9hZGNhc3RzIHRoZSBsaXN0ZW5lZCB0eXBlIHRvIHRoZSBmaXJzdCBjaGFubmVsIHRoYXQgd2FzIHJldHJpZXZlZFwiO1xuICAgICAgaXQoYWNUZXN0SWQxMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQSBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEEgYWRkcyBhIGNvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSBmZGMzLmluc3RydW1lbnRcXHJcXG4tIEFwcCBCIHJldHJpZXZlcyB0aGUgZmlyc3QgY2hhbm5lbCB0aGF0IEEgcmV0cmlldmVkXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vTGlzdGVuIGZvciB3aGVuIENoYW5uZWxzQXBwIGV4ZWN1dGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICBjb25zdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lciA9IHdhaXRGb3JDb250ZXh0KFxuICAgICAgICAgIFwiZXhlY3V0aW9uQ29tcGxldGVcIixcbiAgICAgICAgICBhY1Rlc3RJZDEwLFxuICAgICAgICAgIGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIilcbiAgICAgICAgKTtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGxldCB0ZXN0Q2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwidGVzdC1jaGFubmVsXCIpO1xuXG4gICAgICAgIGxpc3RlbmVyID0gYXdhaXQgdGVzdENoYW5uZWwuYWRkQ29udGV4dExpc3RlbmVyKFxuICAgICAgICAgIFwiZmRjMy5pbnN0cnVtZW50XCIsXG4gICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5mYWlsKGAke2Vycm9yTWVzc2FnZX0gJHtjb250ZXh0LnR5cGV9IGNvbnRleHQgcmVjZWl2ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lcik7XG5cbiAgICAgICAgLy9BcHAgQSByZXRyaWV2ZXMgYSBkaWZmZXJlbnQgYXBwIGNoYW5uZWxcbiAgICAgICAgbGV0IHRlc3RDaGFubmVsMiA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFxuICAgICAgICAgIFwiYS1kaWZmZXJlbnQtdGVzdC1jaGFubmVsXCJcbiAgICAgICAgKTtcblxuICAgICAgICAvL0FkZCBjb250ZXh0IGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyMiA9IGF3YWl0IHRlc3RDaGFubmVsMi5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJmZGMzLmluc3RydW1lbnRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmZhaWwoYCR7ZXJyb3JNZXNzYWdlfSAke2NvbnRleHQudHlwZX0gY29udGV4dCByZWNlaXZlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyT2JqZWN0KGxpc3RlbmVyMik7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkMTAsXG4gICAgICAgICAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvL09wZW4gQ2hhbm5lbHNBcHAgdGhlbiBleGVjdXRlIGNvbW1hbmRzIGluIG9yZGVyXG4gICAgICAgIGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgICB7IGFwcElkOiBcIkNoYW5uZWxzQXBwSWRcIiB9LFxuICAgICAgICAgIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KGNoYW5uZWxzQXBwQ29tbWFuZHMsIGNoYW5uZWxzQXBwQ29uZmlnKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vV2FpdCBmb3IgQ2hhbm5lbHNBcHAgdG8gZXhlY3V0ZVxuICAgICAgICBhd2FpdCByZXNvbHZlRXhlY3V0aW9uQ29tcGxldGVMaXN0ZW5lcjtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhY1Rlc3RJZDExID1cbiAgICAgICAgXCIoQUNDb250ZXh0SGlzdG9yeVR5cGVkKSBTaG91bGQgcmVjZWl2ZSBib3RoIGNvbnRleHRzIHdoZW4gYXBwIEIgYnJvYWRjYXN0cyBib3RoIGNvbnRleHRzIHRvIHRoZSBzYW1lIGFwcCBjaGFubmVsIGFuZCBBIGdldHMgY3VycmVudCBjb250ZXh0IGZvciBlYWNoIHR5cGVcIjtcbiAgICAgIGl0KGFjVGVzdElkMTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcclxcblN0ZXBzIHRvIHJlcHJvZHVjZTpcXHJcXG4tIEFwcCBBIHJldHJpZXZlcyBhbiBhcHAgY2hhbm5lbFxcclxcbi0gQXBwIEIgcmV0cmlldmVzIHRoZSBzYW1lIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiBicm9hZGNhc3RzIGEgY29udGV4dCBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudCBhbmQgZmRjMy5jb250YWN0XFxyXFxuLSBBcHAgQSBnZXRzIGN1cnJlbnQgY29udGV4dCBmb3IgdHlwZXMgZmRjMy5pbnN0cnVtZW50IGFuZCBmZGMzLmNvbnRhY3Qke2RvY3VtZW50YXRpb259YDtcblxuICAgICAgICAvL1JldHJpZXZlIGFuIGFwcCBjaGFubmVsXG4gICAgICAgIGNvbnN0IHRlc3RDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJ0ZXN0LWNoYW5uZWxcIik7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGNoYW5uZWxzQXBwQ29uZmlnOiBDaGFubmVsc0FwcENvbmZpZyA9IHtcbiAgICAgICAgICBmZGMzQXBpVmVyc2lvbjogXCIyLjBcIixcbiAgICAgICAgICB0ZXN0SWQ6IGFjVGVzdElkMTEsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9PcGVuIENoYW5uZWxzQXBwIHRoZW4gZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9nZXQgY29udGV4dHMgZnJvbSBDaGFubmVsc0FwcFxuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGVzdENoYW5uZWwuZ2V0Q3VycmVudENvbnRleHQoXCJmZGMzLmluc3RydW1lbnRcIik7XG4gICAgICAgIGV4cGVjdChjb250ZXh0Lm5hbWUpLnRvLmJlLmVxdWFscyhcIkhpc3RvcnktaXRlbS0xXCIsIGVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgY29uc3QgY29udGFjdENvbnRleHQgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dChcbiAgICAgICAgICBcImZkYzMuY29udGFjdFwiXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChjb250YWN0Q29udGV4dC5uYW1lKS50by5iZS5lcXVhbHMoXG4gICAgICAgICAgXCJIaXN0b3J5LWl0ZW0tMVwiLFxuICAgICAgICAgIGVycm9yTWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHRMYXRlc3QgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpO1xuICAgICAgICBleHBlY3QoY29udGV4dExhdGVzdC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmNvbnRhY3RcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhY1Rlc3RJZDEzID1cbiAgICAgICAgXCIoQUNDb250ZXh0SGlzdG9yeU11bHRpcGxlKSBTaG91bGQgcmV0cmlldmUgdGhlIGxhc3QgYnJvYWRjYXN0IGNvbnRleHQgaXRlbSB3aGVuIGFwcCBCIGJyb2FkY2FzdHMgYSBjb250ZXh0IHdpdGggbXVsdGlwbGUgaGlzdG9yeSBpdGVtcyB0byB0aGUgc2FtZSBhcHAgY2hhbm5lbCBhbmQgQSBnZXRzIGN1cnJlbnQgY29udGV4dFwiO1xuICAgICAgaXQoYWNUZXN0SWQxMywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxyXFxuU3RlcHMgdG8gcmVwcm9kdWNlOlxcclxcbi0gQXBwIEEgcmV0cmlldmVzIGFuIGFwcCBjaGFubmVsXFxyXFxuLSBBcHAgQiByZXRyaWV2ZXMgdGhlIHNhbWUgYXBwIGNoYW5uZWxcXHJcXG4tIEFwcCBCIGJyb2FkY2FzdHMgdHdvIGRpZmZlcmVudCBjb250ZXh0cyBvZiB0eXBlIGZkYzMuaW5zdHJ1bWVudFxcclxcbi0gQXBwIEEgZ2V0cyBjdXJyZW50IGNvbnRleHQgZm9yIHR5cGVzIGZkYzMuaW5zdHJ1bWVudCR7ZG9jdW1lbnRhdGlvbn1gO1xuXG4gICAgICAgIC8vUmV0cmlldmUgYW4gYXBwIGNoYW5uZWxcbiAgICAgICAgY29uc3QgdGVzdENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcInRlc3QtY2hhbm5lbFwiKTtcblxuICAgICAgICAvL0xpc3RlbiBmb3Igd2hlbiBDaGFubmVsc0FwcCBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgY29uc3QgcmVzb2x2ZUV4ZWN1dGlvbkNvbXBsZXRlTGlzdGVuZXIgPSB3YWl0Rm9yQ29udGV4dChcbiAgICAgICAgICBcImV4ZWN1dGlvbkNvbXBsZXRlXCIsXG4gICAgICAgICAgYWNUZXN0SWQxMyxcbiAgICAgICAgICBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbHNBcHBDb21tYW5kcyA9IFtcbiAgICAgICAgICBjb21tYW5kcy5yZXRyaWV2ZVRlc3RBcHBDaGFubmVsLFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdEluc3RydW1lbnRDb250ZXh0LFxuICAgICAgICAgIGNvbW1hbmRzLmJyb2FkY2FzdENvbnRhY3RDb250ZXh0LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjaGFubmVsc0FwcENvbmZpZzogQ2hhbm5lbHNBcHBDb25maWcgPSB7XG4gICAgICAgICAgZmRjM0FwaVZlcnNpb246IFwiMi4wXCIsXG4gICAgICAgICAgdGVzdElkOiBhY1Rlc3RJZDEzLFxuICAgICAgICAgIG5vdGlmeUFwcEFPbkNvbXBsZXRpb246IHRydWUsXG4gICAgICAgICAgaGlzdG9yeUl0ZW1zOiAyLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vT3BlbiBDaGFubmVsc0FwcCBhbmQgZXhlY3V0ZSBjb21tYW5kcyBpbiBvcmRlclxuICAgICAgICBhd2FpdCBmZGMzLm9wZW4oXG4gICAgICAgICAgeyBhcHBJZDogXCJDaGFubmVsc0FwcFwiIH0sXG4gICAgICAgICAgYnVpbGRDaGFubmVsc0FwcENvbnRleHQoY2hhbm5lbHNBcHBDb21tYW5kcywgY2hhbm5lbHNBcHBDb25maWcpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy9XYWl0IGZvciBDaGFubmVsc0FwcCB0byBleGVjdXRlXG4gICAgICAgIGF3YWl0IHJlc29sdmVFeGVjdXRpb25Db21wbGV0ZUxpc3RlbmVyO1xuXG4gICAgICAgIC8vUmV0cmlldmUgZmRjMy5pbnN0cnVtZW50IGNvbnRleHRcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRlc3RDaGFubmVsLmdldEN1cnJlbnRDb250ZXh0KFwiZmRjMy5pbnN0cnVtZW50XCIpO1xuICAgICAgICBleHBlY3QoY29udGV4dC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmluc3RydW1lbnRcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgZXhwZWN0KGNvbnRleHQubmFtZSkudG8uYmUuZXF1YWxzKFwiSGlzdG9yeS1pdGVtLTJcIiwgZXJyb3JNZXNzYWdlKTtcblxuICAgICAgICBjb25zdCBjb250ZXh0MiA9IGF3YWl0IHRlc3RDaGFubmVsLmdldEN1cnJlbnRDb250ZXh0KFwiZmRjMy5jb250YWN0XCIpO1xuICAgICAgICBleHBlY3QoY29udGV4dDIudHlwZSkudG8uYmUuZXF1YWxzKFwiZmRjMy5jb250YWN0XCIsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGV4cGVjdChjb250ZXh0Mi5uYW1lKS50by5iZS5lcXVhbHMoXCJIaXN0b3J5LWl0ZW0tMlwiLCBlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHRMYXRlc3QgPSBhd2FpdCB0ZXN0Q2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpO1xuICAgICAgICBleHBlY3QoY29udGV4dExhdGVzdC50eXBlKS50by5iZS5lcXVhbHMoXCJmZGMzLmNvbnRhY3RcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgZXhwZWN0KGNvbnRleHRMYXRlc3QubmFtZSkudG8uYmUuZXF1YWxzKFwiSGlzdG9yeS1pdGVtLTJcIiwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgam9pbkNoYW5uZWwgPSBhc3luYyAoY2hhbm5lbDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBjaGFubmVscyA9IGF3YWl0IGZkYzMuZ2V0VXNlckNoYW5uZWxzKCk7XG4gICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhd2FpdCBmZGMzLmpvaW5Vc2VyQ2hhbm5lbChjaGFubmVsc1tjaGFubmVsIC0gMV0uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXCJObyBzeXN0ZW0gY2hhbm5lbHMgYXZhaWxhYmxlIGZvciBhcHAgQVwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lck9iamVjdChsaXN0ZW5lck9iamVjdCkge1xuICAgICAgYXNzZXJ0LmlzVHJ1ZShcbiAgICAgICAgdHlwZW9mIGxpc3RlbmVyT2JqZWN0ID09PSBcIm9iamVjdFwiLFxuICAgICAgICBcIk5vIGxpc3RlbmVyIG9iamVjdCBmb3VuZFwiXG4gICAgICApO1xuICAgICAgZXhwZWN0KHR5cGVvZiBsaXN0ZW5lck9iamVjdC51bnN1YnNjcmliZSkudG8uYmUuZXF1YWxzKFxuICAgICAgICBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTGlzdGVuZXIgZG9lcyBub3QgY29udGFpbiBhbiB1bnN1YnNjcmliZSBtZXRob2RcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjbG9zZUNoYW5uZWxzQXBwV2luZG93KHRlc3RJZDogc3RyaW5nKSB7XG4gICAgICAvL1RlbGwgQ2hhbm5lbHNBcHAgdG8gY2xvc2Ugd2luZG93XG4gICAgICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGJyb2FkY2FzdEFwcENoYW5uZWxDbG9zZVdpbmRvdyh0ZXN0SWQpO1xuXG4gICAgICAvL1dhaXQgZm9yIENoYW5uZWxzQXBwIHRvIHJlc3BvbmRcbiAgICAgIGF3YWl0IHdhaXRGb3JDb250ZXh0KFwid2luZG93Q2xvc2VkXCIsIHRlc3RJZCwgYXBwQ29udHJvbENoYW5uZWwpO1xuICAgICAgYXdhaXQgd2FpdChjb25zdGFudHMuV2luZG93Q2xvc2VXYWl0VGltZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYnJvYWRjYXN0QXBwQ2hhbm5lbENsb3NlV2luZG93ID0gYXN5bmMgKHRlc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIik7XG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICAgIGNvbnN0IGNsb3NlQ29udGV4dDogQXBwQ29udHJvbENvbnRleHQgPSB7XG4gICAgICAgIHR5cGU6IFwiY2xvc2VXaW5kb3dcIixcbiAgICAgICAgdGVzdElkOiB0ZXN0SWQsXG4gICAgICB9O1xuICAgICAgYXdhaXQgYXBwQ29udHJvbENoYW5uZWwuYnJvYWRjYXN0KGNsb3NlQ29udGV4dCk7XG4gICAgICByZXR1cm4gYXBwQ29udHJvbENoYW5uZWw7XG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHVuc3Vic2NyaWJlTGlzdGVuZXJzKCkge1xuICAgICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0ZW5lcjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBsaXN0ZW5lcjIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXIyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhlY3V0aW9uTGlzdGVuZXIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IGV4ZWN1dGlvbkxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGV4ZWN1dGlvbkxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdhaXRGb3JDb250ZXh0ID0gKFxuICAgICAgY29udGV4dFR5cGU6IHN0cmluZyxcbiAgICAgIHRlc3RJZDogc3RyaW5nLFxuICAgICAgY2hhbm5lbD86IENoYW5uZWxcbiAgICApOiBQcm9taXNlPENvbnRleHQ+ID0+IHtcbiAgICAgIGxldCBleGVjdXRpb25MaXN0ZW5lcjogTGlzdGVuZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8Q29udGV4dD4oYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICBgIFdhaXRpbmcgZm9yIHR5cGU6IFwiJHtjb250ZXh0VHlwZX1cIiwgb24gY2hhbm5lbDogXCIke2NoYW5uZWwuaWR9XCIgaW4gdGVzdDogXCIke3Rlc3RJZH1cImBcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBoYW5kbGVyID0gKGNvbnRleHQ6IEFwcENvbnRyb2xDb250ZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKHRlc3RJZCkge1xuICAgICAgICAgICAgaWYgKHRlc3RJZCA9PSBjb250ZXh0LnRlc3RJZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgYCBSZWNlaXZlZCAke2NvbnRleHRUeXBlfSBmb3IgdGVzdDogJHt0ZXN0SWR9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uTGlzdGVuZXIpIGV4ZWN1dGlvbkxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgICBgIElnbm9yaW5nIFwiJHtjb250ZXh0VHlwZX1cIiBjb250ZXh0IGR1ZSB0byBtaXNtYXRjaGVkIHRlc3RJZCAoZXhwZWN0ZWQ6IFwiJHt0ZXN0SWR9XCIsIGdvdCBcIiR7Y29udGV4dC50ZXN0SWR9XCIpYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgYCBSZWNlaXZlZCAod2l0aG91dCB0ZXN0SWQpIFwiJHtjb250ZXh0VHlwZX1cIiBmb3IgdGVzdDogXCIke3Rlc3RJZH1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkxpc3RlbmVyKSBleGVjdXRpb25MaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICAgIGNvbnRleHRUeXBlLFxuICAgICAgICAgICAgaGFuZGxlclxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY3V0aW9uTGlzdGVuZXIgPSBhd2FpdCBjaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICAgIGNvbnRleHRUeXBlLFxuICAgICAgICAgICAgaGFuZGxlclxuICAgICAgICAgICk7XG4gICAgICAgICAgLy9BcHAgY2hhbm5lbHMgZG8gbm90IGF1dG8tYnJvYWRjYXN0IGN1cnJlbnQgY29udGV4dCB3aGVuIHlvdSBzdGFydCBsaXN0ZW5pbmcsIHNvIHJldHJpZXZlIGN1cnJlbnQgY29udGV4dCB0byBhdm9pZCByYWNlc1xuICAgICAgICAgIGNvbnN0IGNjSGFuZGxlciA9IGFzeW5jIChjb250ZXh0OiBBcHBDb250cm9sQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKHRlc3RJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0SWQgPT0gY29udGV4dD8udGVzdElkICYmIGNvbnRleHQ/LnR5cGUgPT0gY29udGV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICtcbiAgICAgICAgICAgICAgICAgICAgICBgIFJlY2VpdmVkIFwiJHtjb250ZXh0VHlwZX1cIiAoZnJvbSBjdXJyZW50IGNvbnRleHQpIGZvciB0ZXN0OiBcIiR7dGVzdElkfVwiYFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChleGVjdXRpb25MaXN0ZW5lcikgZXhlY3V0aW9uTGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSAvL2RvIG5vdCB3YXJuIGFzIGl0IHdpbGwgYmUgaWdub3JpbmcgbWlzbWF0Y2hlcyB3aGljaCB3aWxsIGJlIGNvbW1vblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgK1xuICAgICAgICAgICAgICAgICAgICAgIGAgQ0hlY2tpbmcgZm9yIGN1cnJlbnQgY29udGV4dCBvZiB0eXBlIFwiJHtjb250ZXh0VHlwZX1cIiBmb3IgdGVzdDogXCIke3Rlc3RJZH1cIiBDdXJyZW50IGNvbnRleHQgZGlkICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID8gXCJcIiA6IFwiTk9UIFwiXG4gICAgICAgICAgICAgICAgICAgICAgfSBleGlzdCwgXG4gICAgaGFkIHRlc3RJZDogXCIke2NvbnRleHQ/LnRlc3RJZH1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RJZCA9PSBjb250ZXh0Py50ZXN0SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImRpZCBtYXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkaWQgTk9UIG1hdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSBcbiAgICBhbmQgdHlwZSBcIiR7Y29udGV4dD8udHlwZX1cIiAoJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ/LnR5cGUgPT0gY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImRpZCBtYXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkaWQgTk9UIG1hdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArXG4gICAgICAgICAgICAgICAgICAgIGAgUmVjZWl2ZWQgXCIke2NvbnRleHRUeXBlfVwiIChmcm9tIGN1cnJlbnQgY29udGV4dCkgZm9yIGFuIHVuc3BlY2lmaWVkIHRlc3RgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uTGlzdGVuZXIpIGV4ZWN1dGlvbkxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY2hhbm5lbC5nZXRDdXJyZW50Q29udGV4dCgpLnRoZW4oY2NIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbnR5cGUgQ2hhbm5lbHNBcHBDb250ZXh0ID0gQ29udGV4dCAmIHtcbiAgY29tbWFuZHM6IHN0cmluZ1tdO1xuICBjb25maWc6IHtcbiAgICB0ZXN0SWQ6IHN0cmluZztcbiAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiBib29sZWFuO1xuICAgIGhpc3RvcnlJdGVtczogbnVtYmVyO1xuICAgIGZkYzNBcGlWZXJzaW9uOiBzdHJpbmc7XG4gIH07XG59O1xuXG50eXBlIENoYW5uZWxzQXBwQ29uZmlnID0ge1xuICBmZGMzQXBpVmVyc2lvbjogc3RyaW5nO1xuICB0ZXN0SWQ6IHN0cmluZztcbiAgbm90aWZ5QXBwQU9uQ29tcGxldGlvbj86IGJvb2xlYW47XG4gIGhpc3RvcnlJdGVtcz86IG51bWJlcjtcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkQ2hhbm5lbHNBcHBDb250ZXh0KFxuICBtb2NrQXBwQ29tbWFuZHM6IHN0cmluZ1tdLFxuICBjb25maWc6IENoYW5uZWxzQXBwQ29uZmlnXG4pOiBDaGFubmVsc0FwcENvbnRleHQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY2hhbm5lbHNBcHBDb250ZXh0XCIsXG4gICAgY29tbWFuZHM6IG1vY2tBcHBDb21tYW5kcyxcbiAgICBjb25maWc6IHtcbiAgICAgIGZkYzNBcGlWZXJzaW9uOiBjb25maWcuZmRjM0FwaVZlcnNpb24sXG4gICAgICB0ZXN0SWQ6IGNvbmZpZy50ZXN0SWQsXG4gICAgICBub3RpZnlBcHBBT25Db21wbGV0aW9uOiBjb25maWcubm90aWZ5QXBwQU9uQ29tcGxldGlvbiA/PyBmYWxzZSxcbiAgICAgIGhpc3RvcnlJdGVtczogY29uZmlnLmhpc3RvcnlJdGVtcyA/PyAxLFxuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IGNvbW1hbmRzID0ge1xuICBqb2luVXNlckNoYW5uZWxPbmU6IFwiam9pblVzZXJDaGFubmVsT25lXCIsXG4gIHJldHJpZXZlVGVzdEFwcENoYW5uZWw6IFwicmV0cmlldmVUZXN0QXBwQ2hhbm5lbFwiLFxuICBicm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dDogXCJicm9hZGNhc3RJbnN0cnVtZW50Q29udGV4dFwiLFxuICBicm9hZGNhc3RDb250YWN0Q29udGV4dDogXCJicm9hZGNhc3RDb250YWN0Q29udGV4dFwiLFxufTtcbiIsImltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzJfMC9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcbmltcG9ydCB7IENvbnRleHQsIENvbnRleHRNZXRhZGF0YSwgSW1wbGVtZW50YXRpb25NZXRhZGF0YSB9IGZyb20gXCJmZGMzXzJfMFwiO1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi4vLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzbGVlcCwgd2FpdCwgd3JhcFByb21pc2UgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHNcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZmluZEluc3RhbmNlc0RvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5maW5kSW5zdGFuY2VzICsgXCJcXHJcXG5DYXVzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMuZmluZEluc3RhbmNlc1wiLCAoKSA9PiB7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGJyb2FkY2FzdENsb3NlV2luZG93KCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTW9ja0FwcFRvQ2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGl0KFwiKDIuMC1GaW5kSW5zdGFuY2VzKSB2YWxpZCBtZXRhZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvL3N0YXJ0IEEgYW5kIHJldHJpZXZlIGl0cyBBcHBJZGVudGlmaWVyXG4gICAgICAgIGNvbnN0IGFwcElkZW50aWZpZXIgPSBhd2FpdCBmZGMzLm9wZW4oe1xuICAgICAgICAgIGFwcElkOiBcIk1ldGFkYXRhQXBwSWRcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9zdGFydCBBIGFnYWluIGFuZCByZXRyaWV2ZSBhbm90aGVyIEFwcElkZW50aWZpZXJcbiAgICAgICAgbGV0IGFwcElkZW50aWZpZXIyID0gYXdhaXQgZmRjMy5vcGVuKHtcbiAgICAgICAgICBhcHBJZDogXCJNZXRhZGF0YUFwcElkXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vY29uZmlybSB0aGF0IHRoZSBpbnN0YW5jZUlkIGZvciBib3RoIGFwcCBpbnN0YW50aWF0aW9ucyBpcyBkaWZmZXJlbnRcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIGFwcElkZW50aWZpZXIuaW5zdGFuY2VJZCxcbiAgICAgICAgICBgVGhlIEFwcElkZW50aWZpZXIncyBpbnN0YW5jZUlkIHByb3BlcnR5IGZvciBib3RoIGluc3RhbmNlcyBvZiB0aGUgb3BlbmVkIGFwcCBzaG91bGQgbm90IGJlIHRoZSBzYW1lLiR7ZmluZEluc3RhbmNlc0RvY3N9YFxuICAgICAgICApLnRvLm5vdC5lcXVhbChhcHBJZGVudGlmaWVyMi5pbnN0YW5jZUlkKTtcblxuICAgICAgICAvL3JldHJpZXZlIGluc3RhbmNlIGRldGFpbHNcbiAgICAgICAgbGV0IGluc3RhbmNlcyA9IGF3YWl0IGZkYzMuZmluZEluc3RhbmNlcyh7IGFwcElkOiBcIk1ldGFkYXRhQXBwSWRcIiB9KTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluc3RhbmNlcy5pbmNsdWRlcyhhcHBJZGVudGlmaWVyKSB8fFxuICAgICAgICAgICFpbnN0YW5jZXMuaW5jbHVkZXMoYXBwSWRlbnRpZmllcjIpXG4gICAgICAgICkge1xuICAgICAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICAgICAgYEF0IGxlYXN0IG9uZSBBcHBJZGVudGlmaWVyIG9iamVjdCBpcyBtaXNzaW5nIGZyb20gdGhlIEFwcElkZW50aWZpZXIgYXJyYXkgcmV0dXJuZWQgYWZ0ZXIgY2FsbGluZyBmZGMzLmZpbmRJbnN0YW5jZXMoYXBwOiBBcHBJZGVudGlmaWVyKSR7ZmluZEluc3RhbmNlc0RvY3N9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHdyYXBQcm9taXNlKCk7XG5cbiAgICAgICAgLy9lbnN1cmUgYXBwSWRlbnRpZmllciByZWNlaXZlZCB0aGUgcmFpc2VkIGludGVudFxuICAgICAgICBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgICBcIm1ldGFkYXRhQ29udGV4dFwiLFxuICAgICAgICAgIChjb250ZXh0OiBNZXRhZGF0YUNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGV4cGVjdChcbiAgICAgICAgICAgICAgY29udGV4dC5jb250ZXh0TWV0YWRhdGEuc291cmNlLFxuICAgICAgICAgICAgICBcIkNvbnRleHRNZXRhZGF0YS5zb3VyY2UgZGlkIG5vdCBtYXRjaCB0aGUgQXBwSWRlbnRpZmllciBvZiB0aGUgZmlyc3QgbW9jayBhcHAgdGhhdCB3YXMgb3BlbmVkXCJcbiAgICAgICAgICAgICkudG8uYmUuZXF1YWxzKGFwcElkZW50aWZpZXIpO1xuICAgICAgICAgICAgd3JhcHBlci5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhQXBwQ29udGV4dCA9IHtcbiAgICAgICAgICB0eXBlOiBcIm1ldGFkYXRhQXBwQ29udGV4dFwiLFxuICAgICAgICAgIGNvbW1hbmQ6IE1ldGFkYXRhQXBwQ29tbWFuZC5jb25maXJtUmFpc2VkSW50ZW50UmVjZWl2ZWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9yYWlzZSBhbiBpbnRlbnQgYW5kIHRhcmdldCBhcHBJZGVudGlmaWVyXG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhd2FpdCBmZGMzLnJhaXNlSW50ZW50KFxuICAgICAgICAgIFwiYVRlc3RpbmdJbnRlbnRcIixcbiAgICAgICAgICBtZXRhZGF0YUFwcENvbnRleHQsXG4gICAgICAgICAgYXBwSWRlbnRpZmllclxuICAgICAgICApO1xuXG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICByZXNvbHV0aW9uLnNvdXJjZSxcbiAgICAgICAgICBcIkludGVudFJlc29sdXRpb24uc291cmNlIGRpZCBub3QgbWF0Y2ggdGhlIG1vY2sgYXBwJ3MgQXBwSWRlbnRpZmllclwiXG4gICAgICAgICkudG8uYmUuZXF1YWwoYXBwSWRlbnRpZmllcik7XG5cbiAgICAgICAgLy9mYWlsIGlmIG5vIG1ldGFkYXRhQ29udGV4dCByZWNlaXZlZFxuICAgICAgICB0aW1lb3V0ID0gYXdhaXQgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHdyYXBwZXIucmVqZWN0KFwiZGlkIG5vdCByZWNlaXZlIE1ldGFkYXRhQ29udGV4dCBmcm9tIG1ldGFkYXRhIGFwcFwiKTtcbiAgICAgICAgfSwgY29uc3RhbnRzLldhaXRUaW1lKTtcblxuICAgICAgICAvL3dhaXQgZm9yIHJhaXNlZCBpbnRlbnRcbiAgICAgICAgYXdhaXQgd3JhcHBlci5wcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZmluZEluc3RhbmNlc0RvY3MgKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvck1vY2tBcHBUb0Nsb3NlKCkge1xuICBsZXQgdGltZW91dDtcbiAgY29uc3QgbWVzc2FnZVJlY2VpdmVkID0gbmV3IFByb21pc2U8Q29udGV4dD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGF3YWl0IGFwcENvbnRyb2xDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgIFwid2luZG93Q2xvc2VkXCIsXG4gICAgICBhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICBhd2FpdCB3YWl0KGNvbnN0YW50cy5XaW5kb3dDbG9zZVdhaXRUaW1lKTtcbiAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgbGlzdGVuZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy9pZiBubyBjb250ZXh0IHJlY2VpdmVkIHJlamVjdCBwcm9taXNlXG4gICAgY29uc3QgeyBwcm9taXNlOiBzbGVlcFByb21pc2UsIHRpbWVvdXQ6IHRoZVRpbWVvdXQgfSA9IHNsZWVwKCk7XG4gICAgdGltZW91dCA9IHRoZVRpbWVvdXQ7XG4gICAgYXdhaXQgc2xlZXBQcm9taXNlO1xuICAgIHJlamVjdChuZXcgRXJyb3IoXCJ3aW5kb3dDbG9zZWQgY29udGV4dCBub3QgcmVjZWl2ZWQgZnJvbSBhcHAgQlwiKSk7XG4gIH0pO1xuXG4gIHJldHVybiBtZXNzYWdlUmVjZWl2ZWQ7XG59XG5cbmNvbnN0IGJyb2FkY2FzdENsb3NlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhcHBDb250cm9sQ2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiYXBwLWNvbnRyb2xcIik7XG4gIGF3YWl0IGFwcENvbnRyb2xDaGFubmVsLmJyb2FkY2FzdCh7IHR5cGU6IFwiY2xvc2VXaW5kb3dcIiB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIGltcGxNZXRhZGF0YT86IEltcGxlbWVudGF0aW9uTWV0YWRhdGE7XG4gIGNvbnRleHRNZXRhZGF0YT86IENvbnRleHRNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUFwcENvbW1hbmRDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIGNvbW1hbmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGVudW0gTWV0YWRhdGFBcHBDb21tYW5kIHtcbiAgc2VuZEdldEluZm9NZXRhZGF0YVRvVGVzdHMgPSBcInNlbmRHZXRJbmZvTWV0YWRhdGFUb1Rlc3RzXCIsXG4gIGNvbmZpcm1SYWlzZWRJbnRlbnRSZWNlaXZlZCA9IFwiY29uZmlybVJhaXNlZEludGVudFJlY2VpdmVkXCIsXG59XG4iLCJpbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18yXzAvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5pbXBvcnQgeyBBcHBNZXRhZGF0YSwgQ29udGV4dCB9IGZyb20gXCJmZGMzXzJfMFwiO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHNcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZ2V0TWV0YWRhdGFEb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uYXBwTWV0YWRhdGEgKyBcIlxcclxcbkNhdXNlOiBcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldEFwcE1ldGFkYXRhXCIsICgpID0+IHtcbiAgICBhZnRlcihhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBicm9hZGNhc3RDbG9zZVdpbmRvdygpO1xuICAgICAgYXdhaXQgd2FpdEZvck1vY2tBcHBUb0Nsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpdChcIk1ldGhvZCBpcyBjYWxsYWJsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZGMzLmdldEFwcE1ldGFkYXRhKHtcbiAgICAgICAgICBhcHBJZDogXCJNZXRhZGF0YUFwcElkXCIsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0TWV0YWRhdGFEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKEdldEFwcE1ldGFkYXRhKSBWYWxpZCBtZXRhZGF0YSBvYmplY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy9yZXRyaWV2ZSBBcHBNZXRhZGF0YSBvYmplY3RcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmZGMzLmdldEFwcE1ldGFkYXRhKHsgYXBwSWQ6IFwiTWV0YWRhdGFBcHBJZFwiIH0pO1xuXG4gICAgICAgIHZhbGlkYXRlQXBwTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0TWV0YWRhdGFEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKDIuMC1BcHBJbnN0YW5jZU1ldGFkYXRhKSBBcHAgaW5zdGFuY2UgbWV0YWRhdGEgaXMgdmFsaWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy9vcGVuIG1ldGFkYXRhIGFwcFxuICAgICAgICBjb25zdCBhcHBJZGVudGlmaWVyMSA9IGF3YWl0IGZkYzMub3Blbih7IGFwcElkOiBcIk1ldGFkYXRhQXBwSWRcIiB9KTtcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIGFwcElkZW50aWZpZXIxLFxuICAgICAgICAgIGBUaGUgQXBwSWRlbnRpZmllciBvYmplY3QgcmV0cmlldmVkIGFmdGVyIGNhbGxpbmcgZmRjMy5vcGVuKCkgc2hvdWxkIGNvbnRhaW4gYW4gYXBwSWQgcHJvcGVydHkuJHtnZXRNZXRhZGF0YURvY3N9YFxuICAgICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJhcHBJZFwiKTtcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIGFwcElkZW50aWZpZXIxLFxuICAgICAgICAgIGBUaGUgQXBwSWRlbnRpZmllciBvYmplY3QgcmV0cmlldmVkIGFmdGVyIGNhbGxpbmcgZmRjMy5vcGVuKCkgc2hvdWxkIGNvbnRhaW4gYW4gaW5zdGFuY2VJZCBwcm9wZXJ0eS4ke2dldE1ldGFkYXRhRG9jc31gXG4gICAgICAgICkudG8uaGF2ZS5wcm9wZXJ0eShcImluc3RhbmNlSWRcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcHBJZGVudGlmaWVyMS5pbnN0YW5jZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYXNzZXJ0LmZhaWwoXCJUaGUgaW5zdGFuY2VJZCBwcm9wZXJ0eSBpcyBub3Qgb2YgdHlwZSBzdHJpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL29wZW4gbWV0YWRhdGEgYWdhaW5cbiAgICAgICAgY29uc3QgYXBwSWRlbnRpZmllcjIgPSBhd2FpdCBmZGMzLm9wZW4oeyBhcHBJZDogXCJNZXRhZGF0YUFwcElkXCIgfSk7XG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBhcHBJZGVudGlmaWVyMixcbiAgICAgICAgICBgVGhlIEFwcElkZW50aWZpZXIgb2JqZWN0IHJldHJpZXZlZCBhZnRlciBjYWxsaW5nIGZkYzMub3BlbigpIHNob3VsZCBjb250YWluIGFuIGFwcElkIHByb3BlcnR5LiR7Z2V0TWV0YWRhdGFEb2NzfWBcbiAgICAgICAgKS50by5oYXZlLnByb3BlcnR5KFwiYXBwSWRcIik7XG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBhcHBJZGVudGlmaWVyMixcbiAgICAgICAgICBgVGhlIEFwcElkZW50aWZpZXIgb2JqZWN0IHJldHJpZXZlZCBhZnRlciBjYWxsaW5nIGZkYzMub3BlbigpIHNob3VsZCBjb250YWluIGFuIGluc3RhbmNlSWQgcHJvcGVydHkuJHtnZXRNZXRhZGF0YURvY3N9YFxuICAgICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZUlkXCIpO1xuXG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICB0eXBlb2YgYXBwSWRlbnRpZmllcjIuaW5zdGFuY2VJZCxcbiAgICAgICAgICBgVGhlIEFwcElkZW50aWZpZXIuaW5zdGFuY2VJZCBwcm9wZXJ0eSBzaG91bGQgYmUgb2YgdHlwZSBzdHJpbmcuIEdvdCAke3R5cGVvZiBhcHBJZGVudGlmaWVyMi5pbnN0YW5jZUlkfWBcbiAgICAgICAgKS50by5iZS5lcXVhbChcInN0cmluZ1wiKTtcblxuICAgICAgICAvL2NoZWNrIGluc3RhbmNlSWQgaXMgZGlmZmVyZW50IGZvciBib3RoIGluc3RhbnRpYXRpb25zIG9mIHRoZSBhcHBcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIGFwcElkZW50aWZpZXIxLmluc3RhbmNlSWQsXG4gICAgICAgICAgYFRoZSBBcHBJZGVudGlmaWVyJ3MgaW5zdGFuY2VJZCBwcm9wZXJ0eSBmb3IgYm90aCBpbnN0YW5jZXMgb2YgdGhlIG9wZW5lZCBhcHAgc2hvdWxkIG5vdCBiZSB0aGUgc2FtZS4ke2dldE1ldGFkYXRhRG9jc31gXG4gICAgICAgICkudG8ubm90LmVxdWFsKGFwcElkZW50aWZpZXIyLmluc3RhbmNlSWQpO1xuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhMSA9IGF3YWl0IGZkYzMuZ2V0QXBwTWV0YWRhdGEoYXBwSWRlbnRpZmllcjEpO1xuXG4gICAgICAgIHZhbGlkYXRlQXBwTWV0YWRhdGEobWV0YWRhdGExKTtcblxuICAgICAgICAvL2NoZWNrIHRoYXQgbWV0YWRhdGEgaW5zdGFuY2VJZCBpcyB0aGUgc2FtZSBhcyB0aGUgYXBwSWRlbnRpZnllciBpbnN0YW5jZUlkXG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBtZXRhZGF0YTEuaW5zdGFuY2VJZCxcbiAgICAgICAgICBcIlRoZSBBcHBNZXRhRGF0YSdzIGluc3RhbmNlSWQgcHJvcGVydHkgdGhhdCB3YXMgcmV0cmlldmVkIHdoZW4gY2FsbGluZyBvcGVuKCkgZG9lcyBub3QgbWF0Y2ggQXBwSWRlbnRpZmllcidzIGluc3RhbmNlSWQgcHJvcGVydHkgdGhhdCB3YXMgcmV0cmlldmVkIHdoZW4gY2FsbGluZyBnZXRBcHBNZXRhZGF0YSgpIGZvciB0aGUgc2FtZSBhcHAgaW5zdGFuY2VcIlxuICAgICAgICApLnRvLmJlLmVxdWFsKGFwcElkZW50aWZpZXIxLmluc3RhbmNlSWQpO1xuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhMiA9IGF3YWl0IGZkYzMuZ2V0QXBwTWV0YWRhdGEoYXBwSWRlbnRpZmllcjIpO1xuXG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBtZXRhZGF0YTIsXG4gICAgICAgICAgYFRoZSBBcHBJZGVudGlmaWVyIG9iamVjdCByZXRyaWV2ZWQgYWZ0ZXIgY2FsbGluZyBmZGMzLm9wZW4oKSBzaG91bGQgY29udGFpbiBhbiBpbnN0YW5jZUlkIHByb3BlcnR5LiR7Z2V0TWV0YWRhdGFEb2NzfWBcbiAgICAgICAgKS50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VJZFwiKTtcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIG1ldGFkYXRhMi5pbnN0YW5jZUlkLFxuICAgICAgICAgIFwiVGhlIEFwcE1ldGFEYXRhJ3MgaW5zdGFuY2VJZCBwcm9wZXJ0eSByZXRyaWV2ZWQgd2hlbiBjYWxsaW5nIG9wZW4oKSBkb2VzIG5vdCBtYXRjaCBBcHBJZGVudGlmaWVyJ3MgaW5zdGFuY2VJZCBwcm9wZXJ0eSByZXRyaWV2ZWQgd2hlbiBjYWxsaW5nIGdldEFwcE1ldGFkYXRhKCkgZm9yIHRoZSBzYW1lIGFwcFwiXG4gICAgICAgICkudG8uYmUuZXF1YWwoYXBwSWRlbnRpZmllcjIuaW5zdGFuY2VJZCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBhc3NlcnQuZmFpbChnZXRNZXRhZGF0YURvY3MgKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvck1vY2tBcHBUb0Nsb3NlKCkge1xuICBsZXQgdGltZW91dDtcbiAgY29uc3QgbWVzc2FnZVJlY2VpdmVkID0gbmV3IFByb21pc2U8Q29udGV4dD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGF3YWl0IGFwcENvbnRyb2xDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgIFwid2luZG93Q2xvc2VkXCIsXG4gICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICByZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vaWYgbm8gY29udGV4dCByZWNlaXZlZCByZWplY3QgcHJvbWlzZVxuICAgIGNvbnN0IHsgcHJvbWlzZTogc2xlZXBQcm9taXNlLCB0aW1lb3V0OiB0aGVUaW1lb3V0IH0gPSBzbGVlcCgpO1xuICAgIHRpbWVvdXQgPSB0aGVUaW1lb3V0O1xuICAgIGF3YWl0IHNsZWVwUHJvbWlzZTtcbiAgICByZWplY3QobmV3IEVycm9yKFwid2luZG93Q2xvc2VkIGNvbnRleHQgbm90IHJlY2VpdmVkIGZyb20gYXBwIEJcIikpO1xuICB9KTtcblxuICByZXR1cm4gbWVzc2FnZVJlY2VpdmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcHBNZXRhZGF0YShtZXRhZGF0YTogQXBwTWV0YWRhdGEpIHtcbiAgZXhwZWN0KFxuICAgIG1ldGFkYXRhLFxuICAgIGBubyBuYW1lIHByb3BlcnR5IGZvdW5kIG9uIEFwcE1ldGFkYXRhIG9iamVjdCR7Z2V0TWV0YWRhdGFEb2NzfWBcbiAgKS50by5oYXZlLnByb3BlcnR5KFwibmFtZVwiKTtcbiAgaWYgKHR5cGVvZiBtZXRhZGF0YS5uYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgYXNzZXJ0LmZhaWwoXG4gICAgICBgSW5jb3JyZWN0IHR5cGUgZGV0ZWN0ZWQgZm9yIEFwcE1ldGFkYXRhLm5hbWUuIEV4cGVjdGVkIGEgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbWV0YWRhdGEubmFtZX1gXG4gICAgKTtcbiAgfVxuICBleHBlY3QoXG4gICAgbWV0YWRhdGEsXG4gICAgYG5vIHZlcnNpb24gcHJvcGVydHkgZm91bmQgb24gQXBwTWV0YWRhdGEgb2JqZWN0JHtnZXRNZXRhZGF0YURvY3N9YFxuICApLnRvLmhhdmUucHJvcGVydHkoXCJ2ZXJzaW9uXCIpO1xuICBleHBlY3QoXG4gICAgdHlwZW9mIG1ldGFkYXRhLnZlcnNpb24sXG4gICAgYEluY29ycmVjdCB0eXBlIGRldGVjdGVkIGZvciBBcHBNZXRhZGF0YS52ZXJzaW9uLiBFeHBlY3RlZCBhIHN0cmluZywgZ290ICR7dHlwZW9mIG1ldGFkYXRhLnZlcnNpb259YFxuICApLnRvLmJlLmVxdWFsKFwic3RyaW5nXCIpO1xuXG4gIGV4cGVjdChcbiAgICBtZXRhZGF0YSxcbiAgICBgbm8gdGl0bGUgcHJvcGVydHkgZm91bmQgb24gQXBwTWV0YWRhdGEgb2JqZWN0JHtnZXRNZXRhZGF0YURvY3N9YFxuICApLnRvLmhhdmUucHJvcGVydHkoXCJ0aXRsZVwiKTtcbiAgZXhwZWN0KFxuICAgIHR5cGVvZiBtZXRhZGF0YS50aXRsZSxcbiAgICBgSW5jb3JyZWN0IHR5cGUgZGV0ZWN0ZWQgZm9yIEFwcE1ldGFkYXRhLnRpdGxlLiBFeHBlY3RlZCBhIHN0cmluZywgZ290ICR7dHlwZW9mIG1ldGFkYXRhLnRpdGxlfWBcbiAgKS50by5iZS5lcXVhbChcInN0cmluZ1wiKTtcblxuICBleHBlY3QoXG4gICAgbWV0YWRhdGEsXG4gICAgYG5vIHRvb2x0aXAgcHJvcGVydHkgZm91bmQgb24gQXBwTWV0YWRhdGEgb2JqZWN0JHtnZXRNZXRhZGF0YURvY3N9YFxuICApLnRvLmhhdmUucHJvcGVydHkoXCJ0b29sdGlwXCIpO1xuICBleHBlY3QoXG4gICAgdHlwZW9mIG1ldGFkYXRhLnRvb2x0aXAsXG4gICAgYEluY29ycmVjdCB0eXBlIGRldGVjdGVkIGZvciBBcHBNZXRhZGF0YS50b29sdGlwLiBFeHBlY3RlZCBhIHN0cmluZywgZ290ICR7dHlwZW9mIG1ldGFkYXRhLnRvb2x0aXB9YFxuICApLnRvLmJlLmVxdWFsKFwic3RyaW5nXCIpO1xuXG4gIGV4cGVjdChcbiAgICBtZXRhZGF0YSxcbiAgICBgbm8gZGVzY3JpcHRpb24gcHJvcGVydHkgZm91bmQgb24gQXBwTWV0YWRhdGEgb2JqZWN0JHtnZXRNZXRhZGF0YURvY3N9YFxuICApLnRvLmhhdmUucHJvcGVydHkoXCJkZXNjcmlwdGlvblwiKTtcbiAgZXhwZWN0KFxuICAgIHR5cGVvZiBtZXRhZGF0YS5kZXNjcmlwdGlvbixcbiAgICBgSW5jb3JyZWN0IHR5cGUgZGV0ZWN0ZWQgZm9yIEFwcE1ldGFkYXRhLmRlc2NyaXB0aW9uLiBFeHBlY3RlZCBhIHN0cmluZywgZ290ICR7dHlwZW9mIG1ldGFkYXRhLmRlc2NyaXB0aW9ufWBcbiAgKS50by5iZS5lcXVhbChcInN0cmluZ1wiKTtcblxuICBleHBlY3QoXG4gICAgbWV0YWRhdGEsXG4gICAgYG5vIGljb25zIHByb3BlcnR5IGZvdW5kIG9uIEFwcE1ldGFkYXRhIG9iamVjdCR7Z2V0TWV0YWRhdGFEb2NzfWBcbiAgKS50by5oYXZlLnByb3BlcnR5KFwiaWNvbnNcIik7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG1ldGFkYXRhLmljb25zKSkge1xuICAgIGFzc2VydC5mYWlsKFxuICAgICAgYEluY29ycmVjdCB0eXBlIGRldGVjdGVkIGZvciBBcHBNZXRhZGF0YS5pY29ucy4gRXhwZWN0ZWQgYW4gQXJyYXksIGdvdCAke3R5cGVvZiBtZXRhZGF0YS5kZXNjcmlwdGlvbn1gXG4gICAgKTtcbiAgfVxuXG4gIC8vZW5zdXJlIGljb25zIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgY29uc3QgaXNPYmplY3RBcnJheSA9IGlzQXJyYXlPZk9iamVjdHMobWV0YWRhdGEuaWNvbnMpO1xuXG4gIGlmICghaXNPYmplY3RBcnJheSlcbiAgICBhc3NlcnQuZmFpbChcIkFwcE1ldGFkYXRhLmljb25zIHNob3VsZCBjb250YWluIGFuIEFycmF5IG9mIG9iamVjdHNcIik7XG5cbiAgZXhwZWN0KG1ldGFkYXRhLCBnZXRNZXRhZGF0YURvY3MpLnRvLmhhdmUucHJvcGVydHkoXCJzY3JlZW5zaG90c1wiKTtcbiAgZXhwZWN0KFxuICAgIHR5cGVvZiBtZXRhZGF0YS5zY3JlZW5zaG90cyxcbiAgICBgSW5jb3JyZWN0IHR5cGUgZGV0ZWN0ZWQgZm9yIEFwcE1ldGFkYXRhLnNjcmVlbnNob3RzLiBFeHBlY3RlZCBhbiBBcnJheSwgZ290ICR7dHlwZW9mIG1ldGFkYXRhLmRlc2NyaXB0aW9ufWBcbiAgKS50by5iZS5lcXVhbChcIkFycmF5XCIpO1xuXG4gIC8vZW5zdXJlIHNjcmVlbnNob3RzIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgY29uc3QgaXNPYmplY3RBcnJheTIgPSBpc0FycmF5T2ZPYmplY3RzKG1ldGFkYXRhLnNjcmVlbnNob3RzKTtcblxuICBpZiAoIWlzT2JqZWN0QXJyYXkyKVxuICAgIGFzc2VydC5mYWlsKFwiQXBwTWV0YWRhdGEuc2NyZWVuc2hvdHMgc2hvdWxkIGNvbnRhaW4gYW4gQXJyYXkgb2Ygb2JqZWN0c1wiKTtcbn1cblxuY29uc3QgYnJvYWRjYXN0Q2xvc2VXaW5kb3cgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgYXdhaXQgYXBwQ29udHJvbENoYW5uZWwuYnJvYWRjYXN0KHsgdHlwZTogXCJjbG9zZVdpbmRvd1wiIH0pO1xufTtcblxuY29uc3QgaXNBcnJheU9mT2JqZWN0cyA9IChhcnJheSk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIGFycmF5Lmxlbmd0aCA+IDAgJiZcbiAgICBhcnJheS5zY3JlZW5zaG90cy5ldmVyeSgodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gICAgfSlcbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18yXzAvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcImZkYzNfMl8wXCI7XG5pbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNsZWVwLCB3cmFwUHJvbWlzZSB9IGZyb20gXCIuLi8uLi8uLi91dGlsc1wiO1xuaW1wb3J0IHsgSW1wbGVtZW50YXRpb25NZXRhZGF0YSB9IGZyb20gXCJmZGMzXzJfMFwiO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVDaGFubmVsIH0gZnJvbSBcImZkYzNfMl8wXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUFwcE1ldGFkYXRhIH0gZnJvbSBcIi4vZmRjMy5nZXRBcHBNZXRhZGF0YVwiO1xuaW1wb3J0IHtcbiAgTWV0YWRhdGFBcHBDb21tYW5kQ29udGV4dCxcbiAgTWV0YWRhdGFDb250ZXh0LFxuICBNZXRhZGF0YUFwcENvbW1hbmQsXG59IGZyb20gXCIuL2ZkYzMuZmluZEluc3RhbmNlc1wiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5jb25zdCBnZXRJbmZvRG9jcyA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmdldEluZm8yXzAgKyBcIlxcclxcbkNhdXNlXCI7XG5jb25zdCBnZXRNZXRhZGF0YURvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5hcHBNZXRhZGF0YSArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldEluZm9cIiwgKCkgPT4ge1xuICAgIGFmdGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGJyb2FkY2FzdENsb3NlV2luZG93KCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTW9ja0FwcFRvQ2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGl0KFwiTWV0aG9kIGlzIGNhbGxhYmxlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZkYzMuZ2V0SW5mbygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoXG4gICAgICAgICAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArXG4gICAgICAgICAgICBBUElEb2N1bWVudGF0aW9uLmdldEluZm8gK1xuICAgICAgICAgICAgXCJcXHJcXG5DYXVzZVwiICtcbiAgICAgICAgICAgIChleC5tZXNzYWdlID8/IGV4KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCIoMi4wLUdldEluZm8xKSBSZXR1cm5zIGEgdmFsaWQgSW1wbGVtZW50YXRpb25NZXRhZGF0YSBvYmplY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW1wbE1ldGFkYXRhID0gYXdhaXQgZmRjMy5nZXRJbmZvKCk7XG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBpbXBsTWV0YWRhdGEsXG4gICAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEgZGlkIG5vdCBoYXZlIHByb3BlcnR5IGZkYzNWZXJzaW9uJHtnZXRJbmZvRG9jc31gXG4gICAgICAgICkudG8uaGF2ZS5wcm9wZXJ0eShcImZkYzNWZXJzaW9uXCIpO1xuICAgICAgICBleHBlY3QocGFyc2VGbG9hdChpbXBsTWV0YWRhdGEuZmRjM1ZlcnNpb24pKS50by5iZS5ncmVhdGVyVGhhbk9yRXF1YWwoXG4gICAgICAgICAgMlxuICAgICAgICApO1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgaW1wbE1ldGFkYXRhLFxuICAgICAgICAgIGBJbXBsZW1lbnRhdGlvbk1ldGFkYXRhIGRpZCBub3QgaGF2ZSBwcm9wZXJ0eSBwcm92aWRlciR7Z2V0SW5mb0RvY3N9YFxuICAgICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJwcm92aWRlclwiKTtcbiAgICAgICAgZXhwZWN0KGltcGxNZXRhZGF0YS5wcm92aWRlcikudG8ubm90LmJlLmVxdWFsKFwiXCIpO1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgaW1wbE1ldGFkYXRhLm9wdGlvbmFsRmVhdHVyZXMsXG4gICAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEub3B0aW9uYWxGZWF0dXJlcyBkaWQgbm90IGhhdmUgcHJvcGVydHkgT3JpZ2luYXRpbmdBcHBNZXRhZGF0YSR7Z2V0SW5mb0RvY3N9YFxuICAgICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJPcmlnaW5hdGluZ0FwcE1ldGFkYXRhXCIpO1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgaW1wbE1ldGFkYXRhLm9wdGlvbmFsRmVhdHVyZXMsXG4gICAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEub3B0aW9uYWxGZWF0dXJlcyBkaWQgbm90IGhhdmUgcHJvcGVydHkgVXNlckNoYW5uZWxNZW1iZXJzaGlwQVBJcyR7Z2V0SW5mb0RvY3N9YFxuICAgICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJVc2VyQ2hhbm5lbE1lbWJlcnNoaXBBUElzXCIpO1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgdHlwZW9mIGltcGxNZXRhZGF0YS5vcHRpb25hbEZlYXR1cmVzLk9yaWdpbmF0aW5nQXBwTWV0YWRhdGEsXG4gICAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEub3B0aW9uYWxGZWF0dXJlcy5PcmlnaW5hdGluZ0FwcE1ldGFkYXRhIHNob3VsZCBiZSBvZiB0eXBlIGJvb2xlYW5gXG4gICAgICAgICkudG8uYmUuZXF1YWwoXCJib29sZWFuXCIpO1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgdHlwZW9mIGltcGxNZXRhZGF0YS5vcHRpb25hbEZlYXR1cmVzLlVzZXJDaGFubmVsTWVtYmVyc2hpcEFQSXMsXG4gICAgICAgICAgXCJJbXBsZW1lbnRhdGlvbk1ldGFkYXRhLm9wdGlvbmFsRmVhdHVyZXMuVXNlckNoYW5uZWxNZW1iZXJzaGlwQVBJcyBzaG91bGQgYmUgb2YgdHlwZSBib29sZWFuXCJcbiAgICAgICAgKS50by5iZS5lcXVhbChcImJvb2xlYW5cIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBhc3NlcnQuZmFpbChnZXRJbmZvRG9jcyArIChleC5tZXNzYWdlID8/IGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdChcIigyLjAtR2V0SW5mbzIpIFJldHVybnMgYSB2YWxpZCBJbXBsZW1lbnRhdGlvbk1ldGFkYXRhIG9iamVjdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcInN0YXJ0c3RhcnRcIik7XG4gICAgICBsZXQgaW1wbE1ldGFkYXRhOiBJbXBsZW1lbnRhdGlvbk1ldGFkYXRhO1xuICAgICAgY29uc3QgYXBwQ29udHJvbENoYW5uZWwgPSBhd2FpdCBnZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcblxuICAgICAgLy9zZXQgY29tbWFuZCBmb3IgbWV0YWRhdGEgYXBwXG4gICAgICBjb25zdCBtZXRhZGF0YUFwcENvbnRleHQ6IE1ldGFkYXRhQXBwQ29tbWFuZENvbnRleHQgPSB7XG4gICAgICAgIHR5cGU6IFwibWV0YWRhdGFBcHBDb250ZXh0XCIsXG4gICAgICAgIGNvbW1hbmQ6IE1ldGFkYXRhQXBwQ29tbWFuZC5zZW5kR2V0SW5mb01ldGFkYXRhVG9UZXN0cyxcbiAgICAgIH07XG5cbiAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHdyYXBQcm9taXNlKCk7XG5cbiAgICAgIGFwcENvbnRyb2xDaGFubmVsLmFkZENvbnRleHRMaXN0ZW5lcihcbiAgICAgICAgXCJtZXRhZGF0YUNvbnRleHRcIixcbiAgICAgICAgYXN5bmMgKGNvbnRleHQ6IE1ldGFkYXRhQ29udGV4dCkgPT4ge1xuICAgICAgICAgIGltcGxNZXRhZGF0YSA9IGNvbnRleHQuaW1wbE1ldGFkYXRhO1xuICAgICAgICAgIHdyYXBwZXIucmVzb2x2ZSgpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYXBwSWRlbnRpZmllciA9IGF3YWl0IGZkYzMub3BlbihcbiAgICAgICAgeyBhcHBJZDogXCJNZXRhZGF0YUFwcElkXCIgfSxcbiAgICAgICAgbWV0YWRhdGFBcHBDb250ZXh0XG4gICAgICApO1xuXG4gICAgICAvL2ZhaWwgaWYgbm8gbWV0YWRhdGFDb250ZXh0IHJlY2VpdmVkXG4gICAgICB0aW1lb3V0ID0gYXdhaXQgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLnJlamVjdChcImRpZCBub3QgcmVjZWl2ZSBNZXRhZGF0YUNvbnRleHQgZnJvbSBtZXRhZGF0YSBhcHBcIik7XG4gICAgICB9LCBjb25zdGFudHMuV2FpdFRpbWUpO1xuXG4gICAgICAvL3dhaXQgZm9yIGxpc3RlbmVyIHRvIHJlY2VpdmUgY29udGV4dFxuICAgICAgYXdhaXQgd3JhcHBlci5wcm9taXNlO1xuXG4gICAgICAvL3ZhbGlkYXRlIEFwcElkZW50aWZpZXJcbiAgICAgIGV4cGVjdChcbiAgICAgICAgYXBwSWRlbnRpZmllcixcbiAgICAgICAgYEFwcElkZW50aWZpZXIgZGlkIG5vdCBoYXZlIHByb3BlcnR5IGFwcElkJHtnZXRJbmZvRG9jc31gXG4gICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJhcHBJZFwiKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgYXBwSWRlbnRpZmllcixcbiAgICAgICAgYEFwcElkZW50aWZpZXIgZGlkIG5vdCBoYXZlIHByb3BlcnR5IGluc3RhbmNlSWQke2dldEluZm9Eb2NzfWBcbiAgICAgICkudG8uaGF2ZS5wcm9wZXJ0eShcImluc3RhbmNlSWRcIik7XG5cbiAgICAgIC8vdmFsaWRhdGUgSW1wbGVtZW50YXRpb25NZXRhZGF0YVxuICAgICAgZXhwZWN0KFxuICAgICAgICBpbXBsTWV0YWRhdGEsXG4gICAgICAgIGBJbXBsZW1lbnRhdGlvbk1ldGFkYXRhIGRpZCBub3QgaGF2ZSBwcm9wZXJ0eSBhcHBNZXRhZGF0YSR7Z2V0SW5mb0RvY3N9YFxuICAgICAgKS50by5oYXZlLnByb3BlcnR5KFwiYXBwTWV0YWRhdGFcIik7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGltcGxNZXRhZGF0YS5hcHBNZXRhZGF0YSxcbiAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEgZGlkIG5vdCBoYXZlIHByb3BlcnR5IGFwcElkJHtnZXRJbmZvRG9jc31gXG4gICAgICApLnRvLmhhdmUucHJvcGVydHkoXCJhcHBJZFwiKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgaW1wbE1ldGFkYXRhLmFwcE1ldGFkYXRhLFxuICAgICAgICBgSW1wbGVtZW50YXRpb25NZXRhZGF0YSBkaWQgbm90IGhhdmUgcHJvcGVydHkgaW5zdGFuY2VJZCR7Z2V0SW5mb0RvY3N9YFxuICAgICAgKS50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VJZFwiKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgaW1wbE1ldGFkYXRhLmFwcE1ldGFkYXRhLmFwcElkLFxuICAgICAgICBgSW1wbGVtZW50YXRpb25NZXRhZGF0YS5hcHBNZXRhZGF0YS5hcHBJZCBkaWQgbm90IG1hdGNoIHRoZSBBcHBsaWNhdGlvbklkZW50aWZpZXIuYXBwSWQgcmV0cmlldmVkIGZyb20gdGhlIG9wZW5lZCBhcHBgXG4gICAgICApLnRvLmJlLmVxdWFsKGFwcElkZW50aWZpZXIuYXBwSWQpO1xuICAgICAgZXhwZWN0KFxuICAgICAgICBpbXBsTWV0YWRhdGEuYXBwTWV0YWRhdGEuaW5zdGFuY2VJZCxcbiAgICAgICAgYEltcGxlbWVudGF0aW9uTWV0YWRhdGEuYXBwTWV0YWRhdGEuaW5zdGFuY2VJZCBkaWQgbm90IG1hdGNoIHRoZSBBcHBsaWNhdGlvbklkZW50aWZpZXIuaW5zdGFuY2VJZCByZXRyaWV2ZWQgZnJvbSB0aGUgb3BlbmVkIGFwcGBcbiAgICAgICkudG8uYmUuZXF1YWwoYXBwSWRlbnRpZmllci5pbnN0YW5jZUlkKTtcbiAgICAgIGNvbnNvbGUubG9nKFwidmFsaWRhdGluZ1wiKTtcblxuICAgICAgLy92YWxpZGF0ZSBBcHBNZXRhZGF0YVxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmZGMzLmdldEFwcE1ldGFkYXRhKGFwcElkZW50aWZpZXIpO1xuICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIHZhbGlkYXRlQXBwTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgY29uc29sZS5sb2coXCJ2ZWZvcmUgY2xlYXJ0aW1lb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd2FpdEZvck1vY2tBcHBUb0Nsb3NlKCkge1xuICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICBjb25zdCBtZXNzYWdlUmVjZWl2ZWQgPSBuZXcgUHJvbWlzZTxDb250ZXh0Pihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcENvbnRyb2xDaGFubmVsID0gYXdhaXQgZmRjMy5nZXRPckNyZWF0ZUNoYW5uZWwoXCJhcHAtY29udHJvbFwiKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBhd2FpdCBhcHBDb250cm9sQ2hhbm5lbC5hZGRDb250ZXh0TGlzdGVuZXIoXG4gICAgICAgICAgXCJ3aW5kb3dDbG9zZWRcIixcbiAgICAgICAgICAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vaWYgbm8gY29udGV4dCByZWNlaXZlZCByZWplY3QgcHJvbWlzZVxuICAgICAgICBjb25zdCB7IHByb21pc2U6IHNsZWVwUHJvbWlzZSwgdGltZW91dDogdGhlVGltZW91dCB9ID0gc2xlZXAoKTtcbiAgICAgICAgdGltZW91dCA9IHRoZVRpbWVvdXQ7XG4gICAgICAgIGF3YWl0IHNsZWVwUHJvbWlzZTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIndpbmRvd0Nsb3NlZCBjb250ZXh0IG5vdCByZWNlaXZlZCBmcm9tIGFwcCBCXCIpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWVzc2FnZVJlY2VpdmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGJyb2FkY2FzdENsb3NlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBwQ29udHJvbENoYW5uZWwgPSBhd2FpdCBmZGMzLmdldE9yQ3JlYXRlQ2hhbm5lbChcImFwcC1jb250cm9sXCIpO1xuICAgICAgYXdhaXQgYXBwQ29udHJvbENoYW5uZWwuYnJvYWRjYXN0KHsgdHlwZTogXCJjbG9zZVdpbmRvd1wiIH0pO1xuICAgIH07XG4gIH0pO1xuIiwiaW1wb3J0IHsgTGlzdGVuZXIgfSBmcm9tIFwiZmRjM18yXzBcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzJfMC9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZG9jdW1lbnRhdGlvbiA9XG4gIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgKyBBUElEb2N1bWVudGF0aW9uLmFkZENvbnRleHRMaXN0ZW5lciArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmFkZENvbnRleHRMaXN0ZW5lclwiLCAoKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lcjtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCIoMi4wLUJhc2ljQ0wxKSBNZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dFR5cGUgPSBcImZkYzMuY29udGFjdFwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZENvbnRleHRMaXN0ZW5lcihjb250ZXh0VHlwZSwgKGluZm86IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYENvbnRleHQgbGlzdGVuZXIgb2YgdHlwZSAke2NvbnRleHRUeXBlfSB0cmlnZ2VyZWQgd2l0aCByZXN1bHQgJHtpbmZvfWBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKGRvY3VtZW50YXRpb24gKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCIoMi4wLUJhc2ljQ0wyKSBSZXR1cm5zIGxpc3RlbmVyIG9iamVjdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lciA9IGF3YWl0IGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKG51bGwsICgpID0+IHt9KTtcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgPT09IFwib2JqZWN0XCIsIGRvY3VtZW50YXRpb24pO1xuICAgICAgICBleHBlY3QodHlwZW9mIGxpc3RlbmVyLnVuc3Vic2NyaWJlLCBkb2N1bWVudGF0aW9uKS50by5iZS5lcXVhbHMoXG4gICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBhc3NlcnQuZmFpbChkb2N1bWVudGF0aW9uICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgeyBMaXN0ZW5lciB9IGZyb20gXCJmZGMzXzJfMFwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMl8wL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5hZGRJbnRlbnRMaXN0ZW5lclwiLCAoKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lcjtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0ZW5lci51bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKDIuMC1CYXNpY0lMMSkgTWV0aG9kIGlzIGNhbGxhYmxlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludGVudE5hbWUgPSBcImZkYzMuY29uZm9ybWFuY2VMaXN0ZW5lclwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIgPSBhd2FpdCBmZGMzLmFkZEludGVudExpc3RlbmVyKGludGVudE5hbWUsIChpbmZvOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGBJbnRlbnQgbGlzdGVuZXIgZm9yIGludGVudCAke2ludGVudE5hbWV9IHRyaWdnZXJlZCB3aXRoIHJlc3VsdCAke2luZm99YFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QobGlzdGVuZXIpLnRvLmhhdmUucHJvcGVydHkoXCJ1bnN1YnNjcmliZVwiKS50aGF0LmlzLmEoXCJmdW5jdGlvblwiKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKFxuICAgICAgICAgIFwiXFxyXFxuRG9jdW1lbnRhdGlvbjogXCIgK1xuICAgICAgICAgICAgQVBJRG9jdW1lbnRhdGlvbi5hZGRJbnRlbnRMaXN0ZW5lciArXG4gICAgICAgICAgICBcIlxcclxcbkNhdXNlXCIgK1xuICAgICAgICAgICAgKGV4Lm1lc3NhZ2UgPz8gZXgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMl8wL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5jb25zdCBnZXRDdXJyZW50Q2hhbm5lbERvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5nZXRDdXJyZW50Q2hhbm5lbCArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldEN1cnJlbnRDaGFubmVsXCIsICgpID0+IHtcbiAgICBpdChcIigyLjAtQmFzaWNDSDEpIE1ldGhvZCBpcyBjYWxsYWJsZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZmRjMy5nZXRDdXJyZW50Q2hhbm5lbCgpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0Q3VycmVudENoYW5uZWxEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KFwiKDIuMC1CYXNpY0NIMikgZ2V0Q3VycmVudENoYW5uZWwoKSByZXR1cm5zIG51bGwgaWYgbm8gY2hhbm5lbCBoYXMgYmVlbiBqb2luZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0Q3VycmVudENoYW5uZWwoKTtcbiAgICAgICAgZXhwZWN0KGNoYW5uZWwpLmVxdWFscyhudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKGdldEN1cnJlbnRDaGFubmVsRG9jcyArIChleC5tZXNzYWdlID8/IGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMl8wL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5jb25zdCBnZXRPckNyZWF0ZUNoYW5uZWxEb2NzID1cbiAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArIEFQSURvY3VtZW50YXRpb24uZ2V0T3JDcmVhdGVDaGFubmVsICsgXCJcXHJcXG5DYXVzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCAoKSA9PlxuICBkZXNjcmliZShcImZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsXCIsICgpID0+IHtcbiAgICBpdChcIigyLjAtQmFzaWNBQzEpIFJldHVybnMgQ2hhbm5lbCBvYmplY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0T3JDcmVhdGVDaGFubmVsKFwiRkRDM0NvbmZvcm1hbmNlXCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcImlkXCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcInR5cGVcIik7XG4gICAgICAgIGV4cGVjdChjaGFubmVsLCBnZXRPckNyZWF0ZUNoYW5uZWxEb2NzKS50by5oYXZlLnByb3BlcnR5KFwiYnJvYWRjYXN0XCIpO1xuICAgICAgICBleHBlY3QoY2hhbm5lbCwgZ2V0T3JDcmVhdGVDaGFubmVsRG9jcykudG8uaGF2ZS5wcm9wZXJ0eShcbiAgICAgICAgICBcImdldEN1cnJlbnRDb250ZXh0XCJcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNoYW5uZWwsIGdldE9yQ3JlYXRlQ2hhbm5lbERvY3MpLnRvLmhhdmUucHJvcGVydHkoXG4gICAgICAgICAgXCJhZGRDb250ZXh0TGlzdGVuZXJcIlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgYXNzZXJ0LmZhaWwoZ2V0T3JDcmVhdGVDaGFubmVsRG9jcyArIChleC5tZXNzYWdlID8/IGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcImNoYWlcIjtcbmltcG9ydCBBUElEb2N1bWVudGF0aW9uIGZyb20gXCIuLi8uLi8uLi9hcGlEb2N1bWVudHNcIjtcbmltcG9ydCB7IERlc2t0b3BBZ2VudCB9IGZyb20gXCJmZGMzXzJfMC9kaXN0L2FwaS9EZXNrdG9wQWdlbnRcIjtcblxuZGVjbGFyZSBsZXQgZmRjMzogRGVza3RvcEFnZW50O1xuY29uc3QgZ2V0U3lzdGVtQ2hhbm5lbERvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICsgQVBJRG9jdW1lbnRhdGlvbi5nZXRTeXN0ZW1DaGFubmVscyArIFwiXFxyXFxuQ2F1c2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLmdldFVzZXJDaGFubmVsc1wiLCAoKSA9PiB7XG4gICAgaXQoXCIoMi4wLUJhc2ljVUMxKSBNZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmRjMy5nZXRVc2VyQ2hhbm5lbHMoKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGFzc2VydC5mYWlsKGdldFN5c3RlbUNoYW5uZWxEb2NzICsgKGV4Lm1lc3NhZ2UgPz8gZXgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18yXzAvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcblxuZnVuY3Rpb24gd3JhcFByb21pc2UoKToge1xuICBwcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICByZXNvbHZlOiAoKSA9PiB2b2lkO1xuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG59IHtcbiAgbGV0IHdyYXBwZXJSZXNvbHZlO1xuICBsZXQgd3JhcHBlclJlamVjdDtcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyYXBwZXJSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cmFwcGVyUmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiB3cmFwcGVyUmVzb2x2ZSwgcmVqZWN0OiB3cmFwcGVyUmVqZWN0IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5qb2luQ2hhbm5lbFwiLCAoKSA9PiB7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZkYzMubGVhdmVDdXJyZW50Q2hhbm5lbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCIoMi4wLUJhc2ljSkMxKSBDYW4gam9pbiBjaGFubmVsIGFuZCBicm9hZGNhc3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHdyYXBQcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXdhaXQgZmRjMy5nZXRVc2VyQ2hhbm5lbHMoKTtcblxuICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmZGMzLmpvaW5Vc2VyQ2hhbm5lbChjaGFubmVsc1swXS5pZCk7XG5cbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhbm5lbCA9IGF3YWl0IGZkYzMuZ2V0Q3VycmVudENoYW5uZWwoKTtcblxuICAgICAgICAgIGV4cGVjdChjdXJyZW50Q2hhbm5lbCkudG8ubm90LmJlLm51bGw7XG5cbiAgICAgICAgICBjb25zdCBnb3RDb250ZXh0ID0gKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVjZWl2ZWRcIiArIGMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZkYzMuYWRkQ29udGV4dExpc3RlbmVyKFwic29tZUNvbnRleHRcIiwgKGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN0eC50eXBlID09IFwic29tZUNvbnRleHRcIikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc29sdmVkXCIpO1xuICAgICAgICAgICAgICB3cmFwcGVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIucmVqZWN0KFwid3JvbmcgY29udGV4dCB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY3VycmVudENoYW5uZWwuYnJvYWRjYXN0KHtcbiAgICAgICAgICAgIHR5cGU6IFwic29tZUNvbnRleHRcIixcbiAgICAgICAgICAgIGlkOiB7IG5hbWU6IFwiaGVsbG9cIiB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgd3JhcHBlci5wcm9taXNlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiZG9uZVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBhc3NlcnQuZmFpbChcIkVycm9yIHdoaWxlIGpvaW5pbmcgY2hhbm5lbDogXCIgKyAoZXgubWVzc2FnZSA/PyBleCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQuZmFpbChcIk5vIHN5c3RlbSBjaGFubmVscyBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuIiwiaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tIFwiY2hhaVwiO1xuaW1wb3J0IEFQSURvY3VtZW50YXRpb24gZnJvbSBcIi4uLy4uLy4uL2FwaURvY3VtZW50c1wiO1xuaW1wb3J0IHsgRGVza3RvcEFnZW50IH0gZnJvbSBcImZkYzNfMl8wL2Rpc3QvYXBpL0Rlc2t0b3BBZ2VudFwiO1xuXG5kZWNsYXJlIGxldCBmZGMzOiBEZXNrdG9wQWdlbnQ7XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+XG4gIGRlc2NyaWJlKFwiZmRjMy5sZWF2ZUN1cnJlbnRDaGFubmVsXCIsICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaXQoXCIoMi4wLUJhc2ljTEMxKSBNZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBmZGMzLmxlYXZlQ3VycmVudENoYW5uZWwoKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBhc3NlcnQuZmFpbChcbiAgICAgICAgXCJcXHJcXG5Eb2N1bWVudGF0aW9uOiBcIiArXG4gICAgICAgICAgQVBJRG9jdW1lbnRhdGlvbi5sZWF2ZUN1cnJlbnRDaGFubmVsICtcbiAgICAgICAgICBcIlxcclxcbkNhdXNlXCIgK1xuICAgICAgICAgIChleC5tZXNzYWdlID8/IGV4KVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuIiwiaW1wb3J0IHsgUmVzb2x2ZUVycm9yIH0gZnJvbSBcImZkYzNfMl8wXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJjaGFpXCI7XG5pbXBvcnQgQVBJRG9jdW1lbnRhdGlvbiBmcm9tIFwiLi4vLi4vLi4vYXBpRG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBEZXNrdG9wQWdlbnQgfSBmcm9tIFwiZmRjM18yXzAvZGlzdC9hcGkvRGVza3RvcEFnZW50XCI7XG5cbmRlY2xhcmUgbGV0IGZkYzM6IERlc2t0b3BBZ2VudDtcbmNvbnN0IGRvY3MgPVxuICBcIlxcclxcbkRvY3VtZW50YXRpb246IFwiICtcbiAgQVBJRG9jdW1lbnRhdGlvbi5yYWlzZUludGVudEZvckNvbnRleHQgK1xuICBcIlxcclxcbkNhdXNlOiBcIjtcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT5cbiAgZGVzY3JpYmUoXCJmZGMzLnJhaXNlSW50ZW50Rm9yQ29udGV4dFwiLCBhc3luYyAoKSA9PiB7XG4gICAgaXQoXCIoMi4wLUJhc2ljUkkxKSBNZXRob2QgaXMgY2FsbGFibGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgdHlwZTogXCJUaGlzQ29udGV4dERvZXNOb3RFeGlzdFwiLFxuICAgICAgICBuYW1lOiBcIk5hbWVcIixcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICB0aWNrZXI6IFwidGlja2VyXCIsXG4gICAgICAgICAgSVNJTjogXCJVUzAzNzgzMzEwMDVcIixcbiAgICAgICAgICBDVVNJUDogXCIwMzc4MzMxMDBcIixcbiAgICAgICAgICBGSUdJOiBcIkJCRzAwMEI5WFJZNFwiLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmRjMy5yYWlzZUludGVudEZvckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIGFzc2VydC5mYWlsKFwiRXhwZWN0ZWQgZXJyb3IgTm9BcHBzRm91bmQgbm90IHRocm93blwiLCBkb2NzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4cGVjdChleCkudG8uaGF2ZS5wcm9wZXJ0eShcIm1lc3NhZ2VcIiwgUmVzb2x2ZUVycm9yLk5vQXBwc0ZvdW5kLCBkb2NzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4iLCJpbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAodGltZW91dE1zOiBudW1iZXIgPSBjb25zdGFudHMuV2FpdFRpbWUpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGltZW91dE1zKTtcbiAgfSk7XG4gIHJldHVybiB7IHByb21pc2UsIHRpbWVvdXQgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXQodGltZW91dE1zPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgcHJvbWlzZSwgdGltZW91dCB9ID0gc2xlZXAodGltZW91dE1zKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUHJvbWlzZSgpOiB7XG4gIHByb21pc2U6IFByb21pc2U8dm9pZD47XG4gIHJlc29sdmU6ICgpID0+IHZvaWQ7XG4gIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn0ge1xuICBsZXQgd3JhcHBlclJlc29sdmU7XG4gIGxldCB3cmFwcGVyUmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyYXBwZXJSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cmFwcGVyUmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogd3JhcHBlclJlc29sdmUsIHJlamVjdDogd3JhcHBlclJlamVjdCB9O1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnR5cGVEZXRlY3QgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgcHJvbWlzZUV4aXN0cyA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyA/IHNlbGYgOiBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaWQtYmxhY2tsaXN0XG5cbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlID0gc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgdG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGggPSA4O1xudmFyIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCA9IC0xO1xuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGFuIG9iamVjdCxcbiAqIG5vcm1hbGlzaW5nIGJlaGF2aW91ciBhY3Jvc3MgZW5naW5lIHZlcnNpb25zICYgd2VsbCBvcHRpbWlzZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB0eXBlRGV0ZWN0KG9iaikge1xuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMywwMzksMDM1IG9wcy9zZWMgwrExLjYyJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDEsNDI0LDEzOCBvcHMvc2VjIMKxNC41NCUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAxLDY1MywxNTMgb3BzL3NlYyDCsTEuOTElICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggOSw5NzgsNjYwIG9wcy9zZWMgwrExLjkyJSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDIsNTU2LDc2OSBvcHMvc2VjIMKxMS43MyUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzOCw1NjQsNzk2IG9wcy9zZWMgwrExLjE1JSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDMxLDE0OCw5NDAgb3BzL3NlYyDCsTEuMTAlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMzIsNjc5LDMzMCBvcHMvc2VjIMKxMS45MCUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCAzMiwzNjMsMzY4IG9wcy9zZWMgwrExLjA3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDMxLDI5Niw4NzAgb3BzL3NlYyDCsTAuOTYlICg4MyBydW5zIHNhbXBsZWQpXG4gICAqL1xuICB2YXIgdHlwZW9mT2JqID0gdHlwZW9mIG9iajtcbiAgaWYgKHR5cGVvZk9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZW9mT2JqO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDI4LDY0NSw3NjUgb3BzL3NlYyDCsTEuMTclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMzYsNDI4LDk2MiBvcHMvc2VjIMKxMS4zNyUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KWBgXG4gICAqICAtIE5vZGUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gUGhhbnRvbUpTID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSBFZGdlID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcylgYFxuICAgKiAgLSBDaHJvbWUgV29ya2VyID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gU2FmYXJpIFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIDExIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIEVkZ2UgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICovXG4gIGlmIChvYmogPT09IGdsb2JhbE9iamVjdCkge1xuICAgIHJldHVybiAnZ2xvYmFsJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyLDg4OCwzNTIgb3BzL3NlYyDCsTAuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMjIsNDc5LDY1MCBvcHMvc2VjIMKxMC45NiUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChcbiAgICBBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPT09IGZhbHNlIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIG9iaikpXG4gICkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9XG5cbiAgLy8gTm90IGNhY2hpbmcgZXhpc3RlbmNlIG9mIGB3aW5kb3dgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMgZHVlIHRvIHBvdGVudGlhbFxuICAvLyBmb3IgYHdpbmRvd2AgdG8gYmUgdW5zZXQgYmVmb3JlIHRlc3RzIGluIHF1YXNpLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjbG9jYXRpb24pXG4gICAgICogV2hhdFdHIEhUTUwkNy43LjMgLSBUaGUgYExvY2F0aW9uYCBpbnRlcmZhY2VcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5sb2NhdGlvbilgYFxuICAgICAqICAtIElFIDw9MTEgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5sb2NhdGlvbiA9PT0gJ29iamVjdCcgJiYgb2JqID09PSB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiAnTG9jYXRpb24nO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkb2N1bWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQzLjEuMSAtIFRoZSBgRG9jdW1lbnRgIG9iamVjdFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtMjY4MDkyNjgpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqICAgICAgIFdoYXRXRyBIVE1MIHN0YXRlczpcbiAgICAgKiAgICAgICAgID4gRm9yIGhpc3RvcmljYWwgcmVhc29ucywgV2luZG93IG9iamVjdHMgbXVzdCBhbHNvIGhhdmUgYVxuICAgICAqICAgICAgICAgPiB3cml0YWJsZSwgY29uZmlndXJhYmxlLCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lZFxuICAgICAqICAgICAgICAgPiBIVE1MRG9jdW1lbnQgd2hvc2UgdmFsdWUgaXMgdGhlIERvY3VtZW50IGludGVyZmFjZSBvYmplY3QuXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudClgYFxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiBvYmogPT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuICdEb2N1bWVudCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI21pbWV0eXBlYXJyYXkpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5taW1lVHlwZXMpYGBcbiAgICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU01pbWVUeXBlc0NvbGxlY3Rpb25dXCJcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLm1pbWVUeXBlcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBvYmogPT09IHdpbmRvdy5uYXZpZ2F0b3IubWltZVR5cGVzKSB7XG4gICAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgICAqIFdoYXRXRyBIVE1MJDguNi4xLjUgLSBQbHVnaW5zIC0gSW50ZXJmYWNlIFBsdWdpbkFycmF5XG4gICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5wbHVnaW5zKWBgXG4gICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAgICovXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBvYmogPT09IHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucykge1xuICAgICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkge1xuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKSlgYFxuICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgSFRNTEJsb2NrRWxlbWVudF1cIlxuICAgICAgKi9cbiAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTFF1b3RlRWxlbWVudCc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWRhdGFjZWxsZWxlbWVudClcbiAgICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSlcbiAgICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKi9cbiAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWhlYWRlcmNlbGxlbGVtZW50KVxuICAgICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJykpXG4gICAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdUSCcpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA2MjUsNjQ0IG9wcy9zZWMgwrExLjU4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggMSwyNzksODUyIG9wcy9zZWMgwrEyLjkxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggMSwxNzgsMTg1IG9wcy9zZWMgwrExLjk1JSAoODMgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggMSwwMDgsMzgwIG9wcy9zZWMgwrEyLjI1JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggMSwxMjgsMDQwIG9wcy9zZWMgwrEyLjExJSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggMSwxNzAsMTE5IG9wcy9zZWMgwrEyLjg4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggMSwxNzYsMzQ4IG9wcy9zZWMgwrE1Ljc5JSAoODYgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggMSwwNTgsNzA3IG9wcy9zZWMgwrE0Ljk0JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggMSwxMTAsNjMzIG9wcy9zZWMgwrE0LjIwJSAoODAgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA3LDEwNSw2NzEgb3BzL3NlYyDCsTEzLjQ3JSAoNjQgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggNSw4ODcsOTEyIG9wcy9zZWMgwrExLjQ2JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggNiw0OTEsNjYxIG9wcy9zZWMgwrExLjc2JSAoNzkgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggNiw1NTksNzk1IG9wcy9zZWMgwrExLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggNiw0NjMsOTY2IG9wcy9zZWMgwrExLjQzJSAoODUgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggNSw2NDEsODQxIG9wcy9zZWMgwrEzLjQ5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggNiw1ODMsNTExIG9wcy9zZWMgwrExLjk4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggNiw2MDYsMDc4IG9wcy9zZWMgwrExLjc0JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggNiw2MDIsMjI0IG9wcy9zZWMgwrExLjc3JSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICB2YXIgc3RyaW5nVGFnID0gKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUYWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgfVxuXG4gIHZhciBvYmpQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICByZWdleCBsaXRlcmFsICAgICAgeCAxLDc3MiwzODUgb3BzL3NlYyDCsTEuODUlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAyLDE0Myw2MzQgb3BzL3NlYyDCsTIuNDYlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDMsOTI4LDAwOSBvcHMvc2VjIMKxMC42NSUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDMsOTMxLDEwOCBvcHMvc2VjIMKxMC41OCUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gUmVnRXhwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnUmVnRXhwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAzLDk1Myw3Nzkgb3BzL3NlYyDCsTEuMzUlICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IERhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdEYXRlJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1wcm9taXNlLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUHJvbWlzZS5yZXNvbHZlKCkpYGBcbiAgICogIC0gQ2hyb21lIDw9NDcgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqICAtIEZpcmVmb3ggMjktTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgKiAgLSBTYWZhcmkgNy4xLUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICovXG4gIGlmIChwcm9taXNlRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gUHJvbWlzZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDQsNTQ1LDg3OSBvcHMvc2VjIMKxMS4xMyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFNldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgbWFwICAgICAgICAgICAgICAgIHggNCwxODMsOTQ1IG9wcy9zZWMgwrE2LjU5JSAoODIgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnTWFwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCA0LDIzNyw1MTAgb3BzL3NlYyDCsTIuMDElICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmICh3ZWFrU2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha1NldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1dlYWtTZXQnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDMsODgxLDM4NCBvcHMvc2VjIMKxMS40NSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtNYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha01hcCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtZGF0YXZpZXcucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChkYXRhVmlld0V4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0YVZpZXcnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVtYXBpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKS5lbnRyaWVzKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ01hcCBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXNldGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFNldCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzZXRJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXVtTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0FycmF5IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBvYmplY3QgZnJvbSBudWxsICAgeCA1LDgzOCwwMDAgb3BzL3NlYyDCsTAuOTklICg4NCBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0XG4gICAgLnByb3RvdHlwZVxuICAgIC50b1N0cmluZ1xuICAgIC5jYWxsKG9iailcbiAgICAuc2xpY2UodG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgsIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCk7XG59XG5cbnJldHVybiB0eXBlRGV0ZWN0O1xuXG59KSkpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBvZmYgKi9cbi8qIGVzbGludC1lbnYgY29tbW9uanMgKi9cblxuLyoqXG4gKiBTaGltIHByb2Nlc3Muc3Rkb3V0LlxuICovXG5cbnByb2Nlc3Muc3Rkb3V0ID0gcmVxdWlyZSgnYnJvd3Nlci1zdGRvdXQnKSh7bGFiZWw6IGZhbHNlfSk7XG5cbnZhciBwYXJzZVF1ZXJ5ID0gcmVxdWlyZSgnLi9saWIvYnJvd3Nlci9wYXJzZS1xdWVyeScpO1xudmFyIGhpZ2hsaWdodFRhZ3MgPSByZXF1aXJlKCcuL2xpYi9icm93c2VyL2hpZ2hsaWdodC10YWdzJyk7XG52YXIgTW9jaGEgPSByZXF1aXJlKCcuL2xpYi9tb2NoYScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIE1vY2hhIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuXG52YXIgbW9jaGEgPSBuZXcgTW9jaGEoe3JlcG9ydGVyOiAnaHRtbCd9KTtcblxuLyoqXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxuICovXG5cbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xuXG52YXIgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycyA9IFtdO1xuXG52YXIgb3JpZ2luYWxPbmVycm9ySGFuZGxlciA9IGdsb2JhbC5vbmVycm9yO1xuXG4vKipcbiAqIFJlbW92ZSB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cbiAqIFJldmVydCB0byBvcmlnaW5hbCBvbmVycm9yIGhhbmRsZXIgaWYgcHJldmlvdXNseSBkZWZpbmVkLlxuICovXG5cbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSwgZm4pIHtcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICBpZiAob3JpZ2luYWxPbmVycm9ySGFuZGxlcikge1xuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgICB2YXIgaSA9IHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuaW5kZXhPZihmbik7XG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBsaXN0ZW5lckNvdW50IGZvciAndW5jYXVnaHRFeGNlcHRpb24nLlxuICovXG5cbnByb2Nlc3MubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmIChuYW1lID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XG4gICAgcmV0dXJuIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxuICovXG5cbnByb2Nlc3Mub24gPSBmdW5jdGlvbiAoZSwgZm4pIHtcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uIChlcnIsIHVybCwgbGluZSkge1xuICAgICAgZm4obmV3IEVycm9yKGVyciArICcgKCcgKyB1cmwgKyAnOicgKyBsaW5lICsgJyknKSk7XG4gICAgICByZXR1cm4gIW1vY2hhLm9wdGlvbnMuYWxsb3dVbmNhdWdodDtcbiAgICB9O1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMucHVzaChmbik7XG4gIH1cbn07XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICByZXR1cm4gdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycztcbiAgfVxuICByZXR1cm4gW107XG59O1xuXG4vLyBUaGUgQkREIFVJIGlzIHJlZ2lzdGVyZWQgYnkgZGVmYXVsdCwgYnV0IG5vIFVJIHdpbGwgYmUgZnVuY3Rpb25hbCBpbiB0aGVcbi8vIGJyb3dzZXIgd2l0aG91dCBhbiBleHBsaWNpdCBjYWxsIHRvIHRoZSBvdmVycmlkZGVuIGBtb2NoYS51aWAgKHNlZSBiZWxvdykuXG4vLyBFbnN1cmUgdGhhdCB0aGlzIGRlZmF1bHQgVUkgZG9lcyBub3QgZXhwb3NlIGl0cyBtZXRob2RzIHRvIHRoZSBnbG9iYWwgc2NvcGUuXG5tb2NoYS5zdWl0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ByZS1yZXF1aXJlJyk7XG5cbnZhciBpbW1lZGlhdGVRdWV1ZSA9IFtdO1xudmFyIGltbWVkaWF0ZVRpbWVvdXQ7XG5cbmZ1bmN0aW9uIHRpbWVzbGljZSgpIHtcbiAgdmFyIGltbWVkaWF0ZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBpbW1lZGlhdGVTdGFydCA8IDEwMCkge1xuICAgIGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCkoKTtcbiAgfVxuICBpZiAoaW1tZWRpYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEhpZ2gtcGVyZm9ybWFuY2Ugb3ZlcnJpZGUgb2YgUnVubmVyLmltbWVkaWF0ZWx5LlxuICovXG5cbk1vY2hhLlJ1bm5lci5pbW1lZGlhdGVseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgaWYgKCFpbW1lZGlhdGVUaW1lb3V0KSB7XG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBhbGxvdyBhc3NlcnRpb24gbGlicmFyaWVzIHRvIHRocm93IGVycm9ycyBkaXJlY3RseSBpbnRvIG1vY2hhLlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiBydW5uaW5nIHRlc3RzIGluIGEgYnJvd3NlciBiZWNhdXNlIHdpbmRvdy5vbmVycm9yIHdpbGxcbiAqIG9ubHkgcmVjZWl2ZSB0aGUgJ21lc3NhZ2UnIGF0dHJpYnV0ZSBvZiB0aGUgRXJyb3IuXG4gKi9cbm1vY2hhLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICBmbihlcnIpO1xuICB9KTtcbiAgdGhyb3cgZXJyO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSB1aSB0byBlbnN1cmUgdGhhdCB0aGUgdWkgZnVuY3Rpb25zIGFyZSBpbml0aWFsaXplZC5cbiAqIE5vcm1hbGx5IHRoaXMgd291bGQgaGFwcGVuIGluIE1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMuXG4gKi9cblxubW9jaGEudWkgPSBmdW5jdGlvbiAodWkpIHtcbiAgTW9jaGEucHJvdG90eXBlLnVpLmNhbGwodGhpcywgdWkpO1xuICB0aGlzLnN1aXRlLmVtaXQoJ3ByZS1yZXF1aXJlJywgZ2xvYmFsLCBudWxsLCB0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHVwIG1vY2hhIHdpdGggdGhlIGdpdmVuIHNldHRpbmcgb3B0aW9ucy5cbiAqL1xuXG5tb2NoYS5zZXR1cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzID0ge3VpOiBvcHRzfTtcbiAgfVxuICBpZiAob3B0cy5kZWxheSA9PT0gdHJ1ZSkge1xuICAgIHRoaXMuZGVsYXkoKTtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIE9iamVjdC5rZXlzKG9wdHMpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAob3B0KSB7XG4gICAgICByZXR1cm4gb3B0ICE9PSAnZGVsYXknO1xuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCBvcHQpKSB7XG4gICAgICAgIHNlbGZbb3B0XShvcHRzW29wdF0pO1xuICAgICAgfVxuICAgIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIG1vY2hhLCByZXR1cm5pbmcgdGhlIFJ1bm5lci5cbiAqL1xuXG5tb2NoYS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIG9wdGlvbnMgPSBtb2NoYS5vcHRpb25zO1xuICBtb2NoYS5nbG9iYWxzKCdsb2NhdGlvbicpO1xuXG4gIHZhciBxdWVyeSA9IHBhcnNlUXVlcnkoZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCB8fCAnJyk7XG4gIGlmIChxdWVyeS5ncmVwKSB7XG4gICAgbW9jaGEuZ3JlcChxdWVyeS5ncmVwKTtcbiAgfVxuICBpZiAocXVlcnkuZmdyZXApIHtcbiAgICBtb2NoYS5mZ3JlcChxdWVyeS5mZ3JlcCk7XG4gIH1cbiAgaWYgKHF1ZXJ5LmludmVydCkge1xuICAgIG1vY2hhLmludmVydCgpO1xuICB9XG5cbiAgcmV0dXJuIE1vY2hhLnByb3RvdHlwZS5ydW4uY2FsbChtb2NoYSwgZnVuY3Rpb24gKGVycikge1xuICAgIC8vIFRoZSBET00gRG9jdW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiBXZWIgV29ya2Vycy5cbiAgICB2YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgaWYgKFxuICAgICAgZG9jdW1lbnQgJiZcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpICYmXG4gICAgICBvcHRpb25zLm5vSGlnaGxpZ2h0aW5nICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICBoaWdobGlnaHRUYWdzKCdjb2RlJyk7XG4gICAgfVxuICAgIGlmIChmbikge1xuICAgICAgZm4oZXJyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIHByb2Nlc3Mgc2hpbS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2NoYWpzL21vY2hhL3B1bGwvOTE2XG4gKi9cblxuTW9jaGEucHJvY2VzcyA9IHByb2Nlc3M7XG5cbi8qKlxuICogRXhwb3NlIG1vY2hhLlxuICovXG5nbG9iYWwuTW9jaGEgPSBNb2NoYTtcbmdsb2JhbC5tb2NoYSA9IG1vY2hhO1xuXG4vLyBmb3IgYnVuZGxlcnM6IGVuYWJsZSBgaW1wb3J0IHtkZXNjcmliZSwgaXR9IGZyb20gJ21vY2hhJ2Bcbi8vIGBiZGRgIGludGVyZmFjZSBvbmx5XG4vLyBwcmV0dGllci1pZ25vcmVcblsgXG4gICdkZXNjcmliZScsICdjb250ZXh0JywgJ2l0JywgJ3NwZWNpZnknLFxuICAneGRlc2NyaWJlJywgJ3hjb250ZXh0JywgJ3hpdCcsICd4c3BlY2lmeScsXG4gICdiZWZvcmUnLCAnYmVmb3JlRWFjaCcsICdhZnRlckVhY2gnLCAnYWZ0ZXInXG5dLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gIG1vY2hhW2tleV0gPSBnbG9iYWxba2V5XTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vY2hhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBqc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoaWdobGlnaHQoanMpIHtcbiAgcmV0dXJuIGpzXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXFwvXFwvKC4qKS9nbSwgJzxzcGFuIGNsYXNzPVwiY29tbWVudFwiPi8vJDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKCcuKj8nKS9nbSwgJzxzcGFuIGNsYXNzPVwic3RyaW5nXCI+JDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKFxcZCtcXC5cXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVwibnVtYmVyXCI+JDE8L3NwYW4+JylcbiAgICAucmVwbGFjZSgvKFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XCJudW1iZXJcIj4kMTwvc3Bhbj4nKVxuICAgIC5yZXBsYWNlKFxuICAgICAgL1xcYm5ld1sgXFx0XSsoXFx3KykvZ20sXG4gICAgICAnPHNwYW4gY2xhc3M9XCJrZXl3b3JkXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cImluaXRcIj4kMTwvc3Bhbj4nXG4gICAgKVxuICAgIC5yZXBsYWNlKFxuICAgICAgL1xcYihmdW5jdGlvbnxuZXd8dGhyb3d8cmV0dXJufHZhcnxpZnxlbHNlKVxcYi9nbSxcbiAgICAgICc8c3BhbiBjbGFzcz1cImtleXdvcmRcIj4kMTwvc3Bhbj4nXG4gICAgKTtcbn1cblxuLyoqXG4gKiBIaWdobGlnaHQgdGhlIGNvbnRlbnRzIG9mIHRhZyBgbmFtZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhuYW1lKSB7XG4gIHZhciBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29kZVtpXS5pbm5lckhUTUwgPSBoaWdobGlnaHQoY29kZVtpXS5pbm5lckhUTUwpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcXNcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VRdWVyeShxcykge1xuICByZXR1cm4gcXNcbiAgICAucmVwbGFjZSgnPycsICcnKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLnJlZHVjZShmdW5jdGlvbiAob2JqLCBwYWlyKSB7XG4gICAgICB2YXIgaSA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgICAgdmFyIGtleSA9IHBhaXIuc2xpY2UoMCwgaSk7XG4gICAgICB2YXIgdmFsID0gcGFpci5zbGljZSgrK2kpO1xuXG4gICAgICAvLyBEdWUgdG8gaG93IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJIHRyZWF0cyBzcGFjZXNcbiAgICAgIG9ialtrZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbC5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiBAbW9kdWxlIGJyb3dzZXIvUHJvZ3Jlc3NcbiovXG5cbi8qKlxuICogRXhwb3NlIGBQcm9ncmVzc2AuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgaW5kaWNhdG9yLlxuICovXG5mdW5jdGlvbiBQcm9ncmVzcygpIHtcbiAgdGhpcy5wZXJjZW50ID0gMDtcbiAgdGhpcy5zaXplKDApO1xuICB0aGlzLmZvbnRTaXplKDExKTtcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XG59XG5cbi8qKlxuICogU2V0IHByb2dyZXNzIHNpemUgdG8gYHNpemVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXG4gKi9cblByb2dyZXNzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGV4dCB0byBgdGV4dGAuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb250IHNpemUgdG8gYHNpemVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXG4gKi9cblByb2dyZXNzLnByb3RvdHlwZS5mb250U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHRoaXMuX2ZvbnRTaXplID0gc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb250IHRvIGBmYW1pbHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbiAoZmFtaWx5KSB7XG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGVyY2VudGFnZSB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMucGVyY2VudCA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3IG9uIGBjdHhgLlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHhcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cbiAqL1xuUHJvZ3Jlc3MucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHRyeSB7XG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIHZhciBoYWxmID0gc2l6ZSAvIDI7XG4gICAgdmFyIHggPSBoYWxmO1xuICAgIHZhciB5ID0gaGFsZjtcbiAgICB2YXIgcmFkID0gaGFsZiAtIDE7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XG5cbiAgICBjdHguZm9udCA9IGZvbnRTaXplICsgJ3B4ICcgKyB0aGlzLl9mb250O1xuXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgKiAocGVyY2VudCAvIDEwMCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcblxuICAgIC8vIG91dGVyIGNpcmNsZVxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjOWY5ZjlmJztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWQsIDAsIGFuZ2xlLCBmYWxzZSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgLy8gaW5uZXIgY2lyY2xlXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyNlZWUnO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZCAtIDEsIDAsIGFuZ2xlLCB0cnVlKTtcbiAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAvLyB0ZXh0XG4gICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0IHx8IChwZXJjZW50IHwgMCkgKyAnJSc7XG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCAtIHcgLyAyICsgMSwgeSArIGZvbnRTaXplIC8gMiAtIDEpO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAvLyBkb24ndCBmYWlsIGlmIHdlIGNhbid0IHJlbmRlciBwcm9ncmVzc1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBDb250ZXh0XG4gKi9cbi8qKlxuICogRXhwb3NlIGBDb250ZXh0YC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29udGV4dGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5cbi8qKlxuICogU2V0IG9yIGdldCB0aGUgY29udGV4dCBgUnVubmFibGVgIHRvIGBydW5uYWJsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBjb250ZXh0XG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnJ1bm5hYmxlID0gZnVuY3Rpb24gKHJ1bm5hYmxlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uYWJsZTtcbiAgfVxuICB0aGlzLnRlc3QgPSB0aGlzLl9ydW5uYWJsZSA9IHJ1bm5hYmxlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB0ZXN0IHRpbWVvdXQgYG1zYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS50aW1lb3V0KCk7XG4gIH1cbiAgdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQobXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB0ZXN0IHNsb3duZXNzIHRocmVzaG9sZCBgbXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnNsb3coKTtcbiAgfVxuICB0aGlzLnJ1bm5hYmxlKCkuc2xvdyhtcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXJrIGEgdGVzdCBhcyBza2lwcGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIFBlbmRpbmdcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ydW5uYWJsZSgpLnNraXAoKTtcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBhIG51bWJlciBvZiBhbGxvd2VkIHJldHJpZXMgb24gZmFpbGVkIHRlc3RzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMoKTtcbiAgfVxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7Zm9ybWF0fSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBDb250YWlucyBlcnJvciBjb2RlcywgZmFjdG9yeSBmdW5jdGlvbnMgdG8gY3JlYXRlIHRocm93YWJsZSBlcnJvciBvYmplY3RzLFxuICogYW5kIHdhcm5pbmcvZGVwcmVjYXRpb24gZnVuY3Rpb25zLlxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogcHJvY2Vzcy5lbWl0V2FybmluZyBvciBhIHBvbHlmaWxsXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19lbWl0d2FybmluZ193YXJuaW5nX29wdGlvbnNcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgZW1pdFdhcm5pbmcgPSAobXNnLCB0eXBlKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhtc2csIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLndhcm4odHlwZSArICc6ICcgKyBtc2cpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgYSBkZXByZWNhdGlvbiB3YXJuaW5nLiBFYWNoIGRpc3RpbmN0IG1lc3NhZ2UgaXMgb25seSBkaXNwbGF5ZWQgb25jZS5cbiAqIElnbm9yZXMgZW1wdHkgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFttc2ddIC0gV2FybmluZyB0byBwcmludFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZGVwcmVjYXRlID0gbXNnID0+IHtcbiAgbXNnID0gU3RyaW5nKG1zZyk7XG4gIGlmIChtc2cgJiYgIWRlcHJlY2F0ZS5jYWNoZVttc2ddKSB7XG4gICAgZGVwcmVjYXRlLmNhY2hlW21zZ10gPSB0cnVlO1xuICAgIGVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICB9XG59O1xuZGVwcmVjYXRlLmNhY2hlID0ge307XG5cbi8qKlxuICogU2hvdyBhIGdlbmVyaWMgd2FybmluZy5cbiAqIElnbm9yZXMgZW1wdHkgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFttc2ddIC0gV2FybmluZyB0byBwcmludFxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2FybiA9IG1zZyA9PiB7XG4gIGlmIChtc2cpIHtcbiAgICBlbWl0V2FybmluZyhtc2cpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoZW4gTW9jaGEgdGhyb3dzIGV4Y2VwdGlvbnMgKG9yIHJlamVjdHMgYFByb21pc2VgcyksIGl0IGF0dGVtcHRzIHRvIGFzc2lnbiBhIGBjb2RlYCBwcm9wZXJ0eSB0byB0aGUgYEVycm9yYCBvYmplY3QsIGZvciBlYXNpZXIgaGFuZGxpbmcuIFRoZXNlIGFyZSB0aGUgcG90ZW50aWFsIHZhbHVlcyBvZiBgY29kZWAuXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxpYi9lcnJvcnNcbiAqL1xudmFyIGNvbnN0YW50cyA9IHtcbiAgLyoqXG4gICAqIEFuIHVucmVjb3ZlcmFibGUgZXJyb3IuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRkFUQUw6ICdFUlJfTU9DSEFfRkFUQUwnLFxuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiBhbiBhcmd1bWVudCB0byBhIGZ1bmN0aW9uIGNhbGwgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfQVJHX1RZUEU6ICdFUlJfTU9DSEFfSU5WQUxJRF9BUkdfVFlQRScsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiBhbiBhcmd1bWVudCB0byBhIGZ1bmN0aW9uIGNhbGwgaXMgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfQVJHX1ZBTFVFOiAnRVJSX01PQ0hBX0lOVkFMSURfQVJHX1ZBTFVFJyxcblxuICAvKipcbiAgICogU29tZXRoaW5nIHdhcyB0aHJvd24sIGJ1dCBpdCB3YXNuJ3QgYW4gYEVycm9yYFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfRVhDRVBUSU9OOiAnRVJSX01PQ0hBX0lOVkFMSURfRVhDRVBUSU9OJyxcblxuICAvKipcbiAgICogQW4gaW50ZXJmYWNlIChlLmcuLCBgTW9jaGEuaW50ZXJmYWNlc2ApIGlzIHVua25vd24gb3IgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfSU5URVJGQUNFOiAnRVJSX01PQ0hBX0lOVkFMSURfSU5URVJGQUNFJyxcblxuICAvKipcbiAgICogQSByZXBvcnRlciAoLmUuZywgYE1vY2hhLnJlcG9ydGVyc2ApIGlzIHVua25vd24gb3IgaW52YWxpZFxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIElOVkFMSURfUkVQT1JURVI6ICdFUlJfTU9DSEFfSU5WQUxJRF9SRVBPUlRFUicsXG5cbiAgLyoqXG4gICAqIGBkb25lKClgIHdhcyBjYWxsZWQgdHdpY2UgaW4gYSBgVGVzdGAgb3IgYEhvb2tgIGNhbGxiYWNrXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgTVVMVElQTEVfRE9ORTogJ0VSUl9NT0NIQV9NVUxUSVBMRV9ET05FJyxcblxuICAvKipcbiAgICogTm8gZmlsZXMgbWF0Y2hlZCB0aGUgcGF0dGVybiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIE5PX0ZJTEVTX01BVENIX1BBVFRFUk46ICdFUlJfTU9DSEFfTk9fRklMRVNfTUFUQ0hfUEFUVEVSTicsXG5cbiAgLyoqXG4gICAqIEtub3duLCBidXQgdW5zdXBwb3J0ZWQgYmVoYXZpb3Igb2Ygc29tZSBraW5kXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgVU5TVVBQT1JURUQ6ICdFUlJfTU9DSEFfVU5TVVBQT1JURUQnLFxuXG4gIC8qKlxuICAgKiBJbnZhbGlkIHN0YXRlIHRyYW5zaXRpb24gb2NjdXJyaW5nIGluIGBNb2NoYWAgaW5zdGFuY2VcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBJTlNUQU5DRV9BTFJFQURZX1JVTk5JTkc6ICdFUlJfTU9DSEFfSU5TVEFOQ0VfQUxSRUFEWV9SVU5OSU5HJyxcblxuICAvKipcbiAgICogSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIG9jY3VycmluZyBpbiBgTW9jaGFgIGluc3RhbmNlXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5TVEFOQ0VfQUxSRUFEWV9ESVNQT1NFRDogJ0VSUl9NT0NIQV9JTlNUQU5DRV9BTFJFQURZX0RJU1BPU0VEJyxcblxuICAvKipcbiAgICogVXNlIG9mIGBvbmx5KClgIHcvIGAtLWZvcmJpZC1vbmx5YCByZXN1bHRzIGluIHRoaXMgZXJyb3IuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRk9SQklEREVOX0VYQ0xVU0lWSVRZOiAnRVJSX01PQ0hBX0ZPUkJJRERFTl9FWENMVVNJVklUWScsXG5cbiAgLyoqXG4gICAqIFRvIGJlIHRocm93biB3aGVuIGEgdXNlci1kZWZpbmVkIHBsdWdpbiBpbXBsZW1lbnRhdGlvbiAoZS5nLiwgYG1vY2hhSG9va3NgKSBpcyBpbnZhbGlkXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT046ICdFUlJfTU9DSEFfSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT04nLFxuXG4gIC8qKlxuICAgKiBUbyBiZSB0aHJvd24gd2hlbiBhIGJ1aWx0aW4gb3IgdGhpcmQtcGFydHkgcGx1Z2luIGRlZmluaXRpb24gKHRoZSBfZGVmaW5pdGlvbl8gb2YgYG1vY2hhSG9va3NgKSBpcyBpbnZhbGlkXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgSU5WQUxJRF9QTFVHSU5fREVGSU5JVElPTjogJ0VSUl9NT0NIQV9JTlZBTElEX1BMVUdJTl9ERUZJTklUSU9OJyxcblxuICAvKipcbiAgICogV2hlbiBhIHJ1bm5hYmxlIGV4Y2VlZHMgaXRzIGFsbG93ZWQgcnVuIHRpbWUuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgVElNRU9VVDogJ0VSUl9NT0NIQV9USU1FT1VUJyxcblxuICAvKipcbiAgICogSW5wdXQgZmlsZSBpcyBub3QgYWJsZSB0byBiZSBwYXJzZWRcbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBVTlBBUlNBQkxFX0ZJTEU6ICdFUlJfTU9DSEFfVU5QQVJTQUJMRV9GSUxFJ1xufTtcblxuLyoqXG4gKiBBIHNldCBjb250YWluaW5nIGFsbCBzdHJpbmcgdmFsdWVzIG9mIGFsbCBNb2NoYSBlcnJvciBjb25zdGFudHMsIGZvciB1c2UgYnkge0BsaW5rIGlzTW9jaGFFcnJvcn0uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBNT0NIQV9FUlJPUlMgPSBuZXcgU2V0KE9iamVjdC52YWx1ZXMoY29uc3RhbnRzKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gbm8gZmlsZXMgdG8gYmUgdGVzdGVkIGNvdWxkIGJlIGZvdW5kIHVzaW5nIHNwZWNpZmllZCBwYXR0ZXJuLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAtIFVzZXItc3BlY2lmaWVkIGFyZ3VtZW50IHZhbHVlLlxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVOb0ZpbGVzTWF0Y2hQYXR0ZXJuRXJyb3IobWVzc2FnZSwgcGF0dGVybikge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5OT19GSUxFU19NQVRDSF9QQVRURVJOO1xuICBlcnIucGF0dGVybiA9IHBhdHRlcm47XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcG9ydGVyIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyB3YXMgbm90IGZvdW5kLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwb3J0ZXIgLSBVc2VyLXNwZWNpZmllZCByZXBvcnRlciB2YWx1ZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IobWVzc2FnZSwgcmVwb3J0ZXIpIHtcbiAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfUkVQT1JURVI7XG4gIGVyci5yZXBvcnRlciA9IHJlcG9ydGVyO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIHRoZSBpbnRlcmZhY2Ugc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIHdhcyBub3QgZm91bmQuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1aSAtIFVzZXItc3BlY2lmaWVkIGludGVyZmFjZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEludGVyZmFjZUVycm9yKG1lc3NhZ2UsIHVpKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfSU5URVJGQUNFO1xuICBlcnIuaW50ZXJmYWNlID0gdWk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBiZWhhdmlvciwgb3B0aW9uLCBvciBwYXJhbWV0ZXIgaXMgdW5zdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcihtZXNzYWdlKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLlVOU1VQUE9SVEVEO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIGFyZ3VtZW50IGlzIG1pc3NpbmcuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudCAtIEFyZ3VtZW50IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgLSBFeHBlY3RlZCBhcmd1bWVudCBkYXRhdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKSB7XG4gIHJldHVybiBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhbiBhcmd1bWVudCBkaWQgbm90IHVzZSB0aGUgc3VwcG9ydGVkIHR5cGVcbiAqXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3VtZW50IC0gQXJndW1lbnQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCAtIEV4cGVjdGVkIGFyZ3VtZW50IGRhdGF0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBpbnN0YW5jZSBkZXRhaWxpbmcgdGhlIGVycm9yIGNvbmRpdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IobWVzc2FnZSwgYXJndW1lbnQsIGV4cGVjdGVkKSB7XG4gIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX0FSR19UWVBFO1xuICBlcnIuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIGVyci5hY3R1YWwgPSB0eXBlb2YgYXJndW1lbnQ7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYW4gYXJndW1lbnQgZGlkIG5vdCB1c2UgdGhlIHN1cHBvcnRlZCB2YWx1ZVxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJndW1lbnQgLSBBcmd1bWVudCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gQXJndW1lbnQgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbl0gLSBXaHkgdmFsdWUgaXMgaW52YWxpZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ3VtZW50VmFsdWVFcnJvcihtZXNzYWdlLCBhcmd1bWVudCwgdmFsdWUsIHJlYXNvbikge1xuICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9BUkdfVkFMVUU7XG4gIGVyci5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICBlcnIudmFsdWUgPSB2YWx1ZTtcbiAgZXJyLnJlYXNvbiA9IHR5cGVvZiByZWFzb24gIT09ICd1bmRlZmluZWQnID8gcmVhc29uIDogJ2lzIGludmFsaWQnO1xuICByZXR1cm4gZXJyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHRvIGJlIHRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0LCBidXQgdGhlIGBFcnJvcmAgaXMgZmFsc3kgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5JTlZBTElEX0VYQ0VQVElPTjtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgZXJyLnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYW4gdW5yZWNvdmVyYWJsZSBlcnJvciBvY2N1cnMuXG4gKlxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gaW5zdGFuY2UgZGV0YWlsaW5nIHRoZSBlcnJvciBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmF0YWxFcnJvcihtZXNzYWdlLCB2YWx1ZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5GQVRBTDtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgZXJyLnZhbHVlID0gdmFsdWU7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogRHluYW1pY2FsbHkgY3JlYXRlcyBhIHBsdWdpbi10eXBlLXNwZWNpZmljIGVycm9yIGJhc2VkIG9uIHBsdWdpbiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7XCJyZXBvcnRlclwifFwidWlcIn0gcGx1Z2luVHlwZSAtIFBsdWdpbiB0eXBlLiBGdXR1cmU6IGV4cGFuZCBhcyBuZWVkZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGx1Z2luSWRdIC0gTmFtZS9wYXRoIG9mIHBsdWdpbiwgaWYgYW55XG4gKiBAdGhyb3dzIFdoZW4gYHBsdWdpblR5cGVgIGlzIG5vdCBrbm93blxuICogQHB1YmxpY1xuICogQHN0YXRpY1xuICogQHJldHVybnMge0Vycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkTGVnYWN5UGx1Z2luRXJyb3IobWVzc2FnZSwgcGx1Z2luVHlwZSwgcGx1Z2luSWQpIHtcbiAgc3dpdGNoIChwbHVnaW5UeXBlKSB7XG4gICAgY2FzZSAncmVwb3J0ZXInOlxuICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yKG1lc3NhZ2UsIHBsdWdpbklkKTtcbiAgICBjYXNlICd1aSc6XG4gICAgICByZXR1cm4gY3JlYXRlSW52YWxpZEludGVyZmFjZUVycm9yKG1lc3NhZ2UsIHBsdWdpbklkKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBsdWdpblR5cGUgXCInICsgcGx1Z2luVHlwZSArICdcIicpO1xuICB9XG59XG5cbi8qKlxuICogKipERVBSRUNBVEVEKiouICBVc2Uge0BsaW5rIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcn0gaW5zdGVhZCAgRHluYW1pY2FsbHkgY3JlYXRlcyBhIHBsdWdpbi10eXBlLXNwZWNpZmljIGVycm9yIGJhc2VkIG9uIHBsdWdpbiB0eXBlXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge1wicmVwb3J0ZXJcInxcImludGVyZmFjZVwifSBwbHVnaW5UeXBlIC0gUGx1Z2luIHR5cGUuIEZ1dHVyZTogZXhwYW5kIGFzIG5lZWRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtwbHVnaW5JZF0gLSBOYW1lL3BhdGggb2YgcGx1Z2luLCBpZiBhbnlcbiAqIEB0aHJvd3MgV2hlbiBgcGx1Z2luVHlwZWAgaXMgbm90IGtub3duXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5FcnJvciguLi5hcmdzKSB7XG4gIGRlcHJlY2F0ZSgnVXNlIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcigpIGluc3RlYWQnKTtcbiAgcmV0dXJuIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvciguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIG1vY2hhIG9iamVjdCdzIGBydW5gIG1ldGhvZCBpcyBleGVjdXRlZCB3aGlsZSBpdCBpcyBhbHJlYWR5IGRpc3Bvc2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIHtib29sZWFufSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1biB0aGUgdmFsdWUgb2YgYGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuYFxuICogQHBhcmFtIHtNb2NoYX0gaW5zdGFuY2UgdGhlIG1vY2hhIGluc3RhbmNlIHRoYXQgdGhyb3cgdGhpcyBlcnJvclxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeURpc3Bvc2VkRXJyb3IoXG4gIG1lc3NhZ2UsXG4gIGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICBpbnN0YW5jZVxuKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOU1RBTkNFX0FMUkVBRFlfRElTUE9TRUQ7XG4gIGVyci5jbGVhblJlZmVyZW5jZXNBZnRlclJ1biA9IGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuO1xuICBlcnIuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIG1vY2hhIG9iamVjdCdzIGBydW5gIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgYSB0ZXN0IHJ1biBpcyBpbiBwcm9ncmVzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqIEBzdGF0aWNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IobWVzc2FnZSwgaW5zdGFuY2UpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5TVEFOQ0VfQUxSRUFEWV9SVU5OSU5HO1xuICBlcnIuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBkb25lKCkgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgdGVzdFxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlIC0gT3JpZ2luYWwgcnVubmFibGVcbiAqIEBwYXJhbSB7RXJyb3J9IFtvcmlnaW5hbEVycl0gLSBPcmlnaW5hbCBlcnJvciwgaWYgYW55XG4gKiBAcmV0dXJucyB7RXJyb3J9IGluc3RhbmNlIGRldGFpbGluZyB0aGUgZXJyb3IgY29uZGl0aW9uXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU11bHRpcGxlRG9uZUVycm9yKHJ1bm5hYmxlLCBvcmlnaW5hbEVycikge1xuICB2YXIgdGl0bGU7XG4gIHRyeSB7XG4gICAgdGl0bGUgPSBmb3JtYXQoJzwlcz4nLCBydW5uYWJsZS5mdWxsVGl0bGUoKSk7XG4gICAgaWYgKHJ1bm5hYmxlLnBhcmVudC5yb290KSB7XG4gICAgICB0aXRsZSArPSAnIChvZiByb290IHN1aXRlKSc7XG4gICAgfVxuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgdGl0bGUgPSBmb3JtYXQoJzwlcz4gKG9mIHVua25vd24gc3VpdGUpJywgcnVubmFibGUudGl0bGUpO1xuICB9XG4gIHZhciBtZXNzYWdlID0gZm9ybWF0KFxuICAgICdkb25lKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluICVzICVzJyxcbiAgICBydW5uYWJsZS50eXBlID8gcnVubmFibGUudHlwZSA6ICd1bmtub3duIHJ1bm5hYmxlJyxcbiAgICB0aXRsZVxuICApO1xuICBpZiAocnVubmFibGUuZmlsZSkge1xuICAgIG1lc3NhZ2UgKz0gZm9ybWF0KCcgb2YgZmlsZSAlcycsIHJ1bm5hYmxlLmZpbGUpO1xuICB9XG4gIGlmIChvcmlnaW5hbEVycikge1xuICAgIG1lc3NhZ2UgKz0gZm9ybWF0KCc7IGluIGFkZGl0aW9uLCBkb25lKCkgcmVjZWl2ZWQgZXJyb3I6ICVzJywgb3JpZ2luYWxFcnIpO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuTVVMVElQTEVfRE9ORTtcbiAgZXJyLnZhbHVlVHlwZSA9IHR5cGVvZiBvcmlnaW5hbEVycjtcbiAgZXJyLnZhbHVlID0gb3JpZ2luYWxFcnI7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYC5vbmx5KClgIGlzIHVzZWQgd2l0aFxuICogYC0tZm9yYmlkLW9ubHlgLlxuICogQHN0YXRpY1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYX0gbW9jaGEgLSBNb2NoYSBpbnN0YW5jZVxuICogQHJldHVybnMge0Vycm9yfSBFcnJvciB3aXRoIGNvZGUge0BsaW5rIGNvbnN0YW50cy5GT1JCSURERU5fRVhDTFVTSVZJVFl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IobW9jaGEpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICBtb2NoYS5pc1dvcmtlclxuICAgICAgPyAnYC5vbmx5YCBpcyBub3Qgc3VwcG9ydGVkIGluIHBhcmFsbGVsIG1vZGUnXG4gICAgICA6ICdgLm9ubHlgIGZvcmJpZGRlbiBieSAtLWZvcmJpZC1vbmx5J1xuICApO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5GT1JCSURERU5fRVhDTFVTSVZJVFk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBwbHVnaW4gZGVmaW5pdGlvbiBpcyBpbnZhbGlkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBbcGx1Z2luRGVmXSAtIFByb2JsZW1hdGljIHBsdWdpbiBkZWZpbml0aW9uXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIHdpdGggY29kZSB7QGxpbmsgY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT059XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5EZWZpbml0aW9uRXJyb3IobXNnLCBwbHVnaW5EZWYpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT047XG4gIGVyci5wbHVnaW5EZWYgPSBwbHVnaW5EZWY7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgdG8gYmUgdGhyb3duIHdoZW4gYSBwbHVnaW4gaW1wbGVtZW50YXRpb24gKHVzZXIgY29kZSkgaXMgaW52YWxpZFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBQbHVnaW4gZGVmaW5pdGlvbiBhbmQgdXNlci1zdXBwbGllZCBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtQbHVnaW5EZWZpbml0aW9ufSBbb3B0cy5wbHVnaW5EZWZdIC0gUGx1Z2luIERlZmluaXRpb25cbiAqIEBwYXJhbSB7Kn0gW29wdHMucGx1Z2luSW1wbF0gLSBQbHVnaW4gSW1wbGVtZW50YXRpb24gKHVzZXItc3VwcGxpZWQpXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7RXJyb3J9IEVycm9yIHdpdGggY29kZSB7QGxpbmsgY29uc3RhbnRzLklOVkFMSURfUExVR0lOX0RFRklOSVRJT059XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRQbHVnaW5JbXBsZW1lbnRhdGlvbkVycm9yKFxuICBtc2csXG4gIHtwbHVnaW5EZWYsIHBsdWdpbkltcGx9ID0ge31cbikge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLmNvZGUgPSBjb25zdGFudHMuSU5WQUxJRF9QTFVHSU5fSU1QTEVNRU5UQVRJT047XG4gIGVyci5wbHVnaW5EZWYgPSBwbHVnaW5EZWY7XG4gIGVyci5wbHVnaW5JbXBsID0gcGx1Z2luSW1wbDtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBhIHJ1bm5hYmxlIGV4Y2VlZHMgaXRzIGFsbG93ZWQgcnVuIHRpbWUuXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIC0gRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XSAtIFRpbWVvdXQgaW4gbXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZV0gLSBGaWxlLCBpZiBnaXZlblxuICogQHJldHVybnMge01vY2hhVGltZW91dEVycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IobXNnLCB0aW1lb3V0LCBmaWxlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuY29kZSA9IGNvbnN0YW50cy5USU1FT1VUO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5maWxlID0gZmlsZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB0byBiZSB0aHJvd24gd2hlbiBmaWxlIGlzIHVucGFyc2FibGVcbiAqIEBwdWJsaWNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBGaWxlIG5hbWVcbiAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3Igd2l0aCBjb2RlIHtAbGluayBjb25zdGFudHMuVU5QQVJTQUJMRV9GSUxFfVxuICovXG5mdW5jdGlvbiBjcmVhdGVVbnBhcnNhYmxlRmlsZUVycm9yKG1lc3NhZ2UsIGZpbGVuYW1lKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5jb2RlID0gY29uc3RhbnRzLlVOUEFSU0FCTEVfRklMRTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlcnJvciBjYW1lIG91dCBvZiBNb2NoYS5cbiAqIF9DYW4gc3VmZmVyIGZyb20gZmFsc2UgbmVnYXRpdmVzLCBidXQgbm90IGZhbHNlIHBvc2l0aXZlcy5fXG4gKiBAc3RhdGljXG4gKiBAcHVibGljXG4gKiBAcGFyYW0geyp9IGVyciAtIEVycm9yLCBvciBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTW9jaGFFcnJvciA9IGVyciA9PlxuICBCb29sZWFuKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBNT0NIQV9FUlJPUlMuaGFzKGVyci5jb2RlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdGFudHMsXG4gIGNyZWF0ZUZhdGFsRXJyb3IsXG4gIGNyZWF0ZUZvcmJpZGRlbkV4Y2x1c2l2aXR5RXJyb3IsXG4gIGNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcixcbiAgY3JlYXRlSW52YWxpZEFyZ3VtZW50VmFsdWVFcnJvcixcbiAgY3JlYXRlSW52YWxpZEV4Y2VwdGlvbkVycm9yLFxuICBjcmVhdGVJbnZhbGlkSW50ZXJmYWNlRXJyb3IsXG4gIGNyZWF0ZUludmFsaWRMZWdhY3lQbHVnaW5FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkRlZmluaXRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZFBsdWdpbkVycm9yLFxuICBjcmVhdGVJbnZhbGlkUGx1Z2luSW1wbGVtZW50YXRpb25FcnJvcixcbiAgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IsXG4gIGNyZWF0ZU1pc3NpbmdBcmd1bWVudEVycm9yLFxuICBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeURpc3Bvc2VkRXJyb3IsXG4gIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5UnVubmluZ0Vycm9yLFxuICBjcmVhdGVNdWx0aXBsZURvbmVFcnJvcixcbiAgY3JlYXRlTm9GaWxlc01hdGNoUGF0dGVybkVycm9yLFxuICBjcmVhdGVUaW1lb3V0RXJyb3IsXG4gIGNyZWF0ZVVucGFyc2FibGVGaWxlRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IsXG4gIGRlcHJlY2F0ZSxcbiAgaXNNb2NoYUVycm9yLFxuICB3YXJuXG59O1xuXG4vKipcbiAqIFRoZSBlcnJvciB0aHJvd24gd2hlbiBhIFJ1bm5hYmxlIHRpbWVzIG91dFxuICogQG1lbWJlcm9mIG1vZHVsZTpsaWIvZXJyb3JzXG4gKiBAdHlwZWRlZiB7RXJyb3J9IE1vY2hhVGltZW91dEVycm9yXG4gKiBAcHJvcGVydHkge2NvbnN0YW50cy5USU1FT1VUfSBjb2RlIC0gRXJyb3IgY29kZVxuICogQHByb3BlcnR5IHtudW1iZXI/fSB0aW1lb3V0IFRpbWVvdXQgaW4gbXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nP30gZmlsZSBGaWxlcGF0aCwgaWYgZ2l2ZW5cbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG5jb25zdCB7aW5oZXJpdHMsIGNvbnN0YW50c30gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgYEhvb2tgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSG9vaztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBIb29rYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSdW5uYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBIb29rKHRpdGxlLCBmbikge1xuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XG4gIHRoaXMudHlwZSA9ICdob29rJztcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKEhvb2ssIFJ1bm5hYmxlKTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIGZvciBhIG5leHQgcnVuLlxuICovXG5Ib29rLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgUnVubmFibGUucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyk7XG4gIGRlbGV0ZSB0aGlzLl9lcnJvcjtcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgdGVzdCBgZXJyYC5cbiAqXG4gKiBAbWVtYmVyb2YgSG9va1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuSG9vay5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGVyciA9IHRoaXMuX2Vycm9yO1xuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgdGhpcy5fZXJyb3IgPSBlcnI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHN1aXRhYmxlIGZvciBJUEMuXG4gKiBGdW5jdGlvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Ib29rLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gIHJldHVybiB7XG4gICAgJCRjdXJyZW50UmV0cnk6IHRoaXMuY3VycmVudFJldHJ5KCksXG4gICAgJCRmdWxsVGl0bGU6IHRoaXMuZnVsbFRpdGxlKCksXG4gICAgJCRpc1BlbmRpbmc6IEJvb2xlYW4odGhpcy5pc1BlbmRpbmcoKSksXG4gICAgJCR0aXRsZVBhdGg6IHRoaXMudGl0bGVQYXRoKCksXG4gICAgY3R4OlxuICAgICAgdGhpcy5jdHggJiYgdGhpcy5jdHguY3VycmVudFRlc3RcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBjdXJyZW50VGVzdDoge1xuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jdHguY3VycmVudFRlc3QudGl0bGUsXG4gICAgICAgICAgICAgIFtNT0NIQV9JRF9QUk9QX05BTUVdOiB0aGlzLmN0eC5jdXJyZW50VGVzdC5pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSxcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICBmaWxlOiB0aGlzLmZpbGUsXG4gICAgcGFyZW50OiB7XG4gICAgICAkJGZ1bGxUaXRsZTogdGhpcy5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWRcbiAgICB9LFxuICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICBbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5pZFxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XG52YXIgRVZFTlRfRklMRV9QUkVfUkVRVUlSRSA9XG4gIHJlcXVpcmUoJy4uL3N1aXRlJykuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUFJFX1JFUVVJUkU7XG5cbi8qKlxuICogQkRELXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgIGRlc2NyaWJlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICAgfSk7XG4gKlxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgIH0pO1xuICogICAgICAgIH0pO1xuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJkZEludGVyZmFjZShzdWl0ZSkge1xuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcblxuICBzdWl0ZS5vbihFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcblxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcbiAgICBjb250ZXh0LmFmdGVyID0gY29tbW9uLmFmdGVyO1xuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgYSBcInN1aXRlXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xuICAgICAqIGFuZC9vciB0ZXN0cy5cbiAgICAgKi9cblxuICAgIGNvbnRleHQuZGVzY3JpYmUgPSBjb250ZXh0LmNvbnRleHQgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZuXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyBkZXNjcmliZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQueGRlc2NyaWJlID1cbiAgICAgIGNvbnRleHQueGNvbnRleHQgPVxuICAgICAgY29udGV4dC5kZXNjcmliZS5za2lwID1cbiAgICAgICAgZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgICAgIHJldHVybiBjb21tb24uc3VpdGUuc2tpcCh7XG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgZm46IGZuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGNsdXNpdmUgc3VpdGUuXG4gICAgICovXG5cbiAgICBjb250ZXh0LmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xuICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC5pdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnhpdCA9XG4gICAgICBjb250ZXh0LnhzcGVjaWZ5ID1cbiAgICAgIGNvbnRleHQuaXQuc2tpcCA9XG4gICAgICAgIGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lml0KHRpdGxlKTtcbiAgICAgICAgfTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZXNjcmlwdGlvbiA9ICdCREQgb3IgUlNwZWMgc3R5bGUgW2RlZmF1bHRdJztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gQG1vZHVsZSBpbnRlcmZhY2VzL2NvbW1vblxuKi9cblxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbnZhciBjcmVhdGVNaXNzaW5nQXJndW1lbnRFcnJvciA9IGVycm9ycy5jcmVhdGVNaXNzaW5nQXJndW1lbnRFcnJvcjtcbnZhciBjcmVhdGVVbnN1cHBvcnRlZEVycm9yID0gZXJyb3JzLmNyZWF0ZVVuc3VwcG9ydGVkRXJyb3I7XG52YXIgY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvciA9IGVycm9ycy5jcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yO1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBjb21tb24gdG8gbW9yZSB0aGFuIG9uZSBpbnRlcmZhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGVbXX0gc3VpdGVzXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbW1vbiBmdW5jdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlcywgY29udGV4dCwgbW9jaGEpIHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzdWl0ZSBzaG91bGQgYmUgdGVzdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSAtIHN1aXRlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdWxkQmVUZXN0ZWQoc3VpdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIW1vY2hhLm9wdGlvbnMuZ3JlcCB8fFxuICAgICAgKG1vY2hhLm9wdGlvbnMuZ3JlcCAmJlxuICAgICAgICBtb2NoYS5vcHRpb25zLmdyZXAudGVzdChzdWl0ZS5mdWxsVGl0bGUoKSkgJiZcbiAgICAgICAgIW1vY2hhLm9wdGlvbnMuaW52ZXJ0KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgb25seSBwcmVzZW50IGlmIGZsYWcgLS1kZWxheSBpcyBwYXNzZWQgaW50byBNb2NoYS4gSXQgdHJpZ2dlcnNcbiAgICAgKiByb290IHN1aXRlIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFRoZSByb290IHN1aXRlLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgdGhlIHJvb3Qgc3VpdGVcbiAgICAgKi9cbiAgICBydW5XaXRoU3VpdGU6IGZ1bmN0aW9uIHJ1bldpdGhTdWl0ZShzdWl0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgc3VpdGUucnVuKCk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGJlZm9yZTogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKG5hbWUsIGZuKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhZnRlciBydW5uaW5nIHRlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGFmdGVyOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgIHN1aXRlc1swXS5hZnRlckFsbChuYW1lLCBmbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2gobmFtZSwgZm4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKG5hbWUsIGZuKTtcbiAgICB9LFxuXG4gICAgc3VpdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGFuIGV4Y2x1c2l2ZSBTdWl0ZTsgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XG4gICAgICAgKi9cbiAgICAgIG9ubHk6IGZ1bmN0aW9uIG9ubHkob3B0cykge1xuICAgICAgICBpZiAobW9jaGEub3B0aW9ucy5mb3JiaWRPbmx5KSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlRm9yYmlkZGVuRXhjbHVzaXZpdHlFcnJvcihtb2NoYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5pc09ubHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIFN1aXRlLCBidXQgc2tpcCBpdDsgY29udmVuaWVuY2UgZnVuY3Rpb25cbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XG4gICAgICAgKi9cbiAgICAgIHNraXA6IGZ1bmN0aW9uIHNraXAob3B0cykge1xuICAgICAgICBvcHRzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzdWl0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy50aXRsZSBUaXRsZSBvZiBTdWl0ZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZm5dIFN1aXRlIEZ1bmN0aW9uIChub3QgYWx3YXlzIGFwcGxpY2FibGUpXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBlbmRpbmddIElzIFN1aXRlIHBlbmRpbmc/XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZmlsZV0gRmlsZXBhdGggd2hlcmUgdGhpcyBTdWl0ZSByZXNpZGVzXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmlzT25seV0gSXMgU3VpdGUgZXhjbHVzaXZlP1xuICAgICAgICogQHJldHVybnMge1N1aXRlfVxuICAgICAgICovXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgIHZhciBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIG9wdHMudGl0bGUpO1xuICAgICAgICBzdWl0ZS5wZW5kaW5nID0gQm9vbGVhbihvcHRzLnBlbmRpbmcpO1xuICAgICAgICBzdWl0ZS5maWxlID0gb3B0cy5maWxlO1xuICAgICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XG4gICAgICAgIGlmIChvcHRzLmlzT25seSkge1xuICAgICAgICAgIHN1aXRlLm1hcmtPbmx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN1aXRlLnBlbmRpbmcgJiZcbiAgICAgICAgICBtb2NoYS5vcHRpb25zLmZvcmJpZFBlbmRpbmcgJiZcbiAgICAgICAgICBzaG91bGRCZVRlc3RlZChzdWl0ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9wdHMuZm4uY2FsbChzdWl0ZSk7XG4gICAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICd1bmRlZmluZWQnICYmICFzdWl0ZS5wZW5kaW5nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0FyZ3VtZW50RXJyb3IoXG4gICAgICAgICAgICAnU3VpdGUgXCInICtcbiAgICAgICAgICAgICAgc3VpdGUuZnVsbFRpdGxlKCkgK1xuICAgICAgICAgICAgICAnXCIgd2FzIGRlZmluZWQgYnV0IG5vIGNhbGxiYWNrIHdhcyBzdXBwbGllZC4gJyArXG4gICAgICAgICAgICAgICdTdXBwbHkgYSBjYWxsYmFjayBvciBleHBsaWNpdGx5IHNraXAgdGhlIHN1aXRlLicsXG4gICAgICAgICAgICAnY2FsbGJhY2snLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMuZm4gJiYgc3VpdGUucGVuZGluZykge1xuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1aXRlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0ZXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vY2hhXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0XG4gICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAqL1xuICAgICAgb25seTogZnVuY3Rpb24gKG1vY2hhLCB0ZXN0KSB7XG4gICAgICAgIGlmIChtb2NoYS5vcHRpb25zLmZvcmJpZE9ubHkpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVGb3JiaWRkZW5FeGNsdXNpdml0eUVycm9yKG1vY2hhKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXN0Lm1hcmtPbmx5KCk7XG4gICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICAgICAqL1xuICAgICAgc2tpcDogZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIGNvbnRleHQudGVzdCh0aXRsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcblxuLyoqXG4gKiBFeHBvcnRzLXN0eWxlIChhcyBOb2RlLmpzIG1vZHVsZSkgaW50ZXJmYWNlOlxuICpcbiAqICAgICBleHBvcnRzLkFycmF5ID0ge1xuICogICAgICAgJyNpbmRleE9mKCknOiB7XG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIC0xIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50JzogZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICB9LFxuICpcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgaW5kZXggd2hlbiB0aGUgdmFsdWUgaXMgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH07XG4gKlxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oU3VpdGUuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUkVRVUlSRSwgdmlzaXQpO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG9iaiwgZmlsZSkge1xuICAgIHZhciBzdWl0ZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBmbiA9IG9ialtrZXldO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckFsbChmbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdiZWZvcmVFYWNoJzpcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FmdGVyRWFjaCc6XG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKGZuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KGtleSwgZm4pO1xuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIGtleSk7XG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID0gJ05vZGUuanMgbW9kdWxlIChcImV4cG9ydHNcIikgc3R5bGUnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJkZCA9IHJlcXVpcmUoJy4vYmRkJyk7XG5leHBvcnRzLnRkZCA9IHJlcXVpcmUoJy4vdGRkJyk7XG5leHBvcnRzLnF1bml0ID0gcmVxdWlyZSgnLi9xdW5pdCcpO1xuZXhwb3J0cy5leHBvcnRzID0gcmVxdWlyZSgnLi9leHBvcnRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xudmFyIEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUgPVxuICByZXF1aXJlKCcuLi9zdWl0ZScpLmNvbnN0YW50cy5FVkVOVF9GSUxFX1BSRV9SRVFVSVJFO1xuXG4vKipcbiAqIFFVbml0LXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XG4gKlxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xuICogICAgICAgb2soYXJyLmxlbmd0aCA9PSAzKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdGVzdCgnI2luZGV4T2YoKScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcbiAqICAgICAgIG9rKGFyci5pbmRleE9mKDIpID09IDEpO1xuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcbiAqXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcVVuaXRJbnRlcmZhY2Uoc3VpdGUpIHtcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XG5cbiAgc3VpdGUub24oRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XG5cbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcbiAgICBjb250ZXh0LmJlZm9yZUVhY2ggPSBjb21tb24uYmVmb3JlRWFjaDtcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgXCJzdWl0ZVwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIFN1aXRlLlxuICAgICAqL1xuXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXG4gICAgICovXG5cbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID0gJ1FVbml0IHN0eWxlJztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XG52YXIgRVZFTlRfRklMRV9QUkVfUkVRVUlSRSA9XG4gIHJlcXVpcmUoJy4uL3N1aXRlJykuY29uc3RhbnRzLkVWRU5UX0ZJTEVfUFJFX1JFUVVJUkU7XG5cbi8qKlxuICogVERELXN0eWxlIGludGVyZmFjZTpcbiAqXG4gKiAgICAgIHN1aXRlKCdBcnJheScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBzdWl0ZVNldHVwKGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xuICpcbiAqICAgICAgICAgIH0pO1xuICpcbiAqICAgICAgICAgIHN1aXRlVGVhcmRvd24oZnVuY3Rpb24oKSB7XG4gKlxuICogICAgICAgICAgfSk7XG4gKiAgICAgICAgfSk7XG4gKiAgICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xuXG4gIHN1aXRlLm9uKEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xuXG4gICAgY29udGV4dC5zZXR1cCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xuICAgIGNvbnRleHQudGVhcmRvd24gPSBjb21tb24uYWZ0ZXJFYWNoO1xuICAgIGNvbnRleHQuc3VpdGVTZXR1cCA9IGNvbW1vbi5iZWZvcmU7XG4gICAgY29udGV4dC5zdWl0ZVRlYXJkb3duID0gY29tbW9uLmFmdGVyO1xuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGEgXCJzdWl0ZVwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZ1xuICAgICAqIG5lc3RlZCBzdWl0ZXMgYW5kL29yIHRlc3RzLlxuICAgICAqL1xuICAgIGNvbnRleHQuc3VpdGUgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgZmlsZTogZmlsZSxcbiAgICAgICAgZm46IGZuXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVuZGluZyBzdWl0ZS5cbiAgICAgKi9cbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXG4gICAgICovXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBmbjogZm5cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kXG4gICAgICogY2FsbGJhY2sgYGZuYCBhY3RpbmcgYXMgYSB0aHVuay5cbiAgICAgKi9cbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xuICAgICAgdGVzdC5maWxlID0gZmlsZTtcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cbiAgICAgKi9cblxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlc2NyaXB0aW9uID1cbiAgJ3RyYWRpdGlvbmFsIFwic3VpdGVcIi9cInRlc3RcIiBpbnN0ZWFkIG9mIEJERFxcJ3MgXCJkZXNjcmliZVwiL1wiaXRcIic7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogbW9jaGFcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgYnVpbHRpblJlcG9ydGVycyA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbW9jaGFyYyA9IHJlcXVpcmUoJy4vbW9jaGFyYy5qc29uJyk7XG52YXIgU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XG52YXIgZXNtVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqcy9lc20tdXRpbHMnKTtcbnZhciBjcmVhdGVTdGF0c0NvbGxlY3RvciA9IHJlcXVpcmUoJy4vc3RhdHMtY29sbGVjdG9yJyk7XG5jb25zdCB7XG4gIGNyZWF0ZUludmFsaWRSZXBvcnRlckVycm9yLFxuICBjcmVhdGVJbnZhbGlkSW50ZXJmYWNlRXJyb3IsXG4gIGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcixcbiAgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlSdW5uaW5nRXJyb3IsXG4gIGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3Qge0VWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBFVkVOVF9GSUxFX1JFUVVJUkV9ID1cbiAgU3VpdGUuY29uc3RhbnRzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6bW9jaGEnKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTW9jaGE7XG5cbi8qKlxuICogQSBNb2NoYSBpbnN0YW5jZSBpcyBhIGZpbml0ZSBzdGF0ZSBtYWNoaW5lLlxuICogVGhlc2UgYXJlIHRoZSBzdGF0ZXMgaXQgY2FuIGJlIGluLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1vY2hhU3RhdGVzID0gdXRpbHMuZGVmaW5lQ29uc3RhbnRzKHtcbiAgLyoqXG4gICAqIEluaXRpYWwgc3RhdGUgb2YgdGhlIG1vY2hhIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJTklUOiAnaW5pdCcsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBydW5uaW5nIHRlc3RzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSVU5OSU5HOiAncnVubmluZycsXG4gIC8qKlxuICAgKiBNb2NoYSBpbnN0YW5jZSBpcyBkb25lIHJ1bm5pbmcgdGVzdHMgYW5kIHJlZmVyZW5jZXMgdG8gdGVzdCBmdW5jdGlvbnMgYW5kIGhvb2tzIGFyZSBjbGVhbmVkLlxuICAgKiBZb3UgY2FuIHJlc2V0IHRoaXMgc3RhdGUgYnkgdW5sb2FkaW5nIHRoZSB0ZXN0IGZpbGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUkVGRVJFTkNFU19DTEVBTkVEOiAncmVmZXJlbmNlc0NsZWFuZWQnLFxuICAvKipcbiAgICogTW9jaGEgaW5zdGFuY2UgaXMgZGlzcG9zZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERJU1BPU0VEOiAnZGlzcG9zZWQnXG59KTtcblxuLyoqXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxuICovXG5cbmlmICghdXRpbHMuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG1vZHVsZS5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIGN3ZCA9IHV0aWxzLmN3ZCgpO1xuICBtb2R1bGUucGF0aHMucHVzaChjd2QsIHBhdGguam9pbihjd2QsICdub2RlX21vZHVsZXMnKSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGludGVybmFscy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBNb2NoYVxuICovXG5leHBvcnRzLnJlcG9ydGVycyA9IGJ1aWx0aW5SZXBvcnRlcnM7XG5leHBvcnRzLlJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xuZXhwb3J0cy5Db250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGFcbiAqL1xuZXhwb3J0cy5SdW5uZXIgPSByZXF1aXJlKCcuL3J1bm5lcicpO1xuZXhwb3J0cy5TdWl0ZSA9IFN1aXRlO1xuZXhwb3J0cy5Ib29rID0gcmVxdWlyZSgnLi9ob29rJyk7XG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxubGV0IGN1cnJlbnRDb250ZXh0O1xuZXhwb3J0cy5hZnRlckVhY2ggPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmFmdGVyRWFjaCB8fCBjdXJyZW50Q29udGV4dC50ZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5hZnRlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYWZ0ZXIgfHwgY3VycmVudENvbnRleHQuc3VpdGVUZWFyZG93bikuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5iZWZvcmVFYWNoID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5iZWZvcmVFYWNoIHx8IGN1cnJlbnRDb250ZXh0LnNldHVwKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmJlZm9yZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuYmVmb3JlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlU2V0dXApLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLmRlc2NyaWJlLm9ubHkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gKGN1cnJlbnRDb250ZXh0LmRlc2NyaWJlIHx8IGN1cnJlbnRDb250ZXh0LnN1aXRlKS5vbmx5LmFwcGx5KFxuICAgIHRoaXMsXG4gICAgYXJnc1xuICApO1xufTtcbmV4cG9ydHMuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuZGVzY3JpYmUgfHwgY3VycmVudENvbnRleHQuc3VpdGUpLnNraXAuYXBwbHkoXG4gICAgdGhpcyxcbiAgICBhcmdzXG4gICk7XG59O1xuZXhwb3J0cy5pdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuYXBwbHkodGhpcywgYXJncyk7XG59O1xuZXhwb3J0cy5pdC5vbmx5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChjdXJyZW50Q29udGV4dC5pdCB8fCBjdXJyZW50Q29udGV4dC50ZXN0KS5vbmx5LmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcbmV4cG9ydHMuaXQuc2tpcCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIHJldHVybiAoY3VycmVudENvbnRleHQuaXQgfHwgY3VycmVudENvbnRleHQudGVzdCkuc2tpcC5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5leHBvcnRzLnhkZXNjcmliZSA9IGV4cG9ydHMuZGVzY3JpYmUuc2tpcDtcbmV4cG9ydHMueGl0ID0gZXhwb3J0cy5pdC5za2lwO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuYmVmb3JlRWFjaDtcbmV4cG9ydHMuc3VpdGVTZXR1cCA9IGV4cG9ydHMuYmVmb3JlO1xuZXhwb3J0cy5zdWl0ZVRlYXJkb3duID0gZXhwb3J0cy5hZnRlcjtcbmV4cG9ydHMuc3VpdGUgPSBleHBvcnRzLmRlc2NyaWJlO1xuZXhwb3J0cy50ZWFyZG93biA9IGV4cG9ydHMuYWZ0ZXJFYWNoO1xuZXhwb3J0cy50ZXN0ID0gZXhwb3J0cy5pdDtcbmV4cG9ydHMucnVuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGN1cnJlbnRDb250ZXh0LnJ1bi5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBNb2NoYSBpbnN0YW5jZSB3aXRoIGBvcHRpb25zYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTW9jaGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBTZXR0aW5ncyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93VW5jYXVnaHRdIC0gUHJvcGFnYXRlIHVuY2F1Z2h0IGVycm9ycz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXN5bmNPbmx5XSAtIEZvcmNlIGBkb25lYCBjYWxsYmFjayBvciBwcm9taXNlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYWlsXSAtIEJhaWwgYWZ0ZXIgZmlyc3QgdGVzdCBmYWlsdXJlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0xlYWtzXSAtIENoZWNrIGZvciBnbG9iYWwgdmFyaWFibGUgbGVha3M/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbG9yXSAtIENvbG9yIFRUWSBvdXRwdXQgZnJvbSByZXBvcnRlcj9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsYXldIC0gRGVsYXkgcm9vdCBzdWl0ZSBleGVjdXRpb24/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpZmZdIC0gU2hvdyBkaWZmIG9uIGZhaWx1cmU/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRyeVJ1bl0gLSBSZXBvcnQgdGVzdHMgd2l0aG91dCBydW5uaW5nIHRoZW0/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxaZXJvXSAtIEZhaWwgdGVzdCBydW4gaWYgemVybyB0ZXN0cz9cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mZ3JlcF0gLSBUZXN0IGZpbHRlciBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmJpZE9ubHldIC0gVGVzdHMgbWFya2VkIGBvbmx5YCBmYWlsIHRoZSBzdWl0ZT9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yYmlkUGVuZGluZ10gLSBQZW5kaW5nIHRlc3RzIGZhaWwgdGhlIHN1aXRlP1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mdWxsVHJhY2VdIC0gRnVsbCBzdGFja3RyYWNlIHVwb24gZmFpbHVyZT9cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmdsb2JhbF0gLSBWYXJpYWJsZXMgZXhwZWN0ZWQgaW4gZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5ncmVwXSAtIFRlc3QgZmlsdGVyIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5saW5lRGlmZnNdIC0gRGlzcGxheSBpbmxpbmUgZGlmZnM/XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmludmVydF0gLSBJbnZlcnQgdGVzdCBmaWx0ZXIgbWF0Y2hlcz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9IaWdobGlnaHRpbmddIC0gRGlzYWJsZSBzeW50YXggaGlnaGxpZ2h0aW5nP1xuICogQHBhcmFtIHtzdHJpbmd8Y29uc3RydWN0b3J9IFtvcHRpb25zLnJlcG9ydGVyXSAtIFJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVwb3J0ZXJPcHRpb25dIC0gUmVwb3J0ZXIgc2V0dGluZ3Mgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJldHJpZXNdIC0gTnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbG93XSAtIFNsb3cgdGhyZXNob2xkIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy50aW1lb3V0XSAtIFRpbWVvdXQgdGhyZXNob2xkIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVpXSAtIEludGVyZmFjZSBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJhbGxlbF0gLSBSdW4gam9icyBpbiBwYXJhbGxlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5qb2JzXSAtIE1heCBudW1iZXIgb2Ygd29ya2VyIHByb2Nlc3NlcyBmb3IgcGFyYWxsZWwgcnVucy5cbiAqIEBwYXJhbSB7TW9jaGFSb290SG9va09iamVjdH0gW29wdGlvbnMucm9vdEhvb2tzXSAtIEhvb2tzIHRvIGJvb3RzdHJhcCB0aGUgcm9vdCBzdWl0ZSB3aXRoLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMucmVxdWlyZV0gLSBQYXRobmFtZSBvZiBgcm9vdEhvb2tzYCBwbHVnaW4gZm9yIHBhcmFsbGVsIHJ1bnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzV29ya2VyXSAtIFNob3VsZCBiZSBgdHJ1ZWAgaWYgYE1vY2hhYCBwcm9jZXNzIGlzIHJ1bm5pbmcgaW4gYSB3b3JrZXIgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gTW9jaGEob3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7Li4ubW9jaGFyYywgLi4ub3B0aW9uc307XG4gIHRoaXMuZmlsZXMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgLy8gcm9vdCBzdWl0ZVxuICB0aGlzLnN1aXRlID0gbmV3IGV4cG9ydHMuU3VpdGUoJycsIG5ldyBleHBvcnRzLkNvbnRleHQoKSwgdHJ1ZSk7XG4gIHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuID0gdHJ1ZTtcbiAgdGhpcy5fc3RhdGUgPSBtb2NoYVN0YXRlcy5JTklUO1xuXG4gIHRoaXMuZ3JlcChvcHRpb25zLmdyZXApXG4gICAgLmZncmVwKG9wdGlvbnMuZmdyZXApXG4gICAgLnVpKG9wdGlvbnMudWkpXG4gICAgLnJlcG9ydGVyKFxuICAgICAgb3B0aW9ucy5yZXBvcnRlcixcbiAgICAgIG9wdGlvbnMucmVwb3J0ZXJPcHRpb24gfHwgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgKVxuICAgIC5zbG93KG9wdGlvbnMuc2xvdylcbiAgICAuZ2xvYmFsKG9wdGlvbnMuZ2xvYmFsKTtcblxuICAvLyB0aGlzIGd1YXJkIGV4aXN0cyBiZWNhdXNlIFN1aXRlI3RpbWVvdXQgZG9lcyBub3QgY29uc2lkZXIgYHVuZGVmaW5lZGAgdG8gYmUgdmFsaWQgaW5wdXRcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy50aW1lb3V0KG9wdGlvbnMudGltZW91dCA9PT0gZmFsc2UgPyAwIDogb3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuXG4gIGlmICgncmV0cmllcycgaW4gb3B0aW9ucykge1xuICAgIHRoaXMucmV0cmllcyhvcHRpb25zLnJldHJpZXMpO1xuICB9XG5cbiAgW1xuICAgICdhbGxvd1VuY2F1Z2h0JyxcbiAgICAnYXN5bmNPbmx5JyxcbiAgICAnYmFpbCcsXG4gICAgJ2NoZWNrTGVha3MnLFxuICAgICdjb2xvcicsXG4gICAgJ2RlbGF5JyxcbiAgICAnZGlmZicsXG4gICAgJ2RyeVJ1bicsXG4gICAgJ2ZhaWxaZXJvJyxcbiAgICAnZm9yYmlkT25seScsXG4gICAgJ2ZvcmJpZFBlbmRpbmcnLFxuICAgICdmdWxsVHJhY2UnLFxuICAgICdpbmxpbmVEaWZmcycsXG4gICAgJ2ludmVydCdcbiAgXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAob3B0aW9uc1tvcHRdKSB7XG4gICAgICB0aGlzW29wdF0oKTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChvcHRpb25zLnJvb3RIb29rcykge1xuICAgIHRoaXMucm9vdEhvb2tzKG9wdGlvbnMucm9vdEhvb2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3Mgd2hpY2ggd2UnbGwgaW5zdGFudGlhdGUgaW4ge0BsaW5rIE1vY2hhI3J1bn0uICBEZWZhdWx0cyB0b1xuICAgKiB7QGxpbmsgUnVubmVyfSBpbiBzZXJpYWwgbW9kZTsgY2hhbmdlcyBpbiBwYXJhbGxlbCBtb2RlLlxuICAgKiBAbWVtYmVyb2YgTW9jaGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuX3J1bm5lckNsYXNzID0gZXhwb3J0cy5SdW5uZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGNhbGwge0BsaW5rIE1vY2hhI2xvYWRGaWxlc30gaW1wbGljaXRseSB3aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIE1vY2hhI3J1bn0uICBJZiB0aGlzIGlzIGB0cnVlYCwgdGhlbiBpdCdzIHVwIHRvIHRoZSBjb25zdW1lciB0byBjYWxsXG4gICAqIHtAbGluayBNb2NoYSNsb2FkRmlsZXN9IF9vcl8ge0BsaW5rIE1vY2hhI2xvYWRGaWxlc0FzeW5jfS5cbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqL1xuICB0aGlzLl9sYXp5TG9hZEZpbGVzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEl0J3MgdXNlZnVsIGZvciBhIE1vY2hhIGluc3RhbmNlIHRvIGtub3cgaWYgaXQncyBydW5uaW5nIGluIGEgd29ya2VyIHByb2Nlc3MuXG4gICAqIFdlIGNvdWxkIGRlcml2ZSB0aGlzIHZpYSBvdGhlciBtZWFucywgYnV0IGl0J3MgaGVscGZ1bCB0byBoYXZlIGEgZmxhZyB0byByZWZlciB0by5cbiAgICogQG1lbWJlcm9mIE1vY2hhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzV29ya2VyID0gQm9vbGVhbihvcHRpb25zLmlzV29ya2VyKTtcblxuICB0aGlzLmdsb2JhbFNldHVwKG9wdGlvbnMuZ2xvYmFsU2V0dXApXG4gICAgLmdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZ2xvYmFsVGVhcmRvd24pXG4gICAgLmVuYWJsZUdsb2JhbFNldHVwKG9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXApXG4gICAgLmVuYWJsZUdsb2JhbFRlYXJkb3duKG9wdGlvbnMuZW5hYmxlR2xvYmFsVGVhcmRvd24pO1xuXG4gIGlmIChcbiAgICBvcHRpb25zLnBhcmFsbGVsICYmXG4gICAgKHR5cGVvZiBvcHRpb25zLmpvYnMgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuam9icyA+IDEpXG4gICkge1xuICAgIGRlYnVnKCdhdHRlbXB0aW5nIHRvIGVuYWJsZSBwYXJhbGxlbCBtb2RlJyk7XG4gICAgdGhpcy5wYXJhbGxlbE1vZGUodHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIGJhaWxpbmcgb24gdGhlIGZpcnN0IGZhaWx1cmUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1iYWlsLWIpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsPXRydWVdIC0gV2hldGhlciB0byBiYWlsIG9uIGZpcnN0IGVycm9yLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwgIT09IGZhbHNlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBBZGRzIGBmaWxlYCB0byBiZSBsb2FkZWQgZm9yIGV4ZWN1dGlvbi5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzZWZ1bCBmb3IgZ2VuZXJpYyBzZXR1cCBjb2RlIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCB3aXRoaW4gdGVzdCBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZpbGUtZmlsZWRpcmVjdG9yeWdsb2IpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZSAtIFBhdGhuYW1lIG9mIGZpbGUgdG8gYmUgbG9hZGVkLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyByZXBvcnRlciB0byBgcmVwb3J0ZXJgLCBkZWZhdWx0cyB0byBcInNwZWNcIi5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXJlcG9ydGVyLW5hbWUtci1uYW1lKVxuICogQHNlZSBbUmVwb3J0ZXJzXSguLi8jcmVwb3J0ZXJzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyTmFtZSAtIFJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcG9ydGVyT3B0aW9uc10gLSBPcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoZSByZXBvcnRlci5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHJlcXVlc3RlZCByZXBvcnRlciBjYW5ub3QgYmUgbG9hZGVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSBYVW5pdCByZXBvcnRlciBhbmQgZGlyZWN0IGl0cyBvdXRwdXQgdG8gZmlsZVxuICogbW9jaGEucmVwb3J0ZXIoJ3h1bml0JywgeyBvdXRwdXQ6ICcvcGF0aC90by90ZXN0c3BlYy54dW5pdC54bWwnIH0pO1xuICovXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb3J0ZXJOYW1lLCByZXBvcnRlck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiByZXBvcnRlck5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyTmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXBvcnRlck5hbWUgPSByZXBvcnRlck5hbWUgfHwgJ3NwZWMnO1xuICAgIHZhciByZXBvcnRlcjtcbiAgICAvLyBUcnkgdG8gbG9hZCBhIGJ1aWx0LWluIHJlcG9ydGVyLlxuICAgIGlmIChidWlsdGluUmVwb3J0ZXJzW3JlcG9ydGVyTmFtZV0pIHtcbiAgICAgIHJlcG9ydGVyID0gYnVpbHRpblJlcG9ydGVyc1tyZXBvcnRlck5hbWVdO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcbiAgICBpZiAoIXJlcG9ydGVyKSB7XG4gICAgICBsZXQgZm91bmRSZXBvcnRlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvdW5kUmVwb3J0ZXIgPSByZXF1aXJlLnJlc29sdmUocmVwb3J0ZXJOYW1lKTtcbiAgICAgICAgcmVwb3J0ZXIgPSByZXF1aXJlKGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmb3VuZFJlcG9ydGVyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZXJyLm1lc3NhZ2UsIGZvdW5kUmVwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIGEgY3dkLXJlbGF0aXZlIHBhdGhcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXBvcnRlciA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKHJlcG9ydGVyTmFtZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFJlcG9ydGVyRXJyb3IoZS5tZXNzYWdlLCByZXBvcnRlck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uID0gcmVwb3J0ZXJPcHRpb25zO1xuICAvLyBhbGlhcyBvcHRpb24gbmFtZSBpcyB1c2VkIGluIGJ1aWx0LWluIHJlcG9ydGVycyB4dW5pdC90YXAvcHJvZ3Jlc3NcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGVzdCBVSSBgbmFtZWAsIGRlZmF1bHRzIHRvIFwiYmRkXCIuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy11aS1uYW1lLXUtbmFtZSlcbiAqIEBzZWUgW0ludGVyZmFjZSBEU0xzXSguLi8jaW50ZXJmYWNlcylcbiAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBbdWk9YmRkXSAtIEludGVyZmFjZSBuYW1lIG9yIGNsYXNzLlxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcmVxdWVzdGVkIGludGVyZmFjZSBjYW5ub3QgYmUgbG9hZGVkXG4gKi9cbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uICh1aSkge1xuICB2YXIgYmluZEludGVyZmFjZTtcbiAgaWYgKHR5cGVvZiB1aSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGJpbmRJbnRlcmZhY2UgPSB1aTtcbiAgfSBlbHNlIHtcbiAgICB1aSA9IHVpIHx8ICdiZGQnO1xuICAgIGJpbmRJbnRlcmZhY2UgPSBleHBvcnRzLmludGVyZmFjZXNbdWldO1xuICAgIGlmICghYmluZEludGVyZmFjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmluZEludGVyZmFjZSA9IHJlcXVpcmUodWkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRJbnRlcmZhY2VFcnJvcihgaW52YWxpZCBpbnRlcmZhY2UgJyR7dWl9J2AsIHVpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZEludGVyZmFjZSh0aGlzLnN1aXRlKTtcblxuICB0aGlzLnN1aXRlLm9uKEVWRU5UX0ZJTEVfUFJFX1JFUVVJUkUsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQgPSBjb250ZXh0O1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTG9hZHMgYGZpbGVzYCBwcmlvciB0byBleGVjdXRpb24uIERvZXMgbm90IHN1cHBvcnQgRVMgTW9kdWxlcy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiByZWxpZXMgb24gTm9kZSdzIGByZXF1aXJlYCB0byBleGVjdXRlXG4gKiB0aGUgdGVzdCBpbnRlcmZhY2UgZnVuY3Rpb25zIGFuZCB3aWxsIGJlIHN1YmplY3QgdG8gaXRzIGNhY2hlLlxuICogU3VwcG9ydHMgb25seSBDb21tb25KUyBtb2R1bGVzLiBUbyBsb2FkIEVTIG1vZHVsZXMsIHVzZSBNb2NoYSNsb2FkRmlsZXNBc3luYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHNlZSB7QGxpbmsgTW9jaGEjbG9hZEZpbGVzQXN5bmN9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIC0gQ2FsbGJhY2sgaW52b2tlZCB1cG9uIGNvbXBsZXRpb24uXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBmaWxlID0gcGF0aC5yZXNvbHZlKGZpbGUpO1xuICAgIHN1aXRlLmVtaXQoRVZFTlRfRklMRV9QUkVfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUkVRVUlSRSwgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XG4gICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRSwgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcbiAgfSk7XG4gIGZuICYmIGZuKCk7XG59O1xuXG4vKipcbiAqIExvYWRzIGBmaWxlc2AgcHJpb3IgdG8gZXhlY3V0aW9uLiBTdXBwb3J0cyBOb2RlIEVTIE1vZHVsZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIE5vZGUncyBgcmVxdWlyZWAgYW5kIGBpbXBvcnRgIHRvIGV4ZWN1dGVcbiAqIHRoZSB0ZXN0IGludGVyZmFjZSBmdW5jdGlvbnMgYW5kIHdpbGwgYmUgc3ViamVjdCB0byBpdHMgY2FjaGUuXG4gKiBTdXBwb3J0cyBib3RoIENKUyBhbmQgRVNNIG1vZHVsZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjYWRkRmlsZX1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3J1bn1cbiAqIEBzZWUge0BsaW5rIE1vY2hhI3VubG9hZEZpbGVzfVxuICogQHJldHVybnMge1Byb21pc2V9XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGxvYWRzIEVTTSAoYW5kIENKUykgdGVzdCBmaWxlcyBhc3luY2hyb25vdXNseSwgdGhlbiBydW5zIHJvb3Qgc3VpdGVcbiAqIG1vY2hhLmxvYWRGaWxlc0FzeW5jKClcbiAqICAgLnRoZW4oKCkgPT4gbW9jaGEucnVuKGZhaWx1cmVzID0+IHByb2Nlc3MuZXhpdENvZGUgPSBmYWlsdXJlcyA/IDEgOiAwKSlcbiAqICAgLmNhdGNoKCgpID0+IHByb2Nlc3MuZXhpdENvZGUgPSAxKTtcbiAqL1xuTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlc0FzeW5jID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHRoaXMubGF6eUxvYWRGaWxlcyh0cnVlKTtcblxuICByZXR1cm4gZXNtVXRpbHMubG9hZEZpbGVzQXN5bmMoXG4gICAgdGhpcy5maWxlcyxcbiAgICBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1BSRV9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGZpbGUsIHJlc3VsdE1vZHVsZSkge1xuICAgICAgc3VpdGUuZW1pdChFVkVOVF9GSUxFX1JFUVVJUkUsIHJlc3VsdE1vZHVsZSwgZmlsZSwgc2VsZik7XG4gICAgICBzdWl0ZS5lbWl0KEVWRU5UX0ZJTEVfUE9TVF9SRVFVSVJFLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgbG9hZGVkIGZpbGUgZnJvbSBOb2RlJ3MgYHJlcXVpcmVgIGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSN1bmxvYWRGaWxlc31cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIC0gUGF0aG5hbWUgb2YgZmlsZSB0byBiZSB1bmxvYWRlZC5cbiAqL1xuTW9jaGEudW5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgIHRocm93IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoXG4gICAgICAndW5sb2FkRmlsZSgpIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIHJldHVybiByZXF1aXJlKCcuL25vZGVqcy9maWxlLXVubG9hZGVyJykudW5sb2FkRmlsZShmaWxlKTtcbn07XG5cbi8qKlxuICogVW5sb2FkcyBgZmlsZXNgIGZyb20gTm9kZSdzIGByZXF1aXJlYCBjYWNoZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgYWxsb3dzIHJlcXVpcmVkIGZpbGVzIHRvIGJlIFwiZnJlc2hseVwiIHJlbG9hZGVkLCBwcm92aWRpbmcgdGhlIGFiaWxpdHlcbiAqIHRvIHJldXNlIGEgTW9jaGEgaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseS5cbiAqIE5vdGU6IGRvZXMgbm90IGNsZWFyIEVTTSBtb2R1bGUgZmlsZXMgZnJvbSB0aGUgY2FjaGVcbiAqXG4gKiA8c3Ryb25nPkludGVuZGVkIGZvciBjb25zdW1lcnMgJm1kYXNoOyBub3QgdXNlZCBpbnRlcm5hbGx5PC9zdHJvbmc+XG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjcnVufVxuICogQHJldHVybnMge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS51bmxvYWRGaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5ESVNQT1NFRCkge1xuICAgIHRocm93IGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5RGlzcG9zZWRFcnJvcihcbiAgICAgICdNb2NoYSBpbnN0YW5jZSBpcyBhbHJlYWR5IGRpc3Bvc2VkLCBpdCBjYW5ub3QgYmUgdXNlZCBhZ2Fpbi4nLFxuICAgICAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4sXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMuZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgIE1vY2hhLnVubG9hZEZpbGUoZmlsZSk7XG4gIH0pO1xuICB0aGlzLl9zdGF0ZSA9IG1vY2hhU3RhdGVzLklOSVQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGBncmVwYCBmaWx0ZXIgYWZ0ZXIgZXNjYXBpbmcgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSNncmVwfVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBhIHJlZ2V4cC5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZWxlY3QgdGVzdHMgd2hvc2UgZnVsbCB0aXRsZSBiZWdpbnMgd2l0aCBgXCJmb29cImAgZm9sbG93ZWQgYnkgYSBwZXJpb2RcbiAqIG1vY2hhLmZncmVwKCdmb28uJyk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5mZ3JlcCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5ncmVwKG5ldyBSZWdFeHAoZXNjYXBlUmUoc3RyKSkpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogU2V0cyBgZ3JlcGAgZmlsdGVyIHVzZWQgdG8gc2VsZWN0IHNwZWNpZmljIHRlc3RzIGZvciBleGVjdXRpb24uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJZiBgcmVgIGlzIGEgcmVnZXhwLWxpa2Ugc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byByZWdleHAuXG4gKiBUaGUgcmVnZXhwIGlzIHRlc3RlZCBhZ2FpbnN0IHRoZSBmdWxsIHRpdGxlIG9mIGVhY2ggdGVzdCAoaS5lLiwgdGhlXG4gKiBuYW1lIG9mIHRoZSB0ZXN0IHByZWNlZGVkIGJ5IHRpdGxlcyBvZiBlYWNoIGl0cyBhbmNlc3RyYWwgc3VpdGVzKS5cbiAqIEFzIHN1Y2gsIHVzaW5nIGFuIDxlbT5leGFjdC1tYXRjaDwvZW0+IGZpeGVkIHBhdHRlcm4gYWdhaW5zdCB0aGVcbiAqIHRlc3QgbmFtZSBpdHNlbGYgd2lsbCBub3QgeWllbGQgYW55IG1hdGNoZXMuXG4gKiA8YnI+XG4gKiA8c3Ryb25nPlByZXZpb3VzIGZpbHRlciB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuIG9uIGVhY2ggY2FsbCE8L3N0cm9uZz5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWdyZXAtcmVnZXhwLWctcmVnZXhwKVxuICogQHNlZSB7QGxpbmsgTW9jaGEjZmdyZXB9XG4gKiBAc2VlIHtAbGluayBNb2NoYSNpbnZlcnR9XG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlIC0gUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gc2VsZWN0IHRlc3RzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2VsZWN0IHRlc3RzIHdob3NlIGZ1bGwgdGl0bGUgY29udGFpbnMgYFwibWF0Y2hcImAsIGlnbm9yaW5nIGNhc2VcbiAqIG1vY2hhLmdyZXAoL21hdGNoL2kpO1xuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHJlZ2V4cC1saWtlIHN0cmluZyBhcmd1bWVudFxuICogbW9jaGEuZ3JlcCgnL21hdGNoL2knKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIyMgQW50aS1leGFtcGxlXG4gKiAvLyBHaXZlbiBlbWJlZGRlZCB0ZXN0IGBpdCgnb25seS10aGlzLXRlc3QnKWAuLi5cbiAqIG1vY2hhLmdyZXAoJy9eb25seS10aGlzLXRlc3QkLycpOyAgICAvLyBOTyEgVXNlIGAub25seSgpYCB0byBkbyB0aGlzIVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSkge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmUpKSB7XG4gICAgLy8gZXh0cmFjdCBhcmdzIGlmIGl0J3MgcmVnZXgtbGlrZSwgaS5lOiBbc3RyaW5nLCBwYXR0ZXJuLCBmbGFnXVxuICAgIHZhciBhcmcgPSByZS5tYXRjaCgvXlxcLyguKilcXC8oW2dpbXldezAsNH0pJHwuKi8pO1xuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gbmV3IFJlZ0V4cChhcmdbMV0gfHwgYXJnWzBdLCBhcmdbMl0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gcmU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludmVydHMgYGdyZXBgIG1hdGNoZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgTW9jaGEjZ3JlcH1cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNlbGVjdCB0ZXN0cyB3aG9zZSBmdWxsIHRpdGxlIGRvZXMgKm5vdCogY29udGFpbiBgXCJtYXRjaFwiYCwgaWdub3JpbmcgY2FzZVxuICogbW9jaGEuZ3JlcCgvbWF0Y2gvaSkuaW52ZXJ0KCk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3B0aW9ucy5pbnZlcnQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBjaGVja2luZyBmb3IgZ2xvYmFsIHZhcmlhYmxlcyBsZWFrZWQgd2hpbGUgcnVubmluZyB0ZXN0cy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWNoZWNrLWxlYWtzKVxuICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tMZWFrcz10cnVlXSAtIFdoZXRoZXIgdG8gY2hlY2sgZm9yIGdsb2JhbCB2YXJpYWJsZSBsZWFrcy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24gKGNoZWNrTGVha3MpIHtcbiAgdGhpcy5vcHRpb25zLmNoZWNrTGVha3MgPSBjaGVja0xlYWtzICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgd2hldGhlciBvciBub3QgdG8gZGlzcG9zZSBhZnRlciBlYWNoIHRlc3QgcnVuLlxuICogRGlzYWJsZSB0aGlzIHRvIGVuc3VyZSB5b3UgY2FuIHJ1biB0aGUgdGVzdCBzdWl0ZSBtdWx0aXBsZSB0aW1lcy5cbiAqIElmIGRpc2FibGVkLCBiZSBzdXJlIHRvIGRpc3Bvc2UgbW9jaGEgd2hlbiB5b3UncmUgZG9uZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy5cbiAqIEBwdWJsaWNcbiAqIEBzZWUge0BsaW5rIE1vY2hhI2Rpc3Bvc2V9XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFuUmVmZXJlbmNlc0FmdGVyUnVuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSBmdW5jdGlvbiAoY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4pIHtcbiAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4gPSBjbGVhblJlZmVyZW5jZXNBZnRlclJ1biAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYW51YWxseSBkaXNwb3NlIHRoaXMgbW9jaGEgaW5zdGFuY2UuIE1hcmsgdGhpcyBpbnN0YW5jZSBhcyBgZGlzcG9zZWRgIGFuZCB1bmFibGUgdG8gcnVuIG1vcmUgdGVzdHMuXG4gKiBJdCBhbHNvIHJlbW92ZXMgZnVuY3Rpb24gcmVmZXJlbmNlcyB0byB0ZXN0cyBmdW5jdGlvbnMgYW5kIGhvb2tzLCBzbyB2YXJpYWJsZXMgdHJhcHBlZCBpbiBjbG9zdXJlcyBjYW4gYmUgY2xlYW5lZCBieSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuXG4gKiBAcHVibGljXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fc3RhdGUgPT09IG1vY2hhU3RhdGVzLlJVTk5JTkcpIHtcbiAgICB0aHJvdyBjcmVhdGVNb2NoYUluc3RhbmNlQWxyZWFkeVJ1bm5pbmdFcnJvcihcbiAgICAgICdDYW5ub3QgZGlzcG9zZSB3aGlsZSB0aGUgbW9jaGEgaW5zdGFuY2UgaXMgc3RpbGwgcnVubmluZyB0ZXN0cy4nXG4gICAgKTtcbiAgfVxuICB0aGlzLnVubG9hZEZpbGVzKCk7XG4gIHRoaXMuX3ByZXZpb3VzUnVubmVyICYmIHRoaXMuX3ByZXZpb3VzUnVubmVyLmRpc3Bvc2UoKTtcbiAgdGhpcy5zdWl0ZS5kaXNwb3NlKCk7XG4gIHRoaXMuX3N0YXRlID0gbW9jaGFTdGF0ZXMuRElTUE9TRUQ7XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIGZ1bGwgc3RhY2sgdHJhY2UgdXBvbiB0ZXN0IGZhaWx1cmUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mdWxsLXRyYWNlKVxuICogQHBhcmFtIHtib29sZWFufSBbZnVsbFRyYWNlPXRydWVdIC0gV2hldGhlciB0byBwcmludCBmdWxsIHN0YWNrdHJhY2UgdXBvbiBmYWlsdXJlLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uIChmdWxsVHJhY2UpIHtcbiAgdGhpcy5vcHRpb25zLmZ1bGxUcmFjZSA9IGZ1bGxUcmFjZSAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgd2hpdGVsaXN0IG9mIHZhcmlhYmxlIG5hbWVzIHRvIGJlIGV4cGVjdGVkIGluIGdsb2JhbCBzY29wZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWdsb2JhbC12YXJpYWJsZS1uYW1lKVxuICogQHNlZSB7QGxpbmsgTW9jaGEjY2hlY2tMZWFrc31cbiAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBnbG9iYWwgLSBBY2NlcHRlZCBnbG9iYWwgdmFyaWFibGUgbmFtZShzKS5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNwZWNpZnkgdmFyaWFibGVzIHRvIGJlIGV4cGVjdGVkIGluIGdsb2JhbCBzY29wZVxuICogbW9jaGEuZ2xvYmFsKFsnalF1ZXJ5JywgJ015TGliJ10pO1xuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24gKGdsb2JhbCkge1xuICB0aGlzLm9wdGlvbnMuZ2xvYmFsID0gKHRoaXMub3B0aW9ucy5nbG9iYWwgfHwgW10pXG4gICAgLmNvbmNhdChnbG9iYWwpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsdCwgaWR4LCBhcnIpIHtcbiAgICAgIHJldHVybiBhcnIuaW5kZXhPZihlbHQpID09PSBpZHg7XG4gICAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcbi8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgJ2dsb2JhbHMnIGlzIGFuIGFsaWFzIG9mICdnbG9iYWwnXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IE1vY2hhLnByb3RvdHlwZS5nbG9iYWw7XG5cbi8qKlxuICogRW5hYmxlcyBvciBkaXNhYmxlcyBUVFkgY29sb3Igb3V0cHV0IGJ5IHNjcmVlbi1vcmllbnRlZCByZXBvcnRlcnMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1jb2xvci1jLWNvbG9ycylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbG9yPXRydWVdIC0gV2hldGhlciB0byBlbmFibGUgY29sb3Igb3V0cHV0LlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHRoaXMub3B0aW9ucy5jb2xvciA9IGNvbG9yICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmVwb3J0ZXIgdG8gdXNlIGlubGluZSBkaWZmcyAocmF0aGVyIHRoYW4gKy8tKVxuICogaW4gdGVzdCBmYWlsdXJlIG91dHB1dC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWlubGluZS1kaWZmcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lubGluZURpZmZzPXRydWVdIC0gV2hldGhlciB0byB1c2UgaW5saW5lIGRpZmZzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLmlubGluZURpZmZzID0gZnVuY3Rpb24gKGlubGluZURpZmZzKSB7XG4gIHRoaXMub3B0aW9ucy5pbmxpbmVEaWZmcyA9IGlubGluZURpZmZzICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmVwb3J0ZXIgdG8gaW5jbHVkZSBkaWZmIGluIHRlc3QgZmFpbHVyZSBvdXRwdXQuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1kaWZmKVxuICogQHBhcmFtIHtib29sZWFufSBbZGlmZj10cnVlXSAtIFdoZXRoZXIgdG8gc2hvdyBkaWZmIG9uIGZhaWx1cmUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChkaWZmKSB7XG4gIHRoaXMub3B0aW9ucy5kaWZmID0gZGlmZiAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogU2V0cyB0aW1lb3V0IHRocmVzaG9sZCB2YWx1ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RyaW5nIGFyZ3VtZW50IGNhbiB1c2Ugc2hvcnRoYW5kIChzdWNoIGFzIFwiMnNcIikgYW5kIHdpbGwgYmUgY29udmVydGVkLlxuICogSWYgdGhlIHZhbHVlIGlzIGAwYCwgdGltZW91dHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXRpbWVvdXQtbXMtdC1tcylcbiAqIEBzZWUgW1RpbWVvdXRzXSguLi8jdGltZW91dHMpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zZWNzIC0gVGltZW91dCB0aHJlc2hvbGQgdmFsdWUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBTZXRzIHRpbWVvdXQgdG8gb25lIHNlY29uZFxuICogbW9jaGEudGltZW91dCgxMDAwKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2FtZSBhcyBhYm92ZSBidXQgdXNpbmcgc3RyaW5nIGFyZ3VtZW50XG4gKiBtb2NoYS50aW1lb3V0KCcxcycpO1xuICovXG5Nb2NoYS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtc2Vjcykge1xuICB0aGlzLnN1aXRlLnRpbWVvdXQobXNlY3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXJldHJpZXMtbilcbiAqIEBzZWUgW1JldHJ5IFRlc3RzXSguLi8jcmV0cnktdGVzdHMpXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnkgLSBOdW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzLlxuICogQHJldHVybiB7TW9jaGF9IHRoaXNcbiAqIEBjaGFpbmFibGVcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQWxsb3cgYW55IGZhaWxlZCB0ZXN0IHRvIHJldHJ5IG9uZSBtb3JlIHRpbWVcbiAqIG1vY2hhLnJldHJpZXMoMSk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKHJldHJ5KSB7XG4gIHRoaXMuc3VpdGUucmV0cmllcyhyZXRyeSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHNsb3duZXNzIHRocmVzaG9sZCB2YWx1ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLXNsb3ctbXMtcy1tcylcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc2VjcyAtIFNsb3duZXNzIHRocmVzaG9sZCB2YWx1ZS5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFNldHMgXCJzbG93XCIgdGhyZXNob2xkIHRvIGhhbGYgYSBzZWNvbmRcbiAqIG1vY2hhLnNsb3coNTAwKTtcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gU2FtZSBhcyBhYm92ZSBidXQgdXNpbmcgc3RyaW5nIGFyZ3VtZW50XG4gKiBtb2NoYS5zbG93KCcwLjVzJyk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zZWNzKSB7XG4gIHRoaXMuc3VpdGUuc2xvdyhtc2Vjcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYWxsIHRlc3RzIHRvIGVpdGhlciBhY2NlcHQgYSBgZG9uZWAgY2FsbGJhY2sgb3IgcmV0dXJuIGEgcHJvbWlzZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWFzeW5jLW9ubHktYSlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jT25seT10cnVlXSAtIFdoZXRoZXIgdG8gZm9yY2UgYGRvbmVgIGNhbGxiYWNrIG9yIHByb21pc2UuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuYXN5bmNPbmx5ID0gZnVuY3Rpb24gKGFzeW5jT25seSkge1xuICB0aGlzLm9wdGlvbnMuYXN5bmNPbmx5ID0gYXN5bmNPbmx5ICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERpc2FibGVzIHN5bnRheCBoaWdobGlnaHRpbmcgKGluIGJyb3dzZXIpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ub0hpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdW5jYXVnaHQgZXJyb3JzIHRvIHByb3BhZ2F0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWFsbG93LXVuY2F1Z2h0KVxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dVbmNhdWdodD10cnVlXSAtIFdoZXRoZXIgdG8gcHJvcGFnYXRlIHVuY2F1Z2h0IGVycm9ycy5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5hbGxvd1VuY2F1Z2h0ID0gZnVuY3Rpb24gKGFsbG93VW5jYXVnaHQpIHtcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSBhbGxvd1VuY2F1Z2h0ICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBEZWxheXMgcm9vdCBzdWl0ZSBleGVjdXRpb24uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2VkIHRvIHBlcmZvcm0gYXN5bmMgb3BlcmF0aW9ucyBiZWZvcmUgYW55IHN1aXRlcyBhcmUgcnVuLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBzZWUgW2RlbGF5ZWQgcm9vdCBzdWl0ZV0oLi4vI2RlbGF5ZWQtcm9vdC1zdWl0ZSlcbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiBkZWxheSgpIHtcbiAgdGhpcy5vcHRpb25zLmRlbGF5ID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcnVubmluZyB0ZXN0cyBpbiBkcnktcnVuIG1vZGUuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1kcnktcnVuKVxuICogQHBhcmFtIHtib29sZWFufSBbZHJ5UnVuPXRydWVdIC0gV2hldGhlciB0byBhY3RpdmF0ZSBkcnktcnVuIG1vZGUuXG4gKiBAcmV0dXJuIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZHJ5UnVuID0gZnVuY3Rpb24gKGRyeVJ1bikge1xuICB0aGlzLm9wdGlvbnMuZHJ5UnVuID0gZHJ5UnVuICE9PSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZhaWxzIHRlc3QgcnVuIGlmIG5vIHRlc3RzIGVuY291bnRlcmVkIHdpdGggZXhpdC1jb2RlIDEuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSBbQ0xJIG9wdGlvbl0oLi4vIy1mYWlsLXplcm8pXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmYWlsWmVybz10cnVlXSAtIFdoZXRoZXIgdG8gZmFpbCB0ZXN0IHJ1bi5cbiAqIEByZXR1cm4ge01vY2hhfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5mYWlsWmVybyA9IGZ1bmN0aW9uIChmYWlsWmVybykge1xuICB0aGlzLm9wdGlvbnMuZmFpbFplcm8gPSBmYWlsWmVybyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgdGVzdHMgbWFya2VkIGBvbmx5YCB0byBmYWlsIHRoZSBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZvcmJpZC1vbmx5KVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yYmlkT25seT10cnVlXSAtIFdoZXRoZXIgdGVzdHMgbWFya2VkIGBvbmx5YCBmYWlsIHRoZSBzdWl0ZS5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkT25seSA9IGZ1bmN0aW9uIChmb3JiaWRPbmx5KSB7XG4gIHRoaXMub3B0aW9ucy5mb3JiaWRPbmx5ID0gZm9yYmlkT25seSAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgcGVuZGluZyB0ZXN0cyBhbmQgdGVzdHMgbWFya2VkIGBza2lwYCB0byBmYWlsIHRoZSBzdWl0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIFtDTEkgb3B0aW9uXSguLi8jLWZvcmJpZC1wZW5kaW5nKVxuICogQHBhcmFtIHtib29sZWFufSBbZm9yYmlkUGVuZGluZz10cnVlXSAtIFdoZXRoZXIgcGVuZGluZyB0ZXN0cyBmYWlsIHRoZSBzdWl0ZS5cbiAqIEByZXR1cm5zIHtNb2NoYX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkUGVuZGluZyA9IGZ1bmN0aW9uIChmb3JiaWRQZW5kaW5nKSB7XG4gIHRoaXMub3B0aW9ucy5mb3JiaWRQZW5kaW5nID0gZm9yYmlkUGVuZGluZyAhPT0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgbW9jaGEgaXMgaW4gdGhlIHdyb25nIHN0YXRlIHRvIGJlIGFibGUgdG8gdHJhbnNpdGlvbiB0byBhIFwicnVubmluZ1wiIHN0YXRlLlxuICogQHByaXZhdGVcbiAqL1xuTW9jaGEucHJvdG90eXBlLl9ndWFyZFJ1bm5pbmdTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9zdGF0ZSA9PT0gbW9jaGFTdGF0ZXMuUlVOTklORykge1xuICAgIHRocm93IGNyZWF0ZU1vY2hhSW5zdGFuY2VBbHJlYWR5UnVubmluZ0Vycm9yKFxuICAgICAgJ01vY2hhIGluc3RhbmNlIGlzIGN1cnJlbnRseSBydW5uaW5nIHRlc3RzLCBjYW5ub3Qgc3RhcnQgYSBuZXh0IHRlc3QgcnVuIHVudGlsIHRoaXMgb25lIGlzIGRvbmUnLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbiAgaWYgKFxuICAgIHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5ESVNQT1NFRCB8fFxuICAgIHRoaXMuX3N0YXRlID09PSBtb2NoYVN0YXRlcy5SRUZFUkVOQ0VTX0NMRUFORURcbiAgKSB7XG4gICAgdGhyb3cgY3JlYXRlTW9jaGFJbnN0YW5jZUFscmVhZHlEaXNwb3NlZEVycm9yKFxuICAgICAgJ01vY2hhIGluc3RhbmNlIGlzIGFscmVhZHkgZGlzcG9zZWQsIGNhbm5vdCBzdGFydCBhIG5ldyB0ZXN0IHJ1bi4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBtb2NoYSBpbnN0YW5jZS4gQmUgc3VyZSB0byBzZXQgZGlzYWJsZSBgY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW5gIHdoZW4geW91IHdhbnQgdG8gcmV1c2UgdGhlIHNhbWUgbW9jaGEgaW5zdGFuY2UgZm9yIG11bHRpcGxlIHRlc3QgcnVucy4nLFxuICAgICAgdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4sXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb2NoYSB2ZXJzaW9uIGFzIHNwZWNpZmllZCBieSBcInBhY2thZ2UuanNvblwiLlxuICpcbiAqIEBuYW1lIE1vY2hhI3ZlcnNpb25cbiAqIEB0eXBlIHN0cmluZ1xuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NoYS5wcm90b3R5cGUsICd2ZXJzaW9uJywge1xuICB2YWx1ZTogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGVzdCBleGVjdXRpb24gaXMgY29tcGxldGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBEb25lQ0JcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYWlsdXJlcyAtIE51bWJlciBvZiBmYWlsdXJlcyB0aGF0IG9jY3VycmVkLlxuICovXG5cbi8qKlxuICogUnVucyByb290IHN1aXRlIGFuZCBpbnZva2VzIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVG8gcnVuIHRlc3RzIG11bHRpcGxlIHRpbWVzIChvciB0byBydW4gdGVzdHMgaW4gZmlsZXMgdGhhdCBhcmVcbiAqIGFscmVhZHkgaW4gdGhlIGByZXF1aXJlYCBjYWNoZSksIG1ha2Ugc3VyZSB0byBjbGVhciB0aGVtIGZyb21cbiAqIHRoZSBjYWNoZSBmaXJzdCFcbiAqXG4gKiBAcHVibGljXG4gKiBAc2VlIHtAbGluayBNb2NoYSN1bmxvYWRGaWxlc31cbiAqIEBzZWUge0BsaW5rIFJ1bm5lciNydW59XG4gKiBAcGFyYW0ge0RvbmVDQn0gW2ZuXSAtIENhbGxiYWNrIGludm9rZWQgd2hlbiB0ZXN0IGV4ZWN1dGlvbiBjb21wbGV0ZWQuXG4gKiBAcmV0dXJucyB7UnVubmVyfSBydW5uZXIgaW5zdGFuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZXhpdCB3aXRoIG5vbi16ZXJvIHN0YXR1cyBpZiB0aGVyZSB3ZXJlIHRlc3QgZmFpbHVyZXNcbiAqIG1vY2hhLnJ1bihmYWlsdXJlcyA9PiBwcm9jZXNzLmV4aXRDb2RlID0gZmFpbHVyZXMgPyAxIDogMCk7XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fZ3VhcmRSdW5uaW5nU3RhdGVUcmFuc2l0aW9uKCk7XG4gIHRoaXMuX3N0YXRlID0gbW9jaGFTdGF0ZXMuUlVOTklORztcbiAgaWYgKHRoaXMuX3ByZXZpb3VzUnVubmVyKSB7XG4gICAgdGhpcy5fcHJldmlvdXNSdW5uZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3VpdGUucmVzZXQoKTtcbiAgfVxuICBpZiAodGhpcy5maWxlcy5sZW5ndGggJiYgIXRoaXMuX2xhenlMb2FkRmlsZXMpIHtcbiAgICB0aGlzLmxvYWRGaWxlcygpO1xuICB9XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBvcHRpb25zLmZpbGVzID0gdGhpcy5maWxlcztcbiAgY29uc3QgcnVubmVyID0gbmV3IHRoaXMuX3J1bm5lckNsYXNzKHN1aXRlLCB7XG4gICAgY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW46IHRoaXMuX2NsZWFuUmVmZXJlbmNlc0FmdGVyUnVuLFxuICAgIGRlbGF5OiBvcHRpb25zLmRlbGF5LFxuICAgIGRyeVJ1bjogb3B0aW9ucy5kcnlSdW4sXG4gICAgZmFpbFplcm86IG9wdGlvbnMuZmFpbFplcm9cbiAgfSk7XG4gIGNyZWF0ZVN0YXRzQ29sbGVjdG9yKHJ1bm5lcik7XG4gIHZhciByZXBvcnRlciA9IG5ldyB0aGlzLl9yZXBvcnRlcihydW5uZXIsIG9wdGlvbnMpO1xuICBydW5uZXIuY2hlY2tMZWFrcyA9IG9wdGlvbnMuY2hlY2tMZWFrcyA9PT0gdHJ1ZTtcbiAgcnVubmVyLmZ1bGxTdGFja1RyYWNlID0gb3B0aW9ucy5mdWxsVHJhY2U7XG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcbiAgcnVubmVyLmFsbG93VW5jYXVnaHQgPSBvcHRpb25zLmFsbG93VW5jYXVnaHQ7XG4gIHJ1bm5lci5mb3JiaWRPbmx5ID0gb3B0aW9ucy5mb3JiaWRPbmx5O1xuICBydW5uZXIuZm9yYmlkUGVuZGluZyA9IG9wdGlvbnMuZm9yYmlkUGVuZGluZztcbiAgaWYgKG9wdGlvbnMuZ3JlcCkge1xuICAgIHJ1bm5lci5ncmVwKG9wdGlvbnMuZ3JlcCwgb3B0aW9ucy5pbnZlcnQpO1xuICB9XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIHJ1bm5lci5nbG9iYWxzKG9wdGlvbnMuZ2xvYmFsKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS51c2VDb2xvcnMgPSBvcHRpb25zLmNvbG9yO1xuICB9XG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaW5saW5lRGlmZnMgPSBvcHRpb25zLmlubGluZURpZmZzO1xuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmhpZGVEaWZmID0gIW9wdGlvbnMuZGlmZjtcblxuICBjb25zdCBkb25lID0gZmFpbHVyZXMgPT4ge1xuICAgIHRoaXMuX3ByZXZpb3VzUnVubmVyID0gcnVubmVyO1xuICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW5cbiAgICAgID8gbW9jaGFTdGF0ZXMuUkVGRVJFTkNFU19DTEVBTkVEXG4gICAgICA6IG1vY2hhU3RhdGVzLklOSVQ7XG4gICAgZm4gPSBmbiB8fCB1dGlscy5ub29wO1xuICAgIGlmICh0eXBlb2YgcmVwb3J0ZXIuZG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVwb3J0ZXIuZG9uZShmYWlsdXJlcywgZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbihmYWlsdXJlcyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJ1bkFzeW5jID0gYXN5bmMgcnVubmVyID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID1cbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVHbG9iYWxTZXR1cCAmJiB0aGlzLmhhc0dsb2JhbFNldHVwRml4dHVyZXMoKVxuICAgICAgICA/IGF3YWl0IHRoaXMucnVuR2xvYmFsU2V0dXAocnVubmVyKVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IGZhaWx1cmVDb3VudCA9IGF3YWl0IHJ1bm5lci5ydW5Bc3luYyh7XG4gICAgICBmaWxlczogdGhpcy5maWxlcyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUdsb2JhbFRlYXJkb3duICYmIHRoaXMuaGFzR2xvYmFsVGVhcmRvd25GaXh0dXJlcygpKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkdsb2JhbFRlYXJkb3duKHJ1bm5lciwge2NvbnRleHR9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhaWx1cmVDb3VudDtcbiAgfTtcblxuICAvLyBubyBcImNhdGNoXCIgaGVyZSBpcyBpbnRlbnRpb25hbC4gZXJyb3JzIGNvbWluZyBvdXQgb2ZcbiAgLy8gUnVubmVyI3J1biBhcmUgY29uc2lkZXJlZCB1bmNhdWdodC91bmhhbmRsZWQgYW5kIGNhdWdodFxuICAvLyBieSB0aGUgYHByb2Nlc3NgIGV2ZW50IGxpc3RlbmVycy5cbiAgLy8gYWxzbzogcmV0dXJuaW5nIGFueXRoaW5nIG90aGVyIHRoYW4gYHJ1bm5lcmAgd291bGQgYmUgYSBicmVha2luZ1xuICAvLyBjaGFuZ2VcbiAgcnVuQXN5bmMocnVubmVyKS50aGVuKGRvbmUpO1xuXG4gIHJldHVybiBydW5uZXI7XG59O1xuXG4vKipcbiAqIEFzc2lnbnMgaG9va3MgdG8gdGhlIHJvb3Qgc3VpdGVcbiAqIEBwYXJhbSB7TW9jaGFSb290SG9va09iamVjdH0gW2hvb2tzXSAtIEhvb2tzIHRvIGFzc2lnbiB0byByb290IHN1aXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5yb290SG9va3MgPSBmdW5jdGlvbiByb290SG9va3Moe1xuICBiZWZvcmVBbGwgPSBbXSxcbiAgYmVmb3JlRWFjaCA9IFtdLFxuICBhZnRlckFsbCA9IFtdLFxuICBhZnRlckVhY2ggPSBbXVxufSA9IHt9KSB7XG4gIGJlZm9yZUFsbCA9IHV0aWxzLmNhc3RBcnJheShiZWZvcmVBbGwpO1xuICBiZWZvcmVFYWNoID0gdXRpbHMuY2FzdEFycmF5KGJlZm9yZUVhY2gpO1xuICBhZnRlckFsbCA9IHV0aWxzLmNhc3RBcnJheShhZnRlckFsbCk7XG4gIGFmdGVyRWFjaCA9IHV0aWxzLmNhc3RBcnJheShhZnRlckVhY2gpO1xuICBiZWZvcmVBbGwuZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmJlZm9yZUFsbChob29rKTtcbiAgfSk7XG4gIGJlZm9yZUVhY2guZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmJlZm9yZUVhY2goaG9vayk7XG4gIH0pO1xuICBhZnRlckFsbC5mb3JFYWNoKGhvb2sgPT4ge1xuICAgIHRoaXMuc3VpdGUuYWZ0ZXJBbGwoaG9vayk7XG4gIH0pO1xuICBhZnRlckVhY2guZm9yRWFjaChob29rID0+IHtcbiAgICB0aGlzLnN1aXRlLmFmdGVyRWFjaChob29rKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGVzIHBhcmFsbGVsIG1vZGUuXG4gKlxuICogTXVzdCBiZSBydW4gYmVmb3JlIGNhbGxpbmcge0BsaW5rIE1vY2hhI3J1bn0uIENoYW5nZXMgdGhlIGBSdW5uZXJgIGNsYXNzIHRvXG4gKiB1c2U7IGFsc28gZW5hYmxlcyBsYXp5IGZpbGUgbG9hZGluZyBpZiBub3QgYWxyZWFkeSBkb25lIHNvLlxuICpcbiAqIFdhcm5pbmc6IHdoZW4gcGFzc2VkIGBmYWxzZWAgYW5kIGxhenkgbG9hZGluZyBoYXMgYmVlbiBlbmFibGVkIF92aWEgYW55IG1lYW5zXyAoaW5jbHVkaW5nIGNhbGxpbmcgYHBhcmFsbGVsTW9kZSh0cnVlKWApLCB0aGlzIG1ldGhvZCB3aWxsIF9ub3RfIGRpc2FibGUgbGF6eSBsb2FkaW5nLiBMYXp5IGxvYWRpbmcgaXMgYSBwcmVyZXF1aXNpdGUgZm9yIHBhcmFsbGVsXG4gKiBtb2RlLCBidXQgcGFyYWxsZWwgbW9kZSBpcyBfbm90XyBhIHByZXJlcXVpc2l0ZSBmb3IgbGF6eSBsb2FkaW5nIVxuICogQHBhcmFtIHtib29sZWFufSBbZW5hYmxlXSAtIElmIGB0cnVlYCwgZW5hYmxlOyBvdGhlcndpc2UgZGlzYWJsZS5cbiAqIEB0aHJvd3MgSWYgcnVuIGluIGJyb3dzZXJcbiAqIEB0aHJvd3MgSWYgTW9jaGEgbm90IGluIGBJTklUYCBzdGF0ZVxuICogQHJldHVybnMge01vY2hhfVxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICovXG5Nb2NoYS5wcm90b3R5cGUucGFyYWxsZWxNb2RlID0gZnVuY3Rpb24gcGFyYWxsZWxNb2RlKGVuYWJsZSA9IHRydWUpIHtcbiAgaWYgKHV0aWxzLmlzQnJvd3NlcigpKSB7XG4gICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcigncGFyYWxsZWwgbW9kZSBpcyBvbmx5IHN1cHBvcnRlZCBpbiBOb2RlLmpzJyk7XG4gIH1cbiAgY29uc3QgcGFyYWxsZWwgPSBCb29sZWFuKGVuYWJsZSk7XG4gIGlmIChcbiAgICBwYXJhbGxlbCA9PT0gdGhpcy5vcHRpb25zLnBhcmFsbGVsICYmXG4gICAgdGhpcy5fbGF6eUxvYWRGaWxlcyAmJlxuICAgIHRoaXMuX3J1bm5lckNsYXNzICE9PSBleHBvcnRzLlJ1bm5lclxuICApIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodGhpcy5fc3RhdGUgIT09IG1vY2hhU3RhdGVzLklOSVQpIHtcbiAgICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKFxuICAgICAgJ2Nhbm5vdCBjaGFuZ2UgcGFyYWxsZWwgbW9kZSBhZnRlciBoYXZpbmcgY2FsbGVkIHJ1bigpJ1xuICAgICk7XG4gIH1cbiAgdGhpcy5vcHRpb25zLnBhcmFsbGVsID0gcGFyYWxsZWw7XG5cbiAgLy8gc3dhcCBSdW5uZXIgY2xhc3NcbiAgdGhpcy5fcnVubmVyQ2xhc3MgPSBwYXJhbGxlbFxuICAgID8gcmVxdWlyZSgnLi9ub2RlanMvcGFyYWxsZWwtYnVmZmVyZWQtcnVubmVyJylcbiAgICA6IGV4cG9ydHMuUnVubmVyO1xuXG4gIC8vIGxhenlMb2FkRmlsZXMgbWF5IGhhdmUgYmVlbiBzZXQgYHRydWVgIG90aGVyd2lzZSAoZm9yIEVTTSBsb2FkaW5nKSxcbiAgLy8gc28ga2VlcCBgdHJ1ZWAgaWYgc28uXG4gIHJldHVybiB0aGlzLmxhenlMb2FkRmlsZXModGhpcy5fbGF6eUxvYWRGaWxlcyB8fCBwYXJhbGxlbCk7XG59O1xuXG4vKipcbiAqIERpc2FibGVzIGltcGxpY2l0IGNhbGwgdG8ge0BsaW5rIE1vY2hhI2xvYWRGaWxlc30gaW4ge0BsaW5rIE1vY2hhI3J1bn0uIFRoaXNcbiAqIHNldHRpbmcgaXMgdXNlZCBieSB3YXRjaCBtb2RlLCBwYXJhbGxlbCBtb2RlLCBhbmQgZm9yIGxvYWRpbmcgRVNNIGZpbGVzLlxuICogQHRvZG8gVGhpcyBzaG91bGQgdGhyb3cgaWYgd2UndmUgYWxyZWFkeSBsb2FkZWQgZmlsZXM7IHN1Y2ggYmVoYXZpb3JcbiAqIG5lY2Vzc2l0YXRlcyBhZGRpbmcgYSBuZXcgc3RhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmFibGVdIC0gSWYgYHRydWVgLCBkaXNhYmxlIGVhZ2VyIGxvYWRpbmcgb2YgZmlsZXMgaW5cbiAqIHtAbGluayBNb2NoYSNydW59XG4gKiBAY2hhaW5hYmxlXG4gKiBAcHVibGljXG4gKi9cbk1vY2hhLnByb3RvdHlwZS5sYXp5TG9hZEZpbGVzID0gZnVuY3Rpb24gbGF6eUxvYWRGaWxlcyhlbmFibGUpIHtcbiAgdGhpcy5fbGF6eUxvYWRGaWxlcyA9IGVuYWJsZSA9PT0gdHJ1ZTtcbiAgZGVidWcoJ3NldCBsYXp5IGxvYWQgdG8gJXMnLCBlbmFibGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29uZmlndXJlcyBvbmUgb3IgbW9yZSBnbG9iYWwgc2V0dXAgZml4dHVyZXMuXG4gKlxuICogSWYgZ2l2ZW4gbm8gcGFyYW1ldGVycywgX3Vuc2V0c18gYW55IHByZXZpb3VzbHktc2V0IGZpeHR1cmVzLlxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmV8TW9jaGFHbG9iYWxGaXh0dXJlW119IFtzZXR1cEZuc10gLSBHbG9iYWwgc2V0dXAgZml4dHVyZShzKVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsU2V0dXAgPSBmdW5jdGlvbiBnbG9iYWxTZXR1cChzZXR1cEZucyA9IFtdKSB7XG4gIHNldHVwRm5zID0gdXRpbHMuY2FzdEFycmF5KHNldHVwRm5zKTtcbiAgdGhpcy5vcHRpb25zLmdsb2JhbFNldHVwID0gc2V0dXBGbnM7XG4gIGRlYnVnKCdjb25maWd1cmVkICVkIGdsb2JhbCBzZXR1cCBmdW5jdGlvbnMnLCBzZXR1cEZucy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29uZmlndXJlcyBvbmUgb3IgbW9yZSBnbG9iYWwgdGVhcmRvd24gZml4dHVyZXMuXG4gKlxuICogSWYgZ2l2ZW4gbm8gcGFyYW1ldGVycywgX3Vuc2V0c18gYW55IHByZXZpb3VzbHktc2V0IGZpeHR1cmVzLlxuICogQGNoYWluYWJsZVxuICogQHB1YmxpY1xuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmV8TW9jaGFHbG9iYWxGaXh0dXJlW119IFt0ZWFyZG93bkZuc10gLSBHbG9iYWwgdGVhcmRvd24gZml4dHVyZShzKVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFsVGVhcmRvd24gPSBmdW5jdGlvbiBnbG9iYWxUZWFyZG93bih0ZWFyZG93bkZucyA9IFtdKSB7XG4gIHRlYXJkb3duRm5zID0gdXRpbHMuY2FzdEFycmF5KHRlYXJkb3duRm5zKTtcbiAgdGhpcy5vcHRpb25zLmdsb2JhbFRlYXJkb3duID0gdGVhcmRvd25GbnM7XG4gIGRlYnVnKCdjb25maWd1cmVkICVkIGdsb2JhbCB0ZWFyZG93biBmdW5jdGlvbnMnLCB0ZWFyZG93bkZucy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGFueSBnbG9iYWwgc2V0dXAgZml4dHVyZXMgc2VxdWVudGlhbGx5LCBpZiBhbnkuXG4gKlxuICogVGhpcyBpcyBfYXV0b21hdGljYWxseSBjYWxsZWRfIGJ5IHtAbGluayBNb2NoYSNydW59IF91bmxlc3NfIHRoZSBgcnVuR2xvYmFsU2V0dXBgIG9wdGlvbiBpcyBgZmFsc2VgOyBzZWUge0BsaW5rIE1vY2hhI2VuYWJsZUdsb2JhbFNldHVwfS5cbiAqXG4gKiBUaGUgY29udGV4dCBvYmplY3QgdGhpcyBmdW5jdGlvbiByZXNvbHZlcyB3aXRoIHNob3VsZCBiZSBjb25zdW1lZCBieSB7QGxpbmsgTW9jaGEjcnVuR2xvYmFsVGVhcmRvd259LlxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIENvbnRleHQgb2JqZWN0IGlmIGFscmVhZHkgaGF2ZSBvbmVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IENvbnRleHQgb2JqZWN0XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5ydW5HbG9iYWxTZXR1cCA9IGFzeW5jIGZ1bmN0aW9uIHJ1bkdsb2JhbFNldHVwKGNvbnRleHQgPSB7fSkge1xuICBjb25zdCB7Z2xvYmFsU2V0dXB9ID0gdGhpcy5vcHRpb25zO1xuICBpZiAoZ2xvYmFsU2V0dXAgJiYgZ2xvYmFsU2V0dXAubGVuZ3RoKSB7XG4gICAgZGVidWcoJ3J1bigpOiBnbG9iYWwgc2V0dXAgc3RhcnRpbmcnKTtcbiAgICBhd2FpdCB0aGlzLl9ydW5HbG9iYWxGaXh0dXJlcyhnbG9iYWxTZXR1cCwgY29udGV4dCk7XG4gICAgZGVidWcoJ3J1bigpOiBnbG9iYWwgc2V0dXAgY29tcGxldGUnKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogUnVuIGFueSBnbG9iYWwgdGVhcmRvd24gZml4dHVyZXMgc2VxdWVudGlhbGx5LCBpZiBhbnkuXG4gKlxuICogVGhpcyBpcyBfYXV0b21hdGljYWxseSBjYWxsZWRfIGJ5IHtAbGluayBNb2NoYSNydW59IF91bmxlc3NfIHRoZSBgcnVuR2xvYmFsVGVhcmRvd25gIG9wdGlvbiBpcyBgZmFsc2VgOyBzZWUge0BsaW5rIE1vY2hhI2VuYWJsZUdsb2JhbFRlYXJkb3dufS5cbiAqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHdpdGggY29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkge0BsaW5rIE1vY2hhI3J1bkdsb2JhbFNldHVwfSwgaWYgYXBwbGljYWJsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBDb250ZXh0IG9iamVjdCBpZiBhbHJlYWR5IGhhdmUgb25lXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBDb250ZXh0IG9iamVjdFxuICovXG5Nb2NoYS5wcm90b3R5cGUucnVuR2xvYmFsVGVhcmRvd24gPSBhc3luYyBmdW5jdGlvbiBydW5HbG9iYWxUZWFyZG93bihcbiAgY29udGV4dCA9IHt9XG4pIHtcbiAgY29uc3Qge2dsb2JhbFRlYXJkb3dufSA9IHRoaXMub3B0aW9ucztcbiAgaWYgKGdsb2JhbFRlYXJkb3duICYmIGdsb2JhbFRlYXJkb3duLmxlbmd0aCkge1xuICAgIGRlYnVnKCdydW4oKTogZ2xvYmFsIHRlYXJkb3duIHN0YXJ0aW5nJyk7XG4gICAgYXdhaXQgdGhpcy5fcnVuR2xvYmFsRml4dHVyZXMoZ2xvYmFsVGVhcmRvd24sIGNvbnRleHQpO1xuICB9XG4gIGRlYnVnKCdydW4oKTogZ2xvYmFsIHRlYXJkb3duIGNvbXBsZXRlJyk7XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBSdW4gZ2xvYmFsIGZpeHR1cmVzIHNlcXVlbnRpYWxseSB3aXRoIGNvbnRleHQgYGNvbnRleHRgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb2NoYUdsb2JhbEZpeHR1cmVbXX0gW2ZpeHR1cmVGbnNdIC0gRml4dHVyZXMgdG8gcnVuXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gY29udGV4dCBvYmplY3RcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IGNvbnRleHQgb2JqZWN0XG4gKi9cbk1vY2hhLnByb3RvdHlwZS5fcnVuR2xvYmFsRml4dHVyZXMgPSBhc3luYyBmdW5jdGlvbiBfcnVuR2xvYmFsRml4dHVyZXMoXG4gIGZpeHR1cmVGbnMgPSBbXSxcbiAgY29udGV4dCA9IHt9XG4pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBmaXh0dXJlRm4gb2YgZml4dHVyZUZucykge1xuICAgIGF3YWl0IGZpeHR1cmVGbi5jYWxsKGNvbnRleHQpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBUb2dnbGUgZXhlY3V0aW9uIG9mIGFueSBnbG9iYWwgc2V0dXAgZml4dHVyZShzKVxuICpcbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Ym9vbGVhbiB9IFtlbmFibGVkPXRydWVdIC0gSWYgYGZhbHNlYCwgZG8gbm90IHJ1biBnbG9iYWwgc2V0dXAgZml4dHVyZVxuICogQHJldHVybnMge01vY2hhfVxuICovXG5Nb2NoYS5wcm90b3R5cGUuZW5hYmxlR2xvYmFsU2V0dXAgPSBmdW5jdGlvbiBlbmFibGVHbG9iYWxTZXR1cChlbmFibGVkID0gdHJ1ZSkge1xuICB0aGlzLm9wdGlvbnMuZW5hYmxlR2xvYmFsU2V0dXAgPSBCb29sZWFuKGVuYWJsZWQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIGV4ZWN1dGlvbiBvZiBhbnkgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmUocylcbiAqXG4gKiBAY2hhaW5hYmxlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfSBbZW5hYmxlZD10cnVlXSAtIElmIGBmYWxzZWAsIGRvIG5vdCBydW4gZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVcbiAqIEByZXR1cm5zIHtNb2NoYX1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmVuYWJsZUdsb2JhbFRlYXJkb3duID0gZnVuY3Rpb24gZW5hYmxlR2xvYmFsVGVhcmRvd24oXG4gIGVuYWJsZWQgPSB0cnVlXG4pIHtcbiAgdGhpcy5vcHRpb25zLmVuYWJsZUdsb2JhbFRlYXJkb3duID0gQm9vbGVhbihlbmFibGVkKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIG9uZSBvciBtb3JlIGdsb2JhbCBzZXR1cCBmaXh0dXJlcyBoYXZlIGJlZW4gc3VwcGxpZWQuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTW9jaGEucHJvdG90eXBlLmhhc0dsb2JhbFNldHVwRml4dHVyZXMgPSBmdW5jdGlvbiBoYXNHbG9iYWxTZXR1cEZpeHR1cmVzKCkge1xuICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuZ2xvYmFsU2V0dXAubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIG1vcmUgZ2xvYmFsIHRlYXJkb3duIGZpeHR1cmVzIGhhdmUgYmVlbiBzdXBwbGllZC5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Nb2NoYS5wcm90b3R5cGUuaGFzR2xvYmFsVGVhcmRvd25GaXh0dXJlcyA9XG4gIGZ1bmN0aW9uIGhhc0dsb2JhbFRlYXJkb3duRml4dHVyZXMoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLmdsb2JhbFRlYXJkb3duLmxlbmd0aCk7XG4gIH07XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGRlZmluZSByb290IGhvb2tzIHRoYXQgd29ya3Mgd2l0aCBwYXJhbGxlbCBydW5zLlxuICogQHR5cGVkZWYge09iamVjdH0gTW9jaGFSb290SG9va09iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxGdW5jdGlvbltdfSBbYmVmb3JlQWxsXSAtIFwiQmVmb3JlIGFsbFwiIGhvb2socylcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2JlZm9yZUVhY2hdIC0gXCJCZWZvcmUgZWFjaFwiIGhvb2socylcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2FmdGVyQWxsXSAtIFwiQWZ0ZXIgYWxsXCIgaG9vayhzKVxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxGdW5jdGlvbltdfSBbYWZ0ZXJFYWNoXSAtIFwiQWZ0ZXIgZWFjaFwiIGhvb2socylcbiAqL1xuXG4vKipcbiAqIEFuIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHtAbGluayBNb2NoYVJvb3RIb29rT2JqZWN0fSwgZWl0aGVyIHN5bmMgb3IgYXN5bmMuXG4gICBAY2FsbGJhY2sgTW9jaGFSb290SG9va0Z1bmN0aW9uXG4gKiBAcmV0dXJucyB7TW9jaGFSb290SG9va09iamVjdHxQcm9taXNlPE1vY2hhUm9vdEhvb2tPYmplY3Q+fVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0J3MgaW52b2tlZCBfb25jZV8gd2hpY2ggaXMgZWl0aGVyIHN5bmMgb3IgYXN5bmMuXG4gKiBDYW4gYmUgYSBcInRlYXJkb3duXCIgb3IgXCJzZXR1cFwiLiAgVGhlc2Ugd2lsbCBhbGwgc2hhcmUgdGhlIHNhbWUgY29udGV4dC5cbiAqIEBjYWxsYmFjayBNb2NoYUdsb2JhbEZpeHR1cmVcbiAqIEByZXR1cm5zIHt2b2lkfFByb21pc2U8dm9pZD59XG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgbWFraW5nIHVwIGFsbCBuZWNlc3NhcnkgcGFydHMgb2YgYSBwbHVnaW4gbG9hZGVyIGFuZCBhZ2dyZWdhdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQbHVnaW5EZWZpbml0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXhwb3J0TmFtZSAtIE5hbWVkIGV4cG9ydCB0byB1c2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uTmFtZV0gLSBPcHRpb24gbmFtZSBmb3IgTW9jaGEgY29uc3RydWN0b3IgKHVzZSBgZXhwb3J0TmFtZWAgaWYgb21pdHRlZClcbiAqIEBwcm9wZXJ0eSB7UGx1Z2luVmFsaWRhdG9yfSBbdmFsaWRhdGVdIC0gVmFsaWRhdG9yIGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge1BsdWdpbkZpbmFsaXplcn0gW2ZpbmFsaXplXSAtIEZpbmFsaXplci9hZ2dyZWdhdG9yIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIChzeW5jKSBmdW5jdGlvbiB0byBhc3NlcnQgYSB1c2VyLXN1cHBsaWVkIHBsdWdpbiBpbXBsZW1lbnRhdGlvbiBpcyB2YWxpZC5cbiAqXG4gKiBEZWZpbmVkIGluIGEge0BsaW5rIFBsdWdpbkRlZmluaXRpb259LlxuXG4gKiBAY2FsbGJhY2sgUGx1Z2luVmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAqIEB0aGlzIHtQbHVnaW5EZWZpbml0aW9ufVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGZpbmFsaXplIHBsdWdpbnMgaW1wbHMgb2YgYSBwYXJ0aWN1bGFyIGlsa1xuICogQGNhbGxiYWNrIFBsdWdpbkZpbmFsaXplclxuICogQHBhcmFtIHtBcnJheTwqPn0gaW1wbHMgLSBVc2VyLXN1cHBsaWVkIGltcGxlbWVudGF0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8Kj58Kn1cbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiBAbW9kdWxlIFBlbmRpbmdcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIFBlbmRpbmcobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIEJhc2VcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJ21zJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKCdsb2ctc3ltYm9scycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG5cbmNvbnN0IGlzQnJvd3NlciA9IHV0aWxzLmlzQnJvd3NlcigpO1xuXG5mdW5jdGlvbiBnZXRCcm93c2VyV2luZG93U2l6ZSgpIHtcbiAgaWYgKCdpbm5lckhlaWdodCcgaW4gZ2xvYmFsKSB7XG4gICAgcmV0dXJuIFtnbG9iYWwuaW5uZXJIZWlnaHQsIGdsb2JhbC5pbm5lcldpZHRoXTtcbiAgfVxuICAvLyBJbiBhIFdlYiBXb3JrZXIsIHRoZSBET00gV2luZG93IGlzIG5vdCBhdmFpbGFibGUuXG4gIHJldHVybiBbNjQwLCA0ODBdO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQmFzZWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuLyoqXG4gKiBDaGVjayBpZiBib3RoIHN0ZGlvIHN0cmVhbXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHR0eS5cbiAqL1xuXG52YXIgaXNhdHR5ID0gaXNCcm93c2VyIHx8IChwcm9jZXNzLnN0ZG91dC5pc1RUWSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSk7XG5cbi8qKlxuICogU2F2ZSBsb2cgcmVmZXJlbmNlcyB0byBhdm9pZCB0ZXN0cyBpbnRlcmZlcmluZyAoc2VlIEdILTM2MDQpLlxuICovXG52YXIgY29uc29sZUxvZyA9IGNvbnNvbGUubG9nO1xuXG4vKipcbiAqIEVuYWJsZSBjb2xvcmluZyBieSBkZWZhdWx0LCBleGNlcHQgaW4gdGhlIGJyb3dzZXIgaW50ZXJmYWNlLlxuICovXG5cbmV4cG9ydHMudXNlQ29sb3JzID1cbiAgIWlzQnJvd3NlciAmJlxuICAoc3VwcG9ydHNDb2xvci5zdGRvdXQgfHwgcHJvY2Vzcy5lbnYuTU9DSEFfQ09MT1JTICE9PSB1bmRlZmluZWQpO1xuXG4vKipcbiAqIElubGluZSBkaWZmcyBpbnN0ZWFkIG9mICsvLVxuICovXG5cbmV4cG9ydHMuaW5saW5lRGlmZnMgPSBmYWxzZTtcblxuLyoqXG4gKiBUcnVuY2F0ZSBkaWZmcyBsb25nZXIgdGhhbiB0aGlzIHZhbHVlIHRvIGF2b2lkIHNsb3cgcGVyZm9ybWFuY2VcbiAqL1xuZXhwb3J0cy5tYXhEaWZmU2l6ZSA9IDgxOTI7XG5cbi8qKlxuICogRGVmYXVsdCBjb2xvciBtYXAuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSB7XG4gIHBhc3M6IDkwLFxuICBmYWlsOiAzMSxcbiAgJ2JyaWdodCBwYXNzJzogOTIsXG4gICdicmlnaHQgZmFpbCc6IDkxLFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxuICBwZW5kaW5nOiAzNixcbiAgc3VpdGU6IDAsXG4gICdlcnJvciB0aXRsZSc6IDAsXG4gICdlcnJvciBtZXNzYWdlJzogMzEsXG4gICdlcnJvciBzdGFjayc6IDkwLFxuICBjaGVja21hcms6IDMyLFxuICBmYXN0OiA5MCxcbiAgbWVkaXVtOiAzMyxcbiAgc2xvdzogMzEsXG4gIGdyZWVuOiAzMixcbiAgbGlnaHQ6IDkwLFxuICAnZGlmZiBndXR0ZXInOiA5MCxcbiAgJ2RpZmYgYWRkZWQnOiAzMixcbiAgJ2RpZmYgcmVtb3ZlZCc6IDMxLFxuICAnZGlmZiBhZGRlZCBpbmxpbmUnOiAnMzA7NDInLFxuICAnZGlmZiByZW1vdmVkIGlubGluZSc6ICczMDs0MSdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzeW1ib2wgbWFwLlxuICovXG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgb2s6IHN5bWJvbHMuc3VjY2VzcyxcbiAgZXJyOiBzeW1ib2xzLmVycm9yLFxuICBkb3Q6ICcuJyxcbiAgY29tbWE6ICcsJyxcbiAgYmFuZzogJyEnXG59O1xuXG4vKipcbiAqIENvbG9yIGBzdHJgIHdpdGggdGhlIGdpdmVuIGB0eXBlYCxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcbiAqIGFzIHdlbGwgYXMgdXNlci1kZWZpbmVkIGNvbG9yXG4gKiBzY2hlbWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG52YXIgY29sb3IgPSAoZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uICh0eXBlLCBzdHIpIHtcbiAgaWYgKCFleHBvcnRzLnVzZUNvbG9ycykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyKTtcbiAgfVxuICByZXR1cm4gJ1xcdTAwMWJbJyArIGV4cG9ydHMuY29sb3JzW3R5cGVdICsgJ20nICsgc3RyICsgJ1xcdTAwMWJbMG0nO1xufSk7XG5cbi8qKlxuICogRXhwb3NlIHRlcm0gd2luZG93IHNpemUsIHdpdGggc29tZSBkZWZhdWx0cyBmb3Igd2hlbiBzdGRlcnIgaXMgbm90IGEgdHR5LlxuICovXG5cbmV4cG9ydHMud2luZG93ID0ge1xuICB3aWR0aDogNzVcbn07XG5cbmlmIChpc2F0dHkpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGV4cG9ydHMud2luZG93LndpZHRoID0gZ2V0QnJvd3NlcldpbmRvd1NpemUoKVsxXTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLndpbmRvdy53aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoMSlbMF07XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc29tZSBiYXNpYyBjdXJzb3IgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiBhbW9uZyByZXBvcnRlcnMuXG4gKi9cblxuZXhwb3J0cy5jdXJzb3IgPSB7XG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbPzI1bCcpO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbPzI1aCcpO1xuICB9LFxuXG4gIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMksnKTtcbiAgfSxcblxuICBiZWdpbm5pbmdPZkxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMEcnKTtcbiAgfSxcblxuICBDUjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc2F0dHkpIHtcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmRlbGV0ZUxpbmUoKTtcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmJlZ2lubmluZ09mTGluZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxyJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvd0RpZmYgPSAoZXhwb3J0cy5zaG93RGlmZiA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgcmV0dXJuIChcbiAgICBlcnIgJiZcbiAgICBlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmXG4gICAgc2FtZVR5cGUoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKSAmJlxuICAgIGVyci5leHBlY3RlZCAhPT0gdW5kZWZpbmVkXG4gICk7XG59KTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5RGlmZk9ianMoZXJyKSB7XG4gIGlmICghdXRpbHMuaXNTdHJpbmcoZXJyLmFjdHVhbCkgfHwgIXV0aWxzLmlzU3RyaW5nKGVyci5leHBlY3RlZCkpIHtcbiAgICBlcnIuYWN0dWFsID0gdXRpbHMuc3RyaW5naWZ5KGVyci5hY3R1YWwpO1xuICAgIGVyci5leHBlY3RlZCA9IHV0aWxzLnN0cmluZ2lmeShlcnIuZXhwZWN0ZWQpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBkaWZmIHdpbGwgYmUgZWl0aGVyIGlubGluZSBvciB1bmlmaWVkIGRlcGVuZGVudCBvbiB0aGUgdmFsdWVcbiAqIG9mIGBCYXNlLmlubGluZURpZmZgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXG4gKi9cblxudmFyIGdlbmVyYXRlRGlmZiA9IChleHBvcnRzLmdlbmVyYXRlRGlmZiA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHRyeSB7XG4gICAgdmFyIG1heExlbiA9IGV4cG9ydHMubWF4RGlmZlNpemU7XG4gICAgdmFyIHNraXBwZWQgPSAwO1xuICAgIGlmIChtYXhMZW4gPiAwKSB7XG4gICAgICBza2lwcGVkID0gTWF0aC5tYXgoYWN0dWFsLmxlbmd0aCAtIG1heExlbiwgZXhwZWN0ZWQubGVuZ3RoIC0gbWF4TGVuKTtcbiAgICAgIGFjdHVhbCA9IGFjdHVhbC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBtYXhMZW4pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gZXhwb3J0cy5pbmxpbmVEaWZmc1xuICAgICAgPyBpbmxpbmVEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpXG4gICAgICA6IHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgIGlmIChza2lwcGVkID4gMCkge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fVxcbiAgICAgIFttb2NoYV0gb3V0cHV0IHRydW5jYXRlZCB0byAke21heExlbn0gY2hhcmFjdGVycywgc2VlIFwibWF4RGlmZlNpemVcIiByZXBvcnRlci1vcHRpb25cXG5gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB2YXIgbXNnID1cbiAgICAgICdcXG4gICAgICAnICtcbiAgICAgIGNvbG9yKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArXG4gICAgICAnICcgK1xuICAgICAgY29sb3IoJ2RpZmYgcmVtb3ZlZCcsICctIGFjdHVhbDogIGZhaWxlZCB0byBnZW5lcmF0ZSBNb2NoYSBkaWZmJykgK1xuICAgICAgJ1xcbic7XG4gICAgcmV0dXJuIG1zZztcbiAgfVxufSk7XG5cbi8qKlxuICogT3V0cHV0cyB0aGUgZ2l2ZW4gYGZhaWx1cmVzYCBhcyBhIGxpc3QuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAdmFyaWF0aW9uIDFcbiAqIEBwYXJhbSB7T2JqZWN0W119IGZhaWx1cmVzIC0gRWFjaCBpcyBUZXN0IGluc3RhbmNlIHdpdGggY29ycmVzcG9uZGluZ1xuICogICAgIEVycm9yIHByb3BlcnR5XG4gKi9cbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChmYWlsdXJlcykge1xuICB2YXIgbXVsdGlwbGVFcnIsIG11bHRpcGxlVGVzdDtcbiAgQmFzZS5jb25zb2xlTG9nKCk7XG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QsIGkpIHtcbiAgICAvLyBmb3JtYXRcbiAgICB2YXIgZm10ID1cbiAgICAgIGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXG4nKSArXG4gICAgICBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJykgK1xuICAgICAgY29sb3IoJ2Vycm9yIHN0YWNrJywgJ1xcbiVzXFxuJyk7XG5cbiAgICAvLyBtc2dcbiAgICB2YXIgbXNnO1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHRlc3QuZXJyICYmIHRlc3QuZXJyLm11bHRpcGxlKSB7XG4gICAgICBpZiAobXVsdGlwbGVUZXN0ICE9PSB0ZXN0KSB7XG4gICAgICAgIG11bHRpcGxlVGVzdCA9IHRlc3Q7XG4gICAgICAgIG11bHRpcGxlRXJyID0gW3Rlc3QuZXJyXS5jb25jYXQodGVzdC5lcnIubXVsdGlwbGUpO1xuICAgICAgfVxuICAgICAgZXJyID0gbXVsdGlwbGVFcnIuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gdGVzdC5lcnI7XG4gICAgfVxuICAgIHZhciBtZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnIuaW5zcGVjdCgpICsgJyc7XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZSArICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gJyc7XG4gICAgfVxuICAgIHZhciBzdGFjayA9IGVyci5zdGFjayB8fCBtZXNzYWdlO1xuICAgIHZhciBpbmRleCA9IG1lc3NhZ2UgPyBzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDogLTE7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBtc2cgPSBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCArPSBtZXNzYWdlLmxlbmd0aDtcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIC8vIHJlbW92ZSBtc2cgZnJvbSBzdGFja1xuICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpbmRleCArIDEpO1xuICAgIH1cblxuICAgIC8vIHVuY2F1Z2h0XG4gICAgaWYgKGVyci51bmNhdWdodCkge1xuICAgICAgbXNnID0gJ1VuY2F1Z2h0ICcgKyBtc2c7XG4gICAgfVxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXG4gICAgaWYgKCFleHBvcnRzLmhpZGVEaWZmICYmIHNob3dEaWZmKGVycikpIHtcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XG4gICAgICBmbXQgPVxuICAgICAgICBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXG4lc1xcbicpO1xuICAgICAgdmFyIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXihbXjpdKyk6IGV4cGVjdGVkLyk7XG4gICAgICBtc2cgPSAnXFxuICAgICAgJyArIGNvbG9yKCdlcnJvciBtZXNzYWdlJywgbWF0Y2ggPyBtYXRjaFsxXSA6IG1zZyk7XG5cbiAgICAgIG1zZyArPSBnZW5lcmF0ZURpZmYoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcbiAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpO1xuXG4gICAgLy8gaW5kZW50ZWQgdGVzdCB0aXRsZVxuICAgIHZhciB0ZXN0VGl0bGUgPSAnJztcbiAgICB0ZXN0LnRpdGxlUGF0aCgpLmZvckVhY2goZnVuY3Rpb24gKHN0ciwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICB0ZXN0VGl0bGUgKz0gJ1xcbiAgICAgJztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICB0ZXN0VGl0bGUgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHRlc3RUaXRsZSArPSBzdHI7XG4gICAgfSk7XG5cbiAgICBCYXNlLmNvbnNvbGVMb2coZm10LCBpICsgMSwgdGVzdFRpdGxlLCBtc2csIHN0YWNrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEJhc2VgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWxsIG90aGVyIHJlcG9ydGVycyBnZW5lcmFsbHkgaW5oZXJpdCBmcm9tIHRoaXMgcmVwb3J0ZXIuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBCYXNlKHJ1bm5lciwgb3B0aW9ucykge1xuICB2YXIgZmFpbHVyZXMgPSAodGhpcy5mYWlsdXJlcyA9IFtdKTtcblxuICBpZiAoIXJ1bm5lcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcnVubmVyIGFyZ3VtZW50Jyk7XG4gIH1cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XG4gIHRoaXMuc3RhdHMgPSBydW5uZXIuc3RhdHM7IC8vIGFzc2lnbmVkIHNvIFJlcG9ydGVycyBrZWVwIGEgY2xvc2VyIHJlZmVyZW5jZVxuXG4gIHZhciBtYXhEaWZmU2l6ZU9wdCA9XG4gICAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9uICYmIHRoaXMub3B0aW9ucy5yZXBvcnRlck9wdGlvbi5tYXhEaWZmU2l6ZTtcbiAgaWYgKG1heERpZmZTaXplT3B0ICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKE51bWJlcihtYXhEaWZmU2l6ZU9wdCkpKSB7XG4gICAgZXhwb3J0cy5tYXhEaWZmU2l6ZSA9IE51bWJlcihtYXhEaWZmU2l6ZU9wdCk7XG4gIH1cblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkpIHtcbiAgICAgIHRlc3Quc3BlZWQgPSAnc2xvdyc7XG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XG4gICAgICB0ZXN0LnNwZWVkID0gJ21lZGl1bSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XG4gICAgaWYgKHNob3dEaWZmKGVycikpIHtcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XG4gICAgfVxuICAgIC8vIG1vcmUgdGhhbiBvbmUgZXJyb3IgcGVyIHRlc3RcbiAgICBpZiAodGVzdC5lcnIgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRlc3QuZXJyLm11bHRpcGxlID0gKHRlc3QuZXJyLm11bHRpcGxlIHx8IFtdKS5jb25jYXQoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVzdC5lcnIgPSBlcnI7XG4gICAgfVxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE91dHB1dHMgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZiB0aGUgYnVuZGxlZCByZXBvcnRlcnMuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICovXG5CYXNlLnByb3RvdHlwZS5lcGlsb2d1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgdmFyIGZtdDtcblxuICBCYXNlLmNvbnNvbGVMb2coKTtcblxuICAvLyBwYXNzZXNcbiAgZm10ID1cbiAgICBjb2xvcignYnJpZ2h0IHBhc3MnLCAnICcpICtcbiAgICBjb2xvcignZ3JlZW4nLCAnICVkIHBhc3NpbmcnKSArXG4gICAgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XG5cbiAgQmFzZS5jb25zb2xlTG9nKGZtdCwgc3RhdHMucGFzc2VzIHx8IDAsIG1pbGxpc2Vjb25kcyhzdGF0cy5kdXJhdGlvbikpO1xuXG4gIC8vIHBlbmRpbmdcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcbiAgICBmbXQgPSBjb2xvcigncGVuZGluZycsICcgJykgKyBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xuXG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgc3RhdHMucGVuZGluZyk7XG4gIH1cblxuICAvLyBmYWlsdXJlc1xuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcblxuICAgIEJhc2UuY29uc29sZUxvZyhmbXQsIHN0YXRzLmZhaWx1cmVzKTtcblxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgfVxuXG4gIEJhc2UuY29uc29sZUxvZygpO1xufTtcblxuLyoqXG4gKiBQYWRzIHRoZSBnaXZlbiBgc3RyYCB0byBgbGVuYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGxlblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwYWQoc3RyLCBsZW4pIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5saW5lIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcbiAqL1xuZnVuY3Rpb24gaW5saW5lRGlmZihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHZhciBtc2cgPSBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCk7XG5cbiAgLy8gbGluZW5vc1xuICB2YXIgbGluZXMgPSBtc2cuc3BsaXQoJ1xcbicpO1xuICBpZiAobGluZXMubGVuZ3RoID4gNCkge1xuICAgIHZhciB3aWR0aCA9IFN0cmluZyhsaW5lcy5sZW5ndGgpLmxlbmd0aDtcbiAgICBtc2cgPSBsaW5lc1xuICAgICAgLm1hcChmdW5jdGlvbiAoc3RyLCBpKSB7XG4gICAgICAgIHJldHVybiBwYWQoKytpLCB3aWR0aCkgKyAnIHwnICsgJyAnICsgc3RyO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8vIGxlZ2VuZFxuICBtc2cgPVxuICAgICdcXG4nICtcbiAgICBjb2xvcignZGlmZiByZW1vdmVkIGlubGluZScsICdhY3R1YWwnKSArXG4gICAgJyAnICtcbiAgICBjb2xvcignZGlmZiBhZGRlZCBpbmxpbmUnLCAnZXhwZWN0ZWQnKSArXG4gICAgJ1xcblxcbicgK1xuICAgIG1zZyArXG4gICAgJ1xcbic7XG5cbiAgLy8gaW5kZW50XG4gIG1zZyA9IG1zZy5yZXBsYWNlKC9eL2dtLCAnICAgICAgJyk7XG4gIHJldHVybiBtc2c7XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRpZmYuXG4gKi9cbmZ1bmN0aW9uIHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgdmFyIGluZGVudCA9ICcgICAgICAnO1xuICBmdW5jdGlvbiBjbGVhblVwKGxpbmUpIHtcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIGxpbmUpO1xuICAgIH1cbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgbGluZSk7XG4gICAgfVxuICAgIGlmIChsaW5lLm1hdGNoKC9AQC8pKSB7XG4gICAgICByZXR1cm4gJy0tJztcbiAgICB9XG4gICAgaWYgKGxpbmUubWF0Y2goL1xcXFwgTm8gbmV3bGluZS8pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XG4gIH1cbiAgZnVuY3Rpb24gbm90QmxhbmsobGluZSkge1xuICAgIHJldHVybiB0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbGluZSAhPT0gbnVsbDtcbiAgfVxuICB2YXIgbXNnID0gZGlmZi5jcmVhdGVQYXRjaCgnc3RyaW5nJywgYWN0dWFsLCBleHBlY3RlZCk7XG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxuJykuc3BsaWNlKDUpO1xuICByZXR1cm4gKFxuICAgICdcXG4gICAgICAnICtcbiAgICBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgJysgZXhwZWN0ZWQnKSArXG4gICAgJyAnICtcbiAgICBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCAnLSBhY3R1YWwnKSArXG4gICAgJ1xcblxcbicgK1xuICAgIGxpbmVzLm1hcChjbGVhblVwKS5maWx0ZXIobm90QmxhbmspLmpvaW4oJ1xcbicpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBjaGFyYWN0ZXIgZGlmZiBmb3IgYGVycmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGlmZlxuICovXG5mdW5jdGlvbiBlcnJvckRpZmYoYWN0dWFsLCBleHBlY3RlZCkge1xuICByZXR1cm4gZGlmZlxuICAgIC5kaWZmV29yZHNXaXRoU3BhY2UoYWN0dWFsLCBleHBlY3RlZClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIGlmIChzdHIuYWRkZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQgaW5saW5lJywgc3RyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIucmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiByZW1vdmVkIGlubGluZScsIHN0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnZhbHVlO1xuICAgIH0pXG4gICAgLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENvbG9ycyBsaW5lcyBmb3IgYHN0cmAsIHVzaW5nIHRoZSBjb2xvciBgbmFtZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbG9yTGluZXMobmFtZSwgc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gY29sb3IobmFtZSwgc3RyKTtcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IGEgLyBiIGhhdmUgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzYW1lVHlwZShhLCBiKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKGEpID09PSBvYmpUb1N0cmluZy5jYWxsKGIpO1xufVxuXG5CYXNlLmNvbnNvbGVMb2cgPSBjb25zb2xlTG9nO1xuXG5CYXNlLmFic3RyYWN0ID0gdHJ1ZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBEb2NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfU1VJVEVfQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfQkVHSU47XG52YXIgRVZFTlRfU1VJVEVfRU5EID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0VORDtcblxuLyoqXG4gKiBFeHBvc2UgYERvY2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG9jO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYERvY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gRG9jKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgaW5kZW50cyA9IDI7XG5cbiAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0JFR0lOLCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICArK2luZGVudHM7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczxzZWN0aW9uIGNsYXNzPVwic3VpdGVcIj4nLCBpbmRlbnQoKSk7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZygnJXM8aDE+JXM8L2gxPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoc3VpdGUudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPGRsPicsIGluZGVudCgpKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1NVSVRFX0VORCwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQmFzZS5jb25zb2xlTG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xuICAgIC0taW5kZW50cztcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzPC9zZWN0aW9uPicsIGluZGVudCgpKTtcbiAgICAtLWluZGVudHM7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coJyVzICA8ZHQ+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC5maWxlKSk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkdCBjbGFzcz1cImVycm9yXCI+JXM8L2R0PicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKVxuICAgICk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZHQgY2xhc3M9XCJlcnJvclwiPiVzPC9kdD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICB1dGlscy5lc2NhcGUodGVzdC5maWxlKVxuICAgICk7XG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XG4gICAgQmFzZS5jb25zb2xlTG9nKFxuICAgICAgJyVzICA8ZGQgY2xhc3M9XCJlcnJvclwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLFxuICAgICAgaW5kZW50KCksXG4gICAgICBjb2RlXG4gICAgKTtcbiAgICBCYXNlLmNvbnNvbGVMb2coXG4gICAgICAnJXMgIDxkZCBjbGFzcz1cImVycm9yXCI+JXM8L2RkPicsXG4gICAgICBpbmRlbnQoKSxcbiAgICAgIHV0aWxzLmVzY2FwZShlcnIpXG4gICAgKTtcbiAgfSk7XG59XG5cbkRvYy5kZXNjcmlwdGlvbiA9ICdIVE1MIGRvY3VtZW50YXRpb24nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIERvdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xuXG4vKipcbiAqIEV4cG9zZSBgRG90YC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb3Q7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgRG90YCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBEb3QocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xuICB2YXIgbiA9IC0xO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4gICcpO1xuICAgIH1cbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShCYXNlLmNvbG9yKCdwZW5kaW5nJywgQmFzZS5zeW1ib2xzLmNvbW1hKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuICAnKTtcbiAgICB9XG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdzbG93Jykge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcignYnJpZ2h0IHllbGxvdycsIEJhc2Uuc3ltYm9scy5kb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcih0ZXN0LnNwZWVkLCBCYXNlLnN5bWJvbHMuZG90KSk7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuICAnKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQmFzZS5jb2xvcignZmFpbCcsIEJhc2Uuc3ltYm9scy5iYW5nKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxuJyk7XG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoRG90LCBCYXNlKTtcblxuRG90LmRlc2NyaXB0aW9uID0gJ2RvdCBtYXRyaXggcmVwcmVzZW50YXRpb24nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qKlxuICogQG1vZHVsZSBIVE1MXG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcHJvZ3Jlc3MnKTtcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9TVUlURV9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTjtcbnZhciBFVkVOVF9TVUlURV9FTkQgPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKi9cblxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcblxuLyoqXG4gKiBFeHBvc2UgYEhUTUxgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEhUTUw7XG5cbi8qKlxuICogU3RhdHMgdGVtcGxhdGUuXG4gKi9cblxudmFyIHN0YXRzVGVtcGxhdGUgPVxuICAnPHVsIGlkPVwibW9jaGEtc3RhdHNcIj4nICtcbiAgJzxsaSBjbGFzcz1cInByb2dyZXNzXCI+PGNhbnZhcyB3aWR0aD1cIjQwXCIgaGVpZ2h0PVwiNDBcIj48L2NhbnZhcz48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwicGFzc2VzXCI+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5wYXNzZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcbiAgJzxsaSBjbGFzcz1cImZhaWx1cmVzXCI+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIj5mYWlsdXJlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xuICAnPGxpIGNsYXNzPVwiZHVyYXRpb25cIj5kdXJhdGlvbjogPGVtPjA8L2VtPnM8L2xpPicgK1xuICAnPC91bD4nO1xuXG52YXIgcGxheUljb24gPSAnJiN4MjAyMzsnO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEhUTUxgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEhUTUwocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgdmFyIHN0YXQgPSBmcmFnbWVudChzdGF0c1RlbXBsYXRlKTtcbiAgdmFyIGl0ZW1zID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcbiAgdmFyIHBhc3NlcyA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICB2YXIgcGFzc2VzTGluayA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XG4gIHZhciBmYWlsdXJlcyA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xuICB2YXIgZmFpbHVyZXNMaW5rID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcbiAgdmFyIGR1cmF0aW9uID0gaXRlbXNbM10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XG4gIHZhciBjYW52YXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKVswXTtcbiAgdmFyIHJlcG9ydCA9IGZyYWdtZW50KCc8dWwgaWQ9XCJtb2NoYS1yZXBvcnRcIj48L3VsPicpO1xuICB2YXIgc3RhY2sgPSBbcmVwb3J0XTtcbiAgdmFyIHByb2dyZXNzO1xuICB2YXIgY3R4O1xuICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpO1xuXG4gIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuICAgIHZhciByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCAqPSByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ICo9IHJhdGlvO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgIHByb2dyZXNzID0gbmV3IFByb2dyZXNzKCk7XG4gIH1cblxuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm4gZXJyb3IoJyNtb2NoYSBkaXYgbWlzc2luZywgYWRkIGl0IHRvIHlvdXIgZG9jdW1lbnQnKTtcbiAgfVxuXG4gIC8vIHBhc3MgdG9nZ2xlXG4gIG9uKHBhc3Nlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB1bmhpZGUoKTtcbiAgICB2YXIgbmFtZSA9IC9wYXNzLy50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIHBhc3MnO1xuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgcGFzcycpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZmFpbHVyZSB0b2dnbGVcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdW5oaWRlKCk7XG4gICAgdmFyIG5hbWUgPSAvZmFpbC8udGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBmYWlsJztcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IGZhaWwnKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XG4gIHJvb3QuYXBwZW5kQ2hpbGQocmVwb3J0KTtcblxuICBpZiAocHJvZ3Jlc3MpIHtcbiAgICBwcm9ncmVzcy5zaXplKDQwKTtcbiAgfVxuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdWl0ZVxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcbiAgICB2YXIgZWwgPSBmcmFnbWVudChcbiAgICAgICc8bGkgY2xhc3M9XCJzdWl0ZVwiPjxoMT48YSBocmVmPVwiJXNcIj4lczwvYT48L2gxPjwvbGk+JyxcbiAgICAgIHVybCxcbiAgICAgIGVzY2FwZShzdWl0ZS50aXRsZSlcbiAgICApO1xuXG4gICAgLy8gY29udGFpbmVyXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RhY2tbMF0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBpZiAoc3VpdGUucm9vdCkge1xuICAgICAgdXBkYXRlU3RhdHMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2suc2hpZnQoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgdXJsID0gc2VsZi50ZXN0VVJMKHRlc3QpO1xuICAgIHZhciBtYXJrdXAgPVxuICAgICAgJzxsaSBjbGFzcz1cInRlc3QgcGFzcyAlZVwiPjxoMj4lZTxzcGFuIGNsYXNzPVwiZHVyYXRpb25cIj4lZW1zPC9zcGFuPiAnICtcbiAgICAgICc8YSBocmVmPVwiJXNcIiBjbGFzcz1cInJlcGxheVwiPicgK1xuICAgICAgcGxheUljb24gK1xuICAgICAgJzwvYT48L2gyPjwvbGk+JztcbiAgICB2YXIgZWwgPSBmcmFnbWVudChtYXJrdXAsIHRlc3Quc3BlZWQsIHRlc3QudGl0bGUsIHRlc3QuZHVyYXRpb24sIHVybCk7XG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xuICAgIHVwZGF0ZVN0YXRzKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGVsID0gZnJhZ21lbnQoXG4gICAgICAnPGxpIGNsYXNzPVwidGVzdCBmYWlsXCI+PGgyPiVlIDxhIGhyZWY9XCIlZVwiIGNsYXNzPVwicmVwbGF5XCI+JyArXG4gICAgICAgIHBsYXlJY29uICtcbiAgICAgICAgJzwvYT48L2gyPjwvbGk+JyxcbiAgICAgIHRlc3QudGl0bGUsXG4gICAgICBzZWxmLnRlc3RVUkwodGVzdClcbiAgICApO1xuICAgIHZhciBzdGFja1N0cmluZzsgLy8gTm90ZTogSW5jbHVkZXMgbGVhZGluZyBuZXdsaW5lXG4gICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xuXG4gICAgLy8gPD1JRTcgc3RyaW5naWZpZXMgdG8gW09iamVjdCBFcnJvcl0uIFNpbmNlIGl0IGNhbiBiZSBvdmVybG9hZGVkLCB3ZVxuICAgIC8vIGNoZWNrIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBzdHJpbmdpZnlpbmcuXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgIG1lc3NhZ2UgPSB0ZXN0LmVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIGlmICh0ZXN0LmVyci5zdGFjaykge1xuICAgICAgdmFyIGluZGV4T2ZNZXNzYWdlID0gdGVzdC5lcnIuc3RhY2suaW5kZXhPZih0ZXN0LmVyci5tZXNzYWdlKTtcbiAgICAgIGlmIChpbmRleE9mTWVzc2FnZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhY2tTdHJpbmcgPSB0ZXN0LmVyci5zdGFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2suc2xpY2UoXG4gICAgICAgICAgdGVzdC5lcnIubWVzc2FnZS5sZW5ndGggKyBpbmRleE9mTWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuc291cmNlVVJMICYmIHRlc3QuZXJyLmxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgZ2l2ZSB5b3UgYSBzdGFjay4gTGV0J3MgYXQgbGVhc3QgcHJvdmlkZSBhIHNvdXJjZSBsaW5lLlxuICAgICAgc3RhY2tTdHJpbmcgPSAnXFxuKCcgKyB0ZXN0LmVyci5zb3VyY2VVUkwgKyAnOicgKyB0ZXN0LmVyci5saW5lICsgJyknO1xuICAgIH1cblxuICAgIHN0YWNrU3RyaW5nID0gc3RhY2tTdHJpbmcgfHwgJyc7XG5cbiAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxuICAgICAgICBmcmFnbWVudChcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImh0bWwtZXJyb3JcIj4lc1xcbjxwcmUgY2xhc3M9XCJlcnJvclwiPiVlPC9wcmU+PC9kaXY+JyxcbiAgICAgICAgICB0ZXN0LmVyci5odG1sTWVzc2FnZSxcbiAgICAgICAgICBzdGFja1N0cmluZ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKFxuICAgICAgICBmcmFnbWVudCgnPGRpdiBjbGFzcz1cImh0bWwtZXJyb3JcIj4lczwvZGl2PicsIHRlc3QuZXJyLmh0bWxNZXNzYWdlKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoXG4gICAgICAgIGZyYWdtZW50KCc8cHJlIGNsYXNzPVwiZXJyb3JcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpXG4gICAgICApO1xuICAgIH1cblxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBlbCA9IGZyYWdtZW50KFxuICAgICAgJzxsaSBjbGFzcz1cInRlc3QgcGFzcyBwZW5kaW5nXCI+PGgyPiVlPC9oMj48L2xpPicsXG4gICAgICB0ZXN0LnRpdGxlXG4gICAgKTtcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcbiAgICB1cGRhdGVTdGF0cygpO1xuICB9KTtcblxuICBmdW5jdGlvbiBhcHBlbmRUb1N0YWNrKGVsKSB7XG4gICAgLy8gRG9uJ3QgY2FsbCAuYXBwZW5kQ2hpbGQgaWYgI21vY2hhLXJlcG9ydCB3YXMgYWxyZWFkeSAuc2hpZnQoKSdlZCBvZmYgdGhlIHN0YWNrLlxuICAgIGlmIChzdGFja1swXSkge1xuICAgICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRzKCkge1xuICAgIC8vIFRPRE86IGFkZCB0byBzdGF0c1xuICAgIHZhciBwZXJjZW50ID0gKChzdGF0cy50ZXN0cyAvIHJ1bm5lci50b3RhbCkgKiAxMDApIHwgMDtcbiAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgIHByb2dyZXNzLnVwZGF0ZShwZXJjZW50KS5kcmF3KGN0eCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgdmFyIG1zID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xuICAgIHRleHQocGFzc2VzLCBzdGF0cy5wYXNzZXMpO1xuICAgIHRleHQoZmFpbHVyZXMsIHN0YXRzLmZhaWx1cmVzKTtcbiAgICB0ZXh0KGR1cmF0aW9uLCAobXMgLyAxMDAwKS50b0ZpeGVkKDIpKTtcbiAgfVxufVxuXG4vKipcbiAqIE1ha2VzIGEgVVJMLCBwcmVzZXJ2aW5nIHF1ZXJ5c3RyaW5nIChcInNlYXJjaFwiKSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbmV3IFVSTC5cbiAqL1xuZnVuY3Rpb24gbWFrZVVybChzKSB7XG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuXG4gIC8vIFJlbW92ZSBwcmV2aW91cyBncmVwIHF1ZXJ5IHBhcmFtZXRlciBpZiBwcmVzZW50XG4gIGlmIChzZWFyY2gpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWz8mXWdyZXA9W14mXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArXG4gICAgJ2dyZXA9JyArXG4gICAgZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZVJlKHMpKVxuICApO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgc3VpdGUgVVJMLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXG4gKi9cbkhUTUwucHJvdG90eXBlLnN1aXRlVVJMID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHJldHVybiBtYWtlVXJsKHN1aXRlLmZ1bGxUaXRsZSgpKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSB0ZXN0IFVSTC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXG4gKi9cbkhUTUwucHJvdG90eXBlLnRlc3RVUkwgPSBmdW5jdGlvbiAodGVzdCkge1xuICByZXR1cm4gbWFrZVVybCh0ZXN0LmZ1bGxUaXRsZSgpKTtcbn07XG5cbi8qKlxuICogQWRkcyBjb2RlIHRvZ2dsZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgcHJvdmlkZWQgdGVzdCdzIGxpc3QgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxMSUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcbiAqL1xuSFRNTC5wcm90b3R5cGUuYWRkQ29kZVRvZ2dsZSA9IGZ1bmN0aW9uIChlbCwgY29udGVudHMpIHtcbiAgdmFyIGgyID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2gyJylbMF07XG5cbiAgb24oaDIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9KTtcblxuICB2YXIgcHJlID0gZnJhZ21lbnQoJzxwcmU+PGNvZGU+JWU8L2NvZGU+PC9wcmU+JywgdXRpbHMuY2xlYW4oY29udGVudHMpKTtcbiAgZWwuYXBwZW5kQ2hpbGQocHJlKTtcbiAgcHJlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG4vKipcbiAqIERpc3BsYXkgZXJyb3IgYG1zZ2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICovXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cIm1vY2hhLWVycm9yXCI+JXM8L2Rpdj4nLCBtc2cpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBET00gZnJhZ21lbnQgZnJvbSBgaHRtbGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnQoaHRtbCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgaSA9IDE7XG5cbiAgZGl2LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvJShbc2VdKS9nLCBmdW5jdGlvbiAoXywgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgICByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XG4gICAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXG4gKiB3aXRoIGBjbGFzc25hbWVgLCBhbmQgaGlkZSB0aGVtLlxuICpcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXG4gKi9cbmZ1bmN0aW9uIGhpZGVTdWl0ZXNXaXRob3V0KGNsYXNzbmFtZSkge1xuICB2YXIgc3VpdGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxzID0gc3VpdGVzW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NuYW1lKTtcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcbiAgICAgIHN1aXRlc1tpXS5jbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVuaGlkZSAuaGlkZGVuIHN1aXRlcy5cbiAqL1xuZnVuY3Rpb24gdW5oaWRlKCkge1xuICB2YXIgZWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUgaGlkZGVuJyk7XG4gIHdoaWxlIChlbHMubGVuZ3RoID4gMCkge1xuICAgIGVsc1swXS5jbGFzc05hbWUgPSBlbHNbMF0uY2xhc3NOYW1lLnJlcGxhY2UoJ3N1aXRlIGhpZGRlbicsICdzdWl0ZScpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGFuIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcbiAqL1xuZnVuY3Rpb24gdGV4dChlbCwgY29udGVudHMpIHtcbiAgaWYgKGVsLnRleHRDb250ZW50KSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50cztcbiAgfSBlbHNlIHtcbiAgICBlbC5pbm5lclRleHQgPSBjb250ZW50cztcbiAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cbiAqL1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XG4gIH1cbn1cblxuSFRNTC5icm93c2VyT25seSA9IHRydWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEFsaWFzIGV4cG9ydHMgdG8gYSB0aGVpciBub3JtYWxpemVkIGZvcm1hdCBNb2NoYSNyZXBvcnRlciB0byBwcmV2ZW50IGEgbmVlZFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmV4cG9ydHMuRG90ID0gZXhwb3J0cy5kb3QgPSByZXF1aXJlKCcuL2RvdCcpO1xuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcbmV4cG9ydHMuSlNPTiA9IGV4cG9ydHMuanNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcbmV4cG9ydHMuTWluID0gZXhwb3J0cy5taW4gPSByZXF1aXJlKCcuL21pbicpO1xuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcbmV4cG9ydHMuWFVuaXQgPSBleHBvcnRzLnh1bml0ID0gcmVxdWlyZSgnLi94dW5pdCcpO1xuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcbmV4cG9ydHMuTGFuZGluZyA9IGV4cG9ydHMubGFuZGluZyA9IHJlcXVpcmUoJy4vbGFuZGluZycpO1xuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBKU09OU3RyZWFtXG4gKi9cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfUlVOX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTjtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBKU09OU3RyZWFtYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OU3RyZWFtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYEpTT05TdHJlYW1gIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEpTT05TdHJlYW0ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHdyaXRlRXZlbnQoWydzdGFydCcsIHt0b3RhbDogdG90YWx9XSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgd3JpdGVFdmVudChbJ3Bhc3MnLCBjbGVhbih0ZXN0KV0pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XG4gICAgdGVzdCA9IGNsZWFuKHRlc3QpO1xuICAgIHRlc3QuZXJyID0gZXJyLm1lc3NhZ2U7XG4gICAgdGVzdC5zdGFjayA9IGVyci5zdGFjayB8fCBudWxsO1xuICAgIHdyaXRlRXZlbnQoWydmYWlsJywgdGVzdF0pO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgd3JpdGVFdmVudChbJ2VuZCcsIHNlbGYuc3RhdHNdKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTW9jaGEgZXZlbnQgdG8gYmUgd3JpdHRlbiB0byB0aGUgb3V0cHV0IHN0cmVhbS5cbiAqIEB0eXBlZGVmIHtBcnJheX0gSlNPTlN0cmVhbX5Nb2NoYUV2ZW50XG4gKi9cblxuLyoqXG4gKiBXcml0ZXMgTW9jaGEgZXZlbnQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtKU09OU3RyZWFtfk1vY2hhRXZlbnR9IGV2ZW50IC0gTW9jaGEgZXZlbnQgdG8gYmUgb3V0cHV0LlxuICovXG5mdW5jdGlvbiB3cml0ZUV2ZW50KGV2ZW50KSB7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KGV2ZW50KSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBsaXRlcmFsIHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcywgZXRjLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3QgLSBJbnN0YW5jZSB1c2VkIGFzIGRhdGEgc291cmNlLlxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJlZC1kb3duIHRlc3QgaW5zdGFuY2UgZGF0YVxuICovXG5mdW5jdGlvbiBjbGVhbih0ZXN0KSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxuICAgIGZpbGU6IHRlc3QuZmlsZSxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcbiAgICBjdXJyZW50UmV0cnk6IHRlc3QuY3VycmVudFJldHJ5KCksXG4gICAgc3BlZWQ6IHRlc3Quc3BlZWRcbiAgfTtcbn1cblxuSlNPTlN0cmVhbS5kZXNjcmlwdGlvbiA9ICduZXdsaW5lIGRlbGltaXRlZCBKU09OIGV2ZW50cyc7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgSlNPTlxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG5cbi8qKlxuICogRXhwb3NlIGBKU09OYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIEpTT05cbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIocnVubmVyLCBvcHRpb25zID0ge30pIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgdmFyIGZhaWx1cmVzID0gW107XG4gIHZhciBwYXNzZXMgPSBbXTtcbiAgdmFyIG91dHB1dDtcblxuICBpZiAob3B0aW9ucy5yZXBvcnRlck9wdGlvbiAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9uLm91dHB1dCkge1xuICAgIGlmICh1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhyb3cgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb24ub3V0cHV0O1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcGFzc2VzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBwZW5kaW5nLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXG4gICAgICB0ZXN0czogdGVzdHMubWFwKGNsZWFuKSxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcubWFwKGNsZWFuKSxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxuICAgICAgcGFzc2VzOiBwYXNzZXMubWFwKGNsZWFuKVxuICAgIH07XG5cbiAgICBydW5uZXIudGVzdFJlc3VsdHMgPSBvYmo7XG5cbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvdXRwdXQpLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0LCBqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGAke0Jhc2Uuc3ltYm9scy5lcnJ9IFttb2NoYV0gd3JpdGluZyBvdXRwdXQgdG8gXCIke291dHB1dH1cIiBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9XFxuYFxuICAgICAgICApO1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShqc29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoanNvbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY2xlYW4odGVzdCkge1xuICB2YXIgZXJyID0gdGVzdC5lcnIgfHwge307XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGVyciA9IGVycm9ySlNPTihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXG4gICAgZmlsZTogdGVzdC5maWxlLFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcbiAgICBzcGVlZDogdGVzdC5zcGVlZCxcbiAgICBlcnI6IGNsZWFuQ3ljbGVzKGVycilcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbnNpZGUgYG9iamAgd2l0aCAnW29iamVjdCBPYmplY3RdJ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuQ3ljbGVzKG9iaikge1xuICB2YXIgY2FjaGUgPSBbXTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhY2hlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgaW4gYSBjaXJjbGUsIHdlJ2xsIHByaW50IFtvYmplY3QgT2JqZWN0XVxuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gRXJyb3Igb2JqZWN0IGludG8gYSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVycm9ySlNPTihlcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZXJyW2tleV07XG4gIH0sIGVycik7XG4gIHJldHVybiByZXM7XG59XG5cbkpTT05SZXBvcnRlci5kZXNjcmlwdGlvbiA9ICdzaW5nbGUgSlNPTiBvYmplY3QnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIExhbmRpbmdcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9URVNUX0VORCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0VORDtcbnZhciBTVEFURV9GQUlMRUQgPSByZXF1aXJlKCcuLi9ydW5uYWJsZScpLmNvbnN0YW50cy5TVEFURV9GQUlMRUQ7XG5cbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG5cbi8qKlxuICogRXhwb3NlIGBMYW5kaW5nYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMYW5kaW5nO1xuXG4vKipcbiAqIEFpcnBsYW5lIGNvbG9yLlxuICovXG5cbkJhc2UuY29sb3JzLnBsYW5lID0gMDtcblxuLyoqXG4gKiBBaXJwbGFuZSBjcmFzaCBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9yc1sncGxhbmUgY3Jhc2gnXSA9IDMxO1xuXG4vKipcbiAqIFJ1bndheSBjb2xvci5cbiAqL1xuXG5CYXNlLmNvbG9ycy5ydW53YXkgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBMYW5kaW5nYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gSW5zdGFuY2UgdHJpZ2dlcnMgcmVwb3J0ZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBydW5uZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBMYW5kaW5nKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB3aWR0aCA9IChCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUpIHwgMDtcbiAgdmFyIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0O1xuXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcbiAgdmFyIGNyYXNoZWQgPSAtMTtcbiAgdmFyIG4gPSAwO1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZ1bmN0aW9uIHJ1bndheSgpIHtcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcbiAgICByZXR1cm4gJyAgJyArIGNvbG9yKCdydW53YXknLCBidWYpO1xuICB9XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS53cml0ZSgnXFxuXFxuXFxuICAnKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHBsYW5lIGNyYXNoZWRcbiAgICB2YXIgY29sID0gY3Jhc2hlZCA9PT0gLTEgPyAoKHdpZHRoICogKytuKSAvICsrdG90YWwpIHwgMCA6IGNyYXNoZWQ7XG4gICAgLy8gc2hvdyB0aGUgY3Jhc2hcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gU1RBVEVfRkFJTEVEKSB7XG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcbiAgICAgIGNyYXNoZWQgPSBjb2w7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIGxhbmRpbmcgc3RyaXBcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbJyArICh3aWR0aCArIDEpICsgJ0RcXHUwMDFiWzJBJyk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcbiAgJyk7XG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheShjb2wpLmpvaW4oJ+KLhScpKSk7XG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KHdpZHRoIC0gY29sKS5qb2luKCfii4UnKSArICdcXG4nKSk7XG4gICAgc3RyZWFtLndyaXRlKHJ1bndheSgpKTtcbiAgICBzdHJlYW0ud3JpdGUoJ1xcdTAwMWJbMG0nKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG5cbiAgLy8gaWYgY3Vyc29yIGlzIGhpZGRlbiB3aGVuIHdlIGN0cmwtQywgdGhlbiBpdCB3aWxsIHJlbWFpbiBoaWRkZW4gdW5sZXNzLi4uXG4gIHByb2Nlc3Mub25jZSgnU0lHSU5UJywgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsICdTSUdJTlQnKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xuXG5MYW5kaW5nLmRlc2NyaXB0aW9uID0gJ1VuaWNvZGUgbGFuZGluZyBzdHJpcCc7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgTGlzdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfVEVTVF9CRUdJTjtcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XG5cbi8qKlxuICogRXhwb3NlIGBMaXN0YC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYExpc3RgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIExpc3QocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG4gPSAwO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfQkVHSU4sIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Bhc3MnLCAnICAgICcgKyB0ZXN0LmZ1bGxUaXRsZSgpICsgJzogJykpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgLScpICsgY29sb3IoJ3BlbmRpbmcnLCAnICVzJyk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9XG4gICAgICBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xuICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzOiAnKSArXG4gICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnJWRtcycpO1xuICAgIGN1cnNvci5DUigpO1xuICAgIEJhc2UuY29uc29sZUxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCksIHRlc3QuZHVyYXRpb24pO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIGN1cnNvci5DUigpO1xuICAgIEJhc2UuY29uc29sZUxvZyhjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QuZnVsbFRpdGxlKCkpO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhMaXN0LCBCYXNlKTtcblxuTGlzdC5kZXNjcmlwdGlvbiA9ICdsaWtlIFwic3BlY1wiIHJlcG9ydGVyIGJ1dCBmbGF0JztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBNYXJrZG93blxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9FTkQgPSBjb25zdGFudHMuRVZFTlRfUlVOX0VORDtcbnZhciBFVkVOVF9TVUlURV9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTjtcbnZhciBFVkVOVF9TVUlURV9FTkQgPSBjb25zdGFudHMuRVZFTlRfU1VJVEVfRU5EO1xudmFyIEVWRU5UX1RFU1RfUEFTUyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1M7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIFNVSVRFX1BSRUZJWCA9ICckJztcblxuLyoqXG4gKiBFeHBvc2UgYE1hcmtkb3duYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNYXJrZG93bjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBNYXJrZG93bmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWFya2Rvd24ocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHZhciBidWYgPSAnJztcblxuICBmdW5jdGlvbiB0aXRsZShzdHIpIHtcbiAgICByZXR1cm4gQXJyYXkobGV2ZWwpLmpvaW4oJyMnKSArICcgJyArIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFRPQyhzdWl0ZSwgb2JqKSB7XG4gICAgdmFyIHJldCA9IG9iajtcbiAgICB2YXIga2V5ID0gU1VJVEVfUFJFRklYICsgc3VpdGUudGl0bGU7XG5cbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHtzdWl0ZTogc3VpdGV9O1xuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgICAgbWFwVE9DKHN1aXRlLCBvYmopO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVRPQyhvYmosIGxldmVsKSB7XG4gICAgKytsZXZlbDtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgdmFyIGxpbms7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKGtleSA9PT0gJ3N1aXRlJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgIT09IFNVSVRFX1BSRUZJWCkge1xuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcbiAgICAgICAgbGluayArPSAnKCMnICsgdXRpbHMuc2x1ZyhvYmpba2V5XS5zdWl0ZS5mdWxsVGl0bGUoKSkgKyAnKVxcbic7XG4gICAgICAgIGJ1ZiArPSBBcnJheShsZXZlbCkuam9pbignICAnKSArIGxpbms7XG4gICAgICB9XG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVRPQyhzdWl0ZSkge1xuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VE9DKG9iaiwgMCk7XG4gIH1cblxuICBnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgKytsZXZlbDtcbiAgICB2YXIgc2x1ZyA9IHV0aWxzLnNsdWcoc3VpdGUuZnVsbFRpdGxlKCkpO1xuICAgIGJ1ZiArPSAnPGEgbmFtZT1cIicgKyBzbHVnICsgJ1wiPjwvYT4nICsgJ1xcbic7XG4gICAgYnVmICs9IHRpdGxlKHN1aXRlLnRpdGxlKSArICdcXG4nO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgLS1sZXZlbDtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XG4gICAgYnVmICs9IHRlc3QudGl0bGUgKyAnLlxcbic7XG4gICAgYnVmICs9ICdcXG5gYGBqc1xcbic7XG4gICAgYnVmICs9IGNvZGUgKyAnXFxuJztcbiAgICBidWYgKz0gJ2BgYFxcblxcbic7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnIyBUT0NcXG4nKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShidWYpO1xuICB9KTtcbn1cblxuTWFya2Rvd24uZGVzY3JpcHRpb24gPSAnR2l0SHViIEZsYXZvcmVkIE1hcmtkb3duJztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBNaW5cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfUlVOX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTjtcblxuLyoqXG4gKiBFeHBvc2UgYE1pbmAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWluO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYE1pbmAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIG1pbmltYWwgdGVzdCByZXBvcnRlciBpcyBiZXN0IHVzZWQgd2l0aCAnLS13YXRjaCcuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWluKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICBydW5uZXIub24oRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYXIgc2NyZWVuXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMkonKTtcbiAgICAvLyBzZXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcdTAwMWJbMTszSCcpO1xuICB9KTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fRU5ELCB0aGlzLmVwaWxvZ3VlLmJpbmQodGhpcykpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxuICovXG5pbmhlcml0cyhNaW4sIEJhc2UpO1xuXG5NaW4uZGVzY3JpcHRpb24gPSAnZXNzZW50aWFsbHkganVzdCBhIHN1bW1hcnknO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIE55YW5cbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBFVkVOVF9SVU5fQkVHSU4gPSBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcblxuLyoqXG4gKiBFeHBvc2UgYERvdGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBOeWFuYCByZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTnlhblxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIE55YW5DYXQocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC43NSkgfCAwO1xuICB2YXIgbnlhbkNhdFdpZHRoID0gKHRoaXMubnlhbkNhdFdpZHRoID0gMTEpO1xuXG4gIHRoaXMuY29sb3JJbmRleCA9IDA7XG4gIHRoaXMubnVtYmVyT2ZMaW5lcyA9IDQ7XG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcbiAgdGhpcy5zY29yZWJvYXJkV2lkdGggPSA1O1xuICB0aGlzLnRpY2sgPSAwO1xuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XG4gIHRoaXMudHJhamVjdG9yeVdpZHRoTWF4ID0gd2lkdGggLSBueWFuQ2F0V2lkdGg7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEVORElORywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZHJhdygpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kcmF3KCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRyYXcoKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIEJhc2UuY3Vyc29yLnNob3coKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubnVtYmVyT2ZMaW5lczsgaSsrKSB7XG4gICAgICB3cml0ZSgnXFxuJyk7XG4gICAgfVxuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKE55YW5DYXQsIEJhc2UpO1xuXG4vKipcbiAqIERyYXcgdGhlIG55YW4gY2F0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFwcGVuZFJhaW5ib3coKTtcbiAgdGhpcy5kcmF3U2NvcmVib2FyZCgpO1xuICB0aGlzLmRyYXdSYWluYm93KCk7XG4gIHRoaXMuZHJhd055YW5DYXQoKTtcbiAgdGhpcy50aWNrID0gIXRoaXMudGljaztcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgXCJzY29yZWJvYXJkXCIgc2hvd2luZyB0aGUgbnVtYmVyXG4gKiBvZiBwYXNzZXMsIGZhaWx1cmVzIGFuZCBwZW5kaW5nIHRlc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1Njb3JlYm9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgZnVuY3Rpb24gZHJhdyh0eXBlLCBuKSB7XG4gICAgd3JpdGUoJyAnKTtcbiAgICB3cml0ZShCYXNlLmNvbG9yKHR5cGUsIG4pKTtcbiAgICB3cml0ZSgnXFxuJyk7XG4gIH1cblxuICBkcmF3KCdncmVlbicsIHN0YXRzLnBhc3Nlcyk7XG4gIGRyYXcoJ2ZhaWwnLCBzdGF0cy5mYWlsdXJlcyk7XG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcbiAgd3JpdGUoJ1xcbicpO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogQXBwZW5kIHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlZ21lbnQgPSB0aGlzLnRpY2sgPyAnXycgOiAnLSc7XG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubnVtYmVyT2ZMaW5lczsgaW5kZXgrKykge1xuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xuICAgIGlmICh0cmFqZWN0b3J5Lmxlbmd0aCA+PSB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCkge1xuICAgICAgdHJhamVjdG9yeS5zaGlmdCgpO1xuICAgIH1cbiAgICB0cmFqZWN0b3J5LnB1c2gocmFpbmJvd2lmaWVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEcmF3IHRoZSByYWluYm93LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgd3JpdGUoJ1xcdTAwMWJbJyArIHNlbGYuc2NvcmVib2FyZFdpZHRoICsgJ0MnKTtcbiAgICB3cml0ZShsaW5lLmpvaW4oJycpKTtcbiAgICB3cml0ZSgnXFxuJyk7XG4gIH0pO1xuXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgbnlhbiBjYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xuICB2YXIgZGlzdCA9ICdcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xuICB2YXIgcGFkZGluZyA9ICcnO1xuXG4gIHdyaXRlKGRpc3QpO1xuICB3cml0ZSgnXywtLS0tLS0sJyk7XG4gIHdyaXRlKCdcXG4nKTtcblxuICB3cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgICcgOiAnICAgJztcbiAgd3JpdGUoJ198JyArIHBhZGRpbmcgKyAnL1xcXFxfL1xcXFwgJyk7XG4gIHdyaXRlKCdcXG4nKTtcblxuICB3cml0ZShkaXN0KTtcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICdfJyA6ICdfXyc7XG4gIHZhciB0YWlsID0gc2VsZi50aWNrID8gJ34nIDogJ14nO1xuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcbiAgd3JpdGUoJ1xcbicpO1xuXG4gIHdyaXRlKGRpc3QpO1xuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcbiAgd3JpdGUocGFkZGluZyArICdcIlwiICBcIlwiICcpO1xuICB3cml0ZSgnXFxuJyk7XG5cbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xufTtcblxuLyoqXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5mYWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcbiAgICByZXR1cm4gJyggeCAueCknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBlbmRpbmcpIHtcbiAgICByZXR1cm4gJyggbyAubyknO1xuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xuICAgIHJldHVybiAnKCBeIC5eKSc7XG4gIH1cbiAgcmV0dXJuICcoIC0gLi0pJztcbn07XG5cbi8qKlxuICogTW92ZSBjdXJzb3IgdXAgYG5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICovXG5cbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24gKG4pIHtcbiAgd3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQScpO1xufTtcblxuLyoqXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuXG5OeWFuQ2F0LnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24gKG4pIHtcbiAgd3JpdGUoJ1xcdTAwMWJbJyArIG4gKyAnQicpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29sb3JzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2ICogNzsgaSsrKSB7XG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xuICAgIHZhciBuID0gaSAqICgxLjAgLyA2KTtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuICsgMiAqIHBpMykgKyAzKTtcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcnM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHJhaW5ib3cgdG8gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcbiAgdGhpcy5jb2xvckluZGV4ICs9IDE7XG4gIHJldHVybiAnXFx1MDAxYlszODs1OycgKyBjb2xvciArICdtJyArIHN0ciArICdcXHUwMDFiWzBtJztcbn07XG5cbi8qKlxuICogU3Rkb3V0IGhlbHBlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgbWVzc2FnZSB0byB3cml0ZSB0byBzdGRvdXQuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlKHN0cmluZykge1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpO1xufVxuXG5OeWFuQ2F0LmRlc2NyaXB0aW9uID0gJ1wibnlhbiBjYXRcIic7XG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgUHJvZ3Jlc3NcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XG5cbi8qKlxuICogRXhwb3NlIGBQcm9ncmVzc2AuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XG5cbi8qKlxuICogR2VuZXJhbCBwcm9ncmVzcyBiYXIgY29sb3IuXG4gKi9cblxuQmFzZS5jb2xvcnMucHJvZ3Jlc3MgPSA5MDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGBQcm9ncmVzc2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUHJvZ3Jlc3MocnVubmVyLCBvcHRpb25zKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIsIG9wdGlvbnMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHdpZHRoID0gKEJhc2Uud2luZG93LndpZHRoICogMC41KSB8IDA7XG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcbiAgdmFyIGNvbXBsZXRlID0gMDtcbiAgdmFyIGxhc3ROID0gLTE7XG5cbiAgLy8gZGVmYXVsdCBjaGFyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlcG9ydGVyT3B0aW9ucyA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zIHx8IHt9O1xuXG4gIG9wdGlvbnMub3BlbiA9IHJlcG9ydGVyT3B0aW9ucy5vcGVuIHx8ICdbJztcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcbiAgb3B0aW9ucy5pbmNvbXBsZXRlID0gcmVwb3J0ZXJPcHRpb25zLmluY29tcGxldGUgfHwgQmFzZS5zeW1ib2xzLmRvdDtcbiAgb3B0aW9ucy5jbG9zZSA9IHJlcG9ydGVyT3B0aW9ucy5jbG9zZSB8fCAnXSc7XG4gIG9wdGlvbnMudmVyYm9zZSA9IHJlcG9ydGVyT3B0aW9ucy52ZXJib3NlIHx8IGZhbHNlO1xuXG4gIC8vIHRlc3RzIHN0YXJ0ZWRcbiAgcnVubmVyLm9uKEVWRU5UX1JVTl9CRUdJTiwgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICB9KTtcblxuICAvLyB0ZXN0cyBjb21wbGV0ZVxuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBjb21wbGV0ZSsrO1xuXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xuICAgIHZhciBuID0gKHdpZHRoICogcGVyY2VudCkgfCAwO1xuICAgIHZhciBpID0gd2lkdGggLSBuO1xuXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0TiA9IG47XG5cbiAgICBjdXJzb3IuQ1IoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFx1MDAxYltKJyk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KG4pLmpvaW4ob3B0aW9ucy5jb21wbGV0ZSkpO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcbiAgLy8gYW5kIHRoZSBmYWlsdXJlcyBpZiBhbnlcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGN1cnNvci5zaG93KCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgIHNlbGYuZXBpbG9ndWUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFByb2dyZXNzLCBCYXNlKTtcblxuUHJvZ3Jlc3MuZGVzY3JpcHRpb24gPSAnYSBwcm9ncmVzcyBiYXInO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIFNwZWNcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vcnVubmVyJykuY29uc3RhbnRzO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1NVSVRFX0VORCA9IGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQ7XG52YXIgRVZFTlRfVEVTVF9GQUlMID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfRkFJTDtcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcblxuLyoqXG4gKiBFeHBvc2UgYFNwZWNgLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNwZWM7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgU3BlY2AgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3BlYyhydW5uZXIsIG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lciwgb3B0aW9ucyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaW5kZW50cyA9IDA7XG4gIHZhciBuID0gMDtcblxuICBmdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XG4gIH1cblxuICBydW5uZXIub24oRVZFTlRfUlVOX0JFR0lOLCBmdW5jdGlvbiAoKSB7XG4gICAgQmFzZS5jb25zb2xlTG9nKCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9TVUlURV9CRUdJTiwgZnVuY3Rpb24gKHN1aXRlKSB7XG4gICAgKytpbmRlbnRzO1xuICAgIEJhc2UuY29uc29sZUxvZyhjb2xvcignc3VpdGUnLCAnJXMlcycpLCBpbmRlbnQoKSwgc3VpdGUudGl0bGUpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfU1VJVEVfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgLS1pbmRlbnRzO1xuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XG4gICAgICBCYXNlLmNvbnNvbGVMb2coKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdCA9IGluZGVudCgpICsgY29sb3IoJ3BlbmRpbmcnLCAnICAtICVzJyk7XG4gICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BBU1MsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdmFyIGZtdDtcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XG4gICAgICBmbXQgPVxuICAgICAgICBpbmRlbnQoKSArXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtdCA9XG4gICAgICAgIGluZGVudCgpICtcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcbiAgICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzJykgK1xuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xuICAgICAgQmFzZS5jb25zb2xlTG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XG4gICAgfVxuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIEJhc2UuY29uc29sZUxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xuXG5TcGVjLmRlc2NyaXB0aW9uID0gJ2hpZXJhcmNoaWNhbCAmIHZlcmJvc2UgW2RlZmF1bHRdJztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBUQVBcbiAqL1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xudmFyIHNwcmludGYgPSB1dGlsLmZvcm1hdDtcblxuLyoqXG4gKiBFeHBvc2UgYFRBUGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEFQO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFRBUGAgcmVwb3J0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lciAtIEluc3RhbmNlIHRyaWdnZXJzIHJlcG9ydGVyIGFjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcnVubmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVEFQKHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBuID0gMTtcblxuICB2YXIgdGFwVmVyc2lvbiA9ICcxMic7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLnRhcFZlcnNpb24pIHtcbiAgICAgIHRhcFZlcnNpb24gPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy50YXBWZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJvZHVjZXIgPSBjcmVhdGVQcm9kdWNlcih0YXBWZXJzaW9uKTtcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZVZlcnNpb24oKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgKytuO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9QRU5ESU5HLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHNlbGYuX3Byb2R1Y2VyLndyaXRlUGVuZGluZyhuLCB0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZVBhc3MobiwgdGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX0ZBSUwsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcbiAgICBzZWxmLl9wcm9kdWNlci53cml0ZUZhaWwobiwgdGVzdCwgZXJyKTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3Byb2R1Y2VyLndyaXRlRXBpbG9ndWUocnVubmVyLnN0YXRzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFRBUCwgQmFzZSk7XG5cbi8qKlxuICogUmV0dXJucyBhIFRBUC1zYWZlIHRpdGxlIG9mIGB0ZXN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtUZXN0fSB0ZXN0IC0gVGVzdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGl0bGUgd2l0aCBhbnkgaGFzaCBjaGFyYWN0ZXIgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiB0aXRsZSh0ZXN0KSB7XG4gIHJldHVybiB0ZXN0LmZ1bGxUaXRsZSgpLnJlcGxhY2UoLyMvZywgJycpO1xufVxuXG4vKipcbiAqIFdyaXRlcyBuZXdsaW5lLXRlcm1pbmF0ZWQgZm9ybWF0dGVkIHN0cmluZyB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gYHByaW50ZmAtbGlrZSBmb3JtYXQgc3RyaW5nXG4gKiBAcGFyYW0gey4uLip9IFt2YXJBcmdzXSAtIEZvcm1hdCBzdHJpbmcgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIHByaW50bG4oZm9ybWF0LCB2YXJBcmdzKSB7XG4gIHZhciB2YXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgdmFyZ3NbMF0gKz0gJ1xcbic7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHNwcmludGYuYXBwbHkobnVsbCwgdmFyZ3MpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYHRhcFZlcnNpb25gLWFwcHJvcHJpYXRlIFRBUCBwcm9kdWNlciBpbnN0YW5jZSwgaWYgcG9zc2libGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXBWZXJzaW9uIC0gVmVyc2lvbiBvZiBUQVAgc3BlY2lmaWNhdGlvbiB0byBwcm9kdWNlLlxuICogQHJldHVybnMge1RBUFByb2R1Y2VyfSBzcGVjaWZpY2F0aW9uLWFwcHJvcHJpYXRlIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIGhhcyBubyBhc3NvY2lhdGVkIHByb2R1Y2VyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9kdWNlcih0YXBWZXJzaW9uKSB7XG4gIHZhciBwcm9kdWNlcnMgPSB7XG4gICAgMTI6IG5ldyBUQVAxMlByb2R1Y2VyKCksXG4gICAgMTM6IG5ldyBUQVAxM1Byb2R1Y2VyKClcbiAgfTtcbiAgdmFyIHByb2R1Y2VyID0gcHJvZHVjZXJzW3RhcFZlcnNpb25dO1xuXG4gIGlmICghcHJvZHVjZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaW52YWxpZCBvciB1bnN1cHBvcnRlZCBUQVAgdmVyc2lvbjogJyArIEpTT04uc3RyaW5naWZ5KHRhcFZlcnNpb24pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwcm9kdWNlcjtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVBQcm9kdWNlci5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxlbT5Pbmx5PC9lbT4gdG8gYmUgdXNlZCBhcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVEFQUHJvZHVjZXIoKSB7fVxuXG4vKipcbiAqIFdyaXRlcyB0aGUgVEFQIHZlcnNpb24gdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgcGxhbiB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG50ZXN0cyAtIE51bWJlciBvZiB0ZXN0cyB0aGF0IGFyZSBwbGFubmVkIHRvIHJ1bi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGxhbiA9IGZ1bmN0aW9uIChudGVzdHMpIHtcbiAgcHJpbnRsbignJWQuLiVkJywgMSwgbnRlc3RzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIHRoYXQgdGVzdCBwYXNzZWQgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gSW5kZXggb2YgdGVzdCB0aGF0IHBhc3NlZC5cbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIEluc3RhbmNlIGNvbnRhaW5pbmcgdGVzdCBpbmZvcm1hdGlvbi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGFzcyA9IGZ1bmN0aW9uIChuLCB0ZXN0KSB7XG4gIHByaW50bG4oJ29rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhhdCB0ZXN0IHdhcyBza2lwcGVkIHRvIHJlcG9ydGVyIG91dHB1dCBzdHJlYW0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIEluZGV4IG9mIHRlc3QgdGhhdCB3YXMgc2tpcHBlZC5cbiAqIEBwYXJhbSB7VGVzdH0gdGVzdCAtIEluc3RhbmNlIGNvbnRhaW5pbmcgdGVzdCBpbmZvcm1hdGlvbi5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlUGVuZGluZyA9IGZ1bmN0aW9uIChuLCB0ZXN0KSB7XG4gIHByaW50bG4oJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IG4gLSBJbmRleCBvZiB0ZXN0IHRoYXQgZmFpbGVkLlxuICogQHBhcmFtIHtUZXN0fSB0ZXN0IC0gSW5zdGFuY2UgY29udGFpbmluZyB0ZXN0IGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gUmVhc29uIHRoZSB0ZXN0IGZhaWxlZC5cbiAqL1xuVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbCA9IGZ1bmN0aW9uIChuLCB0ZXN0LCBlcnIpIHtcbiAgcHJpbnRsbignbm90IG9rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIHN1bW1hcnkgZXBpbG9ndWUgdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0cyAtIE9iamVjdCBjb250YWluaW5nIHJ1biBzdGF0aXN0aWNzLlxuICovXG5UQVBQcm9kdWNlci5wcm90b3R5cGUud3JpdGVFcGlsb2d1ZSA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAvLyA6VEJEOiBXaHkgaXMgdGhpcyBub3QgY291bnRpbmcgcGVuZGluZyB0ZXN0cz9cbiAgcHJpbnRsbignIyB0ZXN0cyAnICsgKHN0YXRzLnBhc3NlcyArIHN0YXRzLmZhaWx1cmVzKSk7XG4gIHByaW50bG4oJyMgcGFzcyAnICsgc3RhdHMucGFzc2VzKTtcbiAgLy8gOlRCRDogV2h5IGFyZSB3ZSBub3Qgc2hvd2luZyBwZW5kaW5nIHJlc3VsdHM/XG4gIHByaW50bG4oJyMgZmFpbCAnICsgc3RhdHMuZmFpbHVyZXMpO1xuICB0aGlzLndyaXRlUGxhbihzdGF0cy5wYXNzZXMgKyBzdGF0cy5mYWlsdXJlcyArIHN0YXRzLnBlbmRpbmcpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVAxMlByb2R1Y2VyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvZHVjZXMgb3V0cHV0IGNvbmZvcm1pbmcgdG8gdGhlIFRBUDEyIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVEFQUHJvZHVjZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGVzdGFueXRoaW5nLm9yZy90YXAtc3BlY2lmaWNhdGlvbi5odG1sfFNwZWNpZmljYXRpb259XG4gKi9cbmZ1bmN0aW9uIFRBUDEyUHJvZHVjZXIoKSB7XG4gIC8qKlxuICAgKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLCB3aXRoIGVycm9yIGZvcm1hdHRpbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdGhpcy53cml0ZUZhaWwgPSBmdW5jdGlvbiAobiwgdGVzdCwgZXJyKSB7XG4gICAgVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbC5jYWxsKHRoaXMsIG4sIHRlc3QsIGVycik7XG4gICAgaWYgKGVyci5tZXNzYWdlKSB7XG4gICAgICBwcmludGxuKGVyci5tZXNzYWdlLnJlcGxhY2UoL14vZ20sICcgICcpKTtcbiAgICB9XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgcHJpbnRsbihlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJykpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYFRBUFByb2R1Y2VyLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFRBUDEyUHJvZHVjZXIsIFRBUFByb2R1Y2VyKTtcblxuLyoqXG4gKiBAc3VtbWFyeVxuICogQ29uc3RydWN0cyBhIG5ldyBUQVAxM1Byb2R1Y2VyLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvZHVjZXMgb3V0cHV0IGNvbmZvcm1pbmcgdG8gdGhlIFRBUDEzIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVEFQUHJvZHVjZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGVzdGFueXRoaW5nLm9yZy90YXAtdmVyc2lvbi0xMy1zcGVjaWZpY2F0aW9uLmh0bWx8U3BlY2lmaWNhdGlvbn1cbiAqL1xuZnVuY3Rpb24gVEFQMTNQcm9kdWNlcigpIHtcbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgVEFQIHZlcnNpb24gdG8gcmVwb3J0ZXIgb3V0cHV0IHN0cmVhbS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0aGlzLndyaXRlVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmludGxuKCdUQVAgdmVyc2lvbiAxMycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhhdCB0ZXN0IGZhaWxlZCB0byByZXBvcnRlciBvdXRwdXQgc3RyZWFtLCB3aXRoIGVycm9yIGZvcm1hdHRpbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdGhpcy53cml0ZUZhaWwgPSBmdW5jdGlvbiAobiwgdGVzdCwgZXJyKSB7XG4gICAgVEFQUHJvZHVjZXIucHJvdG90eXBlLndyaXRlRmFpbC5jYWxsKHRoaXMsIG4sIHRlc3QsIGVycik7XG4gICAgdmFyIGVtaXRZYW1sQmxvY2sgPSBlcnIubWVzc2FnZSAhPSBudWxsIHx8IGVyci5zdGFjayAhPSBudWxsO1xuICAgIGlmIChlbWl0WWFtbEJsb2NrKSB7XG4gICAgICBwcmludGxuKGluZGVudCgxKSArICctLS0nKTtcbiAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICBwcmludGxuKGluZGVudCgyKSArICdtZXNzYWdlOiB8LScpO1xuICAgICAgICBwcmludGxuKGVyci5tZXNzYWdlLnJlcGxhY2UoL14vZ20sIGluZGVudCgzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICBwcmludGxuKGluZGVudCgyKSArICdzdGFjazogfC0nKTtcbiAgICAgICAgcHJpbnRsbihlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgaW5kZW50KDMpKSk7XG4gICAgICB9XG4gICAgICBwcmludGxuKGluZGVudCgxKSArICcuLi4nKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5kZW50KGxldmVsKSB7XG4gICAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbignICAnKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgVEFQUHJvZHVjZXIucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoVEFQMTNQcm9kdWNlciwgVEFQUHJvZHVjZXIpO1xuXG5UQVAuZGVzY3JpcHRpb24gPSAnVEFQLWNvbXBhdGlibGUgb3V0cHV0JztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBYVW5pdFxuICovXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgY3JlYXRlVW5zdXBwb3J0ZWRFcnJvciA9IGVycm9ycy5jcmVhdGVVbnN1cHBvcnRlZEVycm9yO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL3J1bm5lcicpLmNvbnN0YW50cztcbnZhciBFVkVOVF9URVNUX1BBU1MgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9QQVNTO1xudmFyIEVWRU5UX1RFU1RfRkFJTCA9IGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUw7XG52YXIgRVZFTlRfUlVOX0VORCA9IGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EO1xudmFyIEVWRU5UX1RFU1RfUEVORElORyA9IGNvbnN0YW50cy5FVkVOVF9URVNUX1BFTkRJTkc7XG52YXIgU1RBVEVfRkFJTEVEID0gcmVxdWlyZSgnLi4vcnVubmFibGUnKS5jb25zdGFudHMuU1RBVEVfRkFJTEVEO1xudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKi9cbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XG5cbi8qKlxuICogRXhwb3NlIGBYVW5pdGAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXIgLSBJbnN0YW5jZSB0cmlnZ2VycyByZXBvcnRlciBhY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHJ1bm5lciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFhVbml0KHJ1bm5lciwgb3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgcnVubmVyLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHRoZSBuYW1lIG9mIHRoZSB0ZXN0IHN1aXRlLCBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgcmVzdWx0aW5nIFhNTCBmaWxlXG4gIHZhciBzdWl0ZU5hbWU7XG5cbiAgLy8gdGhlIGRlZmF1bHQgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSBpZiBub25lIGlzIHByb3ZpZGVkXG4gIHZhciBERUZBVUxUX1NVSVRFX05BTUUgPSAnTW9jaGEgVGVzdHMnO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkge1xuICAgICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKCdmaWxlIG91dHB1dCBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgIH1cblxuICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpLCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzZWxmLmZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgc3VpdGUgbmFtZSBmcm9tIHRoZSByZXBvcnRlciBvcHRpb25zIChpZiBwcm92aWRlZClcbiAgICBzdWl0ZU5hbWUgPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5zdWl0ZU5hbWU7XG4gIH1cblxuICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc3VpdGUgbmFtZVxuICBzdWl0ZU5hbWUgPSBzdWl0ZU5hbWUgfHwgREVGQVVMVF9TVUlURV9OQU1FO1xuXG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcbiAgfSk7XG5cbiAgcnVubmVyLm9uKEVWRU5UX1RFU1RfUEFTUywgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xuICB9KTtcblxuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAodGVzdCkge1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH0pO1xuXG4gIHJ1bm5lci5vbmNlKEVWRU5UX1JVTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRlKFxuICAgICAgdGFnKFxuICAgICAgICAndGVzdHN1aXRlJyxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IHN1aXRlTmFtZSxcbiAgICAgICAgICB0ZXN0czogc3RhdHMudGVzdHMsXG4gICAgICAgICAgZmFpbHVyZXM6IDAsXG4gICAgICAgICAgZXJyb3JzOiBzdGF0cy5mYWlsdXJlcyxcbiAgICAgICAgICBza2lwcGVkOiBzdGF0cy50ZXN0cyAtIHN0YXRzLmZhaWx1cmVzIC0gc3RhdHMucGFzc2VzLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b1VUQ1N0cmluZygpLFxuICAgICAgICAgIHRpbWU6IHN0YXRzLmR1cmF0aW9uIC8gMTAwMCB8fCAwXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgKTtcblxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHNlbGYudGVzdCh0KTtcbiAgICB9KTtcblxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cbiAqL1xuaW5oZXJpdHMoWFVuaXQsIEJhc2UpO1xuXG4vKipcbiAqIE92ZXJyaWRlIGRvbmUgdG8gY2xvc2UgdGhlIHN0cmVhbSAoaWYgaXQncyBhIGZpbGUpLlxuICpcbiAqIEBwYXJhbSBmYWlsdXJlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGZuKSB7XG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcbiAgICB0aGlzLmZpbGVTdHJlYW0uZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGZhaWx1cmVzKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmbihmYWlsdXJlcyk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXG4gKi9cblhVbml0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gIGlmICh0aGlzLmZpbGVTdHJlYW0pIHtcbiAgICB0aGlzLmZpbGVTdHJlYW0ud3JpdGUobGluZSArICdcXG4nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcbicpO1xuICB9IGVsc2Uge1xuICAgIEJhc2UuY29uc29sZUxvZyhsaW5lKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPdXRwdXQgdGFnIGZvciB0aGUgZ2l2ZW4gYHRlc3QuYFxuICpcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICovXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XG4gIEJhc2UudXNlQ29sb3JzID0gZmFsc2U7XG5cbiAgdmFyIGF0dHJzID0ge1xuICAgIGNsYXNzbmFtZTogdGVzdC5wYXJlbnQuZnVsbFRpdGxlKCksXG4gICAgbmFtZTogdGVzdC50aXRsZSxcbiAgICB0aW1lOiB0ZXN0LmR1cmF0aW9uIC8gMTAwMCB8fCAwXG4gIH07XG5cbiAgaWYgKHRlc3Quc3RhdGUgPT09IFNUQVRFX0ZBSUxFRCkge1xuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcbiAgICB2YXIgZGlmZiA9XG4gICAgICAhQmFzZS5oaWRlRGlmZiAmJiBCYXNlLnNob3dEaWZmKGVycilcbiAgICAgICAgPyAnXFxuJyArIEJhc2UuZ2VuZXJhdGVEaWZmKGVyci5hY3R1YWwsIGVyci5leHBlY3RlZClcbiAgICAgICAgOiAnJztcbiAgICB0aGlzLndyaXRlKFxuICAgICAgdGFnKFxuICAgICAgICAndGVzdGNhc2UnLFxuICAgICAgICBhdHRycyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRhZyhcbiAgICAgICAgICAnZmFpbHVyZScsXG4gICAgICAgICAge30sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZXNjYXBlKGVyci5tZXNzYWdlKSArIGVzY2FwZShkaWZmKSArICdcXG4nICsgZXNjYXBlKGVyci5zdGFjaylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdza2lwcGVkJywge30sIHRydWUpKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIHRydWUpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIVE1MIHRhZyBoZWxwZXIuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBhdHRyc1xuICogQHBhcmFtIGNsb3NlXG4gKiBAcGFyYW0gY29udGVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0YWcobmFtZSwgYXR0cnMsIGNsb3NlLCBjb250ZW50KSB7XG4gIHZhciBlbmQgPSBjbG9zZSA/ICcvPicgOiAnPic7XG4gIHZhciBwYWlycyA9IFtdO1xuICB2YXIgdGFnO1xuXG4gIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cnMsIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz1cIicgKyBlc2NhcGUoYXR0cnNba2V5XSkgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICB0YWcgPSAnPCcgKyBuYW1lICsgKHBhaXJzLmxlbmd0aCA/ICcgJyArIHBhaXJzLmpvaW4oJyAnKSA6ICcnKSArIGVuZDtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0YWcgKz0gY29udGVudCArICc8LycgKyBuYW1lICsgZW5kO1xuICB9XG4gIHJldHVybiB0YWc7XG59XG5cblhVbml0LmRlc2NyaXB0aW9uID0gJ1hVbml0LWNvbXBhdGlibGUgWE1MIG91dHB1dCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmFibGUnKTtcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCdtcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qge1xuICBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IsXG4gIGNyZWF0ZU11bHRpcGxlRG9uZUVycm9yLFxuICBjcmVhdGVUaW1lb3V0RXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBSdW5uYWJsZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSdW5uYWJsZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIGV4dGVybmFsOkV2ZW50RW1pdHRlclxuICogQHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBSdW5uYWJsZSh0aXRsZSwgZm4pIHtcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuYm9keSA9IChmbiB8fCAnJykudG9TdHJpbmcoKTtcbiAgdGhpcy5hc3luYyA9IGZuICYmIGZuLmxlbmd0aDtcbiAgdGhpcy5zeW5jID0gIXRoaXMuYXN5bmM7XG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xuICB0aGlzLl9zbG93ID0gNzU7XG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcbiAgdXRpbHMuYXNzaWduTmV3TW9jaGFJRCh0aGlzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZ2V0TW9jaGFJRCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xudXRpbHMuaW5oZXJpdHMoUnVubmFibGUsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBpbml0aWFsbHkgb3IgZm9yIGEgbmV4dCBydW4uXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xuICB0aGlzLl9jdXJyZW50UmV0cnkgPSAwO1xuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgZGVsZXRlIHRoaXMuc3RhdGU7XG4gIGRlbGV0ZSB0aGlzLmVycjtcbn07XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgdGltZW91dCB2YWx1ZSBpbiBtc2Vjcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge251bWJlcn0gY3VycmVudCB0aW1lb3V0IHRocmVzaG9sZCB2YWx1ZVxuICovXG4vKipcbiAqIEBzdW1tYXJ5XG4gKiBTZXQgdGltZW91dCB0aHJlc2hvbGQgdmFsdWUgKG1zZWNzKS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RyaW5nIGFyZ3VtZW50IGNhbiB1c2Ugc2hvcnRoYW5kIChlLmcuLCBcIjJzXCIpIGFuZCB3aWxsIGJlIGNvbnZlcnRlZC5cbiAqIFRoZSB2YWx1ZSB3aWxsIGJlIGNsYW1wZWQgdG8gcmFuZ2UgWzxjb2RlPjA8L2NvZGU+LCA8Y29kZT4yXjxzdXA+MzE8L3N1cD4tMTwvY29kZT5dLlxuICogSWYgY2xhbXBlZCB2YWx1ZSBtYXRjaGVzIGVpdGhlciByYW5nZSBlbmRwb2ludCwgdGltZW91dHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvc2V0VGltZW91dCNNYXhpbXVtX2RlbGF5X3ZhbHVlfVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtcyAtIFRpbWVvdXQgdGhyZXNob2xkIHZhbHVlLlxuICogQHJldHVybnMge1J1bm5hYmxlfSB0aGlzXG4gKiBAY2hhaW5hYmxlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB9XG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xuICB9XG5cbiAgLy8gQ2xhbXAgdG8gcmFuZ2VcbiAgdmFyIElOVF9NQVggPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuICB2YXIgcmFuZ2UgPSBbMCwgSU5UX01BWF07XG4gIG1zID0gdXRpbHMuY2xhbXAobXMsIHJhbmdlKTtcblxuICAvLyBzZWUgIzE2NTIgZm9yIHJlYXNvbmluZ1xuICBpZiAobXMgPT09IHJhbmdlWzBdIHx8IG1zID09PSByYW5nZVsxXSkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBtcztcbiAgfVxuICBkZWJ1ZygndGltZW91dCAlZCcsIHRoaXMuX3RpbWVvdXQpO1xuXG4gIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCBzbG93IGBtc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCB0eXBlb2YgbXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XG4gIHRoaXMuX3Nsb3cgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhbHQgYW5kIG1hcmsgYXMgcGVuZGluZy5cbiAqXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcbiAqIEBwdWJsaWNcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGVuZGluZyA9IHRydWU7XG4gIHRocm93IG5ldyBQZW5kaW5nKCdzeW5jIHNraXA7IGFib3J0aW5nIGV4ZWN1dGlvbicpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIHJ1bm5hYmxlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIGZhaWxlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfRkFJTEVEO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIHBhc3NlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNQYXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfUEFTU0VEO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiByZXRyaWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XG4gIH1cbiAgdGhpcy5fcmV0cmllcyA9IG47XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgY3VycmVudCByZXRyeVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5jdXJyZW50UmV0cnkgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJldHJ5O1xuICB9XG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IG47XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcbiAqIGZ1bGwgdGl0bGUuXG4gKlxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5mdWxsVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRpdGxlUGF0aCgpLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0aXRsZSBwYXRoIGdlbmVyYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQncyB0aXRsZSBwYXRoIHdpdGggdGhlIHRpdGxlLlxuICpcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5SdW5uYWJsZS5wcm90b3R5cGUudGl0bGVQYXRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQudGl0bGVQYXRoKCkuY29uY2F0KFt0aGlzLnRpdGxlXSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHRpbWVvdXQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLnJlc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKTtcblxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLnRpbWVvdXQoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmNhbGxiYWNrKHNlbGYuX3RpbWVvdXRFcnJvcihtcykpO1xuICAgIHNlbGYudGltZWRPdXQgPSB0cnVlO1xuICB9LCBtcyk7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgYSBsaXN0IG9mIHdoaXRlbGlzdGVkIGdsb2JhbHMgZm9yIHRoaXMgdGVzdCBydW4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcbiAqL1xuUnVubmFibGUucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoZ2xvYmFscykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsb3dlZEdsb2JhbHM7XG4gIH1cbiAgdGhpcy5fYWxsb3dlZEdsb2JhbHMgPSBnbG9iYWxzO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIHRlc3QgYW5kIGludm9rZSBgZm4oZXJyKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gIHZhciBmaW5pc2hlZDtcbiAgdmFyIGVycm9yV2FzSGFuZGxlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSByZXR1cm4gZm4oKTtcblxuICAvLyBTb21ldGltZXMgdGhlIGN0eCBleGlzdHMsIGJ1dCBpdCBpcyBub3QgcnVubmFibGVcbiAgaWYgKGN0eCAmJiBjdHgucnVubmFibGUpIHtcbiAgICBjdHgucnVubmFibGUodGhpcyk7XG4gIH1cblxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgZnVuY3Rpb24gbXVsdGlwbGUoZXJyKSB7XG4gICAgaWYgKGVycm9yV2FzSGFuZGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnJvcldhc0hhbmRsZWQgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBjcmVhdGVNdWx0aXBsZURvbmVFcnJvcihzZWxmLCBlcnIpKTtcbiAgfVxuXG4gIC8vIGZpbmlzaGVkXG4gIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgdmFyIG1zID0gc2VsZi50aW1lb3V0KCk7XG4gICAgaWYgKHNlbGYudGltZWRPdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsZShlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KCk7XG4gICAgc2VsZi5kdXJhdGlvbiA9IG5ldyBEYXRlKCkgLSBzdGFydDtcbiAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgaWYgKCFlcnIgJiYgc2VsZi5kdXJhdGlvbiA+IG1zICYmIG1zID4gMCkge1xuICAgICAgZXJyID0gc2VsZi5fdGltZW91dEVycm9yKG1zKTtcbiAgICB9XG4gICAgZm4oZXJyKTtcbiAgfVxuXG4gIC8vIGZvciAucmVzZXRUaW1lb3V0KCkgYW5kIFJ1bm5lciN1bmNhdWdodCgpXG4gIHRoaXMuY2FsbGJhY2sgPSBkb25lO1xuXG4gIGlmICh0aGlzLmZuICYmIHR5cGVvZiB0aGlzLmZuLmNhbGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBkb25lKFxuICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0EgcnVubmFibGUgbXVzdCBiZSBwYXNzZWQgYSBmdW5jdGlvbiBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50LidcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGV4cGxpY2l0IGFzeW5jIHdpdGggYGRvbmVgIGFyZ3VtZW50XG4gIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgIC8vIGFsbG93cyBza2lwKCkgdG8gYmUgdXNlZCBpbiBhbiBleHBsaWNpdCBhc3luYyBjb250ZXh0XG4gICAgdGhpcy5za2lwID0gZnVuY3Rpb24gYXN5bmNTa2lwKCkge1xuICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIGRvbmUoKTtcbiAgICAgIC8vIGhhbHQgZXhlY3V0aW9uLCB0aGUgdW5jYXVnaHQgaGFuZGxlciB3aWxsIGlnbm9yZSB0aGUgZmFpbHVyZS5cbiAgICAgIHRocm93IG5ldyBQZW5kaW5nKCdhc3luYyBza2lwOyBhYm9ydGluZyBleGVjdXRpb24nKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gaGFuZGxlcyBhc3luYyBydW5uYWJsZXMgd2hpY2ggYWN0dWFsbHkgcnVuIHN5bmNocm9ub3VzbHlcbiAgICAgIGVycm9yV2FzSGFuZGxlZCA9IHRydWU7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xuICAgICAgICByZXR1cm47IC8vIGRvbmUoKSBpcyBhbHJlYWR5IGNhbGxlZCBpbiB0aGlzLnNraXAoKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgZG9uZShSdW5uYWJsZS50b1ZhbHVlT3JFcnJvcihlcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3luYyBvciBwcm9taXNlLXJldHVybmluZ1xuICB0cnkge1xuICAgIGNhbGxGbih0aGlzLmZuKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JXYXNIYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBkb25lKFJ1bm5hYmxlLnRvVmFsdWVPckVycm9yKGVycikpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEZuKGZuKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZi5yZXNldFRpbWVvdXQoKTtcbiAgICAgIHJlc3VsdC50aGVuKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIC8vIFJldHVybiBudWxsIHNvIGxpYnJhcmllcyBsaWtlIGJsdWViaXJkIGRvIG5vdCB3YXJuIGFib3V0XG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgZG9uZShyZWFzb24gfHwgbmV3IEVycm9yKCdQcm9taXNlIHJlamVjdGVkIHdpdGggbm8gb3IgZmFsc3kgcmVhc29uJykpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsZi5hc3luY09ubHkpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJy0tYXN5bmMtb25seSBvcHRpb24gaW4gdXNlIHdpdGhvdXQgZGVjbGFyaW5nIGBkb25lKClgIG9yIHJldHVybmluZyBhIHByb21pc2UnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEZuQXN5bmMoZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgIHJldHVybiBkb25lKFxuICAgICAgICAgICAgbmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgZXJyKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBkb25lKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdSZXNvbHV0aW9uIG1ldGhvZCBpcyBvdmVyc3BlY2lmaWVkLiBTcGVjaWZ5IGEgY2FsbGJhY2sgKm9yKiByZXR1cm4gYSBQcm9taXNlOyBub3QgYm90aC4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgXCJ0aW1lb3V0XCIgZXJyb3JcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgLSBUaW1lb3V0IChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcmV0dXJucyB7RXJyb3J9IGEgXCJ0aW1lb3V0XCIgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5hYmxlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24gKG1zKSB7XG4gIGxldCBtc2cgPSBgVGltZW91dCBvZiAke21zfW1zIGV4Y2VlZGVkLiBGb3IgYXN5bmMgdGVzdHMgYW5kIGhvb2tzLCBlbnN1cmUgXCJkb25lKClcIiBpcyBjYWxsZWQ7IGlmIHJldHVybmluZyBhIFByb21pc2UsIGVuc3VyZSBpdCByZXNvbHZlcy5gO1xuICBpZiAodGhpcy5maWxlKSB7XG4gICAgbXNnICs9ICcgKCcgKyB0aGlzLmZpbGUgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVvdXRFcnJvcihtc2csIG1zLCB0aGlzLmZpbGUpO1xufTtcblxudmFyIGNvbnN0YW50cyA9IHV0aWxzLmRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBSdW5uYWJsZX0tcmVsYXRlZCBjb25zdGFudHMuXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlcm9mIFJ1bm5hYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAc3RhdGljXG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiBgc3RhdGVgIHByb3Agd2hlbiBhIGBSdW5uYWJsZWAgaGFzIGZhaWxlZFxuICAgICAqL1xuICAgIFNUQVRFX0ZBSUxFRDogJ2ZhaWxlZCcsXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgYHN0YXRlYCBwcm9wIHdoZW4gYSBgUnVubmFibGVgIGhhcyBwYXNzZWRcbiAgICAgKi9cbiAgICBTVEFURV9QQVNTRUQ6ICdwYXNzZWQnLFxuICAgIC8qKlxuICAgICAqIFZhbHVlIG9mIGBzdGF0ZWAgcHJvcCB3aGVuIGEgYFJ1bm5hYmxlYCBoYXMgYmVlbiBza2lwcGVkIGJ5IHVzZXJcbiAgICAgKi9cbiAgICBTVEFURV9QRU5ESU5HOiAncGVuZGluZydcbiAgfVxuKTtcblxuLyoqXG4gKiBHaXZlbiBgdmFsdWVgLCByZXR1cm4gaWRlbnRpdHkgaWYgdHJ1dGh5LCBvdGhlcndpc2UgY3JlYXRlIGFuIFwiaW52YWxpZCBleGNlcHRpb25cIiBlcnJvciBhbmQgcmV0dXJuIHRoYXQuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBWYWx1ZSB0byByZXR1cm4sIGlmIHByZXNlbnRcbiAqIEByZXR1cm5zIHsqfEVycm9yfSBgdmFsdWVgLCBvdGhlcndpc2UgYW4gYEVycm9yYFxuICogQHByaXZhdGVcbiAqL1xuUnVubmFibGUudG9WYWx1ZU9yRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSB8fFxuICAgIGNyZWF0ZUludmFsaWRFeGNlcHRpb25FcnJvcihcbiAgICAgICdSdW5uYWJsZSBmYWlsZWQgd2l0aCBmYWxzeSBvciB1bmRlZmluZWQgZXhjZXB0aW9uLiBQbGVhc2UgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZC4nLFxuICAgICAgdmFsdWVcbiAgICApXG4gICk7XG59O1xuXG5SdW5uYWJsZS5jb25zdGFudHMgPSBjb25zdGFudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmVyJyk7XG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XG52YXIgU3VpdGUgPSByZXF1aXJlKCcuL3N1aXRlJyk7XG52YXIgSE9PS19UWVBFX0JFRk9SRV9FQUNIID0gU3VpdGUuY29uc3RhbnRzLkhPT0tfVFlQRV9CRUZPUkVfRUFDSDtcbnZhciBIT09LX1RZUEVfQUZURVJfRUFDSCA9IFN1aXRlLmNvbnN0YW50cy5IT09LX1RZUEVfQUZURVJfRUFDSDtcbnZhciBIT09LX1RZUEVfQUZURVJfQUxMID0gU3VpdGUuY29uc3RhbnRzLkhPT0tfVFlQRV9BRlRFUl9BTEw7XG52YXIgSE9PS19UWVBFX0JFRk9SRV9BTEwgPSBTdWl0ZS5jb25zdGFudHMuSE9PS19UWVBFX0JFRk9SRV9BTEw7XG52YXIgRVZFTlRfUk9PVF9TVUlURV9SVU4gPSBTdWl0ZS5jb25zdGFudHMuRVZFTlRfUk9PVF9TVUlURV9SVU47XG52YXIgU1RBVEVfRkFJTEVEID0gUnVubmFibGUuY29uc3RhbnRzLlNUQVRFX0ZBSUxFRDtcbnZhciBTVEFURV9QQVNTRUQgPSBSdW5uYWJsZS5jb25zdGFudHMuU1RBVEVfUEFTU0VEO1xudmFyIFNUQVRFX1BFTkRJTkcgPSBSdW5uYWJsZS5jb25zdGFudHMuU1RBVEVfUEVORElORztcbnZhciBzdGFja0ZpbHRlciA9IHV0aWxzLnN0YWNrVHJhY2VGaWx0ZXIoKTtcbnZhciBzdHJpbmdpZnkgPSB1dGlscy5zdHJpbmdpZnk7XG5cbmNvbnN0IHtcbiAgY3JlYXRlSW52YWxpZEV4Y2VwdGlvbkVycm9yLFxuICBjcmVhdGVVbnN1cHBvcnRlZEVycm9yLFxuICBjcmVhdGVGYXRhbEVycm9yLFxuICBpc01vY2hhRXJyb3IsXG4gIGNvbnN0YW50czogZXJyb3JDb25zdGFudHNcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vKipcbiAqIE5vbi1lbnVtZXJhYmxlIGdsb2JhbHMuXG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cbnZhciBnbG9iYWxzID0gW1xuICAnc2V0VGltZW91dCcsXG4gICdjbGVhclRpbWVvdXQnLFxuICAnc2V0SW50ZXJ2YWwnLFxuICAnY2xlYXJJbnRlcnZhbCcsXG4gICdYTUxIdHRwUmVxdWVzdCcsXG4gICdEYXRlJyxcbiAgJ3NldEltbWVkaWF0ZScsXG4gICdjbGVhckltbWVkaWF0ZSdcbl07XG5cbnZhciBjb25zdGFudHMgPSB1dGlscy5kZWZpbmVDb25zdGFudHMoXG4gIC8qKlxuICAgKiB7QGxpbmsgUnVubmVyfS1yZWxhdGVkIGNvbnN0YW50cy5cbiAgICogQHB1YmxpY1xuICAgKiBAbWVtYmVyb2YgUnVubmVyXG4gICAqIEByZWFkb25seVxuICAgKiBAYWxpYXMgY29uc3RhbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIEhvb2t9IGV4ZWN1dGlvbiBiZWdpbnNcbiAgICAgKi9cbiAgICBFVkVOVF9IT09LX0JFR0lOOiAnaG9vaycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBIb29rfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX0hPT0tfRU5EOiAnaG9vayBlbmQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBSb290IHtAbGluayBTdWl0ZX0gZXhlY3V0aW9uIGJlZ2lucyAoYWxsIGZpbGVzIGhhdmUgYmVlbiBwYXJzZWQgYW5kIGhvb2tzL3Rlc3RzIGFyZSByZWFkeSBmb3IgZXhlY3V0aW9uKVxuICAgICAqL1xuICAgIEVWRU5UX1JVTl9CRUdJTjogJ3N0YXJ0JyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gUm9vdCB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBoYXMgYmVlbiBkZWxheWVkIHZpYSBgZGVsYXlgIG9wdGlvblxuICAgICAqL1xuICAgIEVWRU5UX0RFTEFZX0JFR0lOOiAnd2FpdGluZycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGRlbGF5ZWQgUm9vdCB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBpcyB0cmlnZ2VyZWQgYnkgdXNlciB2aWEgYGdsb2JhbC5ydW4oKWBcbiAgICAgKi9cbiAgICBFVkVOVF9ERUxBWV9FTkQ6ICdyZWFkeScsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIFJvb3Qge0BsaW5rIFN1aXRlfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX1JVTl9FTkQ6ICdlbmQnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgU3VpdGV9IGV4ZWN1dGlvbiBiZWdpbnNcbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9CRUdJTjogJ3N1aXRlJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFN1aXRlfSBleGVjdXRpb24gZW5kc1xuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0VORDogJ3N1aXRlIGVuZCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBleGVjdXRpb24gYmVnaW5zXG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9CRUdJTjogJ3Rlc3QnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIGVuZHNcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX0VORDogJ3Rlc3QgZW5kJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGV4ZWN1dGlvbiBmYWlsc1xuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfRkFJTDogJ2ZhaWwnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB7QGxpbmsgVGVzdH0gZXhlY3V0aW9uIHN1Y2NlZWRzXG4gICAgICovXG4gICAgRVZFTlRfVEVTVF9QQVNTOiAncGFzcycsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHtAbGluayBUZXN0fSBiZWNvbWVzIHBlbmRpbmdcbiAgICAgKi9cbiAgICBFVkVOVF9URVNUX1BFTkRJTkc6ICdwZW5kaW5nJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ge0BsaW5rIFRlc3R9IGV4ZWN1dGlvbiBoYXMgZmFpbGVkLCBidXQgd2lsbCByZXRyeVxuICAgICAqL1xuICAgIEVWRU5UX1RFU1RfUkVUUlk6ICdyZXRyeScsXG4gICAgLyoqXG4gICAgICogSW5pdGlhbCBzdGF0ZSBvZiBSdW5uZXJcbiAgICAgKi9cbiAgICBTVEFURV9JRExFOiAnaWRsZScsXG4gICAgLyoqXG4gICAgICogU3RhdGUgc2V0IHRvIHRoaXMgdmFsdWUgd2hlbiB0aGUgUnVubmVyIGhhcyBzdGFydGVkIHJ1bm5pbmdcbiAgICAgKi9cbiAgICBTVEFURV9SVU5OSU5HOiAncnVubmluZycsXG4gICAgLyoqXG4gICAgICogU3RhdGUgc2V0IHRvIHRoaXMgdmFsdWUgd2hlbiB0aGUgUnVubmVyIGhhcyBzdG9wcGVkXG4gICAgICovXG4gICAgU1RBVEVfU1RPUFBFRDogJ3N0b3BwZWQnXG4gIH1cbik7XG5cbmNsYXNzIFJ1bm5lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgYFJ1bm5lcmAgYXQgdGhlIFJvb3Qge0BsaW5rIFN1aXRlfSwgd2hpY2ggcmVwcmVzZW50cyBhIGhpZXJhcmNoeSBvZiB7QGxpbmsgU3VpdGV8U3VpdGVzfSBhbmQge0BsaW5rIFRlc3R8VGVzdHN9LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBleHRlcm5hbDpFdmVudEVtaXR0ZXJcbiAgICogQHB1YmxpY1xuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgLSBSb290IHN1aXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBTZXR0aW5ncyBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5jbGVhblJlZmVyZW5jZXNBZnRlclJ1bl0gLSBXaGV0aGVyIHRvIGNsZWFuIHJlZmVyZW5jZXMgdG8gdGVzdCBmbnMgYW5kIGhvb2tzIHdoZW4gYSBzdWl0ZSBpcyBkb25lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRlbGF5XSAtIFdoZXRoZXIgdG8gZGVsYXkgZXhlY3V0aW9uIG9mIHJvb3Qgc3VpdGUgdW50aWwgcmVhZHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZHJ5UnVuXSAtIFdoZXRoZXIgdG8gcmVwb3J0IHRlc3RzIHdpdGhvdXQgcnVubmluZyB0aGVtLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZhaWxaZXJvXSAtIFdoZXRoZXIgdG8gZmFpbCB0ZXN0IHJ1biBpZiB6ZXJvIHRlc3RzIGVuY291bnRlcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3VpdGUsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fZ2xvYmFscyA9IFtdO1xuICAgIHRoaXMuX2Fib3J0ID0gZmFsc2U7XG4gICAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHMuU1RBVEVfSURMRTtcbiAgICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcbiAgICB0aGlzLmZhaWx1cmVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPEV2ZW50RW1pdHRlcixNYXA8c3RyaW5nLFNldDxFdmVudExpc3RlbmVyPj4+fVxuICAgICAqL1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub24oY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCBmdW5jdGlvbiAodGVzdCkge1xuICAgICAgaWYgKHRlc3QudHlwZSA9PT0gJ3Rlc3QnICYmIHRlc3QucmV0cmllZFRlc3QoKSAmJiB0ZXN0LnBhcmVudCkge1xuICAgICAgICB2YXIgaWR4ID1cbiAgICAgICAgICB0ZXN0LnBhcmVudC50ZXN0cyAmJiB0ZXN0LnBhcmVudC50ZXN0cy5pbmRleE9mKHRlc3QucmV0cmllZFRlc3QoKSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkgdGVzdC5wYXJlbnQudGVzdHNbaWR4XSA9IHRlc3Q7XG4gICAgICB9XG4gICAgICBzZWxmLmNoZWNrR2xvYmFscyh0ZXN0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKGNvbnN0YW50cy5FVkVOVF9IT09LX0VORCwgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHNlbGYuY2hlY2tHbG9iYWxzKGhvb2spO1xuICAgIH0pO1xuICAgIHRoaXMuX2RlZmF1bHRHcmVwID0gLy4qLztcbiAgICB0aGlzLmdyZXAodGhpcy5fZGVmYXVsdEdyZXApO1xuICAgIHRoaXMuZ2xvYmFscyh0aGlzLmdsb2JhbFByb3BzKCkpO1xuXG4gICAgdGhpcy51bmNhdWdodCA9IHRoaXMuX3VuY2F1Z2h0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bmhhbmRsZWQgPSAocmVhc29uLCBwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoaXNNb2NoYUVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ3RyYXBwZWQgdW5oYW5kbGVkIHJlamVjdGlvbiBjb21pbmcgb3V0IG9mIE1vY2hhOyBmb3J3YXJkaW5nIHRvIHVuY2F1Z2h0IGhhbmRsZXI6JyxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51bmNhdWdodChyZWFzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ3RyYXBwZWQgdW5oYW5kbGVkIHJlamVjdGlvbiBmcm9tIChwcm9iYWJseSkgdXNlciBjb2RlOyByZS1lbWl0dGluZyBvbiBwcm9jZXNzJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgIHByb2Nlc3MsXG4gICAgICAgICAgJ3VuaGFuZGxlZFJlamVjdGlvbicsXG4gICAgICAgICAgdGhpcy51bmhhbmRsZWRcbiAgICAgICAgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy51bmhhbmRsZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBwZXIgZm9yIHNldEltbWVkaWF0ZSwgcHJvY2Vzcy5uZXh0VGljaywgb3IgYnJvd3NlciBwb2x5ZmlsbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLmltbWVkaWF0ZWx5ID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBwcm9jZXNzLm5leHRUaWNrO1xuXG4vKipcbiAqIFJlcGxhY2VtZW50IGZvciBgdGFyZ2V0Lm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpYCB0aGF0IGRvZXMgYm9va2tlZXBpbmcgdG8gcmVtb3ZlIHRoZW0gd2hlbiB0aGlzIHJ1bm5lciBpbnN0YW5jZSBpcyBkaXNwb3NlZC5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSB0YXJnZXQgLSBUaGUgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuIC0gTGlzdGVuZXIgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGRlYnVnKFxuICAgICdfYWRkRXZlbnRMaXN0ZW5lcigpOiBhZGRpbmcgZm9yIGV2ZW50ICVzOyAlZCBjdXJyZW50IGxpc3RlbmVycycsXG4gICAgZXZlbnROYW1lLFxuICAgIHRhcmdldC5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSlcbiAgKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKFxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhcyh0YXJnZXQpICYmXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZ2V0KHRhcmdldCkuaGFzKGV2ZW50TmFtZSkgJiZcbiAgICB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQodGFyZ2V0KS5nZXQoZXZlbnROYW1lKS5oYXMobGlzdGVuZXIpXG4gICkge1xuICAgIGRlYnVnKFxuICAgICAgJ3dhcm5pbmc6IHRyaWVkIHRvIGF0dGFjaCBkdXBsaWNhdGUgZXZlbnQgbGlzdGVuZXIgZm9yICVzJyxcbiAgICAgIGV2ZW50TmFtZVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRhcmdldC5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgY29uc3QgdGFyZ2V0TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzKHRhcmdldClcbiAgICA/IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0YXJnZXQpXG4gICAgOiBuZXcgTWFwKCk7XG4gIGNvbnN0IHRhcmdldEV2ZW50TGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzLmhhcyhldmVudE5hbWUpXG4gICAgPyB0YXJnZXRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICA6IG5ldyBTZXQoKTtcbiAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgdGFyZ2V0TGlzdGVuZXJzLnNldChldmVudE5hbWUsIHRhcmdldEV2ZW50TGlzdGVuZXJzKTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2V0KHRhcmdldCwgdGFyZ2V0TGlzdGVuZXJzKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZW1lbnQgZm9yIGB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcilgIHRoYXQgYWxzbyB1cGRhdGVzIHRoZSBib29ra2VlcGluZy5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSB0YXJnZXQgLSBUaGUgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBMaXN0ZW5lciBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgdGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXG4gIGlmICh0aGlzLl9ldmVudExpc3RlbmVycy5oYXModGFyZ2V0KSkge1xuICAgIGNvbnN0IHRhcmdldExpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRMaXN0ZW5lcnMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgIGNvbnN0IHRhcmdldEV2ZW50TGlzdGVuZXJzID0gdGFyZ2V0TGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmICghdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuc2l6ZSkge1xuICAgICAgICB0YXJnZXRMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFyZ2V0TGlzdGVuZXJzLnNpemUpIHtcbiAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmRlbGV0ZSh0YXJnZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygndHJ5aW5nIHRvIHJlbW92ZSBsaXN0ZW5lciBmb3IgdW50cmFja2VkIG9iamVjdCAlcycsIHRhcmdldCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgc2V0IGR1cmluZyBhIHJ1biBvbiB0aGlzIGluc3RhbmNlLlxuICogUmVtYXJrOiB0aGlzIGRvZXMgX25vdF8gY2xlYW4vZGlzcG9zZSB0aGUgdGVzdHMgb3Igc3VpdGVzIHRoZW1zZWx2ZXMuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgodGFyZ2V0TGlzdGVuZXJzLCB0YXJnZXQpID0+IHtcbiAgICB0YXJnZXRMaXN0ZW5lcnMuZm9yRWFjaCgodGFyZ2V0RXZlbnRMaXN0ZW5lcnMsIGV2ZW50TmFtZSkgPT4ge1xuICAgICAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogUnVuIHRlc3RzIHdpdGggZnVsbCB0aXRsZXMgbWF0Y2hpbmcgYHJlYC4gVXBkYXRlcyBydW5uZXIudG90YWxcbiAqIHdpdGggbnVtYmVyIG9mIHRlc3RzIG1hdGNoZWQuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSwgaW52ZXJ0KSB7XG4gIGRlYnVnKCdncmVwKCk6IHNldHRpbmcgdG8gJXMnLCByZSk7XG4gIHRoaXMuX2dyZXAgPSByZTtcbiAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xuICB0aGlzLnRvdGFsID0gdGhpcy5ncmVwVG90YWwodGhpcy5zdWl0ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGVzdHMgbWF0Y2hpbmcgdGhlIGdyZXAgc2VhcmNoIGZvciB0aGVcbiAqIGdpdmVuIHN1aXRlLlxuICpcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZ3JlcFRvdGFsID0gZnVuY3Rpb24gKHN1aXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRvdGFsID0gMDtcblxuICBzdWl0ZS5lYWNoVGVzdChmdW5jdGlvbiAodGVzdCkge1xuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcbiAgICBpZiAoc2VsZi5faW52ZXJ0KSB7XG4gICAgICBtYXRjaCA9ICFtYXRjaDtcbiAgICB9XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0b3RhbCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGdsb2JhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoZ2xvYmFsKTtcblxuICAvLyBub24tZW51bWVyYWJsZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKH5wcm9wcy5pbmRleE9mKGdsb2JhbHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJvcHMucHVzaChnbG9iYWxzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8qKlxuICogQWxsb3cgdGhlIGdpdmVuIGBhcnJgIG9mIGdsb2JhbHMuXG4gKlxuICogQHB1YmxpY1xuICogQG1lbWJlcm9mIFJ1bm5lclxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcbiAgfVxuICBkZWJ1ZygnZ2xvYmFscygpOiBzZXR0aW5nIHRvICVPJywgYXJyKTtcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGFycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuY2hlY2tHbG9iYWxzID0gZnVuY3Rpb24gKHRlc3QpIHtcbiAgaWYgKCF0aGlzLmNoZWNrTGVha3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9rID0gdGhpcy5fZ2xvYmFscztcblxuICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsUHJvcHMoKTtcbiAgdmFyIGxlYWtzO1xuXG4gIGlmICh0ZXN0KSB7XG4gICAgb2sgPSBvay5jb25jYXQodGVzdC5fYWxsb3dlZEdsb2JhbHMgfHwgW10pO1xuICB9XG5cbiAgaWYgKHRoaXMucHJldkdsb2JhbHNMZW5ndGggPT09IGdsb2JhbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHJldkdsb2JhbHNMZW5ndGggPSBnbG9iYWxzLmxlbmd0aDtcblxuICBsZWFrcyA9IGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKTtcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGxlYWtzKTtcblxuICBpZiAobGVha3MubGVuZ3RoKSB7XG4gICAgdmFyIG1zZyA9IGBnbG9iYWwgbGVhayhzKSBkZXRlY3RlZDogJHtsZWFrcy5tYXAoZSA9PiBgJyR7ZX0nYCkuam9pbignLCAnKX1gO1xuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IobXNnKSk7XG4gIH1cbn07XG5cbi8qKlxuICogRmFpbCB0aGUgZ2l2ZW4gYHRlc3RgLlxuICpcbiAqIElmIGB0ZXN0YCBpcyBhIGhvb2ssIGZhaWx1cmVzIHdvcmsgaW4gdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICogLSBJZiBiYWlsLCBydW4gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgYW5kIGBhZnRlcmAgaG9va3MsXG4gKiAgIHRoZW4gZXhpdFxuICogLSBGYWlsZWQgYGJlZm9yZWAgaG9vayBza2lwcyBhbGwgdGVzdHMgaW4gYSBzdWl0ZSBhbmQgc3Vic3VpdGVzLFxuICogICBidXQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXJgIGhvb2tcbiAqIC0gRmFpbGVkIGBiZWZvcmUgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxuICogICBzdWl0ZSBhbmQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXIgZWFjaGAgaG9vayxcbiAqICAgd2hpY2ggaXMgcnVuIG9ubHkgb25jZVxuICogLSBGYWlsZWQgYGFmdGVyYCBob29rIGRvZXMgbm90IGFsdGVyIGV4ZWN1dGlvbiBvcmRlclxuICogLSBGYWlsZWQgYGFmdGVyIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcbiAqICAgc3VpdGUgYW5kIHN1YnN1aXRlcywgYnV0IGV4ZWN1dGVzIG90aGVyIGBhZnRlciBlYWNoYFxuICogICBob29rc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5hYmxlfSB0ZXN0XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZmFpbCBhIHBlbmRpbmcgdGVzdC5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHRlc3QsIGVyciwgZm9yY2UpIHtcbiAgZm9yY2UgPSBmb3JjZSA9PT0gdHJ1ZTtcbiAgaWYgKHRlc3QuaXNQZW5kaW5nKCkgJiYgIWZvcmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHMuU1RBVEVfU1RPUFBFRCkge1xuICAgIGlmIChlcnIuY29kZSA9PT0gZXJyb3JDb25zdGFudHMuTVVMVElQTEVfRE9ORSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBjcmVhdGVGYXRhbEVycm9yKFxuICAgICAgJ1Rlc3QgZmFpbGVkIGFmdGVyIHJvb3Qgc3VpdGUgZXhlY3V0aW9uIGNvbXBsZXRlZCEnLFxuICAgICAgZXJyXG4gICAgKTtcbiAgfVxuXG4gICsrdGhpcy5mYWlsdXJlcztcbiAgZGVidWcoJ3RvdGFsIG51bWJlciBvZiBmYWlsdXJlczogJWQnLCB0aGlzLmZhaWx1cmVzKTtcbiAgdGVzdC5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcblxuICBpZiAoIWlzRXJyb3IoZXJyKSkge1xuICAgIGVyciA9IHRocm93bjJFcnJvcihlcnIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBlcnIuc3RhY2sgPVxuICAgICAgdGhpcy5mdWxsU3RhY2tUcmFjZSB8fCAhZXJyLnN0YWNrID8gZXJyLnN0YWNrIDogc3RhY2tGaWx0ZXIoZXJyLnN0YWNrKTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgLy8gc29tZSBlbnZpcm9ubWVudHMgZG8gbm90IHRha2Uga2luZGx5IHRvIG1vbmtleWluZyB3aXRoIHRoZSBzdGFja1xuICB9XG5cbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0ZBSUwsIHRlc3QsIGVycik7XG59O1xuXG4vKipcbiAqIFJ1biBob29rIGBuYW1lYCBjYWxsYmFja3MgYW5kIHRoZW4gaW52b2tlIGBmbigpYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuUnVubmVyLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIGlmICh0aGlzLl9vcHRzLmRyeVJ1bikgcmV0dXJuIGZuKCk7XG5cbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcbiAgdmFyIGhvb2tzID0gc3VpdGUuZ2V0SG9va3MobmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBuZXh0KGkpIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuICAgIGlmICghaG9vaykge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gaG9vaztcblxuICAgIGlmIChuYW1lID09PSBIT09LX1RZUEVfQkVGT1JFX0FMTCkge1xuICAgICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBob29rLnBhcmVudC50ZXN0c1swXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9BRlRFUl9BTEwpIHtcbiAgICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gaG9vay5wYXJlbnQudGVzdHNbaG9vay5wYXJlbnQudGVzdHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2suY3R4LmN1cnJlbnRUZXN0ID0gc2VsZi50ZXN0O1xuICAgIH1cblxuICAgIHNldEhvb2tUaXRsZShob29rKTtcblxuICAgIGhvb2suYWxsb3dVbmNhdWdodCA9IHNlbGYuYWxsb3dVbmNhdWdodDtcblxuICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfSE9PS19CRUdJTiwgaG9vayk7XG5cbiAgICBpZiAoIWhvb2subGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgc2VsZi5fYWRkRXZlbnRMaXN0ZW5lcihob29rLCAnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZmFpbChob29rLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaG9vay5ydW4oZnVuY3Rpb24gY2JIb29rUnVuKGVycikge1xuICAgICAgdmFyIHRlc3RFcnJvciA9IGhvb2suZXJyb3IoKTtcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgc2VsZi5mYWlsKHNlbGYudGVzdCwgdGVzdEVycm9yKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbmRpdGlvbmFsIHNraXBcbiAgICAgIGlmIChob29rLnBlbmRpbmcpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9BRlRFUl9FQUNIKSB7XG4gICAgICAgICAgLy8gVE9ETyBkZWZpbmUgYW5kIGltcGxlbWVudCB1c2UgY2FzZVxuICAgICAgICAgIGlmIChzZWxmLnRlc3QpIHtcbiAgICAgICAgICAgIHNlbGYudGVzdC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSE9PS19UWVBFX0JFRk9SRV9FQUNIKSB7XG4gICAgICAgICAgaWYgKHNlbGYudGVzdCkge1xuICAgICAgICAgICAgc2VsZi50ZXN0LnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX0hPT0tfRU5ELCBob29rKTtcbiAgICAgICAgICBob29rLnBlbmRpbmcgPSBmYWxzZTsgLy8gYWN0aXZhdGVzIGhvb2sgZm9yIG5leHQgdGVzdFxuICAgICAgICAgIHJldHVybiBmbihuZXcgRXJyb3IoJ2Fib3J0IGhvb2tEb3duJykpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IEhPT0tfVFlQRV9CRUZPUkVfQUxMKSB7XG4gICAgICAgICAgc3VpdGUudGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xuICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdWl0ZS5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICAgICAgICAgIHN1aXRlLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhvb2tzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaG9vay5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGVyckZvcmJpZCA9IGNyZWF0ZVVuc3VwcG9ydGVkRXJyb3IoJ2B0aGlzLnNraXBgIGZvcmJpZGRlbicpO1xuICAgICAgICAgIHNlbGYuZmFpbChob29rLCBlcnJGb3JiaWQpO1xuICAgICAgICAgIHJldHVybiBmbihlcnJGb3JiaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBzZWxmLmZhaWwoaG9vaywgZXJyKTtcbiAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcbiAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX0hPT0tfRU5ELCBob29rKTtcbiAgICAgIGRlbGV0ZSBob29rLmN0eC5jdXJyZW50VGVzdDtcbiAgICAgIHNldEhvb2tUaXRsZShob29rKTtcbiAgICAgIG5leHQoKytpKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNldEhvb2tUaXRsZShob29rKSB7XG4gICAgICBob29rLm9yaWdpbmFsVGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgfHwgaG9vay50aXRsZTtcbiAgICAgIGlmIChob29rLmN0eCAmJiBob29rLmN0eC5jdXJyZW50VGVzdCkge1xuICAgICAgICBob29rLnRpdGxlID0gYCR7aG9vay5vcmlnaW5hbFRpdGxlfSBmb3IgXCIke2hvb2suY3R4LmN1cnJlbnRUZXN0LnRpdGxlfVwiYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJlbnRUaXRsZTtcbiAgICAgICAgaWYgKGhvb2sucGFyZW50LnRpdGxlKSB7XG4gICAgICAgICAgcGFyZW50VGl0bGUgPSBob29rLnBhcmVudC50aXRsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUaXRsZSA9IGhvb2sucGFyZW50LnJvb3QgPyAne3Jvb3R9JyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGhvb2sudGl0bGUgPSBgJHtob29rLm9yaWdpbmFsVGl0bGV9IGluIFwiJHtwYXJlbnRUaXRsZX1cImA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcbiAgICBuZXh0KDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcbiAqIGluIG9yZGVyLCBhbmQgY2FsbGJhY2sgYGZuKGVyciwgZXJyU3VpdGUpYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uIChuYW1lLCBzdWl0ZXMsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9yaWcgPSB0aGlzLnN1aXRlO1xuXG4gIGZ1bmN0aW9uIG5leHQoc3VpdGUpIHtcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XG5cbiAgICBpZiAoIXN1aXRlKSB7XG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIHNlbGYuaG9vayhuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgICByZXR1cm4gZm4oZXJyLCBlcnJTdWl0ZSk7XG4gICAgICB9XG5cbiAgICAgIG5leHQoc3VpdGVzLnBvcCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcbn07XG5cbi8qKlxuICogUnVuICdhZnRlckVhY2gnIGhvb2tzIGZyb20gYm90dG9tIHVwLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rVXAgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpLnJldmVyc2UoKTtcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcbn07XG5cbi8qKlxuICogUnVuICdiZWZvcmVFYWNoJyBob29rcyBmcm9tIHRvcCBsZXZlbCBkb3duLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHByaXZhdGVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ob29rRG93biA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwYXJlbnQgU3VpdGVzIGZyb21cbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XG4gIHZhciBzdWl0ZXMgPSBbXTtcbiAgd2hpbGUgKHN1aXRlLnBhcmVudCkge1xuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xuICAgIHN1aXRlcy5wdXNoKHN1aXRlKTtcbiAgfVxuICByZXR1cm4gc3VpdGVzO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGN1cnJlbnQgdGVzdCBhbmQgY2FsbGJhY2sgYGZuKGVycilgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcHJpdmF0ZVxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX29wdHMuZHJ5UnVuKSByZXR1cm4gUnVubmVyLmltbWVkaWF0ZWx5KGZuKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0O1xuXG4gIGlmICghdGVzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmFzeW5jT25seSkge1xuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRlc3QsICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcbiAgfSk7XG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcbiAgICB0ZXN0LmFsbG93VW5jYXVnaHQgPSB0cnVlO1xuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XG4gIH1cbiAgdHJ5IHtcbiAgICB0ZXN0LnJ1bihmbik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZuKGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogUnVuIHRlc3RzIGluIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0cyA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGVzdHMgPSBzdWl0ZS50ZXN0cy5zbGljZSgpO1xuICB2YXIgdGVzdDtcblxuICBmdW5jdGlvbiBob29rRXJyKF8sIGVyclN1aXRlLCBhZnRlcikge1xuICAgIC8vIGJlZm9yZS9hZnRlciBFYWNoIGhvb2sgZm9yIGVyclN1aXRlIGZhaWxlZDpcbiAgICB2YXIgb3JpZyA9IHNlbGYuc3VpdGU7XG5cbiAgICAvLyBmb3IgZmFpbGVkICdhZnRlciBlYWNoJyBob29rIHN0YXJ0IGZyb20gZXJyU3VpdGUgcGFyZW50LFxuICAgIC8vIG90aGVyd2lzZSBzdGFydCBmcm9tIGVyclN1aXRlIGl0c2VsZlxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xuXG4gICAgaWYgKHNlbGYuc3VpdGUpIHtcbiAgICAgIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBmdW5jdGlvbiAoZXJyMiwgZXJyU3VpdGUyKSB7XG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgICAvLyBzb21lIGhvb2tzIG1heSBmYWlsIGV2ZW4gbm93XG4gICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBvcnQgZXJyb3Igc3VpdGVcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xuICAgICAgZm4oZXJyU3VpdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoZXJyLCBlcnJTdWl0ZSkge1xuICAgIC8vIGlmIHdlIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyXG4gICAgaWYgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpIHtcbiAgICAgIHRlc3RzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBuZXh0IHRlc3RcbiAgICB0ZXN0ID0gdGVzdHMuc2hpZnQoKTtcblxuICAgIC8vIGFsbCBkb25lXG4gICAgaWYgKCF0ZXN0KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICAvLyBncmVwXG4gICAgdmFyIG1hdGNoID0gc2VsZi5fZ3JlcC50ZXN0KHRlc3QuZnVsbFRpdGxlKCkpO1xuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBSdW4gaW1tZWRpYXRlbHkgb25seSBpZiB3ZSBoYXZlIGRlZmluZWQgYSBncmVwLiBXaGVuIHdlXG4gICAgICAvLyBkZWZpbmUgYSBncmVwIOKAlCBJdCBjYW4gY2F1c2UgbWF4aW11bSBjYWxsc3RhY2sgZXJyb3IgaWZcbiAgICAgIC8vIHRoZSBncmVwIGlzIGRvaW5nIGEgbGFyZ2UgcmVjdXJzaXZlIGxvb3AgYnkgbmVnbGVjdGluZ1xuICAgICAgLy8gYWxsIHRlc3RzLiBUaGUgcnVuIGltbWVkaWF0ZWx5IGZ1bmN0aW9uIGFsc28gY29tZXMgd2l0aFxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBjb3N0LiBTbyB3ZSBkb24ndCB3YW50IHRvIHJ1biBpbW1lZGlhdGVseVxuICAgICAgLy8gaWYgd2UgcnVuIHRoZSB3aG9sZSB0ZXN0IHN1aXRlLCBiZWNhdXNlIHJ1bm5pbmcgdGhlIHdob2xlXG4gICAgICAvLyB0ZXN0IHN1aXRlIGRvbid0IGRvIGFueSBpbW1lZGlhdGUgcmVjdXJzaXZlIGxvb3BzLiBUaHVzLFxuICAgICAgLy8gYWxsb3dpbmcgYSBKUyBydW50aW1lIHRvIGJyZWF0aGUuXG4gICAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcbiAgICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0YXRpYyBza2lwLCBubyBob29rcyBhcmUgZXhlY3V0ZWRcbiAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xuICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJyksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVzdC5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HLCB0ZXN0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQsIHRlc3QpO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBleGVjdXRlIHRlc3QgYW5kIGhvb2socylcbiAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfQkVHSU4sIChzZWxmLnRlc3QgPSB0ZXN0KSk7XG4gICAgc2VsZi5ob29rRG93bihIT09LX1RZUEVfQkVGT1JFX0VBQ0gsIGZ1bmN0aW9uIChlcnIsIGVyclN1aXRlKSB7XG4gICAgICAvLyBjb25kaXRpb25hbCBza2lwIHdpdGhpbiBiZWZvcmVFYWNoXG4gICAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xuICAgICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XG4gICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORywgdGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0VORCwgdGVzdCk7XG4gICAgICAgIC8vIHNraXAgaW5uZXIgYWZ0ZXJFYWNoIGhvb2tzIGJlbG93IGVyclN1aXRlIGxldmVsXG4gICAgICAgIHZhciBvcmlnU3VpdGUgPSBzZWxmLnN1aXRlO1xuICAgICAgICBzZWxmLnN1aXRlID0gZXJyU3VpdGUgfHwgc2VsZi5zdWl0ZTtcbiAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBmdW5jdGlvbiAoZSwgZVN1aXRlKSB7XG4gICAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWdTdWl0ZTtcbiAgICAgICAgICBuZXh0KGUsIGVTdWl0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IHNlbGYudGVzdDtcbiAgICAgIHNlbGYucnVuVGVzdChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRlc3QgPSBzZWxmLnRlc3Q7XG4gICAgICAgIC8vIGNvbmRpdGlvbmFsIHNraXAgd2l0aGluIGl0XG4gICAgICAgIGlmICh0ZXN0LnBlbmRpbmcpIHtcbiAgICAgICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJyksIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXN0LnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICAgIHNlbGYuZW1pdChjb25zdGFudHMuRVZFTlRfVEVTVF9QRU5ESU5HLCB0ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX0VORCwgdGVzdCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKEhPT0tfVFlQRV9BRlRFUl9FQUNILCBuZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgcmV0cnkgPSB0ZXN0LmN1cnJlbnRSZXRyeSgpO1xuICAgICAgICAgIGlmIChyZXRyeSA8IHRlc3QucmV0cmllcygpKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVGVzdCA9IHRlc3QuY2xvbmUoKTtcbiAgICAgICAgICAgIGNsb25lZFRlc3QuY3VycmVudFJldHJ5KHJldHJ5ICsgMSk7XG4gICAgICAgICAgICB0ZXN0cy51bnNoaWZ0KGNsb25lZFRlc3QpO1xuXG4gICAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfUkVUUlksIHRlc3QsIGVycik7XG5cbiAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiArIGhvb2sgdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY291bnQgd3JvbmdcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcChIT09LX1RZUEVfQUZURVJfRUFDSCwgbmV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIG5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdC5zdGF0ZSA9IFNUQVRFX1BBU1NFRDtcbiAgICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9URVNUX1BBU1MsIHRlc3QpO1xuICAgICAgICBzZWxmLmVtaXQoY29uc3RhbnRzLkVWRU5UX1RFU1RfRU5ELCB0ZXN0KTtcbiAgICAgICAgc2VsZi5ob29rVXAoSE9PS19UWVBFX0FGVEVSX0VBQ0gsIG5leHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLm5leHQgPSBuZXh0O1xuICB0aGlzLmhvb2tFcnIgPSBob29rRXJyO1xuICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIFJ1biB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblJ1bm5lci5wcm90b3R5cGUucnVuU3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUsIGZuKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdG90YWwgPSB0aGlzLmdyZXBUb3RhbChzdWl0ZSk7XG5cbiAgZGVidWcoJ3J1blN1aXRlKCk6IHJ1bm5pbmcgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XG5cbiAgaWYgKCF0b3RhbCB8fCAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkpIHtcbiAgICBkZWJ1ZygncnVuU3VpdGUoKTogYmFpbGluZycpO1xuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9CRUdJTiwgKHRoaXMuc3VpdGUgPSBzdWl0ZSkpO1xuXG4gIGZ1bmN0aW9uIG5leHQoZXJyU3VpdGUpIHtcbiAgICBpZiAoZXJyU3VpdGUpIHtcbiAgICAgIC8vIGN1cnJlbnQgc3VpdGUgZmFpbGVkIG9uIGEgaG9vayBmcm9tIGVyclN1aXRlXG4gICAgICBpZiAoZXJyU3VpdGUgPT09IHN1aXRlKSB7XG4gICAgICAgIC8vIGlmIGVyclN1aXRlIGlzIGN1cnJlbnQgc3VpdGVcbiAgICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgc2libGluZyBzdWl0ZVxuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgICAgLy8gZXJyU3VpdGUgaXMgYW1vbmcgdGhlIHBhcmVudHMgb2YgY3VycmVudCBzdWl0ZVxuICAgICAgLy8gc3RvcCBleGVjdXRpb24gb2YgZXJyU3VpdGUgYW5kIGFsbCBzdWItc3VpdGVzXG4gICAgICByZXR1cm4gZG9uZShlcnJTdWl0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIHZhciBjdXJyID0gc3VpdGUuc3VpdGVzW2krK107XG4gICAgaWYgKCFjdXJyKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIGdyZXAgbmVnbGVjdGluZyBsYXJnZSBudW1iZXIgb2YgdGVzdHMgY2F1c2luZyBhXG4gICAgLy8gaHVnZSByZWN1cnNpdmUgbG9vcCBhbmQgdGh1cyBhIG1heGltdW0gY2FsbCBzdGFjayBlcnJvci5cbiAgICAvLyBTZWUgY29tbWVudCBpbiBgdGhpcy5ydW5UZXN0cygpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcbiAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKGVyclN1aXRlKSB7XG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xuICAgIHNlbGYubmV4dFN1aXRlID0gbmV4dDtcblxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGVzdFxuICAgIGRlbGV0ZSBzZWxmLnRlc3Q7XG5cbiAgICBzZWxmLmhvb2soSE9PS19UWVBFX0FGVEVSX0FMTCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQsIHN1aXRlKTtcbiAgICAgIGZuKGVyclN1aXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMubmV4dFN1aXRlID0gbmV4dDtcblxuICB0aGlzLmhvb2soSE9PS19UWVBFX0JFRk9SRV9BTEwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICBzZWxmLnJ1blRlc3RzKHN1aXRlLCBuZXh0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zIHdpdGhpbiBydW5uZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgYXMgYFJ1bm5lciN1bmNhdWdodGAgYXQgaW5zdGFudGlhdGlvblxuICogdGltZS4gSXQncyBpbnRlbmRlZCB0byBiZSBsaXN0ZW5pbmcgb24gdGhlIGBQcm9jZXNzLnVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudC5cbiAqIEluIG9yZGVyIHRvIG5vdCBsZWFrIEVFIGxpc3RlbmVycywgd2UgbmVlZCB0byBlbnN1cmUgbm8gbW9yZSB0aGFuIGEgc2luZ2xlXG4gKiBgdW5jYXVnaHRFeGNlcHRpb25gIGxpc3RlbmVyIGV4aXN0cyBwZXIgYFJ1bm5lcmAuICBUaGUgb25seSB3YXkgdG8gZG9cbiAqIHRoaXMtLWJlY2F1c2UgdGhpcyBmdW5jdGlvbiBuZWVkcyB0aGUgY29udGV4dCAoYW5kIHdlIGRvbid0IGhhdmUgbGFtYmRhcyktLWlzXG4gKiB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYC4gV2UgbmVlZCBzdHJpY3QgZXF1YWxpdHkgdG8gdW5yZWdpc3RlciBhbmRcbiAqIF9vbmx5XyB1bnJlZ2lzdGVyIHRoZSBfb25lXyBsaXN0ZW5lciB3ZSBzZXQgZnJvbSB0aGVcbiAqIGBQcm9jZXNzLnVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudDsgd291bGQgYmUgcG9vciBmb3JtIHRvIGp1c3QgcmVtb3ZlXG4gKiBldmVyeXRoaW5nLiBTZWUge0BsaW5rIFJ1bm5lciNydW59IGZvciB3aGVyZSB0aGUgZXZlbnQgbGlzdGVuZXIgaXMgcmVnaXN0ZXJlZFxuICogYW5kIHVucmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIFNvbWUgdW5jYXVnaHQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cblJ1bm5lci5wcm90b3R5cGUuX3VuY2F1Z2h0ID0gZnVuY3Rpb24gKGVycikge1xuICAvLyB0aGlzIGlzIGRlZmVuc2l2ZSB0byBwcmV2ZW50IGZ1dHVyZSBkZXZlbG9wZXJzIGZyb20gbWlzLWNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgLy8gaXQncyBtb3JlIGxpa2VseSB0aGF0IGl0J2QgYmUgY2FsbGVkIHdpdGggdGhlIGluY29ycmVjdCBjb250ZXh0LS1zYXksIHRoZSBnbG9iYWxcbiAgLy8gYHByb2Nlc3NgIG9iamVjdC0tdGhhbiBpdCB3b3VsZCB0byBiZSBjYWxsZWQgd2l0aCBhIGNvbnRleHQgdGhhdCBpcyBub3QgYSBcInN1YmNsYXNzXCJcbiAgLy8gb2YgYFJ1bm5lcmAuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSdW5uZXIpKSB7XG4gICAgdGhyb3cgY3JlYXRlRmF0YWxFcnJvcihcbiAgICAgICdSdW5uZXIjdW5jYXVnaHQoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGNvbnRleHQnLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbiAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogY2F1Z2h0IGEgUGVuZGluZycpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBicm93c2VyIGRvZXMgbm90IGV4aXQgc2NyaXB0IHdoZW4gdGhyb3dpbmcgaW4gZ2xvYmFsLm9uZXJyb3IoKVxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0ICYmICF1dGlscy5pc0Jyb3dzZXIoKSkge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBidWJibGluZyBleGNlcHRpb24gZHVlIHRvIC0tYWxsb3ctdW5jYXVnaHQnKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX1NUT1BQRUQpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogdGhyb3dpbmcgYWZ0ZXIgcnVuIGhhcyBjb21wbGV0ZWQhJyk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKGVycikge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBnb3QgdHJ1dGh5IGV4Y2VwdGlvbiAlTycsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHVuZGVmaW5lZC9mYWxzeSBleGNlcHRpb24nKTtcbiAgICBlcnIgPSBjcmVhdGVJbnZhbGlkRXhjZXB0aW9uRXJyb3IoXG4gICAgICAnQ2F1Z2h0IGZhbHN5L3VuZGVmaW5lZCBleGNlcHRpb24gd2hpY2ggd291bGQgb3RoZXJ3aXNlIGJlIHVuY2F1Z2h0LiBObyBzdGFjayB0cmFjZSBmb3VuZDsgdHJ5IGEgZGVidWdnZXInLFxuICAgICAgZXJyXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaXNFcnJvcihlcnIpKSB7XG4gICAgZXJyID0gdGhyb3duMkVycm9yKGVycik7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IGNvbnZlcnRlZCBcImVycm9yXCIgJW8gdG8gRXJyb3InLCBlcnIpO1xuICB9XG4gIGVyci51bmNhdWdodCA9IHRydWU7XG5cbiAgdmFyIHJ1bm5hYmxlID0gdGhpcy5jdXJyZW50UnVubmFibGU7XG5cbiAgaWYgKCFydW5uYWJsZSkge1xuICAgIHJ1bm5hYmxlID0gbmV3IFJ1bm5hYmxlKCdVbmNhdWdodCBlcnJvciBvdXRzaWRlIHRlc3Qgc3VpdGUnKTtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogbm8gY3VycmVudCBSdW5uYWJsZTsgY3JlYXRlZCBhIHBob255IG9uZScpO1xuICAgIHJ1bm5hYmxlLnBhcmVudCA9IHRoaXMuc3VpdGU7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzLlNUQVRFX1JVTk5JTkcpIHtcbiAgICAgIGRlYnVnKCd1bmNhdWdodCgpOiBmYWlsaW5nIGdyYWNlZnVsbHknKTtcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuJ3QgcmVjb3ZlciBmcm9tIHRoaXMgZmFpbHVyZVxuICAgICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHRlc3QgcnVuIGhhcyBub3QgeWV0IHN0YXJ0ZWQ7IHVucmVjb3ZlcmFibGUnKTtcbiAgICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcbiAgICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfUlVOX0VORCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcnVubmFibGUuY2xlYXJUaW1lb3V0KCk7XG5cbiAgaWYgKHJ1bm5hYmxlLmlzRmFpbGVkKCkpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogUnVubmFibGUgaGFzIGFscmVhZHkgZmFpbGVkJyk7XG4gICAgLy8gSWdub3JlIGVycm9yIGlmIGFscmVhZHkgZmFpbGVkXG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHJ1bm5hYmxlLmlzUGVuZGluZygpKSB7XG4gICAgZGVidWcoJ3VuY2F1Z2h0KCk6IHBlbmRpbmcgUnVubmFibGUgd291bmQgdXAgZmFpbGluZyEnKTtcbiAgICAvLyByZXBvcnQgJ3BlbmRpbmcgdGVzdCcgcmV0cm9zcGVjdGl2ZWx5IGFzIGZhaWxlZFxuICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBjYW5ub3QgcmVjb3ZlciBncmFjZWZ1bGx5IGlmIGEgUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkXG4gIC8vIHRoZW4gZmFpbHMgYXN5bmNocm9ub3VzbHlcbiAgaWYgKHJ1bm5hYmxlLmlzUGFzc2VkKCkpIHtcbiAgICBkZWJ1ZygndW5jYXVnaHQoKTogUnVubmFibGUgaGFzIGFscmVhZHkgcGFzc2VkOyBiYWlsaW5nIGdyYWNlZnVsbHknKTtcbiAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XG4gICAgdGhpcy5hYm9ydCgpO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd1bmNhdWdodCgpOiBmb3JjaW5nIFJ1bm5hYmxlIHRvIGNvbXBsZXRlIHdpdGggRXJyb3InKTtcbiAgICByZXR1cm4gcnVubmFibGUuY2FsbGJhY2soZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxuICogb24gY29tcGxldGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIENhbGxiYWNrIHdoZW4gZmluaXNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBGb3Igc3ViY2xhc3Nlc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0cy5maWxlcyAtIEZpbGVzIHRvIHJ1blxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRzLm9wdGlvbnMgLSBjb21tYW5kLWxpbmUgb3B0aW9uc1xuICogQHJldHVybnMge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxuICovXG5SdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbiwgb3B0cyA9IHt9KSB7XG4gIHZhciByb290U3VpdGUgPSB0aGlzLnN1aXRlO1xuICB2YXIgb3B0aW9ucyA9IG9wdHMub3B0aW9ucyB8fCB7fTtcblxuICBkZWJ1ZygncnVuKCk6IGdvdCBvcHRpb25zOiAlTycsIG9wdGlvbnMpO1xuICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMudG90YWwgJiYgdGhpcy5fb3B0cy5mYWlsWmVybykgdGhpcy5mYWlsdXJlcyA9IDE7XG5cbiAgICBkZWJ1ZygncnVuKCk6IHJvb3Qgc3VpdGUgY29tcGxldGVkOyBlbWl0dGluZyAlcycsIGNvbnN0YW50cy5FVkVOVF9SVU5fRU5EKTtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQpO1xuICB9O1xuXG4gIGNvbnN0IGJlZ2luID0gKCkgPT4ge1xuICAgIGRlYnVnKCdydW4oKTogZW1pdHRpbmcgJXMnLCBjb25zdGFudHMuRVZFTlRfUlVOX0JFR0lOKTtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTik7XG4gICAgZGVidWcoJ3J1bigpOiBlbWl0dGVkICVzJywgY29uc3RhbnRzLkVWRU5UX1JVTl9CRUdJTik7XG5cbiAgICB0aGlzLnJ1blN1aXRlKHJvb3RTdWl0ZSwgZW5kKTtcbiAgfTtcblxuICBjb25zdCBwcmVwYXJlID0gKCkgPT4ge1xuICAgIGRlYnVnKCdydW4oKTogc3RhcnRpbmcnKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBgb25seWAgZmlsdGVyXG4gICAgaWYgKHJvb3RTdWl0ZS5oYXNPbmx5KCkpIHtcbiAgICAgIHJvb3RTdWl0ZS5maWx0ZXJPbmx5KCk7XG4gICAgICBkZWJ1ZygncnVuKCk6IGZpbHRlcmVkIGV4Y2x1c2l2ZSBSdW5uYWJsZXMnKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50cy5TVEFURV9SVU5OSU5HO1xuICAgIGlmICh0aGlzLl9vcHRzLmRlbGF5KSB7XG4gICAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX0RFTEFZX0VORCk7XG4gICAgICBkZWJ1ZygncnVuKCk6IFwiZGVsYXlcIiBlbmRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBiZWdpbigpO1xuICB9O1xuXG4gIC8vIHJlZmVyZW5jZXMgY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgaWYgKHRoaXMuX29wdHMuY2xlYW5SZWZlcmVuY2VzQWZ0ZXJSdW4pIHtcbiAgICB0aGlzLm9uKGNvbnN0YW50cy5FVkVOVF9TVUlURV9FTkQsIHN1aXRlID0+IHtcbiAgICAgIHN1aXRlLmNsZWFuUmVmZXJlbmNlcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY2FsbGJhY2tcbiAgdGhpcy5vbihjb25zdGFudHMuRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHMuU1RBVEVfU1RPUFBFRDtcbiAgICBkZWJ1ZygncnVuKCk6IGVtaXR0ZWQgJXMnLCBjb25zdGFudHMuRVZFTlRfUlVOX0VORCk7XG4gICAgZm4odGhpcy5mYWlsdXJlcyk7XG4gIH0pO1xuXG4gIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIocHJvY2VzcywgJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdGhpcy51bmNhdWdodCk7XG4gIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIocHJvY2VzcywgJ3VuaGFuZGxlZFJlamVjdGlvbicsIHRoaXMudW5oYW5kbGVkKTtcbiAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5jYXVnaHRFeGNlcHRpb24nLCB0aGlzLnVuY2F1Z2h0KTtcbiAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihwcm9jZXNzLCAndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy51bmhhbmRsZWQpO1xuXG4gIGlmICh0aGlzLl9vcHRzLmRlbGF5KSB7XG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cbiAgICAvLyBtaWdodCBiZSBuaWNlIHRvIGRlYm91bmNlIHNvbWUgZG90cyB3aGlsZSB3ZSB3YWl0LlxuICAgIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfREVMQVlfQkVHSU4sIHJvb3RTdWl0ZSk7XG4gICAgcm9vdFN1aXRlLm9uY2UoRVZFTlRfUk9PVF9TVUlURV9SVU4sIHByZXBhcmUpO1xuICAgIGRlYnVnKCdydW4oKTogd2FpdGluZyBmb3IgZ3JlZW4gbGlnaHQgZHVlIHRvIC0tZGVsYXknKTtcbiAgfSBlbHNlIHtcbiAgICBSdW5uZXIuaW1tZWRpYXRlbHkocHJlcGFyZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG9nZ2xlIHBhcnRpYWwgb2JqZWN0IGxpbmtpbmcgYmVoYXZpb3I7IHVzZWQgZm9yIGJ1aWxkaW5nIG9iamVjdCByZWZlcmVuY2VzIGZyb21cbiAqIHVuaXF1ZSBJRCdzLiBEb2VzIG5vdGhpbmcgaW4gc2VyaWFsIG1vZGUsIGJlY2F1c2UgdGhlIG9iamVjdCByZWZlcmVuY2VzIGFscmVhZHkgZXhpc3QuXG4gKiBTdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnQgdGhpcyAoZS5nLiwgYFBhcmFsbGVsQnVmZmVyZWRSdW5uZXJgKVxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV0gLSBJZiBgdHJ1ZWAsIGVuYWJsZSBwYXJ0aWFsIG9iamVjdCBsaW5raW5nLCBvdGhlcndpc2UgZGlzYWJsZVxuICogQHJldHVybnMge1J1bm5lcn1cbiAqIEBjaGFpbmFibGVcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiAvLyB0aGlzIHJlcG9ydGVyIG5lZWRzIHByb3BlciBvYmplY3QgcmVmZXJlbmNlcyB3aGVuIHJ1biBpbiBwYXJhbGxlbCBtb2RlXG4gKiBjbGFzcyBNeVJlcG9ydGVyKCkge1xuICogICBjb25zdHJ1Y3RvcihydW5uZXIpIHtcbiAqICAgICB0aGlzLnJ1bm5lci5saW5rUGFydGlhbE9iamVjdHModHJ1ZSlcbiAqICAgICAgIC5vbihFVkVOVF9TVUlURV9CRUdJTiwgc3VpdGUgPT4ge1xuICAgICAgICAgICAvLyB0aGlzIFN1aXRlIG1heSBiZSB0aGUgc2FtZSBvYmplY3QuLi5cbiAqICAgICAgIH0pXG4gKiAgICAgICAub24oRVZFTlRfVEVTVF9CRUdJTiwgdGVzdCA9PiB7XG4gKiAgICAgICAgIC8vIC4uLmFzIHRoZSBgdGVzdC5wYXJlbnRgIHByb3BlcnR5XG4gKiAgICAgICB9KTtcbiAqICAgfVxuICogfVxuICovXG5SdW5uZXIucHJvdG90eXBlLmxpbmtQYXJ0aWFsT2JqZWN0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBMaWtlIHtAbGluayBSdW5uZXIjcnVufSwgYnV0IGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIGFuZCByZXR1cm5zIGEgYFByb21pc2VgIGluc3RlYWQgb2YgYSBgUnVubmVyYC5cbiAqIFRoaXMgZnVuY3Rpb24gY2Fubm90IHJlamVjdDsgYW4gYHVuaGFuZGxlZFJlamVjdGlvbmAgZXZlbnQgd2lsbCBidWJibGUgdXAgdG8gdGhlIGBwcm9jZXNzYCBvYmplY3QgaW5zdGVhZC5cbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBSdW5uZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25zIGZvciB7QGxpbmsgUnVubmVyI3J1bn1cbiAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IEZhaWx1cmUgY291bnRcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5ydW5Bc3luYyA9IGFzeW5jIGZ1bmN0aW9uIHJ1bkFzeW5jKG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgdGhpcy5ydW4ocmVzb2x2ZSwgb3B0cyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDbGVhbmx5IGFib3J0IGV4ZWN1dGlvbi5cbiAqXG4gKiBAbWVtYmVyb2YgUnVubmVyXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cbiAqL1xuUnVubmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2Fib3J0KCk6IGFib3J0aW5nJyk7XG4gIHRoaXMuX2Fib3J0ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgTW9jaGEgaXMgcnVubmluZyBpbiBwYXJhbGxlbCBtb2RlLiAgRm9yIHJlcG9ydGVycy5cbiAqXG4gKiBTdWJjbGFzc2VzIHNob3VsZCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgdmFsdWUuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7ZmFsc2V9XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuaXNQYXJhbGxlbE1vZGUgPSBmdW5jdGlvbiBpc1BhcmFsbGVsTW9kZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmVzIGFuIGFsdGVybmF0ZSByZXBvcnRlciBmb3Igd29ya2VyIHByb2Nlc3NlcyB0byB1c2UuIFN1YmNsYXNzZXNcbiAqIHVzaW5nIHdvcmtlciBwcm9jZXNzZXMgc2hvdWxkIGltcGxlbWVudCB0aGlzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBBYnNvbHV0ZSBwYXRoIHRvIGFsdGVybmF0ZSByZXBvcnRlciBmb3Igd29ya2VyIHByb2Nlc3NlcyB0byB1c2VcbiAqIEByZXR1cm5zIHtSdW5uZXJ9XG4gKiBAdGhyb3dzIFdoZW4gaW4gc2VyaWFsIG1vZGVcbiAqIEBjaGFpbmFibGVcbiAqIEBhYnN0cmFjdFxuICovXG5SdW5uZXIucHJvdG90eXBlLndvcmtlclJlcG9ydGVyID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBjcmVhdGVVbnN1cHBvcnRlZEVycm9yKCd3b3JrZXJSZXBvcnRlcigpIG5vdCBzdXBwb3J0ZWQgaW4gc2VyaWFsIG1vZGUnKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIGxlYWtzIHdpdGggdGhlIGdpdmVuIGdsb2JhbHMgZmxhZ2dlZCBhcyBgb2tgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBva1xuICogQHBhcmFtIHtBcnJheX0gZ2xvYmFsc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKSB7XG4gIHJldHVybiBnbG9iYWxzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGV4cG9zZXMgaWZyYW1lcyBhcyBpbmRleCBpbnNpZGUgdGhlIHdpbmRvdyBvYmplY3RcbiAgICBpZiAoL15cXGQrLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpbiBmaXJlZm94XG4gICAgLy8gaWYgcnVubmVyIHJ1bnMgaW4gYW4gaWZyYW1lLCB0aGlzIGlmcmFtZSdzIHdpbmRvdy5nZXRJbnRlcmZhY2UgbWV0aG9kXG4gICAgLy8gbm90IGluaXQgYXQgZmlyc3QgaXQgaXMgYXNzaWduZWQgaW4gc29tZSBzZWNvbmRzXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgL15nZXRJbnRlcmZhY2UvLnRlc3Qoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFuIGlmcmFtZSBjb3VsZCBiZSBhcHByb2FjaGVkIGJ5IHdpbmRvd1tpZnJhbWVJbmRleF1cbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgL15cXGQrLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPcGVyYSBhbmQgSUUgZXhwb3NlIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEhUTUwgZWxlbWVudCBJRHMgKGlzc3VlICMyNDMpXG4gICAgaWYgKC9ebW9jaGEtLy50ZXN0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IG9rLmZpbHRlcihmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICh+b2suaW5kZXhPZignKicpKSB7XG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihvay5zcGxpdCgnKicpWzBdKSA9PT0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkgPT09IG9rO1xuICAgIH0pO1xuICAgIHJldHVybiAhbWF0Y2hlZC5sZW5ndGggJiYgKCFnbG9iYWwubmF2aWdhdG9yIHx8IGtleSAhPT0gJ29uZXJyb3InKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRXJyb3Igb2JqZWN0IG9yIGEgZHVjay10eXBlZCBlcXVpdmFsZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyIC0gb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyLm1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnIpIHtcbiAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyk7XG59XG5cbi8qKlxuICpcbiAqIENvbnZlcnRzIHRocm93biBub24tZXh0ZW5zaWJsZSB0eXBlIGludG8gcHJvcGVyIEVycm9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHRocm93biAtIE5vbi1leHRlbnNpYmxlIHR5cGUgdGhyb3duIGJ5IGNvZGVcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG5mdW5jdGlvbiB0aHJvd24yRXJyb3IoZXJyKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYHRoZSAke3V0aWxzLmNhbm9uaWNhbFR5cGUoZXJyKX0gJHtzdHJpbmdpZnkoXG4gICAgICBlcnJcbiAgICApfSB3YXMgdGhyb3duLCB0aHJvdyBhbiBFcnJvciA6KWBcbiAgKTtcbn1cblxuUnVubmVyLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBOb2RlLmpzJyBgRXZlbnRFbWl0dGVyYFxuICogQGV4dGVybmFsIEV2ZW50RW1pdHRlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUnVubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgYSB7QGxpbmsgU3RhdHNDb2xsZWN0b3J9IG9iamVjdC5cbiAqIEBtb2R1bGVcbiAqL1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9ydW5uZXInKS5jb25zdGFudHM7XG52YXIgRVZFTlRfVEVTVF9QQVNTID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEFTUztcbnZhciBFVkVOVF9URVNUX0ZBSUwgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9GQUlMO1xudmFyIEVWRU5UX1NVSVRFX0JFR0lOID0gY29uc3RhbnRzLkVWRU5UX1NVSVRFX0JFR0lOO1xudmFyIEVWRU5UX1JVTl9CRUdJTiA9IGNvbnN0YW50cy5FVkVOVF9SVU5fQkVHSU47XG52YXIgRVZFTlRfVEVTVF9QRU5ESU5HID0gY29uc3RhbnRzLkVWRU5UX1RFU1RfUEVORElORztcbnZhciBFVkVOVF9SVU5fRU5EID0gY29uc3RhbnRzLkVWRU5UX1JVTl9FTkQ7XG52YXIgRVZFTlRfVEVTVF9FTkQgPSBjb25zdGFudHMuRVZFTlRfVEVTVF9FTkQ7XG5cbi8qKlxuICogVGVzdCBzdGF0aXN0aWNzIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0c0NvbGxlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN1aXRlcyAtIGludGVnZXIgY291bnQgb2Ygc3VpdGVzIHJ1bi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0ZXN0cyAtIGludGVnZXIgY291bnQgb2YgdGVzdHMgcnVuLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhc3NlcyAtIGludGVnZXIgY291bnQgb2YgcGFzc2luZyB0ZXN0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nIC0gaW50ZWdlciBjb3VudCBvZiBwZW5kaW5nIHRlc3RzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZhaWx1cmVzIC0gaW50ZWdlciBjb3VudCBvZiBmYWlsZWQgdGVzdHMuXG4gKiBAcHJvcGVydHkge0RhdGV9IHN0YXJ0IC0gdGltZSB3aGVuIHRlc3RpbmcgYmVnYW4uXG4gKiBAcHJvcGVydHkge0RhdGV9IGVuZCAtIHRpbWUgd2hlbiB0ZXN0aW5nIGNvbmNsdWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIG51bWJlciBvZiBtc2VjcyB0aGF0IHRlc3RpbmcgdG9vay5cbiAqL1xuXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRzIHN1Y2ggYXMgdGVzdCBkdXJhdGlvbiwgbnVtYmVyIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuLCBieSBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBlbWl0dGVkIGJ5IGBydW5uZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyIC0gUnVubmVyIGluc3RhbmNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGZhbHN5IGBydW5uZXJgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRzQ29sbGVjdG9yKHJ1bm5lcikge1xuICAvKipcbiAgICogQHR5cGUgU3RhdHNDb2xsZWN0b3JcbiAgICovXG4gIHZhciBzdGF0cyA9IHtcbiAgICBzdWl0ZXM6IDAsXG4gICAgdGVzdHM6IDAsXG4gICAgcGFzc2VzOiAwLFxuICAgIHBlbmRpbmc6IDAsXG4gICAgZmFpbHVyZXM6IDBcbiAgfTtcblxuICBpZiAoIXJ1bm5lcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcnVubmVyIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcblxuICBydW5uZXIub25jZShFVkVOVF9SVU5fQkVHSU4sIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfU1VJVEVfQkVHSU4sIGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9QQVNTLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMucGFzc2VzKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9GQUlMLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdHMuZmFpbHVyZXMrKztcbiAgfSk7XG4gIHJ1bm5lci5vbihFVkVOVF9URVNUX1BFTkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy5wZW5kaW5nKys7XG4gIH0pO1xuICBydW5uZXIub24oRVZFTlRfVEVTVF9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICBzdGF0cy50ZXN0cysrO1xuICB9KTtcbiAgcnVubmVyLm9uY2UoRVZFTlRfUlVOX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XG4gICAgc3RhdHMuZHVyYXRpb24gPSBzdGF0cy5lbmQgLSBzdGF0cy5zdGFydDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RhdHNDb2xsZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHtFdmVudEVtaXR0ZXJ9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBIb29rID0gcmVxdWlyZSgnLi9ob29rJyk7XG52YXIge1xuICBhc3NpZ25OZXdNb2NoYUlELFxuICBjbGFtcCxcbiAgY29uc3RhbnRzOiB1dGlsc0NvbnN0YW50cyxcbiAgZGVmaW5lQ29uc3RhbnRzLFxuICBnZXRNb2NoYUlELFxuICBpbmhlcml0cyxcbiAgaXNTdHJpbmdcbn0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnN1aXRlJyk7XG5jb25zdCBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCdtcycpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuY29uc3Qge01PQ0hBX0lEX1BST1BfTkFNRX0gPSB1dGlsc0NvbnN0YW50cztcblxuLyoqXG4gKiBFeHBvc2UgYFN1aXRlYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdWl0ZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBwYXJlbnQgYFN1aXRlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N1aXRlfSBwYXJlbnQgLSBQYXJlbnQgc3VpdGUgKHJlcXVpcmVkISlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRpdGxlXG4gKiBAcmV0dXJuIHtTdWl0ZX1cbiAqL1xuU3VpdGUuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgdGl0bGUpIHtcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRpdGxlLCBwYXJlbnQuY3R4KTtcbiAgc3VpdGUucGFyZW50ID0gcGFyZW50O1xuICB0aXRsZSA9IHN1aXRlLmZ1bGxUaXRsZSgpO1xuICBwYXJlbnQuYWRkU3VpdGUoc3VpdGUpO1xuICByZXR1cm4gc3VpdGU7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYFN1aXRlYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLCBgY3R4YCwgYW5kIGBpc1Jvb3RgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXJ8RXZlbnRFbWl0dGVyfVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gU3VpdGUgdGl0bGUuXG4gKiBAcGFyYW0ge0NvbnRleHR9IHBhcmVudENvbnRleHQgLSBQYXJlbnQgY29udGV4dCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzUm9vdD1mYWxzZV0gLSBXaGV0aGVyIHRoaXMgaXMgdGhlIHJvb3Qgc3VpdGUuXG4gKi9cbmZ1bmN0aW9uIFN1aXRlKHRpdGxlLCBwYXJlbnRDb250ZXh0LCBpc1Jvb3QpIHtcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcbiAgICB0aHJvdyBlcnJvcnMuY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yKFxuICAgICAgJ1N1aXRlIGFyZ3VtZW50IFwidGl0bGVcIiBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIFwiJyArXG4gICAgICAgIHR5cGVvZiB0aXRsZSArXG4gICAgICAgICdcIicsXG4gICAgICAndGl0bGUnLFxuICAgICAgJ3N0cmluZydcbiAgICApO1xuICB9XG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgZnVuY3Rpb24gQ29udGV4dCgpIHt9XG4gIENvbnRleHQucHJvdG90eXBlID0gcGFyZW50Q29udGV4dDtcbiAgdGhpcy5jdHggPSBuZXcgQ29udGV4dCgpO1xuICB0aGlzLnN1aXRlcyA9IFtdO1xuICB0aGlzLnRlc3RzID0gW107XG4gIHRoaXMucm9vdCA9IGlzUm9vdCA9PT0gdHJ1ZTtcbiAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcbiAgdGhpcy5fYmVmb3JlRWFjaCA9IFtdO1xuICB0aGlzLl9iZWZvcmVBbGwgPSBbXTtcbiAgdGhpcy5fYWZ0ZXJFYWNoID0gW107XG4gIHRoaXMuX2FmdGVyQWxsID0gW107XG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xuICB0aGlzLl9zbG93ID0gNzU7XG4gIHRoaXMuX2JhaWwgPSBmYWxzZTtcbiAgdGhpcy5fb25seVRlc3RzID0gW107XG4gIHRoaXMuX29ubHlTdWl0ZXMgPSBbXTtcbiAgYXNzaWduTmV3TW9jaGFJRCh0aGlzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRNb2NoYUlEKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXG4gKi9cbmluaGVyaXRzKFN1aXRlLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgc3RhdGUgaW5pdGlhbGx5IG9yIGZvciBhIG5leHQgcnVuLlxuICovXG5TdWl0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkb1Jlc2V0KHRoaW5nVG9SZXNldCkge1xuICAgIHRoaW5nVG9SZXNldC5yZXNldCgpO1xuICB9XG4gIHRoaXMuc3VpdGVzLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMudGVzdHMuZm9yRWFjaChkb1Jlc2V0KTtcbiAgdGhpcy5fYmVmb3JlRWFjaC5mb3JFYWNoKGRvUmVzZXQpO1xuICB0aGlzLl9hZnRlckVhY2guZm9yRWFjaChkb1Jlc2V0KTtcbiAgdGhpcy5fYmVmb3JlQWxsLmZvckVhY2goZG9SZXNldCk7XG4gIHRoaXMuX2FmdGVyQWxsLmZvckVhY2goZG9SZXNldCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgYFN1aXRlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRoaXMudGl0bGUpO1xuICBkZWJ1ZygnY2xvbmUnKTtcbiAgc3VpdGUuY3R4ID0gdGhpcy5jdHg7XG4gIHN1aXRlLnJvb3QgPSB0aGlzLnJvb3Q7XG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xuICByZXR1cm4gc3VpdGU7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgdGltZW91dCBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcIjJzXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0b2RvIERvIG5vdCBhdHRlbXB0IHRvIHNldCB2YWx1ZSBpZiBgbXNgIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XG4gIH1cblxuICAvLyBDbGFtcCB0byByYW5nZVxuICB2YXIgSU5UX01BWCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gIHZhciByYW5nZSA9IFswLCBJTlRfTUFYXTtcbiAgbXMgPSBjbGFtcChtcywgcmFuZ2UpO1xuXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xuICB0aGlzLl90aW1lb3V0ID0gcGFyc2VJbnQobXMsIDEwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBvciBnZXQgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGEgZmFpbGVkIHRlc3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gblxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcbiAgfVxuICBkZWJ1ZygncmV0cmllcyAlZCcsIG4pO1xuICB0aGlzLl9yZXRyaWVzID0gcGFyc2VJbnQobiwgMTApIHx8IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IHNsb3cgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXCIyc1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcbiAgfVxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcbiAgfVxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcbiAgdGhpcy5fc2xvdyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG9yIGdldCB3aGV0aGVyIHRvIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyb3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFpbFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbiAoYmFpbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFpbDtcbiAgfVxuICBkZWJ1ZygnYmFpbCAlcycsIGJhaWwpO1xuICB0aGlzLl9iYWlsID0gYmFpbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgc3VpdGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5TdWl0ZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wZW5kaW5nIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1BlbmRpbmcoKSk7XG59O1xuXG4vKipcbiAqIEdlbmVyaWMgaG9vay1jcmVhdG9yLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRpdGxlIG9mIGhvb2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gSG9vayBjYWxsYmFja1xuICogQHJldHVybnMge0hvb2t9IEEgbmV3IGhvb2tcbiAqL1xuU3VpdGUucHJvdG90eXBlLl9jcmVhdGVIb29rID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICB2YXIgaG9vayA9IG5ldyBIb29rKHRpdGxlLCBmbik7XG4gIGhvb2sucGFyZW50ID0gdGhpcztcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgaG9vay5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcbiAgaG9vay5maWxlID0gdGhpcy5maWxlO1xuICByZXR1cm4gaG9vaztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgcnVubmluZyB0ZXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImJlZm9yZSBhbGxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYmVmb3JlQWxsLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0FMTCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGFmdGVyIHJ1bm5pbmcgdGVzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImFmdGVyIGFsbFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xuXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xuICB0aGlzLl9hZnRlckFsbC5wdXNoKGhvb2spO1xuICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1NVSVRFX0FERF9IT09LX0FGVEVSX0FMTCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSB0aXRsZTtcbiAgICB0aXRsZSA9IGZuLm5hbWU7XG4gIH1cbiAgdGl0bGUgPSAnXCJiZWZvcmUgZWFjaFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xuXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xuICB0aGlzLl9iZWZvcmVFYWNoLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0VBQ0gsIGhvb2spO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBlYWNoIHRlc3QgY2FzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xuICovXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IHRpdGxlO1xuICAgIHRpdGxlID0gZm4ubmFtZTtcbiAgfVxuICB0aXRsZSA9ICdcImFmdGVyIGVhY2hcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcblxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcbiAgdGhpcy5fYWZ0ZXJFYWNoLnB1c2goaG9vayk7XG4gIHRoaXMuZW1pdChjb25zdGFudHMuRVZFTlRfU1VJVEVfQUREX0hPT0tfQUZURVJfRUFDSCwgaG9vayk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0ZXN0IGBzdWl0ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hZGRTdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSkge1xuICBzdWl0ZS5wYXJlbnQgPSB0aGlzO1xuICBzdWl0ZS5yb290ID0gZmFsc2U7XG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xuICB0aGlzLnN1aXRlcy5wdXNoKHN1aXRlKTtcbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9BRERfU1VJVEUsIHN1aXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGB0ZXN0YCB0byB0aGlzIHN1aXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcbiAqL1xuU3VpdGUucHJvdG90eXBlLmFkZFRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICB0ZXN0LnBhcmVudCA9IHRoaXM7XG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcbiAgdGhpcy5lbWl0KGNvbnN0YW50cy5FVkVOVF9TVUlURV9BRERfVEVTVCwgdGVzdCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXG4gKiBmdWxsIHRpdGxlLlxuICpcbiAqIEBtZW1iZXJvZiBTdWl0ZVxuICogQHB1YmxpY1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5TdWl0ZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50aXRsZVBhdGgoKS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdGl0bGUgcGF0aCBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcbiAqIHRpdGxlIHBhdGguXG4gKlxuICogQG1lbWJlcm9mIFN1aXRlXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblN1aXRlLnByb3RvdHlwZS50aXRsZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcmVudC50aXRsZVBhdGgoKSk7XG4gIH1cbiAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICByZXN1bHQucHVzaCh0aGlzLnRpdGxlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cbiAqXG4gKiBAbWVtYmVyb2YgU3VpdGVcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnRvdGFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuc3VpdGVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzdWl0ZSkge1xuICAgICAgcmV0dXJuIHN1bSArIHN1aXRlLnRvdGFsKCk7XG4gICAgfSwgMCkgKyB0aGlzLnRlc3RzLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggc3VpdGUgcmVjdXJzaXZlbHkgdG8gZmluZCBhbGwgdGVzdHMuIEFwcGxpZXMgYVxuICogZnVuY3Rpb24gaW4gdGhlIGZvcm1hdCBgZm4odGVzdClgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U3VpdGV9XG4gKi9cblN1aXRlLnByb3RvdHlwZS5lYWNoVGVzdCA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLnRlc3RzLmZvckVhY2goZm4pO1xuICB0aGlzLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xuICAgIHN1aXRlLmVhY2hUZXN0KGZuKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcnVuIHRoZSByb290IHN1aXRlIGlmIHdlIGhhcHBlbiB0byBiZSBydW5uaW5nIGluIGRlbGF5ZWQgbW9kZS5cbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gIGlmICh0aGlzLnJvb3QpIHtcbiAgICB0aGlzLmVtaXQoY29uc3RhbnRzLkVWRU5UX1JPT1RfU1VJVEVfUlVOKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdWl0ZSBoYXMgYW4gYG9ubHlgIHRlc3Qgb3Igc3VpdGUgYXMgYSBkZXNjZW5kYW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuU3VpdGUucHJvdG90eXBlLmhhc09ubHkgPSBmdW5jdGlvbiBoYXNPbmx5KCkge1xuICByZXR1cm4gKFxuICAgIHRoaXMuX29ubHlUZXN0cy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5fb25seVN1aXRlcy5sZW5ndGggPiAwIHx8XG4gICAgdGhpcy5zdWl0ZXMuc29tZShmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICAgIHJldHVybiBzdWl0ZS5oYXNPbmx5KCk7XG4gICAgfSlcbiAgKTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHN1aXRlcyBiYXNlZCBvbiBgaXNPbmx5YCBsb2dpYy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblN1aXRlLnByb3RvdHlwZS5maWx0ZXJPbmx5ID0gZnVuY3Rpb24gZmlsdGVyT25seSgpIHtcbiAgaWYgKHRoaXMuX29ubHlUZXN0cy5sZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgc3VpdGUgY29udGFpbnMgYG9ubHlgIHRlc3RzLCBydW4gdGhvc2UgYW5kIGlnbm9yZSBhbnkgbmVzdGVkIHN1aXRlcy5cbiAgICB0aGlzLnRlc3RzID0gdGhpcy5fb25seVRlc3RzO1xuICAgIHRoaXMuc3VpdGVzID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcnVuIGFueSBvZiB0aGUgdGVzdHMgaW4gdGhpcyBzdWl0ZS5cbiAgICB0aGlzLnRlc3RzID0gW107XG4gICAgdGhpcy5fb25seVN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChvbmx5U3VpdGUpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgb2YgdGhlIHRlc3RzIG9uIHRoaXMgYG9ubHlgIHN1aXRlIHNob3VsZCBiZSBydW4sIHNvIGRvbid0IGZpbHRlciBpdC5cbiAgICAgIGlmIChvbmx5U3VpdGUuaGFzT25seSgpKSB7XG4gICAgICAgIG9ubHlTdWl0ZS5maWx0ZXJPbmx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gUnVuIHRoZSBgb25seWAgc3VpdGVzLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdWl0ZXMgdGhhdCBoYXZlIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgYXMgZGVzY2VuZGFudHMuXG4gICAgdmFyIG9ubHlTdWl0ZXMgPSB0aGlzLl9vbmx5U3VpdGVzO1xuICAgIHRoaXMuc3VpdGVzID0gdGhpcy5zdWl0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFN1aXRlKSB7XG4gICAgICByZXR1cm4gb25seVN1aXRlcy5pbmRleE9mKGNoaWxkU3VpdGUpICE9PSAtMSB8fCBjaGlsZFN1aXRlLmZpbHRlck9ubHkoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBLZWVwIHRoZSBzdWl0ZSBvbmx5IGlmIHRoZXJlIGlzIHNvbWV0aGluZyB0byBydW5cbiAgcmV0dXJuIHRoaXMudGVzdHMubGVuZ3RoID4gMCB8fCB0aGlzLnN1aXRlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc3VpdGUgdG8gdGhlIGxpc3Qgb2Ygc3Vic3VpdGVzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5hcHBlbmRPbmx5U3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUpIHtcbiAgdGhpcy5fb25seVN1aXRlcy5wdXNoKHN1aXRlKTtcbn07XG5cbi8qKlxuICogTWFya3MgYSBzdWl0ZSB0byBiZSBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuU3VpdGUucHJvdG90eXBlLm1hcmtPbmx5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hcHBlbmRPbmx5U3VpdGUodGhpcyk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0ZXN0IHRvIHRoZSBsaXN0IG9mIHRlc3RzIG1hcmtlZCBgb25seWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICovXG5TdWl0ZS5wcm90b3R5cGUuYXBwZW5kT25seVRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xuICB0aGlzLl9vbmx5VGVzdHMucHVzaCh0ZXN0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgb2YgaG9va3MgYnkgaG9vayBuYW1lOyBzZWUgYEhPT0tfVFlQRV8qYCBjb25zdGFudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5TdWl0ZS5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiBnZXRIb29rcyhuYW1lKSB7XG4gIHJldHVybiB0aGlzWydfJyArIG5hbWVdO1xufTtcblxuLyoqXG4gKiBjbGVhbnMgYWxsIHJlZmVyZW5jZXMgZnJvbSB0aGlzIHN1aXRlIGFuZCBhbGwgY2hpbGQgc3VpdGVzLlxuICovXG5TdWl0ZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcbiAgICBzdWl0ZS5kaXNwb3NlKCk7XG4gIH0pO1xuICB0aGlzLmNsZWFuUmVmZXJlbmNlcygpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgdGhlIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnNcbiAqIChiZWZvcmUvYWZ0ZXIvYmVmb3JlRWFjaC9hZnRlckVhY2gpIGFuZCB0ZXN0cyBvZiBhIFN1aXRlLlxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXG4gKiBhcyB0aG9zZSBmdW5jdGlvbnMgbWF5IHJlZmVyZW5jZSB2YXJpYWJsZXMgZnJvbSBjbG9zdXJlcyxcbiAqIHRodXMgdGhvc2UgdmFyaWFibGVzIGNhbiBuZXZlciBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhcyBsb25nXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblN1aXRlLnByb3RvdHlwZS5jbGVhblJlZmVyZW5jZXMgPSBmdW5jdGlvbiBjbGVhblJlZmVyZW5jZXMoKSB7XG4gIGZ1bmN0aW9uIGNsZWFuQXJyUmVmZXJlbmNlcyhhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgZGVsZXRlIGFycltpXS5mbjtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVBbGwpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2JlZm9yZUFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9iZWZvcmVFYWNoKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9iZWZvcmVFYWNoKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2FmdGVyQWxsKSkge1xuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyh0aGlzLl9hZnRlckFsbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9hZnRlckVhY2gpKSB7XG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHRoaXMuX2FmdGVyRWFjaCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWxldGUgdGhpcy50ZXN0c1tpXS5mbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgSVBDLlxuICogRnVuY3Rpb25zIGFyZSByZXByZXNlbnRlZCBieSBrZXlzIGJlZ2lubmluZyB3aXRoIGAkJGAuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuU3VpdGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBfYmFpbDogdGhpcy5fYmFpbCxcbiAgICAkJGZ1bGxUaXRsZTogdGhpcy5mdWxsVGl0bGUoKSxcbiAgICAkJGlzUGVuZGluZzogQm9vbGVhbih0aGlzLmlzUGVuZGluZygpKSxcbiAgICByb290OiB0aGlzLnJvb3QsXG4gICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMuaWQsXG4gICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHtbTU9DSEFfSURfUFJPUF9OQU1FXTogdGhpcy5wYXJlbnQuaWR9IDogbnVsbFxuICB9O1xufTtcblxudmFyIGNvbnN0YW50cyA9IGRlZmluZUNvbnN0YW50cyhcbiAgLyoqXG4gICAqIHtAbGluayBTdWl0ZX0tcmVsYXRlZCBjb25zdGFudHMuXG4gICAqIEBwdWJsaWNcbiAgICogQG1lbWJlcm9mIFN1aXRlXG4gICAqIEBhbGlhcyBjb25zdGFudHNcbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1BPU1RfUkVRVUlSRTogJ3Bvc3QtcmVxdWlyZScsXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCBiZWZvcmUgYSB0ZXN0IGZpbGUgaGFzIGJlZW4gbG9hZGVkLiBJbiBicm93c2VyLCB0aGlzIGlzIGVtaXR0ZWQgb25jZSBhbiBpbnRlcmZhY2UgaGFzIGJlZW4gc2VsZWN0ZWQuXG4gICAgICovXG4gICAgRVZFTlRfRklMRV9QUkVfUkVRVUlSRTogJ3ByZS1yZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgdGVzdCBmaWxlIGhhcyBiZWVuIGxvYWRlZC4gTm90IGVtaXR0ZWQgaW4gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFVkVOVF9GSUxFX1JFUVVJUkU6ICdyZXF1aXJlJyxcbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYGdsb2JhbC5ydW4oKWAgaXMgY2FsbGVkICh1c2Ugd2l0aCBgZGVsYXlgIG9wdGlvbikuXG4gICAgICovXG4gICAgRVZFTlRfUk9PVF9TVUlURV9SVU46ICdydW4nLFxuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYWZ0ZXIgYWxsXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0FMTDogJ2FmdGVyQWxsJyxcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgZm9yIGNvbGxlY3Rpb24gb2YgYSBgU3VpdGVgJ3MgXCJhZnRlciBlYWNoXCIgaG9va3MuXG4gICAgICovXG4gICAgSE9PS19UWVBFX0FGVEVSX0VBQ0g6ICdhZnRlckVhY2gnLFxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBmb3IgY29sbGVjdGlvbiBvZiBhIGBTdWl0ZWAncyBcImJlZm9yZSBhbGxcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGZvciBjb2xsZWN0aW9uIG9mIGEgYFN1aXRlYCdzIFwiYmVmb3JlIGVhY2hcIiBob29rcy5cbiAgICAgKi9cbiAgICBIT09LX1RZUEVfQkVGT1JFX0VBQ0g6ICdiZWZvcmVFYWNoJyxcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBjaGlsZCBgU3VpdGVgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfU1VJVEU6ICdzdWl0ZScsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImFmdGVyIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQUZURVJfQUxMOiAnYWZ0ZXJBbGwnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYW4gXCJhZnRlciBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19BRlRFUl9FQUNIOiAnYWZ0ZXJFYWNoJyxcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGFmdGVyIGFuIFwiYmVmb3JlIGFsbFwiIGBIb29rYCBoYXMgYmVlbiBhZGRlZCB0byBhIGBTdWl0ZWAuXG4gICAgICovXG4gICAgRVZFTlRfU1VJVEVfQUREX0hPT0tfQkVGT1JFX0FMTDogJ2JlZm9yZUFsbCcsXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhbiBcImJlZm9yZSBlYWNoXCIgYEhvb2tgIGhhcyBiZWVuIGFkZGVkIHRvIGEgYFN1aXRlYC5cbiAgICAgKi9cbiAgICBFVkVOVF9TVUlURV9BRERfSE9PS19CRUZPUkVfRUFDSDogJ2JlZm9yZUVhY2gnLFxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgYSBgVGVzdGAgaGFzIGJlZW4gYWRkZWQgdG8gYSBgU3VpdGVgLlxuICAgICAqL1xuICAgIEVWRU5UX1NVSVRFX0FERF9URVNUOiAndGVzdCdcbiAgfVxuKTtcblxuU3VpdGUuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgY3JlYXRlSW52YWxpZEFyZ3VtZW50VHlwZUVycm9yID0gZXJyb3JzLmNyZWF0ZUludmFsaWRBcmd1bWVudFR5cGVFcnJvcjtcbnZhciBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nO1xuXG5jb25zdCB7TU9DSEFfSURfUFJPUF9OQU1FfSA9IHV0aWxzLmNvbnN0YW50cztcblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBSdW5uYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gVGVzdCB0aXRsZSAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIC0gVGVzdCBjYWxsYmFjay4gIElmIG9taXR0ZWQsIHRoZSBUZXN0IGlzIGNvbnNpZGVyZWQgXCJwZW5kaW5nXCJcbiAqL1xuZnVuY3Rpb24gVGVzdCh0aXRsZSwgZm4pIHtcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcbiAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQXJndW1lbnRUeXBlRXJyb3IoXG4gICAgICAnVGVzdCBhcmd1bWVudCBcInRpdGxlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIFwiJyArXG4gICAgICAgIHR5cGVvZiB0aXRsZSArXG4gICAgICAgICdcIicsXG4gICAgICAndGl0bGUnLFxuICAgICAgJ3N0cmluZydcbiAgICApO1xuICB9XG4gIHRoaXMudHlwZSA9ICd0ZXN0JztcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxuICovXG51dGlscy5pbmhlcml0cyhUZXN0LCBSdW5uYWJsZSk7XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBpbml0aWFsbHkgb3IgZm9yIGEgbmV4dCBydW4uXG4gKi9cblRlc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBSdW5uYWJsZS5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgdGhpcy5wZW5kaW5nID0gIXRoaXMuZm47XG4gIGRlbGV0ZSB0aGlzLnN0YXRlO1xufTtcblxuLyoqXG4gKiBTZXQgb3IgZ2V0IHJldHJpZWQgdGVzdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRlc3QucHJvdG90eXBlLnJldHJpZWRUZXN0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZWRUZXN0O1xuICB9XG4gIHRoaXMuX3JldHJpZWRUZXN0ID0gbjtcbn07XG5cbi8qKlxuICogQWRkIHRlc3QgdG8gdGhlIGxpc3Qgb2YgdGVzdHMgbWFya2VkIGBvbmx5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXN0LnByb3RvdHlwZS5tYXJrT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYXJlbnQuYXBwZW5kT25seVRlc3QodGhpcyk7XG59O1xuXG5UZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aGlzLnRpdGxlLCB0aGlzLmZuKTtcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcbiAgdGVzdC5jdXJyZW50UmV0cnkodGhpcy5jdXJyZW50UmV0cnkoKSk7XG4gIHRlc3QucmV0cmllZFRlc3QodGhpcy5yZXRyaWVkVGVzdCgpIHx8IHRoaXMpO1xuICB0ZXN0Lmdsb2JhbHModGhpcy5nbG9iYWxzKCkpO1xuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xuICB0ZXN0LmZpbGUgPSB0aGlzLmZpbGU7XG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XG4gIHJldHVybiB0ZXN0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG1pbmltYWwgb2JqZWN0IHN1aXRhYmxlIGZvciB0cmFuc21pc3Npb24gb3ZlciBJUEMuXG4gKiBGdW5jdGlvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IGtleXMgYmVnaW5uaW5nIHdpdGggYCQkYC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5UZXN0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gIHJldHVybiB7XG4gICAgJCRjdXJyZW50UmV0cnk6IHRoaXMuX2N1cnJlbnRSZXRyeSxcbiAgICAkJGZ1bGxUaXRsZTogdGhpcy5mdWxsVGl0bGUoKSxcbiAgICAkJGlzUGVuZGluZzogQm9vbGVhbih0aGlzLnBlbmRpbmcpLFxuICAgICQkcmV0cmllZFRlc3Q6IHRoaXMuX3JldHJpZWRUZXN0IHx8IG51bGwsXG4gICAgJCRzbG93OiB0aGlzLl9zbG93LFxuICAgICQkdGl0bGVQYXRoOiB0aGlzLnRpdGxlUGF0aCgpLFxuICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICBlcnI6IHRoaXMuZXJyLFxuICAgIHBhcmVudDoge1xuICAgICAgJCRmdWxsVGl0bGU6IHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpLFxuICAgICAgW01PQ0hBX0lEX1BST1BfTkFNRV06IHRoaXMucGFyZW50LmlkXG4gICAgfSxcbiAgICBzcGVlZDogdGhpcy5zcGVlZCxcbiAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgZmlsZTogdGhpcy5maWxlLFxuICAgIFtNT0NIQV9JRF9QUk9QX05BTUVdOiB0aGlzLmlkXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCB0aHJvdWdob3V0IE1vY2hhJ3MgY29kZWJhc2UuXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHtuYW5vaWR9ID0gcmVxdWlyZSgnbmFub2lkL25vbi1zZWN1cmUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgaGUgPSByZXF1aXJlKCdoZScpO1xuXG5jb25zdCBNT0NIQV9JRF9QUk9QX05BTUUgPSAnX19tb2NoYV9pZF9fJztcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciAtIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIC0gQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgZWl0aGVyIGNvbnN0cnVjdG9yIGlzIG51bGwsIG9yIGlmIHN1cGVyIGNvbnN0cnVjdG9yXG4gKiAgICAgbGFja3MgYSBwcm90b3R5cGUuXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSB1dGlsLmluaGVyaXRzO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICByZXR1cm4gaGUuZW5jb2RlKFN0cmluZyhodG1sKSwge3VzZU5hbWVkUmVmZXJlbmNlczogZmFsc2V9KTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuc2x1ZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1xccysvZywgJy0nKVxuICAgIC5yZXBsYWNlKC9bXi1cXHddL2csICcnKVxuICAgIC5yZXBsYWNlKC8tezIsfS9nLCAnLScpO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbiBmcm9tIGBzdHJgLCBhbmQgcmUtaW5kZW50IGZvciBwcmUgd2hpdGVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHN0ciA9IHN0clxuICAgIC5yZXBsYWNlKC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vZywgJ1xcbicpXG4gICAgLnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gICAgLy8gKHRyYWRpdGlvbmFsKS0+ICBzcGFjZS9uYW1lICAgICBwYXJhbWV0ZXJzICAgIGJvZHkgICAgIChsYW1iZGEpLT4gcGFyYW1ldGVycyAgICAgICBib2R5ICAgbXVsdGktc3RhdGVtZW50L3NpbmdsZSAgICAgICAgICBrZWVwIGJvZHkgY29udGVudFxuICAgIC5yZXBsYWNlKFxuICAgICAgL15mdW5jdGlvbig/Olxccyp8XFxzK1teKF0qKVxcKFteKV0qXFwpXFxzKlxceygoPzoufFxcbikqPylcXHMqXFx9JHxeXFwoW14pXSpcXClcXHMqPT5cXHMqKD86XFx7KCg/Oi58XFxuKSo/KVxccypcXH18KCg/Oi58XFxuKSopKSQvLFxuICAgICAgJyQxJDIkMydcbiAgICApO1xuXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXG4/KCAqKS8pWzFdLmxlbmd0aDtcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXG4/KFxcdCopLylbMV0ubGVuZ3RoO1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFxuICAgICdeXFxuPycgKyAodGFicyA/ICdcXHQnIDogJyAnKSArICd7JyArICh0YWJzIHx8IHNwYWNlcykgKyAnfScsXG4gICAgJ2dtJ1xuICApO1xuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHJlLCAnJyk7XG5cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKipcbiAqIElmIGEgdmFsdWUgY291bGQgaGF2ZSBwcm9wZXJ0aWVzLCBhbmQgaGFzIG5vbmUsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXG4gKlxuICogRnVuY3Rpb25zIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAnW0Z1bmN0aW9uXSdgXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXG4gKiBBbGwgZWxzZTogcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KSB7XG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ1tGdW5jdGlvbl0nO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XG4gKiBpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21wdXRlZCB0eXBlXG4gKiBAZXhhbXBsZVxuICogY2Fub25pY2FsVHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIGNhbm9uaWNhbFR5cGUoW10pIC8vICdhcnJheSdcbiAqIGNhbm9uaWNhbFR5cGUoMSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogY2Fub25pY2FsVHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIGNhbm9uaWNhbFR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xuICogY2Fub25pY2FsVHlwZSgvZm9vLykgLy8gJ3JlZ2V4cCdcbiAqIGNhbm9uaWNhbFR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xuICogY2Fub25pY2FsVHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXG4gKiBjYW5vbmljYWxUeXBlKG5ldyBTdHJpbmcoJ2ZvbycpIC8vICdvYmplY3QnXG4gKiBjYW5vbmljYWxUeXBlKGFzeW5jIGZ1bmN0aW9uKCkge30pIC8vICdhc3luY2Z1bmN0aW9uJ1xuICogY2Fub25pY2FsVHlwZShhd2FpdCBpbXBvcnQobmFtZSkpIC8vICdtb2R1bGUnXG4gKi9cbnZhciBjYW5vbmljYWxUeXBlID0gKGV4cG9ydHMuY2Fub25pY2FsVHlwZSA9IGZ1bmN0aW9uIGNhbm9uaWNhbFR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbCh2YWx1ZSlcbiAgICAucmVwbGFjZSgvXlxcWy4rXFxzKC4rPyldJC8sICckMScpXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuLyoqXG4gKlxuICogUmV0dXJucyBhIGdlbmVyYWwgdHlwZSBvciBkYXRhIHN0cnVjdHVyZSBvZiBhIHZhcmlhYmxlXG4gKiBAcHJpdmF0ZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0RhdGFfc3RydWN0dXJlc1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IE9uZSBvZiB1bmRlZmluZWQsIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBiaWdpbnQsIHN5bWJvbCwgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqIHR5cGUoW10pIC8vICdhcnJheSdcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xuICogdHlwZShJbmZpbml0eSkgLy8gJ251bWJlcidcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdvYmplY3QnXG4gKiB0eXBlKC9mb28vKSAvLyAnb2JqZWN0J1xuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXG4gKiB0eXBlKGdsb2JhbCkgLy8gJ29iamVjdCdcbiAqIHR5cGUobmV3IFN0cmluZygnZm9vJykgLy8gJ3N0cmluZydcbiAqL1xuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAvLyBOdWxsIGlzIHNwZWNpYWxcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBjb25zdCBwcmltaXRpdmVzID0gbmV3IFNldChbXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdudW1iZXInLFxuICAgICdzdHJpbmcnLFxuICAgICdiaWdpbnQnLFxuICAgICdzeW1ib2wnXG4gIF0pO1xuICBjb25zdCBfdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKF90eXBlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gX3R5cGU7XG4gIGlmIChwcmltaXRpdmVzLmhhcyhfdHlwZSkpIHJldHVybiBfdHlwZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gJ2FycmF5JztcblxuICByZXR1cm4gX3R5cGU7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XG4gKlxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxuICogLSBJZiBgdmFsdWVgIGlzIGFuICplbXB0eSogb2JqZWN0LCBmdW5jdGlvbiwgb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgZnVuY3Rpb25cbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxuICogICBKU09OLnN0cmluZ2lmeSgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgdHlwZUhpbnQgPSBjYW5vbmljYWxUeXBlKHZhbHVlKTtcblxuICBpZiAoIX5bJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbiddLmluZGV4T2YodHlwZUhpbnQpKSB7XG4gICAgaWYgKHR5cGVIaW50ID09PSAnYnVmZmVyJykge1xuICAgICAgdmFyIGpzb24gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTi5jYWxsKHZhbHVlKTtcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb24sXG4gICAgICAgIDJcbiAgICAgICkucmVwbGFjZSgvLChcXG58JCkvZywgJyQxJyk7XG4gICAgfVxuXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxuICAgIC8vIGludG8gYW4gYXJyYXkgYW5kIGJhY2sgdG8gb2JqLlxuICAgIGlmICh0eXBlSGludCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNoYXIsIGlkeCkge1xuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApKSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShcbiAgICAgICAgZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSxcbiAgICAgICAgMlxuICAgICAgKS5yZXBsYWNlKC8sKFxcbnwkKS9nLCAnJDEnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xufTtcblxuLyoqXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXI9fSBzcGFjZXNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5KG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xuICBpZiAodHlwZW9mIHNwYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xuICB9XG5cbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xuICB2YXIgc3BhY2UgPSBzcGFjZXMgKiBkZXB0aDtcbiAgdmFyIHN0ciA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcbiAgdmFyIGVuZCA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcbiAgdmFyIGxlbmd0aCA9XG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT09ICdudW1iZXInXG4gICAgICA/IG9iamVjdC5sZW5ndGhcbiAgICAgIDogT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGg7XG4gIC8vIGAucmVwZWF0KClgIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHJlcGVhdChzLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSh2YWwpIHtcbiAgICBzd2l0Y2ggKGNhbm9uaWNhbFR5cGUodmFsKSkge1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICB2YWwgPSAnWycgKyB2YWwgKyAnXSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdmFsID1cbiAgICAgICAgICB2YWwgPT09IDAgJiYgMSAvIHZhbCA9PT0gLUluZmluaXR5IC8vIGAtMGBcbiAgICAgICAgICAgID8gJy0wJ1xuICAgICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKSArICduJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgPyB2YWwudG9TdHJpbmcoKSA6IHZhbC50b0lTT1N0cmluZygpO1xuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YWwgPVxuICAgICAgICAgIHZhbCA9PT0gJ1tGdW5jdGlvbl0nIHx8IHZhbCA9PT0gJ1tDaXJjdWxhcl0nXG4gICAgICAgICAgICA/IHZhbFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWwpOyAvLyBzdHJpbmdcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBpKSkge1xuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xuICAgIH1cbiAgICAtLWxlbmd0aDtcbiAgICBzdHIgKz1cbiAgICAgICdcXG4gJyArXG4gICAgICByZXBlYXQoJyAnLCBzcGFjZSkgK1xuICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICcnIDogJ1wiJyArIGkgKyAnXCI6ICcpICsgLy8ga2V5XG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAvLyB2YWx1ZVxuICAgICAgKGxlbmd0aCA/ICcsJyA6ICcnKTsgLy8gY29tbWFcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgc3RyICtcbiAgICAvLyBbXSwge31cbiAgICAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXG4nICsgcmVwZWF0KCcgJywgLS1zcGFjZSkgKyBlbmQgOiBlbmQpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IFRoaW5nIHRoYXQgaGFzIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlci4gUmVjdXJzaXZlLlxuICpcbiAqIElmIHRoZSBUaGluZy4uLlxuICogLSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4sIHJldHVybiBzdHJpbmcgYCdbQ2lyY3VsYXJdJ2BcbiAqIC0gaXMgYHVuZGVmaW5lZGAsIHJldHVybiBzdHJpbmcgYCdbdW5kZWZpbmVkXSdgXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxuICogLSBpcyBzb21lIG90aGVyIHByaW1pdGl2ZSwgcmV0dXJuIHRoZSB2YWx1ZVxuICogLSBpcyBub3QgYSBwcmltaXRpdmUgb3IgYW4gYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIFRoaW5nJ3MgYHRvU3RyaW5nKClgIG1ldGhvZFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuICogLSBpcyBhbiBlbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZW1wdHlSZXByZXNlbnRhdGlvbigpYFxuICpcbiAqIEBwcml2YXRlXG4gKiBAc2VlIHtAbGluayBleHBvcnRzLnN0cmluZ2lmeX1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFjaz1bXV0gU3RhY2sgb2Ygc2VlbiB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZUhpbnRdIFR5cGUgaGludFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cbiAqL1xuZXhwb3J0cy5jYW5vbmljYWxpemUgPSBmdW5jdGlvbiBjYW5vbmljYWxpemUodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xuICB2YXIgY2Fub25pY2FsaXplZE9iajtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIHByb3A7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdHlwZUhpbnQgPSB0eXBlSGludCB8fCBjYW5vbmljYWxUeXBlKHZhbHVlKTtcbiAgZnVuY3Rpb24gd2l0aFN0YWNrKHZhbHVlLCBmbikge1xuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgIGZuKCk7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuXG4gIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlSGludCkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnYnVmZmVyJzpcbiAgICBjYXNlICdudWxsJzpcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2Fub25pY2FsaXplKGl0ZW0sIHN0YWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tdW5yZWFjaGFibGUtbG9vcCAqL1xuICAgICAgZm9yIChwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGNhbm9uaWNhbGl6ZWRPYmogfHwge307XG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdyZWdleHAnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlICsgJyc7XG4gIH1cblxuICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbn07XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqIFRoaXMgRmlsdGVyIGJhc2VkIG9uIGBtb2NoYS1jbGVhbmAgbW9kdWxlLihzZWU6IGBnaXRodWIuY29tL3JzdGFjcnV6L21vY2hhLWNsZWFuYClcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIHlvdSBnZXQgYSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCBnZXQgdGhlIEVycm9yLnN0YWNrIGFzIGFuIGlucHV0LFxuICogYW5kIHJldHVybiBhIHByZXR0aWZ5IG91dHB1dC5cbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcbiAgdmFyIGlzID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHtub2RlOiB0cnVlfSA6IHticm93c2VyOiB0cnVlfTtcbiAgdmFyIHNsYXNoID0gcGF0aC5zZXA7XG4gIHZhciBjd2Q7XG4gIGlmIChpcy5ub2RlKSB7XG4gICAgY3dkID0gZXhwb3J0cy5jd2QoKSArIHNsYXNoO1xuICB9IGVsc2Uge1xuICAgIGN3ZCA9IChcbiAgICAgIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiBsb2NhdGlvblxuICAgICkuaHJlZi5yZXBsYWNlKC9cXC9bXi9dKiQvLCAnLycpO1xuICAgIHNsYXNoID0gJy8nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2NoYUludGVybmFsKGxpbmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgfmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZihzbGFzaCArICdtb2NoYS5qcycpIHx8XG4gICAgICB+bGluZS5pbmRleE9mKHNsYXNoICsgJ21vY2hhLm1pbi5qcycpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZUludGVybmFsKGxpbmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgfmxpbmUuaW5kZXhPZignKHRpbWVycy5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignKGV2ZW50cy5qczonKSB8fFxuICAgICAgfmxpbmUuaW5kZXhPZignKG5vZGUuanM6JykgfHxcbiAgICAgIH5saW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykgfHxcbiAgICAgIH5saW5lLmluZGV4T2YoJ0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLm5leHQgKG5hdGl2ZSknKSB8fFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgc3RhY2sgPSBzdGFjay5yZWR1Y2UoZnVuY3Rpb24gKGxpc3QsIGxpbmUpIHtcbiAgICAgIGlmIChpc01vY2hhSW50ZXJuYWwobGluZSkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChpcy5ub2RlICYmIGlzTm9kZUludGVybmFsKGxpbmUpKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXG4gICAgICBpZiAoLzpcXGQrOlxcZCtcXCk/JC8udGVzdChsaW5lKSkge1xuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKCcoJyArIGN3ZCwgJygnKTtcbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGxpbmUpO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcbicpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcnVkZSwgYnV0IGVmZmVjdGl2ZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBgdmFsdWVgIGlzIGEgUHJvbWlzZVxuICovXG5leHBvcnRzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nXG4gICk7XG59O1xuXG4vKipcbiAqIENsYW1wcyBhIG51bWVyaWMgdmFsdWUgdG8gYW4gaW5jbHVzaXZlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNsYW1wZWQuXG4gKiBAcGFyYW0ge251bWJlcltdfSByYW5nZSAtIFR3byBlbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgW21pbiwgbWF4XSByYW5nZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNsYW1wZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCByYW5nZSkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIHJhbmdlWzBdKSwgcmFuZ2VbMV0pO1xufTtcblxuLyoqXG4gKiBJdCdzIGEgbm9vcC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcC1saWtlIG9iamVjdC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgXCJtYXBcIiBpcyBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUsIGZvciBvdXIgcHVycG9zZXMuIEluIHNvbWUgY2FzZXNcbiAqIHRoaXMgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZSB0aGFuIGEgYE1hcGAsIGVzcGVjaWFsbHkgaWYgeW91ciBlbnZpcm9ubWVudFxuICogZG9lc24ndCBzdXBwb3J0IGl0LiBSZWNvbW1lbmRlZCBmb3IgdXNlIGluIE1vY2hhJ3MgcHVibGljIEFQSXMuXG4gKlxuICogQHB1YmxpY1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpNYXB9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpPYmplY3QuY3JlYXRlIC0gQ3VzdG9tIG9iamVjdHN9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduI0N1c3RvbV9hbmRfTnVsbF9vYmplY3RzfE1ETjpPYmplY3QuYXNzaWdufVxuICogQHBhcmFtIHsuLi4qfSBbb2JqXSAtIEFyZ3VtZW50cyB0byBgT2JqZWN0LmFzc2lnbigpYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZSwgaGF2aW5nIGAuLi5vYmpgIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0cy5jcmVhdGVNYXAgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KFxuICAgIG51bGwsXG4gICAgW09iamVjdC5jcmVhdGUobnVsbCldLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZC1vbmx5IG1hcC1saWtlIG9iamVjdC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgZGlmZmVycyBmcm9tIHtAbGluayBtb2R1bGU6dXRpbHMuY3JlYXRlTWFwIGNyZWF0ZU1hcH0gb25seSBpbiB0aGF0XG4gKiB0aGUgYXJndW1lbnQgbXVzdCBiZSBub24tZW1wdHksIGJlY2F1c2UgdGhlIHJlc3VsdCBpcyBmcm96ZW4uXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnV0aWxzLmNyZWF0ZU1hcCBjcmVhdGVNYXB9XG4gKiBAcGFyYW0gey4uLip9IFtvYmpdIC0gQXJndW1lbnRzIHRvIGBPYmplY3QuYXNzaWduKClgLlxuICogQHJldHVybnMge09iamVjdH0gQSBmcm96ZW4gb2JqZWN0IHdpdGggbm8gcHJvdG90eXBlLCBoYXZpbmcgYC4uLm9iamAgcHJvcGVydGllc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBhcmd1bWVudCBpcyBub3QgYSBub24tZW1wdHkgb2JqZWN0LlxuICovXG5leHBvcnRzLmRlZmluZUNvbnN0YW50cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKGNhbm9uaWNhbFR5cGUob2JqKSAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKG9iaikubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudDsgZXhwZWN0ZWQgYSBub24tZW1wdHkgb2JqZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoZXhwb3J0cy5jcmVhdGVNYXAob2JqKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICpcbiAqIFdyYXBwZXIgYXJvdW5kIGBwcm9jZXNzLmN3ZCgpYCBmb3IgaXNvbGF0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmN3ZCA9IGZ1bmN0aW9uIGN3ZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuY3dkKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIE1vY2hhIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyLlxuICogQ2hlY2tzIGZvciBgcHJvY2Vzcy5icm93c2VyYC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiBCb29sZWFuKHByb2Nlc3MuYnJvd3Nlcik7XG59O1xuXG4vKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhbiBhcnJheTsgdXNlZnVsIGZvciBvcHRpb25hbGx5IGFjY2VwdGluZyBhcnJheSBwYXJhbWV0ZXJzXG4gKlxuICogSXQgZm9sbG93cyB0aGVzZSBydWxlcywgZGVwZW5kaW5nIG9uIGB2YWx1ZWAuICBJZiBgdmFsdWVgIGlzLi4uXG4gKiAxLiBgdW5kZWZpbmVkYDogcmV0dXJuIGFuIGVtcHR5IEFycmF5XG4gKiAyLiBgbnVsbGA6IHJldHVybiBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIGBudWxsYCBlbGVtZW50XG4gKiAzLiBBbnkgb3RoZXIgb2JqZWN0OiByZXR1cm4gdGhlIHZhbHVlIG9mIGBBcnJheS5mcm9tKClgIF9pZl8gdGhlIG9iamVjdCBpcyBpdGVyYWJsZVxuICogNC4gb3RoZXJ3aXNlOiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50LCBgdmFsdWVgXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gU29tZXRoaW5nIHRvIGNhc3QgdG8gYW4gQXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAqL1xuZXhwb3J0cy5jYXN0QXJyYXkgPSBmdW5jdGlvbiBjYXN0QXJyYXkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICh0eXBlb2YgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZClcbiAgKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufTtcblxuZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLmRlZmluZUNvbnN0YW50cyh7XG4gIE1PQ0hBX0lEX1BST1BfTkFNRVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB1bmlxdWUgaWRlbnRpZmllclxuICogQHJldHVybnMge3N0cmluZ30gVW5pcXVlIGlkZW50aWZpZXJcbiAqL1xuZXhwb3J0cy51bmlxdWVJRCA9ICgpID0+IG5hbm9pZCgpO1xuXG5leHBvcnRzLmFzc2lnbk5ld01vY2hhSUQgPSBvYmogPT4ge1xuICBjb25zdCBpZCA9IGV4cG9ydHMudW5pcXVlSUQoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgTU9DSEFfSURfUFJPUF9OQU1FLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIE1vY2hhIElEIGZyb20gYW4gb2JqZWN0LCBpZiBwcmVzZW50LlxuICogQHBhcmFtIHsqfSBbb2JqXSAtIE9iamVjdFxuICogQHJldHVybnMge3N0cmluZ3x2b2lkfVxuICovXG5leHBvcnRzLmdldE1vY2hhSUQgPSBvYmogPT5cbiAgb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gb2JqW01PQ0hBX0lEX1BST1BfTkFNRV0gOiB1bmRlZmluZWQ7XG4iLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUgPSAyMSkgPT4ge1xuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgbGV0IGkgPSBzaXplXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGgpIHwgMF1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9ICcnXG4gIGxldCBpID0gc2l6ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiA2NCkgfCAwXVxuICB9XG4gIHJldHVybiBpZFxufVxubW9kdWxlLmV4cG9ydHMgPSB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIiwiaW1wb3J0IGNoYWkgZnJvbSAnLi9pbmRleC5qcyc7XG5cbmV4cG9ydCBjb25zdCBleHBlY3QgPSBjaGFpLmV4cGVjdDtcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gY2hhaS52ZXJzaW9uO1xuZXhwb3J0IGNvbnN0IEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuZXhwb3J0IGNvbnN0IEFzc2VydGlvbkVycm9yID0gY2hhaS5Bc3NlcnRpb25FcnJvcjtcbmV4cG9ydCBjb25zdCB1dGlsID0gY2hhaS51dGlsO1xuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGNoYWkuY29uZmlnO1xuZXhwb3J0IGNvbnN0IHVzZSA9IGNoYWkudXNlO1xuZXhwb3J0IGNvbnN0IHNob3VsZCA9IGNoYWkuc2hvdWxkO1xuZXhwb3J0IGNvbnN0IGFzc2VydCA9IGNoYWkuYXNzZXJ0O1xuZXhwb3J0IGNvbnN0IGNvcmUgPSBjaGFpLmNvcmU7XG5cbmV4cG9ydCBkZWZhdWx0IGNoYWk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJleHBvcnQgKiBmcm9tIFwiLi90ZXN0L3Rlc3RTdWl0ZVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9